---
title: "Hot Update"
layout: single
date: 2025-06-01
categories: [笔记]
tags: [Unity, Hot Update]
author: "ljf12825"
permalink: /posts/2025-08-02-Hot-Update/
---
热更新指的是在游戏运行后，不需要重写打包和分发客户端，就能更新或修复代码、资源的机制\
简单理解：
- 不热更：出了bug -> 改代码 -> 重新打包 -> 玩家重新下载安装
- 热更：除了bug -> 改代码 -> 发布更新包 -> 玩家下小补丁，立即生效

为什么要用热更新
- 移动端、主机端游戏包体大、审核严格，频繁发新包代价极高
- 上线后bug修复：能第一时间止血
- 内容更新：节省分发成本（活动、新关卡、皮肤）
- 快速迭代：尤其是手游和运营类游戏


## Unity热更新常见方式
### 资源热更新
主要解决美术资源、配置文件更新问题\
实现思路：
- 把资源（Prefab/Texture/音效等）打成AssetBundle
- 游戏运行时从服务器下载最新AssetBundle -> 替换旧资源
- 配合资源版本管理（Manifest + Hash）

特点：
- 实现简单
- Unity官方支持
- 只能更新资源，不能更新逻辑代码

### 代码热更新
核心：C#脚本的运行时代码替换\
UnityC#脚本编译后会生成IL（中间语言），运行时通过Mono或IL2CPP执行\
要想热更，需要解决如何加载/执行新代码

常见方案：
1. 反射/动态加载DLL
  - 用Mono编译器在外部生成新的DLL
  - 游戏运行时加载（Assembly.Load）
  - 可以调用新逻辑，但有局限性

缺点：
  - IL2CPP平台不支持直接动态加载DLL（比如iOS）

2. ILRuntime（国内常用）
  - 一个开源的IL解释器
  - 运行时用解释执行外部编译的DLL
  - 解决了IL2CPP的限制，可以在iOS/Android都用

特点：
  - 跨平台
  - 活跃社区，国内大厂常用（比如热更新游戏项目）
  - 心梗你比原生IL差（解释执行）

3. HybridCLR（近几年兴起）
  - 思路是补全Unity剪掉的AOT元数据，让运行时能加载新的IL
  - 结合热更DLL + 补充元数据，实现近似原生的性能

特点：
  - 性能接近原生
  - 无需解释器，能跑在IL2CPP上
  - 实现复杂，生态还在发展

4. Lua/JS脚本热更
  - 用Lua、JS等脚本语言写游戏逻辑
  - Unity只负责运行时环境
  - 热更就是替换脚本文件

特点：
  - 逻辑热更灵活
  - 不依赖C#
  - 开发效率、IDE支持差，团队要适应

## 混合方案
- 资源用AssetBundle更新
- 逻辑用HybridCLR/ILRuntime/Lua热更
- 配置数据用JSON/CSV/ScriptableObject更新

## 热更的关键技术点
1. 版本管理
  - 需要有版本号、校验Hash、对比差异的机制

2. 更新流程
  - 检查更新 -> 下载资源/DLL -> 校验 -> 替换

3. 安全性
  - 防止恶意替换，通常用签名验证、加密

4. 灰度发布
  - 分批投放，避免更新导致全服崩溃

### 反射和动态加载DLL
这种方式尤其适用于C#脚本的运行时修改\
它的基本思想是将某些逻辑封装在DLL文件中，在游戏运行时动态加载这些DLL，并通过反射来调用其中的功能

#### 原理
**反射**\
反射是C#提供的机制，可以在运行时获取对象的元数据（如类、方法、属性等），并可以通过这些元数据来动态地实例化对象或调用方法\
它是热更新的核心技术之一，通常用来实现在不修改现有代码的情况下调用新DLL中的功能

**动态加载DLL**
C#提供了`Assembly.Load`方法，可以在运行时加载外部的DLL文件，并通过反射来访问其中的类型和成员（如类、方法）\
通过这种方式，可以将新版本中的DLL替换到游戏中，而无需重新打包整个应用

#### 实现
1. 将逻辑封装为DLL
将业务逻辑代码编译成一个独立的DLL文件
  - 将这部分代码从Unity主项目中分离，独立编译成DLL
  - DLL中的功能可以是游戏中的各种逻辑模块，比如角色行为、敌人AI任务系统等

2. 在运行时动态加载DLL
使用`Assembly.Load`来加载DLL文件。加载时，可以通过文件路径、资源流等方式加载DLL文件\
例如
```cs
using System.Reflecion;

// 动态加载DLL
string dllPath = "Assets/HotUpdate/HotUpdate.dll";
Assembly hotUpdateAssembly = Assembly.LoadFrom(dllPath);
```

3. 通过反射调用DLL中的类和方法
加载完DLL后，可以通过反射来创建DLL中的对象并调用它们的方法\
例如，假设有一个`Player`类，并且它有一个`Move`方法
```cs
// 获取类型
Type playerType = hotUpdateAssembly.GetType("HotUpdate.Player");

// 创建实例
object playerInstance = Activator.CreateInstance(playerType);

// 获取方法并调用
MethodInfo moveMethod = playerType.GetMethod("Move");
moveMethod.Invoke(playerInstance, null); // 这里传入的参数可以根据需要传入
```

4. 处理依赖和接口
如果想把某些接口保留给DLL使用，可以通过接口实现来避免代码耦合\
在反射中，通常会使用接口来确保DLL中的代码能访问到需要的功能\
例如，定义一个公共接口
```cs
public interface IPlayer
{
  void Move();
  void Attack();
}
```
然后在DLL中实现这个接口
```cs
public class Player : IPlayer
{
  public void Move() { /* 运动逻辑 */ }
  public void Attack() { /* 攻击逻辑 */ }
}
```
主程序运行时加载DLL后，可以通过反射获取到接口和实现类，避免直接引用DLL中的实现类，从而减少耦合

5. 更新和卸载DLL
每当想更新代码时，只需要替换DLL文件，游戏运行时会加载新的DLL\
可以实现代码的卸载和重新加载（但这在.NET环境下并不完全支持，尤其是在IL2CPP环境下），可以通过使用AppDomain来卸载和重新加载DLL

#### 特点
**优点**
1. 灵活性高
可以在不修改主程序的情况下更新代码。只需要替换 DLL 文件，玩家无需重新下载游戏
  - 如果是修复 bug 或者增加一些功能，特别是在线游戏，热更新非常有用

2. 快速修复和更新
缩短了开发周期，尤其是在测试阶段，能快速实现代码修改
  - 例如，修复客户端的小问题，可以只更新某个模块的 DLL，而不需要重新发布整包

3. 减少游戏包体大小
  - 大型游戏通常有很多可扩展的模块（如剧情、任务、AI等）
  - 只加载需要更新的DLL文件，避免了整包的更新

4. 跨平台支持
对于支持Mono的平台（如Android、PC），反射和动态加载DLL的方式可以很好地实现热更新\
对于iOS、主机平台等则存在一定限制（特别是IL2CPP环境下）

**缺点**
1. 性能开销
使用反射会带来一定的性能开销。虽然现代的 JIT 编译和优化技术已经减少了这些开销，但比起直接调用普通方法，反射的速度仍然较慢

2. 代码耦合性强
动态加载 DLL 可能会导致项目之间的依赖关系过于复杂，尤其是涉及到多个 DLL 之间的相互引用时
  - 需要通过接口或抽象类来进行解耦，但这增加了代码设计的难度

3. 调试难度增加
动态加载 DLL 后，调试时可能会遇到更多的困难，尤其是在 IDE 中无法直接追踪到 DLL 内的逻辑
  - 如果错误发生在 DLL 中，定位问题会更加复杂

4. IL2CPP不支持直接加载DLL
由于 Unity 的 IL2CPP 编译方式不支持直接加载 DLL，因此这对 iOS 和其他 IL2CPP 平台的支持较差
  - 解决方法是将代码转换成 C++，或者使用 HybridCLR 等解决方案

5. 内存管理问题
在运行时加载和卸载 DLL 会引入一定的内存管理问题，尤其是在没有垃圾回收机制的环境下（如 IL2CPP）
  - 如果没有正确管理内存，可能会导致内存泄漏等问题

#### 适用场景
1. 在线游戏bug修复
对于一些大型的 MMO 或 MOBA 类型的游戏，可能需要频繁修复小的 bug 或调整一些游戏逻辑。通过热更新方式，开发人员可以快速发布修复，用户无需等待长时间的更新包

2. 内容更新和新功能
如果游戏内有定期更新的新功能（例如新的活动、任务、道具等），这时也可以通过热更新的方式，定期加载新的 DLL，而不需要重新下载整个游戏客户端

3. 游戏内测试和调试
开发者可以将测试版本的 DLL 通过热更新的方式推送给玩家，以进行 A/B 测试或者验证某些游戏逻辑的调整，而不需要强制用户重新安装更新包

在实际应用中，反射和动态加载DLL方式常常与AssetBundle和配置文件热更新结合使用，形成一个完整的热更新解决方案