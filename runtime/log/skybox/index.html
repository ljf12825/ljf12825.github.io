<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Skybox</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-lua.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-rust.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/runtime/>★</a></li><li><a href=/runtime/lab/>Lab</a></li><li><a href=/runtime/log/>Log</a></li><li><a href=/runtime/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/ target=_blank>lua.org</a>
<a href=https://www.luarocks.org/ target=_blank>luarocks.org</a>
<a href=https://www.luajit.org/ target=_blank>luajit.org</a></p><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Skybox<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><p>Skybox是一种渲染技术，用于在3D场景中创建远景背景，例如天空、宇宙、城市天际线等<br>它本质上是一种把纹理图贴在一个立方体（或球体）内侧的技巧，玩家看不到边界，只能看到包裹在四周的“天空”</p><p>关键特性：</p><ul><li>无限远：无论玩家如何移动，天空和总是保持固定的距离，永远不会被靠近（天空盒会跟随相机移动）从而创造出“无限远”的错觉</li><li>环境光源：天空盒不仅是视觉背景，其颜色和亮度还会为场景中的物体提供环境光（Ambient Light）和反射光（Reflection），这是实现场景光照统一和真实感的关键</li></ul><h2 id=创建skybox>创建Skybox</h2><h3 id=1-使用现成材质>1. 使用现成材质</h3><p>菜单栏 -> Window -> Rendering -> Lighting<br><img src=/images/content/SkyboxMaterial.jpg alt=SkyboxMaterial></p><h3 id=2-使用6张图片自定义创建立方体天空盒>2. 使用6张图片自定义创建立方体天空盒</h3><ol><li>准备图片：需要6张正方形图片，分别对应立方体的六个面（<code>+X, -X, +Y, -Y, +Z, -Z</code>）。通常命名为<code>right</code>, <code>left</code>, <code>top</code>, <code>bottom</code>, <code>front</code>, <code>back</code>或<code>px</code>, <code>nx</code>, <code>py</code>, <code>ny</code>, <code>pz</code>, <code>nz</code></li></ol><ul><li>确保图片的Wrap Mode设置为Clamp，防止边缘接缝处出现拉伸</li></ul><ol start=2><li>创建材质</li></ol><ul><li>在Project视图中右键->Create->Material</li><li>将新建的材质命名为<code>MySkybox</code></li><li>在材质的Inspector面板中，点击Shader下拉菜单，选择Skybox -> Cubemap</li></ul><ol start=3><li>配置Cubemap</li></ol><ul><li>创建Cubemap资源：Project下右键 -> Create -> Rendering -> LegacyCubemap，将六张图拖入Cubemap资源，然后将这个Cubemap资源拖到天空材质球的<code>Cubemap</code>槽位</li></ul><ol start=4><li>应用材质球：同<code>1. 使用现成材质</code></li></ol><h3 id=3-使用proceduralskybox>3. 使用ProceduralSkybox</h3><h4 id=创建shader文件>创建Shader文件</h4><ol><li>Project右键 -> Create -> Shader -> Unlit Shader</li><li>将其命名为<code>ProceduralSkybox</code></li><li>删除所有代码，替换为</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-glsl data-lang=glsl><span style=display:flex><span>Shader &#34;Skybox<span style=color:#ff79c6>/</span>Procedural Skybox&#34;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 顶部颜色（天顶）</span>
</span></span><span style=display:flex><span>        _SkyColor (&#34;Sky Color&#34;, Color) <span style=color:#ff79c6>=</span> (<span style=color:#bd93f9>0.37</span>, <span style=color:#bd93f9>0.52</span>, <span style=color:#bd93f9>0.73</span>, <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 地平线颜色</span>
</span></span><span style=display:flex><span>        _HorizonColor (&#34;Horizon Color&#34;, Color) <span style=color:#ff79c6>=</span> (<span style=color:#bd93f9>0.89</span>, <span style=color:#bd93f9>0.89</span>, <span style=color:#bd93f9>0.89</span>, <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 地面颜色（地平线以下）</span>
</span></span><span style=display:flex><span>        _GroundColor (&#34;Ground Color&#34;, Color) <span style=color:#ff79c6>=</span> (<span style=color:#bd93f9>0.33</span>, <span style=color:#bd93f9>0.27</span>, <span style=color:#bd93f9>0.21</span>, <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 太阳颜色</span>
</span></span><span style=display:flex><span>        _SunColor (&#34;Sun Color&#34;, Color) <span style=color:#ff79c6>=</span> (<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>0.8</span>, <span style=color:#bd93f9>0.6</span>, <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 太阳大小（半径）</span>
</span></span><span style=display:flex><span>        _SunSize (&#34;Sun Size&#34;, Range(<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>)) <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0.04</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 太阳晕影大小（光晕扩散）</span>
</span></span><span style=display:flex><span>        _SunGlow (&#34;Sun Glow&#34;, Range(<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>10</span>)) <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2.5</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 太阳在天空中的方向（通常由脚本绑定方向光的方向来控制）</span>
</span></span><span style=display:flex><span>        _SunDirection (&#34;Sun Direction&#34;, Vector) <span style=color:#ff79c6>=</span> (<span style=color:#bd93f9>0.3</span>, <span style=color:#bd93f9>0.8</span>, <span style=color:#bd93f9>0.5</span>, <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 天空颜色的幂次，控制颜色过渡的陡峭程度</span>
</span></span><span style=display:flex><span>        _SkyExponent (&#34;Sky Exponent&#34;, Range(<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>10</span>)) <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1.5</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 地平线的大气厚度效果</span>
</span></span><span style=display:flex><span>        _AtmosphereThickness (&#34;Atmosphere Thickness&#34;, Range(<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>10</span>)) <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1.0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            &#34;Queue&#34;<span style=color:#ff79c6>=</span>&#34;Background&#34;
</span></span><span style=display:flex><span>            &#34;RenderType&#34;<span style=color:#ff79c6>=</span>&#34;Background&#34;
</span></span><span style=display:flex><span>            &#34;PreviewType&#34;<span style=color:#ff79c6>=</span>&#34;Skybox&#34;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Cull Off <span style=color:#6272a4>// 关闭剔除，因为要从内部渲染</span>
</span></span><span style=display:flex><span>        ZWrite Off <span style=color:#6272a4>// 关闭深度写入，天空盒永远在最远处</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            CGPROGRAM
</span></span><span style=display:flex><span>            #pragma vertex vert
</span></span><span style=display:flex><span>            #pragma fragment frag
</span></span><span style=display:flex><span>            #include &#34;UnityCG.cginc&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>struct</span> appdata
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                float4 vertex <span style=color:#ff79c6>:</span> POSITION;
</span></span><span style=display:flex><span>                float3 uv <span style=color:#ff79c6>:</span> TEXCOORD0; <span style=color:#6272a4>// 使用三维UV来采样天空球</span>
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>struct</span> v2f
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                float4 vertex <span style=color:#ff79c6>:</span> SV_POSITION;
</span></span><span style=display:flex><span>                float3 viewDir <span style=color:#ff79c6>:</span> TEXCOORD0; <span style=color:#6272a4>// 将视图方向传递给片元着色器</span>
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 将属性变量连接到CG代码</span>
</span></span><span style=display:flex><span>            fixed4 _SkyColor;
</span></span><span style=display:flex><span>            fixed4 _HorizonColor;
</span></span><span style=display:flex><span>            fixed4 _GroundColor;
</span></span><span style=display:flex><span>            fixed4 _SunColor;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>half</span> _SunSize;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>half</span> _SunGlow;
</span></span><span style=display:flex><span>            half4 _SunDirection;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>half</span> _SkyExponent;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>half</span> _AtmosphereThickness;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            v2f vert (appdata v)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                v2f o;
</span></span><span style=display:flex><span>                o.vertex <span style=color:#ff79c6>=</span> UnityObjectToClipPos(v.vertex);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 获取世界空间下的视图方向（顶点位置）</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 对于天空盒，顶点位置就是视图方向</span>
</span></span><span style=display:flex><span>                o.viewDir <span style=color:#ff79c6>=</span> mul((float3x3)unity_ObjectToWorld, v.vertex.xyz);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span> o;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            fixed4 frag (v2f i) <span style=color:#ff79c6>:</span> SV_Target
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 标准化视图方向</span>
</span></span><span style=display:flex><span>                float3 viewDir <span style=color:#ff79c6>=</span> normalize(i.viewDir);
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 标准化太阳方向（确保是单位向量）</span>
</span></span><span style=display:flex><span>                float3 sunDir <span style=color:#ff79c6>=</span> normalize(_SunDirection.xyz);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 1. 计算基础天空颜色（基于视角的垂直分量y）</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>float</span> horizon <span style=color:#ff79c6>=</span> dot(viewDir, float3(<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>0</span>)); <span style=color:#6272a4>// 计算与垂直方向的点积</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 将horizon从[-1, 1] 映射到 [0, 1] 并应用幂次控制过渡</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>float</span> skyGradient <span style=color:#ff79c6>=</span> saturate(horizon <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>0.5</span> <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>0.5</span>);
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 应用指数控制过渡的平滑度</span>
</span></span><span style=display:flex><span>                skyGradient <span style=color:#ff79c6>=</span> pow(skyGradient, _SkyExponent);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 混合天空和地平线颜色</span>
</span></span><span style=display:flex><span>                fixed4 skyFinal <span style=color:#ff79c6>=</span> lerp(_HorizonColor, _SkyColor, skyGradient);
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 混合地平线和地面颜色（对于地平线以下的部分）</span>
</span></span><span style=display:flex><span>                skyFinal <span style=color:#ff79c6>=</span> lerp(_GroundColor, skyFinal, saturate(horizon <span style=color:#ff79c6>*</span> _AtmosphereThickness));
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 2. 计算太阳</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 计算视线方向与太阳方向的夹角</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>float</span> sunDot <span style=color:#ff79c6>=</span> dot(viewDir, sunDir);
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 平滑步进函数，在sunDot接近1（即视角指向太阳中心）时产生一个圆盘</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>float</span> sunDisk <span style=color:#ff79c6>=</span> smoothstep(<span style=color:#bd93f9>1.0</span> <span style=color:#ff79c6>-</span> _SunSize, <span style=color:#bd93f9>1.0</span>, sunDot);
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 计算太阳光晕，一个更宽更柔和的过渡</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>float</span> sunGlow <span style=color:#ff79c6>=</span> pow(saturate(sunDot), _SunGlow);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 结合太阳圆盘和光晕</span>
</span></span><span style=display:flex><span>                fixed4 sunFinal <span style=color:#ff79c6>=</span> (_SunColor <span style=color:#ff79c6>*</span> (sunDisk <span style=color:#ff79c6>+</span> sunGlow));
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 3. 将太阳效果叠加到天空背景上（使用加法混合，因为光是叠加的）</span>
</span></span><span style=display:flex><span>                fixed4 col <span style=color:#ff79c6>=</span> skyFinal <span style=color:#ff79c6>+</span> sunFinal;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span> col;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            ENDCG
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 防止回退到其他Shader</span>
</span></span><span style=display:flex><span>    Fallback Off
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=创建并使用材质>创建并使用材质</h4><p>创建一个材质名为<code>Mat_ProceduralSky</code>，在材质Inspector窗口中点击Shader下拉菜单，选择Skybox -/> ProceduralSkybox（Shader第一行创建）；调整材质属性，使用该材质作为天空盒材质</p><h4 id=与场景光联动>与场景光联动</h4><p>为了让太阳的位置与场景中的主方向光（模拟太阳）同步，需要创建一个简单的脚本
<code>SyncSunDirection.cs</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#50fa7b>
</span></span></span><span style=display:flex><span><span style=color:#50fa7b>[ExecuteAlways]</span> <span style=color:#6272a4>// execute always include editor mode</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>SyncSunDirection</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#50fa7b>    [SerializeField]</span> <span style=color:#8be9fd;font-style:italic>private</span> Light _sunLight; <span style=color:#6272a4>// directional light</span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>    [SerializeField]</span> <span style=color:#8be9fd;font-style:italic>private</span> Material _skyboxMaterial; <span style=color:#6272a4>// proceduralskybox</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 在材质中定义的_SunDirection属性的标识符</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>readonly</span> <span style=color:#8be9fd>int</span> SunDirectionID = Shader.PropertyToID(<span style=color:#f1fa8c>&#34;_SunDirection&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>void</span> Update()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (_sunLight != <span style=color:#ff79c6>null</span> &amp;&amp; _skyboxMaterial != <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 将光源的forward方向（光照方向的反方向）传递给材质</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 因为光源.transform.forward指向光照照射的方向（太阳到物体）</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 而天空盒需要的是太阳在天空中的位置方向（物体到太阳），所以取反</span>
</span></span><span style=display:flex><span>            Vector3 sunDirectionInSky = -_sunLight.transform.forward;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 设置材质的向量属性</span>
</span></span><span style=display:flex><span>            _skyboxMaterial.SetVector(SunDirectionID, <span style=color:#ff79c6>new</span> Vector4(
</span></span><span style=display:flex><span>                sunDirectionInSky.x,
</span></span><span style=display:flex><span>                sunDirectionInSky.y,
</span></span><span style=display:flex><span>                sunDirectionInSky.z,
</span></span><span style=display:flex><span>                <span style=color:#bd93f9>0f</span> <span style=color:#6272a4>// 第四个分量通常不用</span>
</span></span><span style=display:flex><span>            ));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>将该脚本挂在场景中任何物体上，拖入字段<br>在编辑器中旋转directional light，天空盒中的太阳位置也会实时更新</p><p><img src=/images/content/Sundirection1.jpg alt=SunDirection1>
<img src=/images/content/Sundirection2.jpg alt=SunDirection2></p><h2 id=skybox的类型与属性>Skybox的类型与属性</h2><p>Unity提供了几种不同类型的天空盒Shader，适用于不同的需求和资源类型</p><ol><li>6Sided(Cubemap)
使用6张独立的纹理。最经典和兼容新最好的方式</li></ol><ul><li>Tint Color：对每个面的纹理进行颜色染色</li><li>Exposure：调整天空盒的整体亮度。这个值会直接影响环境光的强度</li><li>Rotation：围绕Y轴旋转整个天空盒，可以调整太阳/云层的位置</li></ul><ol start=2><li>Cubemap
使用一个单独的Cubemap资源（<code>.cubemap</code>文件），而不是六张分散的图片。Cube资源可以被引擎优化，性能通常稍好</li></ol><ul><li>可以从六张图片生成Cubemap资源，见上所述</li></ul><ol start=3><li>Panoramic(LatLong/360°)
使用一张等距柱状投影(Equirectangular)的360°全景图（2:1宽高比）。这是360°相机拍摄的图片格式</li></ol><ul><li>优点：只需处理一张纹理，非常方便</li><li>Mapping：选择投影方式:<code>6 Frames Layout(类正方体)</code>和<code>Latitude Longitude Layout（类地球）</code>，<code>Automatic</code>通常即可正确识别</li></ul><ol start=4><li>Procedural（程序化）
通过Shader算法实时生成天空，无需任何纹理</li></ol><ul><li>Sun：需要指定一个Directional Light作为太阳。天空盒会根据这个光的方向是是改变天空的颜色、太阳大小、晕影等</li><li>控制参数丰富<ul><li><code>Atmosphere Thickness</code>：大气厚度，影响天空的蓝色程度</li><li><code>Ground Color</code>：地平线处的颜色</li><li><code>Sun Size</code> / <code>Sun Size Convergence</code>：控制太阳的大小和模糊程度</li></ul></li><li>优点：动态，可以随着游戏时间变化（通过代码控制Directional Light的旋转）</li><li>缺点：风格化较强，不如基于图像的天空盒真实</li></ul><h2 id=深入原理与高级应用>深入原理与高级应用</h2><h3 id=1-天空盒环境光与光照烘焙gi>1. 天空盒、环境光与光照烘焙（GI）</h3><p>这是天空盒最核心的高级功能之一</p><ul><li>环境光（Ambient Light）：在Lighting窗口的Environment标签中，<code>Source</code>如果设置为<code>Skybox</code>，那么场景的环境颜色和强度将完全由当前设置的天空盒决定。Unity会通过对天空盒进行采样来计算出平均的环境光颜色。调整<code>Intensity Multiplier</code>可以控制环境光强度</li><li>光照烘焙（Baked GI）<ul><li>当使用Baked Global Illumination时，天空盒是作为一个重要的环境光源被烘焙到光照贴图（Lightmaps）中的</li><li>它的颜色和强度会直接影响场景中间接光照的结果</li><li>在Lighting窗口中，可以设置Environment Lighting的相关参数，如<code>Intensity</code>和<code>Ambient Occlusion</code>，来控制天空盒在烘焙时的影响</li></ul></li></ul><h3 id=2-反射探针reflection-probes>2. 反射探针（Reflection Probes）</h3><p>天空盒的另一个核心作用是提供默认的反射源</p><ul><li>场景中具有光滑材质的物体（如金属、水面），其反射内容如果没有配置局部Reflection Probes，物体默认使用天空盒作为其反射源</li><li>可以创建Refelction Probes，并将其<code>Source</code>设置为<code>Skybox</code>，这样它就会捕获当前场景的天空盒（或自定义的天空盒）生成一个立方体贴图，供周围的物体使用。这对于让动态物体也能融入环境光至关重要</li></ul><h3 id=3-动态切换天空盒>3. 动态切换天空盒</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>SkyboxChanger</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> Material[] skyboxMaterials;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> ReflectionProbe reflectionProbe; <span style=color:#6272a4>// 可选，如果需要更新反射探针</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> ChangeSkybox(<span style=color:#8be9fd>int</span> index)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (index &lt; <span style=color:#bd93f9>0</span> || index &gt;= skyboxMatterials.Length)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.LogError(<span style=color:#f1fa8c>&#34;Index out of range!&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 设置渲染设置中的天空盒</span>
</span></span><span style=display:flex><span>        RenderSettings.skybox = syboxMaterials[index];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 立即强制过呢更新环境光照和反射</span>
</span></span><span style=display:flex><span>        DynamicGI.UpdateEnvironment();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 重置反射探针</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (refflectionProbe != <span style=color:#ff79c6>null</span>) reflectionProbe.RenderProbe();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-性能优化与最佳实践>4. 性能优化与最佳实践</h3><ul><li><p>纹理压缩：天空盒纹理通常很大，需要使用合适的压缩格式</p><ul><li>PC/主机平台：通常使用<code>BCn/HDR</code>压缩（如RGB Crunched DXT5）</li><li>Android：通常使用<code>ETC2</code>（支持Alpha）或<code>ASTC</code>（更优的压缩比和质量）</li><li>iOS：通常使用<code>PVRTC</code>或<code>ASTC</code></li><li>HDR：如果天空盒是高动态范围的（非常亮，如太阳），确保导入设置中勾选<code>Generate Mip Maps</code>并设置合适的压缩格式（如BC6H用于HDR Cubemap）</li></ul></li><li><p>Mip Map：通常建议开启，尤其是在有雾效或需要景深效果的场景中，可以改善远处的外观和性能。但对于永远在“无限远”处的天空盒，有时关闭它节省内存也是可行的，但需要测试</p></li><li><p>分辨率：不要使用过高的分辨率。2048x2048或1024x1024每面对于大多数项目来说已经足够。过高的分辨率会显著增加内存占用和加载时间</p></li><li><p>HDR vs LDR：使用HDR（高动态范围）天空盒可以带来更真实的光照效果，尤其是在配置Post-Processing Stack后处理堆栈中的Tonemapping是，效果惊人。但需要确保项目设置中Color Space为Linear</p></li></ul><h3 id=5-常见问题排查>5. 常见问题排查</h3><ul><li>接缝（Seams）：确保6张图片的Wrap Mode设置为Clamp，而不是Repeat</li><li>天空盒不显式/变紫：检查材质Shader是否正确，纹理是否丢失</li><li>光照不正确：更改天空盒后，如果使用了烘焙光照，必须重新烘焙才能更新光照贴图。动态GI则需要调用</li><li>移动端性能差：检查纹理压缩格式和分辨率。Panoramic天空盒在部分低端移动设备上可能比6 Sided的更耗性能，因为需要实时进行坐标转换</li></ul></div><nav class=post-nav><a href=/runtime/log/serialization-and-persistance/ class=hover:underline>pre: Serialization and Persistence</a>
<a href=/runtime/log/tag/ class=hover:underline>next: Tag</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#创建skybox>创建Skybox</a><ul><li><a href=#1-使用现成材质>1. 使用现成材质</a></li><li><a href=#2-使用6张图片自定义创建立方体天空盒>2. 使用6张图片自定义创建立方体天空盒</a></li><li><a href=#3-使用proceduralskybox>3. 使用ProceduralSkybox</a><ul><li><a href=#创建shader文件>创建Shader文件</a></li><li><a href=#创建并使用材质>创建并使用材质</a></li><li><a href=#与场景光联动>与场景光联动</a></li></ul></li></ul></li><li><a href=#skybox的类型与属性>Skybox的类型与属性</a></li><li><a href=#深入原理与高级应用>深入原理与高级应用</a><ul><li><a href=#1-天空盒环境光与光照烘焙gi>1. 天空盒、环境光与光照烘焙（GI）</a></li><li><a href=#2-反射探针reflection-probes>2. 反射探针（Reflection Probes）</a></li><li><a href=#3-动态切换天空盒>3. 动态切换天空盒</a></li><li><a href=#4-性能优化与最佳实践>4. 性能优化与最佳实践</a></li><li><a href=#5-常见问题排查>5. 常见问题排查</a></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>