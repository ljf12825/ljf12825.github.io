<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Assets Import and Load</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-lua.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-rust.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/runtime/>★</a></li><li><a href=/runtime/lab/>Lab</a></li><li><a href=/runtime/log/>Log</a></li><li><a href=/runtime/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a> |
<a href=https://isocpp.org/ target=_blank>isocpp</a> |
<a href=https://open-std.org target=_blank>open-std</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/ target=_blank>lua.org</a> |
<a href=https://www.luarocks.org/ target=_blank>luarocks.org</a> |
<a href=https://www.luajit.org/ target=_blank>luajit.org</a></p><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a></p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a></p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Assets Import and Load<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><p>如何将外部资源导入到Unity中并在运行时使用</p><h2 id=资源导入>资源导入</h2><p>资源导入是指Unity将外部资源文件（如.fbx、.png、.mp3等）转换为引擎可以使用的内部格式。导入过程不仅包括将资源放入Unity项目中，还涉及到Unity如何优化、压缩、管理这些资源</p><h3 id=资源导入的关键步骤>资源导入的关键步骤</h3><ul><li>文件放置：在资源文件中放入Unity项目的<code>Assets</code>文件中。Unity会自动检测到这些文件，并开始导入流程</li><li>导入设置：在Inspector面板中，选中资源文件后，可以看到不同类型资源的导入设置（如<code>Texture Type</code>、<code>Model Import Settings</code>等）。不同的资源类型有不同的设置，影响最终的导入结果<ul><li>对于纹理，可以设置纹理的类型（如2D或Sprite），以及压缩选项（如DXT1、DXT5等）</li><li>对于模型，可以设置模型的网格、骨骼、动画等导入选项</li><li>对于音频，可以设置压缩类型、采样率等</li></ul></li><li>资源优化：Unity会根据导入设置自动处理资源，可能会进行压缩、网格简化、生成多种LOD等优化操作</li><li>Meta文件：Unity会为每个导入的资源创建一个<code>.meta</code>文件，用于保存资源的设置、ID等信息。这个文件对资源管理非常重要，尤其是在团队协作时，避免丢失资源链接</li></ul><h3 id=常见的资源类型导入>常见的资源类型导入</h3><ul><li><p>纹理（Texture）：Unity会自动识别常见的纹理文件类型，并提供压缩、过滤等选项
详见<a href=/log/Texture>Texture 导入</a></p></li><li><p>模型（Models）：Unity支持多种3D模型格式，尤其是<code>.fbx</code>，并支持自动生成碰撞体、网格和骨骼动画
详见<a href=/log/Model/>Model</a></p></li><li><p>音频（Audio）：音频文件支持不同的压缩格式，可以设置为单声道、立体声等
详见<a href=/log/Audio-System>Audio System</a></p></li><li><p>动画（Animations）：可以通过<code>Animator</code>系统来管理和播放
详见<a href=/log/Animation-System>Animation System</a></p></li></ul><h2 id=资源加载>资源加载</h2><p>在游戏运行时，如何高效地加载和管理这些已经导入的资源至关重要，尤其是在需要加载大量资源时。Unity提供了多种加载资源的方式，以便优化性能和内存使用</p><h3 id=class-resources>class Resources</h3><p><code>Resources</code>类在Unity中提供了一种动态加载资产的方式，允许你访问存储在特定文件夹中的对象，如Texture，Prefab，Audio Clips等。这些文件必须存放在项目中名为“Resources”的文件夹内</p><h4 id=存放资产到resources文件夹>存放资产到Resources文件夹</h4><ul><li>希望在运行时动态加载的所有资产必须存放在名为“Resources”的文件夹中。你可以在<code>Assets</code>目录下创建多个“Resources”文件夹</li><li>存放在这些文件夹中的资产不会通过Inspector自动引用，因此Unity无法对它们进行优化，直接包含在最终构建中</li></ul><h4 id=加载方式>加载方式</h4><ul><li><code>Resources.Load()</code>和<code>Resources.FindObjectsOfTypeAll()</code>函数可以用来加载和访问资产<ul><li><code>Resouces.Load()</code>：按路径加载单个资产</li><li><code>Resouces.FindObjectsOfTypeAll()</code>：用于查找并访问场景中或<code>Resources</code>文件夹下的所有对象</li></ul></li><li>使用路径加载资产时，所有存放在<code>Resources</code>文件夹中的资产会被纳入构建中，这可能导致构建大小增加</li></ul><h4 id=构建优化问题>构建优化问题</h4><p>通常，Unity 会通过 Inspector 暴露对资产的引用，这样在构建时它可以自动计算出哪些资产是实际使用的，从而避免不必要的资源被包含在最终构建中。但如果使用 <code>Resources</code> 文件夹，Unity 无法做到这一点，因此所有资产都会被包含在构建中，即使你没有使用它们</p><h4 id=不推荐过度使用路径加载>不推荐过度使用路径加载</h4><p>使用路径名来加载资产会导致代码不那么可复用，因为脚本会硬编码依赖于资产存放的位置。这不如通过Inspector暴露的引用直观和易于维护</p><h4 id=使用场景>使用场景</h4><p>在一些情况下，直接通过代码加载资产会更方便，特别是在你需要在运行时生成对象时。例如，程序化生成一个游戏物体并为其赋予纹理，或者加载动态生成的资源时，使用 Resources.Load() 会非常方便</p><h4 id=内存管理>内存管理</h4><p>使用 <code>Resources.Load()</code> 加载的资产，特别是纹理等资源，可能会占用内存，即使这些实例没有出现在场景中。为了释放内存，可以调用 <code>Resources.UnloadUnusedAssets()</code> 来卸载不再使用的资源。</p><blockquote><p><code>Resources</code>文件夹在创建项目时不会自动生成，需要手动创建这个文件夹才能使用</p></blockquote><h4 id=api>API</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>FindObjectsOfTypeAll</code></td><td>返回当前内存中所有指定类型 <code>T</code> 的对象列表。</td></tr><tr><td><code>InstanceIDIsValid</code></td><td>如果给定的实例 ID 对应一个有效的对象，则返回 <code>true</code>。该对象可能已经被删除或尚未加载到内存中。</td></tr><tr><td><code>InstanceIDsToValidArray</code></td><td>将实例 ID 数组转换为布尔数组，指示每个实例 ID 是否对应内存中的有效对象。对象可能已删除或未加载。</td></tr><tr><td><code>InstanceIDToObject</code></td><td>将实例 ID 转换为对象引用。</td></tr><tr><td><code>InstanceIDToObjectList</code></td><td>将实例 ID 数组转换为对象引用列表。</td></tr><tr><td><code>Load</code></td><td>加载存储在 <code>Resources</code> 文件夹路径下的指定类型的资源。</td></tr><tr><td><code>LoadAll</code></td><td>加载 <code>Resources</code> 文件夹路径下的文件夹或文件中的所有资源。</td></tr><tr><td><code>LoadAsync</code></td><td>异步加载存储在 <code>Resources</code> 文件夹路径下的资源。</td></tr><tr><td><code>UnloadAsset</code></td><td>从内存中卸载指定的资源。</td></tr><tr><td><code>UnloadUnusedAssets</code></td><td>卸载未使用的资源，释放内存。</td></tr></tbody></table><p><a href=https://docs.unity3d.com/ScriptReference/Resources.html>Unity Scripting Resources</a></p><h3 id=asset-bundles>Asset Bundles</h3><p>Asset Bundles是Unity的一个资源打包系统，允许开发者将游戏中的资源（如模型、纹理、音频等）打包成一个或多个独立的文件（称为Asset Bundles），以便按需加载。</p><p>这种方式适用于大规模资源的管理，尤其是当资源文件较大或需要动态加载时，Asset Bundles提供了比<code>Resources</code>文件夹更灵活的资源加载和内存管理方式</p><h4 id=asset-bundles的核心概念>Asset Bundles的核心概念</h4><ul><li>打包：将游戏资源（如纹理、模型、音频等）打包成独立的文件，以便后期按需加载</li><li>加载：通过代码加载Asset Bundles中的资源，而不是将所有资源一次性加载到内存中，从而优化内存使用和加载速度</li><li>卸载：通过代码释放已加载的Asset Bundles资源，确保内存得到有效管理</li></ul><h4 id=创建asset-bundles>创建Asset Bundles</h4><p>创建Asset Bundles的过程涉及将资源打包成独立的文件，这些文件可以在运行时动态加载</p><p>打包资源步骤：</p><ol><li>设置资源为Asset Bundle：
在Unity编辑器中，选择资源（如纹理、模型、音频等），在<code>Inspector</code>面板中为资源分配一个Asset Bundles名称</li></ol><ul><li>在<code>Inspector</code>中的<code>Asset Bundle</code>选项设置中，给资源指定一个名字，例如：<code>MyBundle/Textures</code></li></ul><ol start=2><li>构建Asset Bundles
使用BuildPipeline API构建 Asset Bundles</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>using</span> UnityEditor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>AssetBundleBuilder</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#50fa7b>  [MenuItem(&#34;Assets/Build Asset Bundles&#34;)]</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> BuildAllAssetBundles()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    BuildPipeline.BuildAssetBundles(<span style=color:#f1fa8c>&#34;Assets/AssetBundles&#34;</span>, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这段代码会将所有标记为Asset Bundle的资源打包到<code>Assets/Bundles</code>目录中，并生成适用于Windows平台的Asset Bundle
- <code>BuildAssetBundleOptionjs.None</code>：没有特殊选项，可以根据需要选择不同的选项（例如压缩、增量构建等）
- <code>BuildTarget.StandaloneWindows</code>：指定构建目标平台，可以选择其他平台</p><ol start=3><li>输出：
构建后，Unity会在指定的目录中生成Asset Bundle文件</li></ol><h4 id=加载asset-bundles>加载Asset Bundles</h4><p>在游戏运行时，可以通过以下方式加载和使用Asset Bundles</p><p>加载Asset Bundle：
加载Asset Bundle通常是异步的，避免阻塞主线程，保证游戏运行流畅</p><ul><li><p>从文件系统加载Asset Bundle</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>AssetBundleLoader</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  AssetBundle myLoadedAssetBundle;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>void</span> Start()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 异步加载 Asset Bundle</span>
</span></span><span style=display:flex><span>    StartCoroutine(LoadAssetBundleAsync(<span style=color:#f1fa8c>&#34;Assets/AssetBundles/MyBundle&#34;</span>));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IEnumerator LoadAssetBundleAsync(<span style=color:#8be9fd>string</span> bundleUrl)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 异步加载Asset Bundle</span>
</span></span><span style=display:flex><span>    AssetBundleCreateRequest bundleRequest = AssetBundle.LoadFromFileAsync(bundleUrl);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>yield</span> <span style=color:#ff79c6>return</span> bundleRequest;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    myLoadedAssetBundle = bundleRequest.assetBundle;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (myLoadedAssetBundle == <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      Debug.LogError(<span style=color:#f1fa8c>&#34;Failed to load AssetBundle!&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>yield</span> <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 加载资源</span>
</span></span><span style=display:flex><span>    AssetBundleRequest assetRequest = myLoadedAssetBundle.LoadAssetAsync&lt;Texture&gt;(<span style=color:#f1fa8c>&#34;MyTextrue&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>yield</span> reutrn assetRequest;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Texture texture = assetRequest.asset <span style=color:#ff79c6>as</span> Texture;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 使用加载的资源</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>从URL加载Asset Bundle（适用于远程资源）
如果Asset Bundle存储在远程服务器上，可以使用<code>UnityWebRequest</code>从URL加载资源</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> UnityEngine.Networking;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>AssetBundleRemoteLoader</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  AssetBundle myLoadedAssetBundle;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>void</span> Start()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    StartCoroutine(LoadAssetBundleFromURL(<span style=color:#f1fa8c>&#34;http://mycdn.com/assets/MyBundle&#34;</span>));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  IEnumerator LoadAssetBundleFromURL(<span style=color:#8be9fd>string</span> url)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    UnityWebRequest www = UnityWebRequestAssetBundle.GetAssetBundle(url);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>yield</span> <span style=color:#ff79c6>return</span> www.SendWebRequest();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (www.result != UnityWebRequest.Result.Success)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      Debug.LogError(<span style=color:#f1fa8c>&#34;Failed to load AssetBundle from URL!&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>yield</span> <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    myLoadedAssetBundle = DownloadHandlerAssetBundle.GetContent(www);
</span></span><span style=display:flex><span>    AssetBundleRequest assetRequest = myLoadedAssetBundle.LoadAssetAsync&lt;Texture&gt;(<span style=color:#f1fa8c>&#34;MyTexture&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>yield</span> <span style=color:#ff79c6>return</span> assetRequest;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Texture texture = assetRequest.asset <span style=color:#ff79c6>as</span> Texture;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 使用加载的资源</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>加载资源：通过<code>LoadAssetAsync()</code>或<code>LoadAsset()</code>方法加载Asset Bundle中的资源， <code>LoadAssetAsync()</code>更适合异步加载，可以避免阻塞主线程</p></li></ul><h4 id=卸载asset-bundle>卸载Asset Bundle</h4><p>加载后的Asset Bundle和资源可以通过<code>Unload()</code>方法释放，以防止内存泄露</p><ul><li>卸载资源和Asset Bundle</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>myLoadAssetBundle.Unload(<span style=color:#ff79c6>false</span>);
</span></span></code></pre></div><p><code>false</code>参数意味着只卸载Asset Bundle，不会卸载已经加载的资源。如果设置为<code>true</code>，则会卸载资源和Asset Bundle</p><h4 id=asset-bundle的优点和缺点>Asset Bundle的优点和缺点</h4><p>优点：</p><ol><li>按需加载：Asset Bundles 允许你将资源分离成不同的包，并且按需加载，这减少了内存的占用，并提高了加载速度。</li><li>资源分组和优化：你可以将资源按类型或加载频率进行分组（例如，UI 资源、场景资源、远程资源），并根据需要加载，提高游戏性能。</li><li>远程资源加载：Asset Bundles 支持从远程服务器加载资源，非常适合动态内容更新、DLC（可下载内容）和游戏数据包的分发。</li><li>平台兼容性：你可以为不同的平台（Windows、Android、iOS）构建不同的 Asset Bundle，确保在不同平台上使用合适的资源格式。</li></ol><p>缺点：</p><ol><li>管理复杂：随着游戏项目变得越来越大，Asset Bundles 的管理和维护可能变得更加复杂。你需要合理分配资源、管理多个 Asset Bundle、确保版本一致性等。</li><li>版本控制：由于 Asset Bundles 是外部资源包，Unity 并不直接将它们与项目文件一起进行版本控制。你需要单独管理 Asset Bundles 的版本和依赖关系。</li><li>构建时间：Asset Bundles 构建过程可能需要一些时间，尤其是当项目包含大量资源时。</li><li>缓存管理：在远程加载资源时，可能会遇到缓存问题，需要合理设置 CDN 或服务器端的缓存策略，确保资源的最新版本被加载。</li></ol><h4 id=api-1>API</h4><p><strong>Static Properties</strong></p><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody><tr><td><code>memoryBudgetKB</code></td><td>控制共享的 AssetBundle 加载缓存的大小，默认值为 1MB。</td></tr></tbody></table><p><strong>Properties</strong></p><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody><tr><td><code>isStreamedSceneAssetBundle</code></td><td>如果 AssetBundle 包含 Unity 场景文件，则返回 <code>true</code>。</td></tr></tbody></table><p><strong>Public Methods</strong></p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>Contains</code></td><td>检查 AssetBundle 是否包含特定的对象。</td></tr><tr><td><code>GetAllAssetNames</code></td><td>返回 AssetBundle 中所有资源的名称。</td></tr><tr><td><code>GetAllScenePaths</code></td><td>返回 AssetBundle 中所有场景的路径。</td></tr><tr><td><code>LoadAllAssets</code></td><td>同步加载 AssetBundle 中包含的所有资源。</td></tr><tr><td><code>LoadAllAssetsAsync</code></td><td>异步加载 AssetBundle 中包含的所有资源。</td></tr><tr><td><code>LoadAsset</code></td><td>同步加载 AssetBundle 中的某个资源。</td></tr><tr><td><code>LoadAssetAsync</code></td><td>异步加载 AssetBundle 中的某个资源。</td></tr><tr><td><code>LoadAssetWithSubAssets</code></td><td>同步加载 AssetBundle 中的资源及其子资源。</td></tr><tr><td><code>LoadAssetWithSubAssetsAsync</code></td><td>异步加载 AssetBundle 中的资源及其子资源。</td></tr><tr><td><code>Unload</code></td><td>卸载 AssetBundle，释放其占用的数据。</td></tr><tr><td><code>UnloadAsync</code></td><td>异步卸载 AssetBundle 中的资源。</td></tr></tbody></table><p><strong>Static Methods</strong></p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>GetAllLoadedAssetBundles</code></td><td>获取当前所有已加载的 AssetBundle 的枚举。</td></tr><tr><td><code>LoadFromFile</code></td><td>从磁盘文件同步加载 AssetBundle。</td></tr><tr><td><code>LoadFromFileAsync</code></td><td>从磁盘文件异步加载 AssetBundle。</td></tr><tr><td><code>LoadFromMemory</code></td><td>从内存区域同步加载 AssetBundle。</td></tr><tr><td><code>LoadFromMemoryAsync</code></td><td>从内存区域异步加载 AssetBundle。</td></tr><tr><td><code>LoadFromStream</code></td><td>从托管流同步加载 AssetBundle。</td></tr><tr><td><code>LoadFromStreamAsync</code></td><td>从托管流异步加载 AssetBundle。</td></tr><tr><td><code>RecompressAssetBundleAsync</code></td><td>异步将下载或存储的 AssetBundle 从一个构建压缩格式重新压缩到另一个。</td></tr><tr><td><code>UnloadAllAssetBundles</code></td><td>卸载所有当前加载的 AssetBundle。</td></tr></tbody></table><p><a href=https://docs.unity3d.com/ScriptReference/AssetBundle.html>Unity Scripting AssetBundle</a></p><h3 id=addressable-assets-system>Addressable Assets System</h3><p>这是Unity推荐的现代资源加载方式，通过Addressable Asset System，开发者可以将资源分组并动态加载，支持远程加载资源包，极大地提升了资源管理的灵活性和性能</p><h4 id=简介>简介</h4><p>Addressable Asset System允许开发者通过地址使用资产，一旦一个资产被标记为“addressable”，它便生成一个地址，可以在任何地方被调用；无论这个资产是在本地或远程，系统都会定位它和它的依赖，然后返回它</p><p>通过<code>Windows->Asset Management->Addressables</code>使用地址资源系统</p><p>Addressables使用异步加载技术，支持从任意位置加载任意依赖项集合。无论是使用直接引用、传统Asset Bundle还是Resources文件夹，Addressables都可以提供一种更简便的方法</p><p><a href=/log/Addressables/>Addressables</a></p><h2 id=资源卸载>资源卸载</h2><p>资源加载后，不及时释放也可能导致内存泄露</p><h2 id=资源优化>资源优化</h2><p>为了优化资源的加载与使用，Unity有多种工具和策略</p><ul><li>Asset Bundles：Unity提供的Asset Bundles可以将资源打包成一个文件，支持按需加载，适合于游戏内容更新或者大规模的资源管理</li><li>内存管理：Unity的内存管理非常关键，尤其是在移动设备或者内存受限的设备上。通过精确的资源加载和卸载策略，可以避免内存占用过多</li></ul></div><nav class=post-nav><a href=/runtime/log/animation-system/ class=hover:underline>pre: Animation System</a>
<a href=/runtime/log/attribute-in-unity/ class=hover:underline>next: Attribute in Unity</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#资源导入>资源导入</a><ul><li><a href=#资源导入的关键步骤>资源导入的关键步骤</a></li><li><a href=#常见的资源类型导入>常见的资源类型导入</a></li></ul></li><li><a href=#资源加载>资源加载</a><ul><li><a href=#class-resources>class Resources</a><ul><li><a href=#存放资产到resources文件夹>存放资产到Resources文件夹</a></li><li><a href=#加载方式>加载方式</a></li><li><a href=#构建优化问题>构建优化问题</a></li><li><a href=#不推荐过度使用路径加载>不推荐过度使用路径加载</a></li><li><a href=#使用场景>使用场景</a></li><li><a href=#内存管理>内存管理</a></li><li><a href=#api>API</a></li></ul></li><li><a href=#asset-bundles>Asset Bundles</a><ul><li><a href=#asset-bundles的核心概念>Asset Bundles的核心概念</a></li><li><a href=#创建asset-bundles>创建Asset Bundles</a></li><li><a href=#加载asset-bundles>加载Asset Bundles</a></li><li><a href=#卸载asset-bundle>卸载Asset Bundle</a></li><li><a href=#asset-bundle的优点和缺点>Asset Bundle的优点和缺点</a></li><li><a href=#api-1>API</a></li></ul></li><li><a href=#addressable-assets-system>Addressable Assets System</a><ul><li><a href=#简介>简介</a></li></ul></li></ul></li><li><a href=#资源卸载>资源卸载</a></li><li><a href=#资源优化>资源优化</a></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>