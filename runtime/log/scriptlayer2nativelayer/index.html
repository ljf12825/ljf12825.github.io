<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Script Layer to Native Layer</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-lua.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-rust.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/runtime/>★</a></li><li><a href=/runtime/lab/>Lab</a></li><li><a href=/runtime/log/>Log</a></li><li><a href=/runtime/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a> |
<a href=https://isocpp.org/ target=_blank>isocpp</a> |
<a href=https://open-std.org target=_blank>open-std</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/ target=_blank>lua.org</a> |
<a href=https://www.luarocks.org/ target=_blank>luarocks.org</a> |
<a href=https://www.luajit.org/ target=_blank>luajit.org</a></p><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a></p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a></p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Script Layer to Native Layer<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><h2 id=the-bridge-between-native-layer-and-script-layer>The Bridge between Native Layer and Script Layer</h2><p>Unity引擎运行时，本质上是一个C++引擎内核 + C#脚本层的结构</p><p>所写的<code>MonoBehaviour</code>只是在C#中的一个代理对象，真正控制游戏运行的逻辑、渲染、物理等是C++层在执行</p><p>所以从<code>UnityEngine.Object</code>开始，Unity构建了一个“双向映射体系”</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>C++对象（native） &lt;--- instance ID --- UnityEngine.Object（C#托管对象）
</span></span><span style=display:flex><span>        ↑                                       ↑
</span></span><span style=display:flex><span>    内存资源                                   脚本代理
</span></span></code></pre></div><h3 id=从object到monobehaviour的完整继承链>从Object到MonoBehaviour的完整继承链</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>System.Object （纯托管）
</span></span><span style=display:flex><span>└── UnityEngine.Object （托管对象，桥梁类）
</span></span><span style=display:flex><span>    ├── GameObject（托管对象）
</span></span><span style=display:flex><span>    └── Component
</span></span><span style=display:flex><span>        ├── Transform / Renderer / Collider...（托管对象）
</span></span><span style=display:flex><span>        └── MonoBehaviour （托管行为对象，支持生命周期方法）
</span></span></code></pre></div><p>它们都不是普通的C#对象，它们都与C++侧的“实体”挂钩，甚至生命周期也是引擎控制的</p><h3 id=native-layer-与-script-layer的绑定方式>native layer 与 script layer的绑定方式</h3><p>Unity会通过一套机制将C++层对象暴露给C#层，这其中最关键的桥梁是：<code>instance ID + GCHandle + m_CachedPtr</code></p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td><code>m_CachedPtr</code></td><td><code>UnityEngine.Object</code>中保留的指针，指向C++对象的地址（Unsafe）</td></tr><tr><td><code>GCHandle</code></td><td>Unity用于保持托管对象不被GC收走，native端持有</td></tr><tr><td><code>Instance ID</code></td><td>每个 C++ native 对象的唯一标识，Unity使用它查找C#代理对象</td></tr><tr><td><code>ScriptingObject</code></td><td>C++对象的基类，用于和C#对象绑定（runtime下存在）</td></tr><tr><td><code>MonoObject*</code></td><td>指向 C# 对象的原生指针（Mono环境时）</td></tr></tbody></table><p>流程图：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>C++对象 (ScriptingObject)
</span></span><span style=display:flex><span>   ↕ instance ID
</span></span><span style=display:flex><span>C#对象（UnityEngine.Object） ← GCHandle ← C++
</span></span><span style=display:flex><span>         ↑
</span></span><span style=display:flex><span>      m_CachedPtr → C++对象
</span></span></code></pre></div><h3 id=instance-id>instance ID</h3><p>Unity通过使用<code>instance ID</code>统一管理对象</p><p>每个在C++层的Unity对象都有一个唯一的标识符，即<code>instance ID</code>，它用于区分不同的C++对象。这个标识符的作用类似于内存中的指针</p><ul><li>在C#中，可以通过<code>UnityEngine.Object.GetInstanceID()</code>获取该对象的<code>instance ID</code></li><li>在C++中，通过这个<code>instance ID</code>可以找到实际的对象。所有Unity引擎的原生对象都会被注册到一个全局的对象管理器中，这个管理器会维护<code>instance ID</code>和对象之间的映射</li></ul><p>可以把<code>instance ID</code>想象成一个类似于数据库中的“主键”，它指向C++层中的实际属性。在C#层，Unity通过<code>m_CachedPtr</code>或类似机制与C++对象建立联系。C#调用一个方法或访问一个属性时，实际上就是通过这个<code>instance ID</code>去C++层查找并操作相应对象的</p><h3 id=c层对象的生命周期管理>C++层对象的生命周期管理</h3><p>在Unity中，C++层的对象生命周期是由引擎控制的，而不是像普通的C#对象那样由GC自动回收。也就是说，C++对象在被销毁时，并不会立即被C#垃圾处理器回收，而是由Unity引擎自己管理</p><p>关键点：</p><ul><li>C++层对象的创建和销毁：Unity引擎在创建或销毁对象时，会在C#层为这些C++对象创建对应的托管代理。当你调用<code>Destroy()</code>或<code>DestroyImmediate()</code>时，Unity会标记这个对象为待销毁，但实际销毁操作会发生在引擎的下一帧</li><li>GCHandle和<code>instance ID</code>：为了防止C#垃圾回收器误回收正在被引擎使用的对象，Unity会使用<code>GCHandle</code>来防止C#层的对象被GC销毁。<code>GCHandle</code>是一个特定的标记，它告诉C#的垃圾回收器，这个对象在native层还有引用，不应该被回收</li><li>内存管理：一旦<code>GameObject</code>或其他对象在C++层销毁，Unity会通过管理器从托管层移除该对象，确保其不再被访问。此时，C#层的引用会变成<code>null</code>，也就无法再访问该对象了。若访问，C#层会返回<code>null</code>，这便是Unity的<code>fake null</code>行为</li></ul><h3 id=c和c的指针交互>C#和C++的指针交互</h3><p>在C#和C++之间，<code>m_CachedPtr</code>是Unity使用的一个关键字段，它保存了C++对象的指针。这个指针并不会直接暴露，而是通过<code>UnityEngine.Object</code>的方法间接访问</p><p>例如，当使用<code>Instantiate()</code>克隆一个对象时，C#层会创建一个新的对象，并将其<code>m_CachedPtr</code>指向一个新的C++对象。这种机制确保了C#和C++层可以同步管理对象的创建、销毁和引用</p><p>为什么不直接使用C++指针</p><ul><li>安全性：如果C#直接操作C++指针，那么内存管理将变得非常复杂，容易发生野指针错误（例如访问已销毁的对象）</li><li>跨平台：Unity需要支持多个平台，如果直接操作原始指针，会导致平台之间的不兼容</li></ul><h3 id=内存和资源管理native与managed内存>内存和资源管理：Native与Managed内存</h3><p>Unity对内存的管理通常分为两类：托管内存（Managed Memory）和原生内存（Native Memory）</p><p>托管内存：</p><ul><li>这是C#层的内存，由.NET的垃圾回收器负责管理。Unity中的许多类都在托管内存中分配</li><li>例如，通过<code>new GameObject()</code>创建一个对象时，它实际上是在托管内存中创建了一个<code>GameObject</code>代理类，该类最终通过<code>instance ID</code>和C++对象绑定</li></ul><p>原生内存：</p><ul><li>这是C++层的内存。Unity对这些内存进行严格管理，确保它们被正确地分配和释放</li><li>对于一个<code>GameObject</code>，它在C++层的实际数据都存在原生内存中。C#只能通过指针和绑定方法访问这些内存数据，而不能直接操作它</li></ul><h3 id=资源的加载与卸载的底层机制>资源的加载与卸载的底层机制</h3><p>Unity的资源管理在C++层也有对应的资源对象，它们通过资源路径和资源管理系统来加载和卸载</p><p>当使用<code>Resource.Load()</code>或<code>Addressables</code>加载资源时，Unity会在C++层将资源加载到内存中，并返回一个C#层的代理对象。这些资源的引用计数会由C++层管理，当没有对象再引用这些资源时，C++层会负责销毁这些内存并释放内存</p><h3 id=性能和优化>性能和优化</h3><ol><li><p>频繁的资源加载和卸载：如果你在每帧都调用 Resources.Load() 或频繁销毁对象，可能会导致性能瓶颈。推荐使用 Addressables 或 Object Pooling 技术来优化资源管理。</p></li><li><p>避免大量无效对象：例如，创建大量的 GameObject、MonoBehaviour，然后频繁销毁。这样不仅会增加垃圾回收的负担，还会在 C++ 层产生频繁的对象创建和销毁开销。可以使用对象池来减少这种开销。</p></li><li><p>内存泄漏问题：如果对象在 C++ 层没有正确销毁，可能导致内存泄漏。特别是 MonoBehaviour 等绑定对象，它们的销毁需要确保在 C# 层正确解除引用，否则即使对象在 C++ 层销毁，C# 层的引用仍会阻止 GC 回收。</p></li></ol><h3 id=对象创建过程>对象创建过程</h3><p>以创建一个<code>GameObject</code>为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>GameObject go = <span style=color:#ff79c6>new</span> GameObject(<span style=color:#f1fa8c>&#34;Hero&#34;</span>);
</span></span></code></pre></div><p>在背后发生了：</p><ol><li>C#调用UnityEngine的构造方法</li><li>Unity C#层调用了内部绑定的native构造函数（通过<code>[NativeMethod]</code>或<code>extern</code>实现）</li><li>C++中创建了一个<code>GameObject</code>对象，并注册<code>instance ID</code></li><li>Unity C++层为这个对象创建一个C#代理，分配内存，绑定<code>m_CachedPtr</code></li><li>如果启用脚本（MonoBehaviour），则Unity会通过反射或运行时代码绑定，自动挂载脚本（生成MonoObject，绑定）</li></ol><h2 id=monobehaviour的生命周期的控制>MonoBehaviour的生命周期的控制</h2><p>生命周期函数是Unity引擎每帧自动调度的：</p><ul><li>Unity在每帧中，遍历所有激活的<code>GameObject</code>和<code>Component</code></li><li>检查是否存在重写的生命周期函数</li><li>调用托管对象中的方法（通过反射或自动生成的绑定）</li></ul><h2 id=monobehaviour是怎么挂载的>MonoBehaviour是怎么挂载的</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>gameObject.AddComponent&lt;MyScript&gt;();
</span></span></code></pre></div><p>内部流程：</p><ol><li>C#调用泛型方法<code>AddComponent&lt;T>()</code></li><li>UnityC#层调用底层<code>AddComponent(Type t)</code>(native bridge)</li><li>引擎C++层创建一个<code>MonoBehaviour</code>实例（C++对象）</li><li>引擎创建对应的C#代理对象，并调用构造函数</li><li>将代理对象挂到该<code>GameObject</code>下，并添加到调度列表中</li><li>引擎在适当时机调用<code>Awake() -> Start() -> Update()</code></li></ol><p>所以不能用<code>new MyScript()</code>创建MonoBehaviour，它不是纯托管类，是托管↔native绑定类</p></div><nav class=post-nav><a href=/runtime/log/scene-system/ class=hover:underline>pre: Scene System</a>
<a href=/runtime/log/scriptableobject/ class=hover:underline>next: ScriptableObject</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#the-bridge-between-native-layer-and-script-layer>The Bridge between Native Layer and Script Layer</a><ul><li><a href=#从object到monobehaviour的完整继承链>从Object到MonoBehaviour的完整继承链</a></li><li><a href=#native-layer-与-script-layer的绑定方式>native layer 与 script layer的绑定方式</a></li><li><a href=#instance-id>instance ID</a></li><li><a href=#c层对象的生命周期管理>C++层对象的生命周期管理</a></li><li><a href=#c和c的指针交互>C#和C++的指针交互</a></li><li><a href=#内存和资源管理native与managed内存>内存和资源管理：Native与Managed内存</a></li><li><a href=#资源的加载与卸载的底层机制>资源的加载与卸载的底层机制</a></li><li><a href=#性能和优化>性能和优化</a></li><li><a href=#对象创建过程>对象创建过程</a></li></ul></li><li><a href=#monobehaviour的生命周期的控制>MonoBehaviour的生命周期的控制</a></li><li><a href=#monobehaviour是怎么挂载的>MonoBehaviour是怎么挂载的</a></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>