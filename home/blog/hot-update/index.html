<!doctype html><html lang=en><head><meta charset=UTF-8><title>Hot Update</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/home/>~</a></li><li><a href=/home/article/>Article</a></li><li><a href=/home/blog/>Lib</a></li><li><a href=/home/repository/>Repos</a></li><li><a href=/home/files/>Files</a></li><li><a href=/home/resource/>Resource</a></li><li><a href=/home/reference/>Ref</a></li><li><a href=/home/about/>About</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/system/ href=/system/>System</a>          |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |                                |
|                        /    |                                |
|                       /     |                                |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |                <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |                <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                          <a class=nav-item data-path=/csbasic/ href=/csbasic/>CSBasic</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Hot Update<div class=meta>Update: 2025-06-01
>> Creator：ljf12825</div></div><div class=content><p>热更新指的是在游戏运行后，不需要重写打包和分发客户端，就能更新或修复代码、资源的机制<br>简单理解：</p><ul><li>不热更：出了bug -> 改代码 -> 重新打包 -> 玩家重新下载安装</li><li>热更：除了bug -> 改代码 -> 发布更新包 -> 玩家下小补丁，立即生效</li></ul><p>为什么要用热更新</p><ul><li>移动端、主机端游戏包体大、审核严格，频繁发新包代价极高</li><li>上线后bug修复：能第一时间止血</li><li>内容更新：节省分发成本（活动、新关卡、皮肤）</li><li>快速迭代：尤其是手游和运营类游戏</li></ul><h2 id=unity热更新常见方式>Unity热更新常见方式</h2><h3 id=资源热更新>资源热更新</h3><p>主要解决美术资源、配置文件更新问题<br>实现思路：</p><ul><li>把资源（Prefab/Texture/音效等）打成AssetBundle</li><li>游戏运行时从服务器下载最新AssetBundle -> 替换旧资源</li><li>配合资源版本管理（Manifest + Hash）</li></ul><p>特点：</p><ul><li>实现简单</li><li>Unity官方支持</li><li>只能更新资源，不能更新逻辑代码</li></ul><h3 id=代码热更新>代码热更新</h3><p>核心：C#脚本的运行时代码替换<br>UnityC#脚本编译后会生成IL（中间语言），运行时通过Mono或IL2CPP执行<br>要想热更，需要解决如何加载/执行新代码</p><p>常见方案：</p><ol><li>反射/动态加载DLL</li></ol><ul><li>用Mono编译器在外部生成新的DLL</li><li>游戏运行时加载（Assembly.Load）</li><li>可以调用新逻辑，但有局限性</li></ul><p>缺点：</p><ul><li>IL2CPP平台不支持直接动态加载DLL（比如iOS）</li></ul><ol start=2><li>ILRuntime（国内常用）</li></ol><ul><li>一个开源的IL解释器</li><li>运行时用解释执行外部编译的DLL</li><li>解决了IL2CPP的限制，可以在iOS/Android都用</li></ul><p>特点：</p><ul><li>跨平台</li><li>活跃社区，国内大厂常用（比如热更新游戏项目）</li><li>性能比原生IL差（解释执行）</li></ul><ol start=3><li>HybridCLR（近几年兴起）</li></ol><ul><li>思路是补全Unity剪掉的AOT元数据，让运行时能加载新的IL</li><li>结合热更DLL + 补充元数据，实现近似原生的性能</li></ul><p>特点：</p><ul><li>性能接近原生</li><li>无需解释器，能跑在IL2CPP上</li><li>实现复杂，生态还在发展</li></ul><ol start=4><li>Lua/JS脚本热更</li></ol><ul><li>用Lua、JS等脚本语言写游戏逻辑</li><li>Unity只负责运行时环境</li><li>热更就是替换脚本文件</li></ul><p>特点：</p><ul><li>逻辑热更灵活</li><li>不依赖C#</li><li>开发效率、IDE支持差，团队要适应</li></ul><h2 id=混合方案>混合方案</h2><ul><li>资源用AssetBundle更新</li><li>逻辑用HybridCLR/ILRuntime/Lua热更</li><li>配置数据用JSON/CSV/ScriptableObject更新</li></ul><h2 id=热更的关键技术点>热更的关键技术点</h2><ol><li>版本管理</li></ol><ul><li>需要有版本号、校验Hash、对比差异的机制</li></ul><ol start=2><li>更新流程</li></ol><ul><li>检查更新 -> 下载资源/DLL -> 校验 -> 替换</li></ul><ol start=3><li>安全性</li></ol><ul><li>防止恶意替换，通常用签名验证、加密</li></ul><ol start=4><li>灰度发布</li></ol><ul><li>分批投放，避免更新导致全服崩溃</li></ul><h3 id=反射和动态加载dll>反射和动态加载DLL</h3><p>这种方式尤其适用于C#脚本的运行时修改<br>它的基本思想是将某些逻辑封装在DLL文件中，在游戏运行时动态加载这些DLL，并通过反射来调用其中的功能</p><h4 id=原理>原理</h4><p><strong>反射</strong><br>反射是C#提供的机制，可以在运行时获取对象的元数据（如类、方法、属性等），并可以通过这些元数据来动态地实例化对象或调用方法<br>它是热更新的核心技术之一，通常用来实现在不修改现有代码的情况下调用新DLL中的功能</p><p><strong>动态加载DLL</strong>
C#提供了<code>Assembly.Load</code>方法，可以在运行时加载外部的DLL文件，并通过反射来访问其中的类型和成员（如类、方法）<br>通过这种方式，可以将新版本中的DLL替换到游戏中，而无需重新打包整个应用</p><h4 id=实现>实现</h4><ol><li>将逻辑封装为DLL</li></ol><p>将业务逻辑代码编译成一个独立的DLL文件
- 将这部分代码从Unity主项目中分离，独立编译成DLL
- DLL中的功能可以是游戏中的各种逻辑模块，比如角色行为、敌人AI任务系统等</p><ol start=2><li>在运行时动态加载DLL</li></ol><p>使用<code>Assembly.Load</code>来加载DLL文件。加载时，可以通过文件路径、资源流等方式加载DLL文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Reflecion;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 动态加载DLL</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> dllPath = <span style=color:#e6db74>&#34;Assets/HotUpdate/HotUpdate.dll&#34;</span>;
</span></span><span style=display:flex><span>Assembly hotUpdateAssembly = Assembly.LoadFrom(dllPath);
</span></span></code></pre></div><ol start=3><li>通过反射调用DLL中的类和方法</li></ol><p>加载完DLL后，可以通过反射来创建DLL中的对象并调用它们的方法<br>例如，假设有一个<code>Player</code>类，并且它有一个<code>Move</code>方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 获取类型</span>
</span></span><span style=display:flex><span>Type playerType = hotUpdateAssembly.GetType(<span style=color:#e6db74>&#34;HotUpdate.Player&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建实例</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>object</span> playerInstance = Activator.CreateInstance(playerType);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取方法并调用</span>
</span></span><span style=display:flex><span>MethodInfo moveMethod = playerType.GetMethod(<span style=color:#e6db74>&#34;Move&#34;</span>);
</span></span><span style=display:flex><span>moveMethod.Invoke(playerInstance, <span style=color:#66d9ef>null</span>); <span style=color:#75715e>// 这里传入的参数可以根据需要传入</span>
</span></span></code></pre></div><ol start=4><li>处理依赖和接口</li></ol><p>如果想把某些接口保留给DLL使用，可以通过接口实现来避免代码耦合<br>在反射中，通常会使用接口来确保DLL中的代码能访问到需要的功能<br>例如，定义一个公共接口</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IPlayer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> Move();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> Attack();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后在DLL中实现这个接口</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Player</span> : IPlayer
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Move() { <span style=color:#75715e>/* 运动逻辑 */</span> }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Attack() { <span style=color:#75715e>/* 攻击逻辑 */</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>主程序运行时加载DLL后，可以通过反射获取到接口和实现类，避免直接引用DLL中的实现类，从而减少耦合</p><ol start=5><li>更新和卸载DLL</li></ol><p>每当想更新代码时，只需要替换DLL文件，游戏运行时会加载新的DLL<br>可以实现代码的卸载和重新加载（但这在.NET环境下并不完全支持，尤其是在IL2CPP环境下），可以通过使用AppDomain来卸载和重新加载DLL</p><h4 id=特点>特点</h4><p><strong>优点</strong></p><ol><li>灵活性高
可以在不修改主程序的情况下更新代码。只需要替换 DLL 文件，玩家无需重新下载游戏</li></ol><ul><li>如果是修复 bug 或者增加一些功能，特别是在线游戏，热更新非常有用</li></ul><ol start=2><li>快速修复和更新
缩短了开发周期，尤其是在测试阶段，能快速实现代码修改</li></ol><ul><li>例如，修复客户端的小问题，可以只更新某个模块的 DLL，而不需要重新发布整包</li></ul><ol start=3><li>减少游戏包体大小</li></ol><ul><li>大型游戏通常有很多可扩展的模块（如剧情、任务、AI等）</li><li>只加载需要更新的DLL文件，避免了整包的更新</li></ul><ol start=4><li>跨平台支持
对于支持Mono的平台（如Android、PC），反射和动态加载DLL的方式可以很好地实现热更新<br>对于iOS、主机平台等则存在一定限制（特别是IL2CPP环境下）</li></ol><p><strong>缺点</strong></p><ol><li><p>性能开销
使用反射会带来一定的性能开销。虽然现代的 JIT 编译和优化技术已经减少了这些开销，但比起直接调用普通方法，反射的速度仍然较慢</p></li><li><p>代码耦合性强
动态加载 DLL 可能会导致项目之间的依赖关系过于复杂，尤其是涉及到多个 DLL 之间的相互引用时</p></li></ol><ul><li>需要通过接口或抽象类来进行解耦，但这增加了代码设计的难度</li></ul><ol start=3><li>调试难度增加
动态加载 DLL 后，调试时可能会遇到更多的困难，尤其是在 IDE 中无法直接追踪到 DLL 内的逻辑</li></ol><ul><li>如果错误发生在 DLL 中，定位问题会更加复杂</li></ul><ol start=4><li>IL2CPP不支持直接加载DLL
由于 Unity 的 IL2CPP 编译方式不支持直接加载 DLL，因此这对 iOS 和其他 IL2CPP 平台的支持较差</li></ol><ul><li>解决方法是将代码转换成 C++，或者使用 HybridCLR 等解决方案</li></ul><ol start=5><li>内存管理问题
在运行时加载和卸载 DLL 会引入一定的内存管理问题，尤其是在没有垃圾回收机制的环境下（如 IL2CPP）</li></ol><ul><li>如果没有正确管理内存，可能会导致内存泄漏等问题</li></ul><h4 id=适用场景>适用场景</h4><ol><li><p>在线游戏bug修复
对于一些大型的 MMO 或 MOBA 类型的游戏，可能需要频繁修复小的 bug 或调整一些游戏逻辑。通过热更新方式，开发人员可以快速发布修复，用户无需等待长时间的更新包</p></li><li><p>内容更新和新功能
如果游戏内有定期更新的新功能（例如新的活动、任务、道具等），这时也可以通过热更新的方式，定期加载新的 DLL，而不需要重新下载整个游戏客户端</p></li><li><p>游戏内测试和调试
开发者可以将测试版本的 DLL 通过热更新的方式推送给玩家，以进行 A/B 测试或者验证某些游戏逻辑的调整，而不需要强制用户重新安装更新包</p></li></ol><p>在实际应用中，反射和动态加载DLL方式常常与AssetBundle和配置文件热更新结合使用，形成一个完整的热更新解决方案</p><h3 id=ilruntime>ILRuntime</h3><p>ILRuntime是一个开源的C#运行时，它可以在Unity或其他.NET环境中动态加载和执行C#代码，特别是运行时加载的DLL文件中的代码。它可以绕过一些Unity在编译时的限制，提供一种能够在IL2CPP环境下进行代码热更新的解决方案<br>ILRuntime允许将游戏逻辑代码编译为单独的DLL文件，并在游戏运行时动态加载这些DLL。这些DLL可以包含希望更新的功能或修复的bug。ILRuntime会在运行时将IL代码加载并解释执行\</p><p>ILRuntime的核心功能：</p><ul><li>热更新支持：通过动态加载IL编译的DLL文件，实现代码热更新</li><li>跨平台支持：ILRuntime可以在Unity的各种平台（包括iOS和Android）上允许，甚至支持IL2CPP</li><li>性能优化：ILRuntime提供了接近本地代码的性能，尤其是在Unity使用IL2CPP编译时，比传统的反射和动态加载DLL性能更高</li><li>支持跨线程执行：ILRuntime支持将热更新的逻辑运行在Unity的主线程以外，提升游戏的性能</li></ul><h4 id=ilruntime的实现原理>ILRuntime的实现原理</h4><p><strong>原理概述</strong>
ILRuntime基于解释执行原理工作，它并不像传统的JIT（即时编译）那样将IL代码即时转换为机器码，而是通过反射和解释器来执行IL代码</p><ul><li>加载DLL：ILRuntime会将外部的DLL加载到内存中，进行解析</li><li>执行IL代码：ILRuntime会通过内部的解释器执行IL代码，而不是直接编译成机器代码。它可以通过将IL代码映射到原生代码的方式来执行动态代码</li><li>托管代码调用：ILRuntime允许你调用托管代码中的方法、属性等，并且支持多态、委托、反射等常见的.NET特性</li></ul><p><strong>工作流程</strong></p><ol><li>编译DLL：将游戏逻辑编译成一个独立的DLL文件</li><li>加载DLL：游戏运行时，ILRuntime会加载这个DLL文件</li><li>反射与调用：ILRuntime会通过反射等机制动态调用DLL中的类和方法，实现游戏的功能更新</li><li>更新DLL：每次修改代码时，只需编译成新的DLL，然后通过热更新流程替换旧的DLL，游戏会加载新的代码逻辑</li></ol><p><strong>核心组件</strong></p><ul><li>CLR模拟：ILRuntime基本上是通过模拟.NET CLR的运行时环境来解释执行IL代码</li><li>解释器：ILRuntime 提供了一套高效的解释器，可以解释执行 IL 代码，而不是通过 JIT 编译器生成机器码</li><li>跨平台支持：ILRuntime 在 Unity 上的实现特别适用于 IL2CPP 环境，它绕过了 IL2CPP 不支持动态加载 DLL 的限制</li></ul><h4 id=ilruntime的特点>ILRuntime的特点</h4><h5 id=优势>优势</h5><ol><li>性能较好
相比于传统的反射和动态加载 DLL 的方法，ILRuntime 提供了较好的性能，尤其是在 IL2CPP 环境下。ILRuntime 使用的是解释执行，因此相对较慢，但它比传统的反射 要高效</li></ol><ul><li>对于需要高性能的游戏，它的性能优化已经足够接近原生代码</li></ul><ol start=2><li><p>跨平台支持
ILRuntime支持Unity所有主流平台，特别是IL2CPP（如iOS）<br>ILRuntime解决了Unity在IL2CPP环境下无法动态加载DLL的问题</p></li><li><p>简化开发
开发者可以在不修改主项目的前提下，通过热更新修复或修改游戏逻辑</p></li></ol><ul><li>比如，修复bug、调整游戏参数、或者添加新功能，只需修改并替换DLL即可</li><li>这减少了开发和测试的周期，提高了效率</li></ul><ol start=4><li>无缝集成到Unity中
ILRuntime可以与Unity无缝集成，开发者无需对现有的Unity项目做太多改动</li></ol><ul><li>它提供了简单易用的API，可以在Unity中快速实现热更新</li></ul><ol start=5><li>支持跨线程执行
ILRuntime 支持将热更新代码的执行放在非主线程中，这对于有大量后台计算任务的游戏来说非常有用</li></ol><ul><li>可以避免主线程被阻塞，提高游戏的流畅度</li></ul><h5 id=缺点>缺点</h5><ol><li>性能开销
尽管ILRuntime已经在性能上做了优化，但它仍然无法与原生编译的代码相媲美</li></ol><ul><li>解释执行的方式相对于JIT编译和AOT编译仍然较慢，尤其是在需要大量计算和频繁调用的逻辑中，性能可能受到影响</li></ul><ol start=2><li>支持的特性有限
ILRuntime是一个运行时解释器，它并不是一个完全的CLR实现，因此在某些特性上的支持有限</li></ol><ul><li>比如，ILRuntime可能不支持一些高级的.NET特性，这要求开发者在使用时要小心</li></ul><ol start=3><li>调试困难
由于热更新代码是通过 ILRuntime 在运行时动态加载的，因此调试热更新的代码比直接调试原生 C# 代码要困难一些</li></ol><ul><li>特别是在 IDE 中，无法直接对加载到运行时的 DLL 进行调试，开发者需要通过日志和其他手段来调试</li></ul><ol start=4><li>内存管理问题
ILRuntime 主要依赖于 垃圾回收机制 来管理内存，因此在使用大量对象和频繁加载 DLL 的场景中，内存管理可能成为一个问题</li></ol><ul><li>开发者需要特别注意内存泄漏和 卸载 DLL 时的资源释放</li></ul><h4 id=使用场景>使用场景</h4><ol><li>游戏运营</li></ol><ul><li>大型在线游戏：MMO、MOBA 等类型的游戏，在运营过程中需要频繁修复 bug 或更新游戏内容。ILRuntime 能够支持游戏中的 代码热更新，从而减少重新发布 APK 或重新审核包的时间</li></ul><ol start=2><li>灵活的插件系统</li></ol><ul><li>插件式结构：一些游戏会采用插件化的架构，例如任务系统、剧情脚本等模块。ILRuntime 允许你把这些模块以 DLL 形式封装，并通过热更新动态加载</li></ul><ol start=3><li>快速迭代</li></ol><ul><li>在开发阶段，尤其是原型开发阶段，ILRuntime 让开发者能够 快速测试新功能和修复 bug。只需替换 DLL 文件，而不需要重新打包整个游戏</li></ul><ol start=4><li>游戏调试和测试</li></ol><ul><li>在游戏发布后，ILRuntime 可以支持 游戏内调试和修改。开发者可以在不影响其他部分代码的情况下，独立调试并测试热更新的模块</li></ul><h4 id=ilruntime的使用>ILRuntime的使用</h4><h5 id=1-准备工作>1. 准备工作</h5><p>安装并配置ILRuntime环境<br>步骤1：导入ILRuntime到Unity</p><ol><li>下载ILRuntime，从GitHub或Unity Asset Stroe中</li><li>导入Unity项目：</li></ol><ul><li>打开Unity项目，在Assets目录下右键选择Import Package或者直接拖拽ILRuntime文件夹导入到项目中
在导入时，需要确保将ILRuntime相关的DLL（比如<code>ILRuntime.dll</code>）和支持文件添加到项目中</li></ul><p>步骤2：配置ILRuntime</p><ul><li>ILRuntime会依赖Unity项目中的CLR环境，并通过ILRuntime提供的API来加载和执行运行时代码</li><li>配置完成后，确保<code>ILRuntime</code>目录和相关文件在Unity的Assets下正确存在</li></ul><h5 id=2-编译和部署dll>2. 编译和部署DLL</h5><p>ILRuntime热更新的关键在于将游戏逻辑代码单独编译为DLL，然后通过ILRuntime在运行时加载和执行<br>步骤1：创建独立的项目和代码</p><ol><li>创建一个C#类库项目：在Visual Studio中创建一个新的Class Library项目，用于编写和编译热更新代码</li></ol><p>例如创建一个<code>HotUpdate</code>类库</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>namespace</span> HotUpdate
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameLogic</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> StartGame()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            UnityEngine.Debug.Log(<span style=color:#e6db74>&#34;Game Started!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>引用ILRuntime</li></ol><ul><li>在C#项目的引用中加入ILRuntime的DLL</li><li>可以将ILRuntime的<code>ILRuntime.dll</code>拷贝到类库项目中，然后将其添加为引用</li></ul><ol start=3><li>编译DLL：编译类库项目，生成一个HotUpdate.dll文件。可以将该DLL文件放到Unity项目的StreamingAssets文件夹下，或者直接放到<code>Assets</code>目录下的某个子文件中</li></ol><p>步骤2：编译其他需要的DLL
除了主游戏项目的C#代码外，可能还需要编译一些辅助库（例如定义接口的库）作为独立的DLL文件</p><h5 id=3-在unity中加载和运行dll>3. 在Unity中加载和运行DLL</h5><p>步骤1：加载DLL<br>在Unity中，需要编写一个脚本来加载并执行DLL中的代码。以下是加载和执行方法的基本步骤</p><ol><li>加载DLL文件：
ILRuntime提供了<code>ILRuntime.Runtime.Enviorment.AppDomain</code>来加载和管理动态加载的程序集</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> ILRuntime.Runtime.Enviorment;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Reflection;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HotUpdateManager</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> AppDomain appDomain;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span>  Start()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化 ILRuntime环境</span>
</span></span><span style=display:flex><span>    appDomain = <span style=color:#66d9ef>new</span> AppDomain();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加载DLL</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> dllPath = Applicaiton.streamingAssetsPath + <span style=color:#e6db74>&#34;/HotUpdate.dll&#34;</span>; <span style=color:#75715e>// 假设DLL在StreamingAssets下</span>
</span></span><span style=display:flex><span>    appDomain.LoadAssembly(dllPath);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中，<code>LoadAssembly</code>方法会加载之前编译好的HotUpdate.dll</p><p>步骤2：反射调用DLL中的类和方法
加载DLL后，需要通过反射调用其中的类和方法。ILRuntime提供的丰富的反射API，可以在运行时获取类型并调用方法<br>例如：加载的DLL中包含一个<code>GameLogic</code>类和<code>StartGame</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> ILRuntime.Runtime.Intereter;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HotUpdateManager</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> AppDomain appDomain;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化 ILRuntime环境</span>
</span></span><span style=display:flex><span>    appDomain = <span style=color:#66d9ef>new</span> AppDomain();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加载DLL</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> dllPath = Application.streamingAssetsPath + <span style=color:#e6db74>&#34;/HotUpdate.dll&#34;</span>;
</span></span><span style=display:flex><span>    appDomain.LoadAssembly(dllPath);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取类型（反射）</span>
</span></span><span style=display:flex><span>    Type gameLogicType = appDomain.LoadedTypes[<span style=color:#e6db74>&#34;HotUpdate.GameLogic&#34;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建实例</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> gameLogicInstance = Activator.CreateInstance(gameLogicType);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取方法（反射）</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> startGameMethod = gameLogicType.GetMethod(<span style=color:#e6db74>&#34;StartGame&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 调用方法</span>
</span></span><span style=display:flex><span>    startGameMethod.Invoke(gameLogicInstance, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>appDomain.LoadedTypes</code>用于获取DLL中所有加载的类型</li><li><code>Activator.CreateInstance</code>用于动态创建类的实例</li><li><code>GetMethod</code>和<code>Invoke</code>用于动态调用方法</li></ul><p>步骤3：处理参数和返回值
ILRuntime支持传递参数并处理返回值。当调用方法时，可以通过反射传递参数给方法，并接收返回值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> method = gameLogicType.GetMethod(<span style=color:#e6db74>&#34;SomeMethod&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> result = method.Invoke(gameLogicInstance, <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>object</span>[] { param1, param2 });
</span></span></code></pre></div><h5 id=4-热更新流程>4. 热更新流程</h5><p>步骤1：替换DLL
热更新的关键就是替换DLL文件。内次修改并重新编译DLL，只需将新的DLL文件替换掉Unity项目中原有的DLL文件</p><p>ILRuntime会在游戏运行时加载新的DLL，并执行其中的代码。Unity会自动通过<code>LoadAssembly</code>加载并运行新的DLL</p><p>步骤2：动态切换逻辑
如果需要动态切换热更新逻辑（比如用户登录后加载不同的功能模块），可以在运行时加载不同版本的DLL或者不同模块的DLL<br>例如，如果更新了某个DLL，可以通过以下方式重新加载并切换数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>appDomain.LoadAssembly(newDllpath); <span style=color:#75715e>// 加载新的DLL</span>
</span></span></code></pre></div><h5 id=注意事项>注意事项</h5><ol><li>跨平台支持：ILRuntime可以在Unity支持的所有平台上运行，特别适合于iOS和Android（IL2CPP环境）</li><li>接口和继承：需要确保热更新的DLL能与主程序共享接口和基类，避免类型冲突。可以将一些接口和抽象类保存在一个公共的程序集（DLL）中</li><li>性能考虑：ILRuntime会通过解释执行IL代码，这回带来一定的性能损失。虽然它已经做了优化，但对于高性能要求的游戏，仍需要注意性能瓶颈</li><li>调试支持：ILRuntime的调试比直接调试C#代码困难，建议使用日志工具和测试工具来调试热更新代码</li></ol><h3 id=hybridclr>HybridCLR</h3><p>HybridCLR是一种Unity热更新方案，它解决了传统热更新技术在IL2CPP平台上遇到的限制</p><ul><li>它允许你在IL2CPP环境下加载和执行C#热更新DLL</li><li>本质上是原生IL与AOT代码的混合执行，因此叫Hybrid（混合）CLR</li></ul><p>特点：</p><ul><li>支持IL2CPP（iOS、主机平台）</li><li>热更新性能接近原生C#</li><li>可以调用原生C++生成的AOT代码</li><li>支持泛型、委托、接口等完整C#特性</li></ul><p>ILRuntime适合快速迭代、小项目，HybridCLR更适合商业项目和高性能需求</p><h4 id=hybridclr的原理>HybridCLR的原理</h4><p>HybridCLR的核心是 AOT 补充 + IL 执行</p><ol><li><p>AOT 预生成
Unity IL2CPP会将C#转换成C++，编译成机器码。HybridCLR会生成一份补充AOT元数据（Method/Type信息），以支持运行时加载新的DLL</p></li><li><p>DLL热更新
把热更新逻辑编译成DLL（纯IL代码），运行时通过HybridCLR的加载机制调用</p></li><li><p>混合执行</p></li></ol><ul><li>对AOT已有的方法直接调用原生代码</li><li>对热更新DLL中的方法，HybridCLR会利用AOT元数据和IL来执行</li><li>支持接口、泛型、委托、虚方法等特性</li></ul><ol start=4><li>优势</li></ol><ul><li>不用解释执行，性能接近原生</li><li>可以热更新几乎完整的C#逻辑</li><li>支持IL2CPP平台</li></ul><h4 id=使用场景-1>使用场景</h4><ol><li>商业游戏热更新</li></ol><ul><li>MMOG、MOBA、卡牌等长期运营游戏</li><li>需要频繁修复逻辑bug或添加新功能</li></ul><ol start=2><li>性能敏感场景</li></ol><ul><li>游戏核心逻辑、AI计算、战斗逻辑</li><li>使用ILRuntime可能会有性能瓶颈，HybridCLR更适合</li></ul><ol start=3><li>跨平台热更新</li></ol><ul><li>Android/ iOS/ 主机/PC</li><li>HybridCLR支持所有IL2CPP平台</li></ul><h4 id=使用>使用</h4><h5 id=步骤1导入hybridclr>步骤1：导入HybridCLR</h5><ol><li>在Unity中导入HybridCLR包（从GitHub或 Unity Package Manager）</li><li>配置HybridCLR插件：</li></ol><ul><li>打开<code>HybridCLR/Settings</code></li><li>设置热更新DLL存放路径</li><li>配置需要生成AOT补充的类型</li></ul><h5 id=步骤2编写热更新dll>步骤2：编写热更新DLL</h5><ol><li>创建一个独立的C# Class Library</li><li>写希望热更新的逻辑，例如：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>namespace</span> HotUpdate
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Player</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Move()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      UnityEngine.Debug.Log(<span style=color:#e6db74>&#34;Player move!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>编译DLL（确保使用.NET Framework 或 .NET Standard 与 Unity兼容）</li><li>将DLL放到Unity项目的热更新目录（通常是<code>Assets/HotUpdate</code>或StreamingAssets）</li></ol><h5 id=步骤3生成aot补充>步骤3：生成AOT补充</h5><p>HybridCLR需要生成AOT元数据补充文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># HybridCLR提供了 Editor 工具来生成</span>
</span></span><span style=display:flex><span>HybridCLR/GenerateAOTMetadata
</span></span></code></pre></div><ul><li>生成的文件会让 IL2CPP可以调用热更新DLL中的泛型、接口、虚方法等</li><li>这是HybridCLR核心所在，否则热更新DLL在IL2CPP上无法正常运行</li></ul><h5 id=步骤4加载和调用dll>步骤4：加载和调用DLL</h5><p>Unity热更新代码示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> HybridCLR;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HotUpdateManager</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化 HybridCLR</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> dllPath = Application.streamingAssetsPath + <span style=color:#e6db74>&#34;/HotUpdate.dll&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> dllBytes = System.IO.File.ReadAllBytes[dllPath];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HybridCLR.RuntimeApi.LoadMetadataForAOTAssembly(dllBytes); <span style=color:#75715e>// 加载 AOT 补充</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 调用热更新 DLL 中的逻辑</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> assembly = System.Reflection.Assembly.Load(dllBytes);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> type = assembly.GetType(<span style=color:#e6db74>&#34;HotUpdate.Player&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> instance = Activator.CreateInstance(type);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> method = type.GetMethod(<span style=color:#e6db74>&#34;Move&#34;</span>);
</span></span><span style=display:flex><span>    method.Invoke(instance, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>LodaMetadataForAOTAssembly是HybridCLR核心API，用于让IL2CPP可以调用热更新DLL</li><li>之后可以用反射或直接调用热更新逻辑</li></ul><h5 id=步骤5热更新流程>步骤5：热更新流程</h5><ol><li>修改热更新代码 -> 编译成新的DLL</li><li>上传到服务器或替换 StreamingAssets下的DLL</li><li>游戏运行时通过HybridCLR加载新的DLL -> 热更新生效</li></ol><blockquote><p>重点：因为HybridCLR使用AOT补充，几乎可以热更新所有C#逻辑，包括泛型、委托、接口和虚方法</p></blockquote><h4 id=特点-1>特点</h4><h5 id=优点>优点</h5><ol><li>性能接近原生：几乎没有解释开销</li><li>完整的C#支持：泛型、接口、委托、虚方法都可以热更新</li><li>跨平台：IL2CPP平台也能热更新</li><li>商业可用</li></ol><h5 id=缺点-1>缺点</h5><ol><li>配置复杂：</li></ol><ul><li>需要生成AOT补充</li><li>DLL编译和路径管理需要规范</li></ul><ol start=2><li>调试比普通C#难：热更新逻运行在HybridCLR上，需要日志和测试工具</li><li>DLL更新流程稍复杂：热更新DLL + AOT补充同步发布</li></ol><h3 id=luajs脚本热更>Lua/JS脚本热更</h3><h4 id=存在原因>存在原因</h4><ol><li>C# 在 iOS 上不能JIT，早期Unity开发者为了热更，常用Lua/JS解释器来绕过限制</li><li>脚本语言灵活：代码写好后直接存文本（.lua或.js），无需重新编译Unity工程</li><li>资源热更配合：逻辑脚本放AssetBundle或远程下载，运行时动态加载</li></ol><h4 id=原理-1>原理</h4><ol><li>Unity中嵌入一个Lua/JS虚拟机（解释器）</li></ol><ul><li>Lua常用xLua、sLua</li><li>JS常用Puerts，底层基于V8引擎</li></ul><ol start=2><li>Unity启动时</li></ol><ul><li>先加载解释器（一个MonoBehaviour挂在场景里）</li><li>把本地或服务器下载的<code>.lua/.js</code>文件读到内存，交给解释器执行</li></ul><ol start=3><li>脚本中调用Unity API</li></ol><ul><li>通过绑定/桥接代码（C# &lt;->Lua/JS）访问GameObject、Transform、UI等</li><li>常见方式：代码生成器 + 反射注册</li></ul><ol start=4><li>逻辑更新时：新版本只需要下发Lua/JS脚本文件，Unity客户端无需重新打包</li></ol><h4 id=lua热更示例xlua为例>Lua热更示例（xLua为例）</h4><p><strong>特点</strong></p><ul><li>性能好，Lua解释器很轻量</li><li>对Unity API绑定比较成熟</li></ul><p><strong>使用步骤</strong></p><ol><li>导入xLua插件</li><li>初始化LuaEnv</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>LuaEnv luaenv = <span style=color:#66d9ef>new</span> LuaEnv();
</span></span><span style=display:flex><span>luaenv.DoString(<span style=color:#e6db74>&#34;print(&#39;Hello Lua!&#39;)&#34;</span>);
</span></span></code></pre></div><ol start=3><li>从外部加载Lua脚本</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>string</span> script = File.ReadAllText(<span style=color:#e6db74>&#34;path/to/script.lua&#34;</span>);
</span></span><span style=display:flex><span>luaenv.DoString(script);
</span></span></code></pre></div><ol start=4><li>C# 与 Lua互调</li></ol><ul><li>在Lua注册一个函数 -> C#调用</li><li>在C#注册一个delegate -> Lua调用</li></ul><p><strong>热更方式</strong></p><ul><li>脚本放到AssetBundle或StreamingAssets</li><li>启动时加载Lua文件，替换旧逻辑即可</li></ul><h4 id=js热更示例puerts为例>JS热更示例（Puerts为例）</h4><p><strong>特点</strong></p><ul><li>绑定 TypeScript，支持静态检查、编辑器智能提示</li><li>可以使用npm包生态</li><li>对复杂项目开发体验更好，但性能略逊于Lua</li></ul><p><strong>使用步骤</strong></p><ol><li>导入Puerts插件（内置V8引擎）</li><li>初始化JsEnv：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>JsEnv jsEnv = <span style=color:#66d9ef>new</span> JsEnv();
</span></span><span style=display:flex><span>jsEnv.Eval(<span style=color:#e6db74>&#34;console.log(&#39;Hello Lua!&#39;)&#34;</span>);
</span></span></code></pre></div><ol start=3><li>调用Unity API</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>UnityEngine</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;csharp&#34;</span>).<span style=color:#a6e22e>UnityEngine</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>UnityEngine</span>.<span style=color:#a6e22e>Debug</span>.<span style=color:#a6e22e>Log</span>(<span style=color:#e6db74>&#34;Hello from JS&#34;</span>);
</span></span></code></pre></div><ol start=4><li>热更同理：加载<code>.js/.ts</code>文件，替换逻辑即可</li></ol><h4 id=特点-2>特点</h4><h5 id=优点-1>优点</h5><ul><li>真正的热更新，直接替换脚本，无需重新打包</li><li>脚本语言灵活，开发效率高</li><li>行业已验证可行性</li></ul><h5 id=缺点-2>缺点</h5><ul><li>性能不如C#直接执行（解释执行/绑定开销）</li><li>与Unity API交互需要生成绑定代码，工作量大</li><li>逻辑写在Lua/JS中，IDE支持不如C#原生</li></ul><h4 id=适用场景-1>适用场景</h4><ul><li>移动端大项目：需要频繁修Bug或活动更新 -> Lua/JS热更更稳妥</li><li>原型开发：快速试错 -> JS/TS有利于迭代</li><li>不适合超高性能/计算密集，推荐ILRuntime/HybridCLR</li></ul></div><nav class=post-nav><a href=/home/blog/gizmos/ class=hover:underline>pre: Gizmos</a>
<a href=/home/blog/input-system/ class=hover:underline>next: Input System</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#unity热更新常见方式>Unity热更新常见方式</a><ul><li><a href=#资源热更新>资源热更新</a></li><li><a href=#代码热更新>代码热更新</a></li></ul></li><li><a href=#混合方案>混合方案</a></li><li><a href=#热更的关键技术点>热更的关键技术点</a><ul><li><a href=#反射和动态加载dll>反射和动态加载DLL</a><ul><li><a href=#原理>原理</a></li><li><a href=#实现>实现</a></li><li><a href=#特点>特点</a></li><li><a href=#适用场景>适用场景</a></li></ul></li><li><a href=#ilruntime>ILRuntime</a><ul><li><a href=#ilruntime的实现原理>ILRuntime的实现原理</a></li><li><a href=#ilruntime的特点>ILRuntime的特点</a><ul><li><a href=#优势>优势</a></li><li><a href=#缺点>缺点</a></li></ul></li><li><a href=#使用场景>使用场景</a></li><li><a href=#ilruntime的使用>ILRuntime的使用</a><ul><li><a href=#1-准备工作>1. 准备工作</a></li><li><a href=#2-编译和部署dll>2. 编译和部署DLL</a></li><li><a href=#3-在unity中加载和运行dll>3. 在Unity中加载和运行DLL</a></li><li><a href=#4-热更新流程>4. 热更新流程</a></li><li><a href=#注意事项>注意事项</a></li></ul></li></ul></li><li><a href=#hybridclr>HybridCLR</a><ul><li><a href=#hybridclr的原理>HybridCLR的原理</a></li><li><a href=#使用场景-1>使用场景</a></li><li><a href=#使用>使用</a><ul><li><a href=#步骤1导入hybridclr>步骤1：导入HybridCLR</a></li><li><a href=#步骤2编写热更新dll>步骤2：编写热更新DLL</a></li><li><a href=#步骤3生成aot补充>步骤3：生成AOT补充</a></li><li><a href=#步骤4加载和调用dll>步骤4：加载和调用DLL</a></li><li><a href=#步骤5热更新流程>步骤5：热更新流程</a></li></ul></li><li><a href=#特点-1>特点</a><ul><li><a href=#优点>优点</a></li><li><a href=#缺点-1>缺点</a></li></ul></li></ul></li><li><a href=#luajs脚本热更>Lua/JS脚本热更</a><ul><li><a href=#存在原因>存在原因</a></li><li><a href=#原理-1>原理</a></li><li><a href=#lua热更示例xlua为例>Lua热更示例（xLua为例）</a></li><li><a href=#js热更示例puerts为例>JS热更示例（Puerts为例）</a></li><li><a href=#特点-2>特点</a><ul><li><a href=#优点-1>优点</a></li><li><a href=#缺点-2>缺点</a></li></ul></li><li><a href=#适用场景-1>适用场景</a></li></ul></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer></body></html>