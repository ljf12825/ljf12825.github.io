<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>linux cli</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/unixlike/>★</a></li><li><a href=/unixlike/lab/>Lab</a></li><li><a href=/unixlike/lib/>Lib</a></li><li><a href=/unixlike/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /             <a class=nav-item data-path=/engine/ href=/engine/>Engine</a>         |
|                             |  /                 |           |
|                             | /                  |           |
|                             |/                   |           |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/framework/ href=/framework/>Framework</a>       |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                          <a class=nav-item data-path=/csbasic/ href=/csbasic/>CSBasic</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>linux cli<div class=meta>Update: 2026-01-14</div></div><div class=content><h1 id=linux-clicommand-line-interface>Linux CLI(Command Line Interface)</h1><p>CLI(Command Line Interface)即命令行界面，是一种用户与计算机交互的方式，用户通过输入文本命令来控制计算机系统，而不是通过图形界面（GUI）进行操作。CLI是一种基于文本的用户界面，用户通过键盘输入命令，计算机则执行相应的操作并返回文本结果</p><ul><li><p>CLI的特点</p><ol><li>文本输入输出：用户通过输入文本命令与计算机交互，结果也以文本的形式返回</li><li>高效和灵活：CLI通常比图形界面更加高效，尤其对于技术人员、开发者和系统管理员来说，能够快速执行批量操作、脚本执行、系统管理等任务</li><li>精确控制：命令行通常允许用户以非常精确的方式控制系统。用户可以通过组合不同的命令和选项来完成复杂的任务</li><li>无图形界面：CLI不依赖图形界面，因此占用的系统资源较少，运行速度较快</li></ol></li><li><p>CLI的优势</p><ul><li>高效性：用户可以通过键盘快速输入多个命令进行批量操作，不需要通过鼠标点击菜单等操作</li><li>灵活性：CLI可以组合多个命令来执行复杂的操作，支持脚本编写，可以自动化很多任务</li><li>资源占用少：由于没有图形界面，CLI界面占用的系统资源较少，适用于低资源环境</li><li>远程操作：CLI非常适合远程操作和管理，比如通过SSH连接到远程服务器时，通常使用CLI进行系统管理和调试</li></ul></li></ul><h2 id=命令提示符command-prompt>命令提示符（Command Prompt）</h2><p>在 Linux 中，命令提示符（Command Prompt）是 Shell 提供的一个接口，用户通过命令行输入命令与操作系统交互。命令提示符不仅仅是一个等待用户输入的标志，它通常会显示一些有用的信息，如当前目录、用户名、主机名等，帮助用户更好地理解当前的工作环境</p><p>在 Linux 中，命令提示符通常由 Shell 来控制，最常用的是 Bash（Bourne Again Shell）。Bash默认会显示一个包含系统状态信息的命令提示符</p><h3 id=命令提示符组成部分>命令提示符组成部分</h3><p>在Linux中，命令提示符通常包含以下几个元素</p><ul><li>用户名：显示当前登录的用户</li><li>主机名：显示当前计算机或主机的名称</li><li>当前目录：显示用户所在的工作目录，<code>~</code>代表用户的主目录</li><li>权限符号：指示用户权限状态。对于普通用户通常是<code>$</code>，对于root用户是<code>#</code></li></ul><p>示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>user@hostname:home/user$ 
</span></span></code></pre></div><ul><li>user：当前登录的用户名</li><li>hostname：当前计算机的主机名</li><li>/home/user：当前工作目录</li><li>$：表现普通用户的命令提示符</li></ul><h3 id=bash的命令提示符ps1>Bash的命令提示符：PS1</h3><p>在Bash中，命令提示符的格式由环境变量<code>PS1</code>控制。<code>PS1</code>是一个存储命令提示符格式的变量，用户可以修改它来定制提示符的显示样式。通过修改<code>PS1</code>，可以改变命令提示符的内容和样式</p><p>在大多数Linux发行版中，<code>PS1</code>默认值类似于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#ae81ff>\u</span>@<span style=color:#ae81ff>\h</span> <span style=color:#ae81ff>\W</span><span style=color:#f92672>]</span><span style=color:#ae81ff>\$</span>
</span></span></code></pre></div><h4 id=常用的ps1转义符>常用的<code>PS1</code>转义符</h4><p>Bash支持在<code>PS1</code>中使用一些转义符来定制提示符的样式</p><ul><li><code>\u</code>：用户名</li><li><code>\h</code>：主机名（主机名的第一个部分，不包含域名）</li><li><code>\H</code>：主机名（包含域名）</li><li><code>\w</code>：当前工作目录的完整路径</li><li><code>\W</code>：当前工作目录的基目录（仅显示当前目录的名称）</li><li><code>\d</code>：当前日期，格式为<code>Weekday Month Date</code></li><li><code>\t</code>：当前时间，格式为<code>HH:MM:SS</code></li><li><code>\@</code>：当前日期，格式为<code>HH:MM AM/PM</code></li><li><code>\#</code>：命令的历史记录编号</li><li><code>\$</code>：如果是普通用户显示<code>$</code>，如果是root用户显示<code>#</code></li><li><code>\n</code>：换行符</li><li><code>\e[COLOR]</code>：用于设置颜色，例如<code>\e[32m</code>设置绿色</li></ul><h4 id=命令提示符的定制>命令提示符的定制</h4><p>可以通过编辑<code>~/.bashrc</code>文件来修改<code>PS1</code>变量，从而定制命令提示符</p><h5 id=颜色和样式>颜色和样式</h5><p>可以为命令提示符添加颜色，使其更具可读性。Bash使用ANSI转义码来设置颜色<br>例如，将提示符中的用户名显示为红色，目录显示为绿色</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>PS1<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;\[\e[31m\]\u\[\e[0m\]@\[\e[34m\]\h\[\e[0m\]:\[\e[32m\]\w\[\e[0m\]\$ &#34;</span>
</span></span></code></pre></div><ul><li><code>\[\e[31m\]</code>：设置文本为红色</li><li><code>\[\e[32m\]</code>：设置文本为绿色</li><li><code>\[\e[34m\]</code>：设置文本为蓝色</li><li><code>\[\e[0m\]</code>：重置颜色</li></ul><h4 id=其他提示符设置>其他提示符设置</h4><h5 id=ps2多行提示符>PS2（多行提示符）</h5><p><code>PS2</code>是多行命令提示符，在命令需要多行输入时会使用<br>例如，当输入一个没有完整结尾的命令时，系统会显示<code>PS2</code>提示符，等待你继续输入<br>默认的<code>PS2</code>设置为<code>PS2="> "</code><br>例如，当你输入一个不完整的命令时</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#34;This is a long command
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&gt; that spans multiple lines&#34;</span>
</span></span></code></pre></div><h5 id=ps3select命令的提示符>PS3（select命令的提示符）</h5><p><code>PS3</code>是在使用<code>select</code>命令时的提示符，用于创建菜单选项。默认值通常是<code>#?</code></p><h5 id=ps4调试模式提示符>PS4（调试模式提示符）</h5><p><code>PS4</code>用于调试脚本时设置提示符，默认值为<code>+</code></p><h2 id=ttyteletypewriter>TTY(Teletypewriter)</h2><p>Linux中的TTY原本指的是终端设备，尤其是早期的打印机终端设备，后来被用来代指所有的终端接口。在现代Linux系统中，TTY的含义更广泛，通常指的是系统中的文本终端，无论是物理终端（例如，串口连接）还是虚拟终端</p><h3 id=tty的类型>TTY的类型</h3><ol><li><p>物理TTY（硬件TTY）：这些是连接到计算机的实际终端设备，早期的例子是通过串口与计算机连接的打字机，后来变成了专用的终端设备</p><ul><li>设备文件：<code>/dev/tty1</code>, <code>/dev/tty2</code>, &mldr; <code>/dev/tty63</code></li><li>访问方式：通过<code>Ctrl + Alt + F1</code>到<code>F7</code>键进行切换<ul><li>通常<code>F1</code> - <code>F6</code>是文本控制台（<code>tty1</code> - <code>tty6</code>）</li><li><code>F7</code>或<code>F1</code>（取决于发行版）通常留给图形桌面环境（X11或Wayland）</li></ul></li><li>特点：直接由内核管理，是系统最底层的用户接口</li></ul></li><li><p>虚拟TTY（虚拟控制台）：现代计算机通过虚拟控制台来模拟多个TTY,用户可以在每个虚拟终端上独立地进行操作。在Linux中，通常使用Ctrl + Alt + F1 到 F6来切换到不同的虚拟终端，这些终端会显示在不同的TTY上</p><ul><li>设备文件：<code>/dev/pts/0</code>, <code>/dev/pts/1</code>, &mldr; （pts是”pseudo-terminal slave“的缩写）</li><li>访问方式：在图形桌面中点击终端图标</li><li>特点<ul><li>它们运行在图形界面之上</li><li>每个打开的终端窗口通常对应一个独立的<code>/dev/pts/X</code>设备</li><li>可以通过<code>tty</code>命令查看当前终端对应的设备文件</li></ul></li></ul></li><li><p>伪终端（PTY）：伪终端通常用于在程序之间模拟交互式终端，最典型的例子就是通过终端程序（如SSH）连接到远程系统时，实际上是通过伪终端与系统交互。伪终端通常由两部分组成：主设备（master）和从设备（slave）</p></li><li><p>串行端口
这最接近TTY的历史起源。它通过物理串行端口（如RS-232）连接终端设备。现在主要用于嵌入式系统开发、调试路由器或交换机等场景</p><ul><li>设备文件：<code>/dev/ttyS0</code>，<code>/dev/ttyS1</code>, &mldr;（S代表Serial）</li></ul></li></ol><h3 id=tty与控制台>TTY与控制台</h3><ul><li>控制台（Console）通常指的是与系统的主要输出和输入设备（如显示器和键盘）相关的终端。在Linux系统中，控制台通常是<code>/dev/console</code></li><li>TTY设备通常是指虚拟控制台或连接到系统的终端设备，它们是作为<code>/dev/ttyX</code>（X为数字）来表示的</li></ul><h3 id=关键组件与工作流程>关键组件与工作流程</h3><p>一个完整的TTY子系统由三部分组成</p><ol><li><p>终端设备（<code>/dev/ttyX</code>, <code>/dev/pts/X</code>）</p><ul><li>这是提供给用户程序（如Shell）的接口。程序向这个设备文件写入数据，数据就会显示在终端屏幕上；程序从这个设备文件读取数据，就是在读取用户的键盘输入</li></ul></li><li><p>行规程（Line Discipline）</p><ul><li>这是TTY的”大脑“，一个位于内核中的中间处理层。它负责在用户输入的原始模式和加工模式之间转换</li><li>加工模式（Cooked Mode / Canonical Mode）：这是默认模式。行规程会处理基本的行编辑功能，比如<ul><li>当按退格键，它会在将字符发送给程序前删除前一个字符</li><li>当按<code>Ctrl+C</code>，它不会发送字符C,而是生成一个<code>SIGINT</code>信号来终止前台程序</li><li>当按<code>Ctrl+Z</code>，它会生成<code>SIGTSTP</code>信号来挂起程序</li><li>当按下回车，将整行数据发送给程序</li></ul></li><li>原始模式（Raw Mode）：在此模式下，行规程几乎不做任何处理。用户的每一个按键都会立即、原封不动地发送给应用程序。这对于像<code>vim</code>, <code>bash</code>（在命令行编辑时）、SSH客户端等需要精细控制输入的程序至关重要</li></ul></li><li><p>UART驱动/终端模拟器</p><ul><li>对于物理串口，这是UART硬件驱动</li><li>对于虚拟终端，这是一个在用户空间运行的终端模拟器程序（如GNOME Terminal），它模拟了物理终端的行为，并提供了一个图形窗口来显示输出和接收输入</li></ul></li></ol><h4 id=数据流向简化示例在虚拟终端中>数据流向简化示例（在虚拟终端中）</h4><ol><li>在GNOME Terminal里按下键盘按键<code>A</code></li><li>终端模拟器（GNEMO Terminal）捕获到按键，通过<code>/dev/ptmx</code>（伪终端主设备）将字符<code>A</code>发送给内核的行规程</li><li>行规程（如果处于加工模式）可能会处理这个字符（比如，如果之前是退格键，则进行删除）</li><li>行规程将处理后的数据放入<code>/dev/pts/0</code>（从设备）的缓冲区</li><li>Shell（比如bash）正在从<code>/dev/pts/0</code>读取输入，它读到了字符<code>A</code></li><li>Bash处理这个字符，可能会将其回显。回显的流程反过来：Bash将字符<code>A</code>写入<code>/dev/pts/0</code> -> 行规程 -> 终端模拟器 -> 终端模拟器在窗口上绘制字符<code>A</code></li></ol><h3 id=使用tty>使用TTY</h3><ol><li><p>切换虚拟终端：按下<code>Ctrl + Alt + F1 到 F6</code>，可以切换到不同的TTY,回到图形界面可以使用<code>Ctrl + Alt + F7 或者 F1</code>（具体取决于分配的设置）</p></li><li><p>登录到TTY：可以在虚拟终端上使用用户名和密码登录。每个TTY都可以有一个独立的会话</p></li></ol><h3 id=相关的重要命令与文件>相关的重要命令与文件</h3><ul><li><code>tty</code>：打印当前终端对应的设备文件路径</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ tty 
</span></span><span style=display:flex><span>/dev/pts/2 
</span></span></code></pre></div><ul><li><code>who</code>或<code>w</code>：查看当前系统中有哪些用户登录，以及他们使用的是哪个TTY</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ who 
</span></span><span style=display:flex><span>alice tty1 2025-10-22 17:06
</span></span><span style=display:flex><span>bob pts/0 2025-10-22 17:07 
</span></span></code></pre></div><ul><li><code>ps -ef</code>：查看进程运行在哪个TTY上（<code>TTY</code>列）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ ps -ef | grep bash
</span></span><span style=display:flex><span>alice   <span style=color:#ae81ff>1234</span>  <span style=color:#ae81ff>1233</span>  <span style=color:#ae81ff>0</span> 10:23 tty1     00:00:00 -bash
</span></span><span style=display:flex><span>bob     <span style=color:#ae81ff>5678</span>  <span style=color:#ae81ff>5677</span>  <span style=color:#ae81ff>0</span> 11:05 pts/0    00:00:00 -bash
</span></span></code></pre></div><ul><li><code>stty</code>：查看和修改TTY设备的设置（即行规程的行为）<ul><li><code>stty -a</code>：显示所有当前设置</li><li><code>stty sane</code>：如果终端设置混乱导致输入输出异常，可以使用这个命令重置</li><li><code>stty echo</code> / <code>stty -echo</code>：开启/关闭回显（比如输入密码时）</li></ul></li><li><code>/dev/tty</code>：这是一个特殊的”魔法“文件，它总是指向当前进程的控制终端。无论你在哪个TTY下，向<code>/dev/tty</code>写入都会显示在你自己的屏幕上</li><li><code>/dev/console</code>：系统控制台，通常指向当前活跃的TTY（可能是<code>tty0</code>或某个串口），用于接收内核启动消息和系统严重错误</li></ul><h4 id=为什么ctrlc能终止程序>为什么<code>Ctrl+C</code>能终止程序</h4><ol><li>当按下<code>Ctrl+C</code></li><li>终端模拟器收到这个组合键</li><li>行规程识别出<code>Ctrl+C</code>不是一个普通的字符，而是一个特殊控制字符（对应ASCII码 0x03，即ETX）</li><li>行规程不会将字符<code>0x03</code>发送给前台进程，而是会向前台进程组发送一个<code>SIGINT</code>信号</li><li>程序收到<code>SIGINT</code>信号，默认行为是终止自己</li></ol><h2 id=shell>Shell</h2><p>Shell = 壳<br>它是操作系统中用户与内核之间的接口</p><ul><li>内核（Kernel）：底层，控制硬件和资源（CPU、内存、文件系统&mldr;）</li><li>Shell：接收用户输入（命令/脚本），翻译成系统调用，让内核去执行</li></ul><p>Linux的Shell是一种命令行界面（CLI），允许用户与操作系统进行交互。它接受用户输入的命令，然后执行相应的操作。Shell既可以是一个用户与系统之间的“桥梁”，也可以是一个强大的脚本语言，用来自动化任务</p><h3 id=shell的类型>Shell的类型</h3><p>Shell不是只有一种，而是有很多实现：</p><ul><li>Sh(Bourne Shell)：最早的Unix Shell</li><li>Bash(Bourne Again Shell)：Linux最常见的Shell，功能强大，几乎是默认标准</li><li>Zsh：可定制性强，搭配Oh-My-Zsh用起来很炫酷</li><li>Fish(Friendly Interactive Shell)：语法友好，自动补全更智能</li><li>Csh/Tcsh：C like，早期流行</li></ul><h3 id=shell的两种使用方式>Shell的两种使用方式</h3><ol><li>交互式</li></ol><ul><li>打开终端输入命令</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ls -l
</span></span><span style=display:flex><span>cd /home
</span></span><span style=display:flex><span>mkdir test
</span></span></code></pre></div><ul><li>Shell逐条接收命令、执行、返回结果</li></ul><ol start=2><li>脚本式</li></ol><ul><li>把一堆命令写进文件里(<code>.sh</code>)，让Shell一次性执行</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Hello, Linux&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i in <span style=color:#f92672>{</span>1..5<span style=color:#f92672>}</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;Count: </span>$i<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><ul><li>执行：<code>bash script.sh</code></li></ul><p>这就是Shell脚本编程</p><h3 id=shell提供的功能>Shell提供的功能</h3><ul><li>命令执行：直接在Shell中输入命令，Shell解释并执行<ul><li>例如，输入<code>ls</code>列出目录内容</li></ul></li><li>输入输出重定向：通过重定向符号（<code>></code>,<code>>></code>,<code>&lt;</code>）控制输入输出流<ul><li>例如，<code>echo "Hello World" > output.txt</code>会将输出写入到<code>output.txt</code>文件</li></ul></li><li>管道(<code>|</code>)：将一个命令的输出直接传递给另一个命令作为输入<ul><li>例如，<code>ps aux | grep 'python'</code>会列出所有与<code>python</code>相关的进程</li></ul></li><li>命令替换：可以将命令的输出作为另一个命令的输入，使用反引号或<code>$()</code>语法<ul><li>例如，<code>echo $(date)</code>会输出当前的日期和时间</li></ul></li><li>环境变量：Shell通过环境变量来存储系统的配置信息<ul><li>例如，<code>$HOME</code>表示当前用户的主目录，<code>$PATH</code>存储可执行文件搜索路径</li></ul></li><li>命令别名：使用<code>alias</code>创建命令的别名，方便快捷<ul><li>例如，<code>alias ll='ls -l'</code>可以将<code>ll</code>作为<code>ls -l</code>的简写</li></ul></li></ul><h3 id=shell脚本>Shell脚本</h3><p>Shell脚本是由一系列命令组成的文件，通常用于自动化重复性任务。脚本的基本语法如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span><span style=color:#75715e># 这是一个注释</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Hello, Wrold!&#34;</span> <span style=color:#75715e># 打印输出</span>
</span></span></code></pre></div><ul><li><code>#!/bin/bash</code>：称为Shebang或Hashbang。它告诉系统使用哪个解释器来执行这个脚本。这是脚本的第一行，必须是绝对路径</li><li><code># 这是一个注释</code>：以<code>#</code>开头的行是注释，不会被解释执行</li><li><code>echo "Hello, World!"</code>：一个简单的Shell命令，用于输出文本</li></ul><h4 id=shebang>Shebang</h4><p>Shebang（也叫hashbang或bang line）是指在脚本文件的第一行中的一个特殊符号<code>#!</code>，后面跟着解释器的路径，用于告诉操作系统该脚本文件应由哪个解释器来执行。它使得用户可以直接通过执行脚本文件来执行程序，而不需要显式地调用解释器（例如<code>bash script.sh</code>）</p><h5 id=shebang语法>Shebang语法</h5><p>Shebang的基本形式是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/path/to/interpreter 
</span></span></span></code></pre></div><ul><li><code>#</code>和<code>!</code>组成的符号<code>#!</code>是一个固定的标志，用来告诉操作系统这是一个shebang行</li><li><code>/path/to/interpreter</code>是解释器的完整路径，例如<code>/bin/bash</code>， <code>/usr/bin/python3</code>等</li></ul><h5 id=如何工作>如何工作</h5><ul><li>Shebang行让脚本文件在执行时知道该用哪个解释器来执行它。当你运行一个脚本时，操作系统会读取脚本的第一行，看到<code>#!</code>后，自动去查找并调用执行的解释器（例如<code>/bin/bash</code>）</li><li>例如，如果有一个<code>hello.sh</code>脚本，并且它的第一行是</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span></code></pre></div><p>当你通过命令<code>./hello.sh</code>来执行它时，系统会使用<code>/bin/bash</code>来解释和执行该脚本的内容，而不需要显式地在命令行中输入<code>bash hello.sh</code></p><h5 id=shebang存在的意义>Shebang存在的意义</h5><ul><li>便捷性：它让脚本可以直接运行，而无需显式指定解释器。例如，只需<code>./script.sh</code>就能隐匿性脚本，而不是先运行<code>bash script.sh</code></li><li>可移植性：Shebang使得脚本可以在不同的系统中运行，只要该解释器存在于相同的路径下。它还支持使用<code>/usr/bin/env</code>来查找解释器，这样即使解释器路径不同，脚本也可以在各种系统上运行</li><li>指定解释器：它允许你指定脚本需要的解释器，不论系统上默认的Shell是什么。这样就可以确保脚本按照你希望的方式执行</li></ul><h5 id=shebang与文件权限>Shebang与文件权限</h5><p>为了使脚本能够被执行，脚本文件必须具备执行权限。可以使用<code>chmod</code>命令赋予执行权限</p><h5 id=shebang与usrbinenv>Shebang与<code>/usr/bin/env</code></h5><p>有时，直接指定解释器的路径可能会在不同系统中产生问题，因为解释器的路径可能不同。例如，Python解释器可能位于<code>usr/bin/python</code>, <code>usr/local/bin/python</code>或<code>/bin/python</code>，这取决于安装方式和操作系统</p><p>为了解决这个问题，可以使用<code>/usr/bin/env</code>，它会自动查找环境变量中的解释器路径</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3 
</span></span></span></code></pre></div><p>使用这种方式，系统会使用<code>env</code>查找系统中第一个可用的<code>python3</code>解释器，而不需要硬编码具体的路径</p><h5 id=shebang的例外>Shebang的例外</h5><ul><li>交互式Shell：如果在终端中直接启动一个Shell（如<code>bash</code>），而没有使用Shebang行，那么Shell会交互式地运行，而不会自动去找指定的解释器</li><li>Shebang脚本的兼容性：大多数Linux系统支持Bash脚本的Shebang，但如果使用了不同类型的Shell（如Zsh），确保脚本首行指向正确的Shell解释器</li></ul><h4 id=如何执行脚本>如何执行脚本</h4><ol><li>添加执行权限（推荐）：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>chmod +x hello.sh 
</span></span><span style=display:flex><span>./hello.sh <span style=color:#75715e># 在当前目录下执行</span>
</span></span></code></pre></div><ol start=2><li>直接使用解释器（无需执行权限）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>bash hello.sh 
</span></span></code></pre></div><h4 id=变量>变量</h4><h5 id=定义和使用变量>定义和使用变量</h5><ul><li>定义：变量名=变量值（等号两边不能有空格）</li><li>使用：在变量名前加<code>$</code>符号，或者用<code>${变量名}</code>(推荐，明确变量边界)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Alice&#34;</span>
</span></span><span style=display:flex><span>age<span style=color:#f92672>=</span><span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;My name is </span>$name<span style=color:#e6db74>.&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;I am </span><span style=color:#e6db74>${</span>age<span style=color:#e6db74>}</span><span style=color:#e6db74> years old.&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将一个命令的结果赋值给变量</span>
</span></span><span style=display:flex><span>current_time<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>date<span style=color:#66d9ef>)</span> <span style=color:#75715e># 或者用反引号 `date`</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Current time is: </span>$current_time<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>注意：变量名区分大小写，且默认都是字符串类型。进行数学运算需要特殊处理</p><h5 id=只读变量和删除变量>只读变量和删除变量</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>readonly my_var<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;This is constant&#34;</span>
</span></span><span style=display:flex><span>my_var<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Change it&#34;</span> <span style=color:#75715e># 这行会报错</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>normal_var<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;To be delete&#34;</span>
</span></span><span style=display:flex><span>unset normal_var
</span></span><span style=display:flex><span>echo $normal_var <span style=color:#75715e># 输出空行</span>
</span></span></code></pre></div><h5 id=环境变量和局部变量>环境变量和局部变量</h5><ul><li>环境变量：对所有Shell会话和子进程都可见，通常用<code>export</code>定义</li><li>局部变量：只在当前Shell脚本中可见</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>local_var<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;I&#39;m local&#34;</span>
</span></span><span style=display:flex><span>export CLOBAL_VAR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;I&#39;m global&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 在脚本中调用另一个脚本，GLOBAL_VAR会被传递过去</span>
</span></span></code></pre></div><h4 id=字符串操作>字符串操作</h4><p>Shell中的变量值通常都被当作字符串处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>str<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Hello World&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取长度</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>${#</span>str<span style=color:#e6db74>}</span> <span style=color:#75715e># 输出11</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 字符串切片</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>${</span>str:0:5<span style=color:#e6db74>}</span> <span style=color:#75715e># 从索引0开始，截取5个字符，输出“Hello”</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查找字符串（返回索引，从1开始计数）</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>`</span>expr index <span style=color:#e6db74>&#34;</span>$str<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;Wo&#34;</span><span style=color:#e6db74>`</span> <span style=color:#75715e># 输出 7</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 字符串替换</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>${</span>str/World/There<span style=color:#e6db74>}</span> <span style=color:#75715e># 输出 “Hello There”</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 更多替换</span>
</span></span><span style=display:flex><span>path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/home/user/file.txt&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>${</span>path%.txt<span style=color:#e6db74>}</span> <span style=color:#75715e># 删除后缀，输出”/home/user/file&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>${</span>path%/*<span style=color:#e6db74>}</span> <span style=color:#75715e># 删除最后一部分，输出 “home/user”</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>${</span>path##*/<span style=color:#e6db74>}</span> <span style=color:#75715e># 只保留最后一部分，输出“file.txt”</span>
</span></span></code></pre></div><h4 id=传递参数>传递参数</h4><p>在执行脚本时，可以向其传递参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e># 假设脚本名为 test.sh</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Script name: </span>$0<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;First argument: </span>$1<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Second argument: </span>$2<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Number of arguments: </span>$#<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;All arguments (as a string): </span>$*<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;All arguments (as an array): </span>$@<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Exit status of last command: </span>$?<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Process ID (PID) of this script: </span>$$<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>执行<code>./test.sh arg1 arg2</code>，输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Script name: ./test.sh
</span></span><span style=display:flex><span>First argument: arg1
</span></span><span style=display:flex><span>Second argument: arg2
</span></span><span style=display:flex><span>Number of arguments: 2
</span></span><span style=display:flex><span>All arguments (as a string): arg1 arg2
</span></span><span style=display:flex><span>All arguments (as an array): arg1 arg2
</span></span><span style=display:flex><span>Exit status of last command: 0
</span></span><span style=display:flex><span>Process ID (PID) of this script: 12345
</span></span></code></pre></div><p><code>$*</code>与<code>$@</code>的区别（在循环中尤其重要）</p><ul><li><code>$*</code>：将所有参数都视为一个整体字符串（&ldquo;arg1arg2&rdquo;）</li><li><code>$@</code>：将每个参数视为独立的字符串（&ldquo;arg1"&ldquo;arg2&rdquo;）</li></ul><h4 id=数组>数组</h4><p>Bash支持一位数组</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 定义数组</span>
</span></span><span style=display:flex><span>fruits<span style=color:#f92672>=(</span><span style=color:#e6db74>&#34;Apple&#34;</span> <span style=color:#e6db74>&#34;Banana&#34;</span> <span style=color:#e6db74>&#34;Orange&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 按索引赋值</span>
</span></span><span style=display:flex><span>fruits<span style=color:#f92672>[</span>3<span style=color:#f92672>]=</span><span style=color:#e6db74>&#34;Grape&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 读取数组元素</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>${</span>fruits[0]<span style=color:#e6db74>}</span> <span style=color:#75715e># 输出 Apple</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 读取所有元素</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>${</span>fruits[@]<span style=color:#e6db74>}</span> <span style=color:#75715e># 输出所有元素为独立字符串</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>${</span>fruits[*]<span style=color:#e6db74>}</span> <span style=color:#75715e># 输出所有元素为整体字符串</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取数组长度</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>${#</span>fruits[@]<span style=color:#e6db74>}</span> <span style=color:#75715e># 输出 4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 遍历数组</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> fruit in <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>fruits[@]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>do</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Fruit: </span>$fruit<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span> 
</span></span></code></pre></div><h4 id=基本运算符>基本运算符</h4><h5 id=算术运算符>算术运算符</h5><p>在Bash中，不能直接用<code>a=1+1</code>，需要使用以下方式</p><ol><li><code>$(( ... ))</code>（最常用，推荐）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>a<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>  <span style=color:#66d9ef>))</span>
</span></span><span style=display:flex><span>echo $a <span style=color:#75715e># 15 </span>
</span></span><span style=display:flex><span>echo <span style=color:#66d9ef>$((</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>%</span> <span style=color:#ae81ff>3</span> <span style=color:#66d9ef>))</span> <span style=color:#75715e># 取模，输出1 </span>
</span></span><span style=display:flex><span><span style=color:#f92672>((</span> a++  <span style=color:#f92672>))</span> <span style=color:#75715e># 自增</span>
</span></span></code></pre></div><ol start=2><li><code>expr</code>命令（较老的方式）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>a<span style=color:#f92672>=</span><span style=color:#e6db74>`</span>expr <span style=color:#ae81ff>10</span> + 5<span style=color:#e6db74>`</span> <span style=color:#75715e># 注意运算符两边的空格</span>
</span></span></code></pre></div><ol start=3><li><code>let</code>命令</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>let <span style=color:#e6db74>&#34;a = 10 + 5&#34;</span>
</span></span></code></pre></div><h5 id=关系运算符常用于或test命令>关系运算符（常用于<code>[[]]</code>或<code>test</code>命令）</h5><ul><li><code>-eq</code>：等于</li><li><code>-ne</code>：不等于</li><li><code>-gt</code>：大于</li><li><code>-lt</code>：小于</li><li><code>-ge</code>：大于等于</li><li><code>-le</code>：小于等于</li></ul><h5 id=字符串运算符>字符串运算符</h5><ul><li><code>=</code>或<code>==</code>：相等</li><li><code>!=</code>：不相等</li><li><code>-z</code>：字符串长度为0（空）</li><li><code>-n</code>：字符串长度非0</li><li><code>str</code>：检查字符串是否不为空（简单写法）</li></ul><h5 id=文件测试运算符>文件测试运算符</h5><ul><li><code>-e file</code>：文件/目录是否存在</li><li><code>-f file</code>：是否是普通文件</li><li><code>-d file</code>：是否是目录</li><li><code>-r file</code>：是否可读</li><li><code>-w file</code>：是否可写</li><li><code>-x file</code>：是否可执行</li><li><code>-s file</code>：文件大小是否大于0（非空）</li></ul><h4 id=流程控制>流程控制</h4><h5 id=条件语句if>条件语句<code>if</code></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> condition  <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e># 执行命令</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>elif</span> <span style=color:#f92672>[[</span> condition2  <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e># 执行命令</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 执行命令</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span> 
</span></span></code></pre></div><p><code>[ ]</code> vs <code>[[ ]]</code> vs <code>test</code></p><ul><li><code>test expression</code>和<code>[ expression ]</code>是等价的，是POSIX标准，但功能较弱</li><li><code>[[ expression ]]</code>是Bash的扩展，功能更强大、更安全（例如，支持<code>&&</code>, <code>||</code>，字符串比较不需要引号也能处理空格）</li></ul><p>示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>read -p <span style=color:#e6db74>&#34;Enter a number: &#34;</span> num 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $num -gt <span style=color:#ae81ff>10</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Number is greater than 10.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>elif</span> <span style=color:#f92672>[[</span> $num -eq <span style=color:#ae81ff>10</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Number is exactly 10.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Number is less than 10.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 检查文件</span>
</span></span><span style=display:flex><span>file<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/path/to/file&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> -f <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&amp;&amp;</span> -r <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;File exists and is readable.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 字符串比较</span>
</span></span><span style=display:flex><span>name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Bob&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $name <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Bob&#34;</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Hello, Bob!&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span> 
</span></span></code></pre></div><h5 id=选择语句case>选择语句<code>case</code></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>read -p <span style=color:#e6db74>&#34;Enter yes or no: &#34;</span> answer 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> $answer in 
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span>Yy<span style=color:#f92672>]</span>|<span style=color:#f92672>[</span>Yy<span style=color:#f92672>][</span>Ee<span style=color:#f92672>][</span>Ss<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>        echo <span style=color:#e6db74>&#34;You agreed.&#34;</span>
</span></span><span style=display:flex><span>        ;;
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span>Nn<span style=color:#f92672>]</span>|<span style=color:#f92672>[</span>Nn<span style=color:#f92672>][</span>Oo<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>        echo <span style=color:#e6db74>&#34;You disagreed.&#34;</span>
</span></span><span style=display:flex><span>        ;;
</span></span><span style=display:flex><span>    *<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        echo <span style=color:#e6db74>&#34;Invalid input&#34;</span>
</span></span><span style=display:flex><span>        ;;
</span></span><span style=display:flex><span><span style=color:#66d9ef>esac</span> 
</span></span></code></pre></div><h5 id=循环语句>循环语句</h5><p><code>for</code>循环</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 遍历值列表</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> color in red green blue; <span style=color:#66d9ef>do</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Color is </span>$color<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 遍历命令输出</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> file in <span style=color:#66d9ef>$(</span>ls *.txt<span style=color:#66d9ef>)</span>; <span style=color:#66d9ef>do</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Processing </span>$file<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># C语言风格</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#f92672>((</span> i<span style=color:#f92672>=</span>0; i&lt;5; i++ <span style=color:#f92672>))</span>; <span style=color:#66d9ef>do</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;i=</span>$i<span style=color:#e6db74>&#34;</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span> 
</span></span></code></pre></div><p><code>while</code>循环</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>count<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#f92672>[[</span> $count -le <span style=color:#ae81ff>5</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>do</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Count: </span>$count<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>((</span>count++<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 读取文件逐行处理（经典用法）</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> IFS<span style=color:#f92672>=</span> read -r line; <span style=color:#66d9ef>do</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Line: </span>$line<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span> &lt; <span style=color:#e6db74>&#34;/path/to/file&#34;</span>
</span></span></code></pre></div><p><code>until</code>循环（与<code>while</code>相反，条件为假时执行）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>count<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>until</span> <span style=color:#f92672>[[</span> $count -gt <span style=color:#ae81ff>5</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>do</span> 
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Count: </span>$count<span style=color:#e6db74>&#34;</span> 
</span></span><span style=display:flex><span>    <span style=color:#f92672>((</span>count++<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span> 
</span></span></code></pre></div><p>循环控制：</p><ul><li><code>break</code>：跳出整个循环</li><li><code>countinue</code>：跳过本次循环，进入下一次</li></ul><h4 id=函数>函数</h4><p>函数用于封装可重用的代码块</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 定义函数</span>
</span></span><span style=display:flex><span>my_function<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    local local_var<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;I&#39;m local&#34;</span> <span style=color:#75715e># 局部变量，推荐使用</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Hello from function&#34;</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;First argument to function is: </span>$1<span style=color:#e6db74>&#34;</span> <span style=color:#75715e># 使用函数自己的参数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e># 返回值（0-255），通常0表示成功</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 另一种定义方式</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> another_func <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Another function&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 调用函数</span>
</span></span><span style=display:flex><span>my_function <span style=color:#e6db74>&#34;arg1&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取函数返回值</span>
</span></span><span style=display:flex><span>my_function
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Function exit status: </span>$?<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>注意：函数内的变量默认是全局的，使用<code>local</code>关键字可以定义局部变量</p><h4 id=输入输出重定向>输入输出重定向</h4><h4 id=调试技巧>调试技巧</h4><ul><li><code>-x</code>：跟踪执行，显示每一行命令及其参数</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>bash -x your_script.sh 
</span></span><span style=display:flex><span><span style=color:#75715e># 或在脚本开头 set -x </span>
</span></span></code></pre></div><ul><li><code>-e</code>：遇到错误（命令返回非零状态）立即退出脚本</li><li><code>-u</code>：遇到未定义的变量时报错</li><li><code>-o pipefail</code>：管道中任何一个命令失败，整个管道就失败</li></ul><p>通常可以在脚本开头这样写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash 
</span></span></span><span style=display:flex><span>set -euo pipefail <span style=color:#75715e># 严格的错误处理模式</span>
</span></span></code></pre></div><h3 id=bash>Bash</h3><p>Bash(Bourne Again Shell)是一个命令行解释器和脚本语言，是Linux和macOS等类Unix操作系统中最常用的Shell之一。Bash是由Brian Fox为GNU项目开发的，是Unix的Bourne Shell(sh)的替代品，因此得名"Bourne Again Shell&rdquo;</p><p>Bash不仅作为一个交互式命令行解释器使用，也广泛用于编写脚本来自动化各种系统管理任务、应用程序部署等工作</p><h2 id=terminal>Terminal</h2><p>在Linux中，Terminal是一个用于与操作系统交互的应用程序，它提供一个命令行界面（CLI）。通过Terminal，用户可以执行命令、运行脚本、管理文件、配置系统等。它是与计算机进行交互的一种非常强大的方式，尤其是对于开发者和系统管理员来说</p><h3 id=定义>定义</h3><p>Terminal（终端）是一个文本界面程序，它允许用户通过键盘输入命令来与操作系统的内核交互。用户通过终端输入命令并接收操作系统的输出结果。Terminal本身不处理这些命令，它会将输入传递给操作系统的Shell（例如Bash, Zsh, Fish等），然后显示命令执行的结果</p><h3 id=组成>组成</h3><ul><li>Shell：Terminal中运行的程序，解释用户输入的命令并执行。常见的Shell包括Bash（默认的Shell）、Zsh、Fish、Sh等</li><li>提示符：在Terminal中通常会看到一个命令提示符（例如<code>user@hostname:~$</code>），它表示系统准备接收输入命令</li><li>终端程序：像GNOME Terminal、Konsole, Xterm, Terminator等是不同的终端仿真器，它们是用户使用命令行界面的应用程序</li></ul><h3 id=功能>功能</h3><ul><li>执行命令：通过Terminal，用户可以执行各种操作系统命令来管理文件、运行程序、安装软件、配置系统等</li><li>脚本执行：Terminal允许运行Shell脚本，用户可以编写一系列命令并批量执行</li><li>文件管理：通过命令行工具（如<code>ls</code>, <code>cp</code>, <code>mv</code>, <code>rm</code>, <code>touch</code>）进行文件管理，查看目录内容，移动文件，复制文件，删除文件等</li><li>程序启动与调试：用户可以在Terminal中启动程序，也可以进行程序的调试，查看日志输出等</li><li>远程管理：通过SSH（Secure Shell）等协议，用户可以远程登录并管理其他计算机，通常通过Terminal完成</li></ul><h3 id=常见的terminal仿真器>常见的Terminal仿真器</h3><p>Linux系统中有很多Terminal仿真器，它们为用户提供了访问Shell的界面。常见的Terminal仪器包括</p><ul><li>GNOME Terminal：默认的GNOME桌面环境中的终端仿真器</li><li>Konsole：KDE桌面环境中的终端</li><li>Xterm：传统的终端仿真器，提供基本的功能</li><li>Terminator：一个功能丰富的终端仿真器，支持多窗口分割</li><li>Alacritty：一个注重性能的GPU加速终端</li><li>LXTerminal：轻量级的终端仿真器，适用于LXDE</li></ul><h2 id=job-control>Job Control</h2><p>作业控制是Shell的一个功能，允许用户同时运行和管理多个进程（作业）。它让用户可以在前台和后台之间移动作业，暂停和恢复作业<br>作业控制 = Shell借助内核的进程组 + 终端前台控制 + 信号，实现前台/后台切换、暂停、恢复</p><h3 id=基本概念>基本概念</h3><h4 id=前台作业foreground-job>前台作业（Foreground Job）</h4><p>与终端交互的作业，接收键盘输入和信号，一个终端只能有一个前台作业</p><h4 id=后台作业background-job>后台作业（Background Job）</h4><p>在后台运行的作业，不接收键盘输入，可以同时运行多个后台作业</p><h4 id=四层结构>四层结构</h4><h5 id=1-进程process>1. 进程（process）</h5><h5 id=2-进程组process-group>2. 进程组（process group）</h5><p>一组相关的进程，用PGID标识（通常等于leader的PID），用来整体接收信号</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ls | grep foo
</span></span></code></pre></div><ul><li><code>ls</code>是一个进程</li><li><code>grep</code>是一个进程</li><li>它们在同一个进程组</li></ul><p>管道 = 一个进程组，这是作业控制的基石</p><h5 id=3-会话session>3. 会话（session）</h5><ul><li>一个进程组</li><li>由<code>setsid()</code>创建</li><li>有一个控制终端（controlling terminal）</li></ul><p>通常</p><ul><li>一个终端 = 一个session</li><li>一个shell = session leader</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Session
</span></span><span style=display:flex><span>|__ 前台进程组（foreground PG）
</span></span><span style=display:flex><span>|__ 后台进程组（background PGs）
</span></span></code></pre></div><h5 id=4-作业job>4. 作业（job）</h5><p>作业不是内核概念，是Shell自己维护的结构</p><p>Shell里</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sleep <span style=color:#ae81ff>100</span> | cat &amp;
</span></span></code></pre></div><p>Shell会记录</p><ul><li>Job ID：<code>%1</code></li><li>对应的PGID</li><li>状态：Running/Stopped</li></ul><p>内核完全不知道<code>%1</code>这种东西</p><h3 id=控制终端>控制终端</h3><p>控制终端通常是指tty/pty，它有一个关键属性：同一时刻，只允许一个进程组成为“前台进程组”，这个状态保存在内核的tty结构里</p><p>前台进程组可以从终端读取输入（<code>read</code>, <code>scanf</code>），接收键盘产生的信号<br>后台进程组如果敢读终端，内核会向该进程组发送<code>SIGTTIN</code>（后台进程读终端，一定不行）或<code>SIGTTOU</code>（后台进程写终端，部分情况），它们的默认行为都是Stop（暂停），写终端不一定能会被暂停，因为很多程序允许后台打印日志</p><h3 id=shell如何进行控制作业>Shell如何进行控制作业</h3><p>以Bash为例，流程是这样的</p><h4 id=启动作业前台>启动作业（前台）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>vim file.txt 
</span></span></code></pre></div><p>Shell进行如下行为</p><ol><li><code>fork()</code></li><li>子进程<code>setpgid()</code> -> 新进程组</li><li><code>tcsetpgrp(tty, pgid)</code> 把终端前台交给这个进程足足</li><li><code>execve(vim)</code></li><li>Shell<code>waitpid()</code>等待</li></ol><h4 id=暂停作业>暂停作业</h4><p>当按下<code>^Z</code></p><ol><li>终端驱动捕获按键</li><li>内核向前台进程组发送<code>SIGTSTP</code></li><li>进程默认行为：暂停</li><li><code>waitpid()</code>返回<code>WIFSTOPPED</code></li><li>Shell发现这个job被停</li><li>Shell重新拿回终端<code>tcsetpgrp()</code>，记录job状态 = Stopped</li></ol><p>Shell并不是被信号暂停的那个，它是观察者</p><h3 id=命令>命令</h3><h4 id=启动作业>启动作业</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 正常启动</span>
</span></span><span style=display:flex><span>$ command
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 后台启动</span>
</span></span><span style=display:flex><span>$ command &amp;
</span></span><span style=display:flex><span>$ sleep <span style=color:#ae81ff>100</span> &amp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 启动后立即转为后台</span>
</span></span><span style=display:flex><span>$ command
</span></span><span style=display:flex><span><span style=color:#75715e># 暂停</span>
</span></span><span style=display:flex><span>$ bg <span style=color:#75715e># 转为后台运行</span>
</span></span></code></pre></div><h4 id=作业控制>作业控制</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 列出所有作业</span>
</span></span><span style=display:flex><span>$ jobs
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> - running sleep <span style=color:#ae81ff>200</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> + stopped vim file.txt 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 带详细信息的列表</span>
</span></span><span style=display:flex><span>$ jobs -l
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> + <span style=color:#ae81ff>12345</span> Running sleep <span style=color:#ae81ff>200</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> - <span style=color:#ae81ff>12346</span> Stopped vim file.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 带进程组信息的列表</span>
</span></span><span style=display:flex><span>$ jobs -p
</span></span></code></pre></div><h4 id=前后台切换>前后台切换</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 暂停当前前台作业（^Z）</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 生成SIGSTP信号</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将暂停的作业转为后台运行</span>
</span></span><span style=display:flex><span>$ bg <span style=color:#f92672>[</span>%job_number<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将作业带到前台</span>
</span></span><span style=display:flex><span>$ fg <span style=color:#f92672>[</span>%job_number<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 示例</span>
</span></span><span style=display:flex><span>$ sleep <span style=color:#ae81ff>200</span> 
</span></span><span style=display:flex><span><span style=color:#75715e># 暂停</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> + <span style=color:#ae81ff>12345</span> suspended sleep <span style=color:#ae81ff>200</span>
</span></span><span style=display:flex><span>$ bg %1 <span style=color:#75715e># 后台继续运行</span>
</span></span><span style=display:flex><span>$ fg %1 <span style=color:#75715e># 带回前台</span>
</span></span></code></pre></div><h4 id=作业标识符>作业标识符</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>%n <span style=color:#75715e># 作业号 n</span>
</span></span><span style=display:flex><span>%string <span style=color:#75715e># 以 string 开头的作业</span>
</span></span><span style=display:flex><span>%?string <span style=color:#75715e># 包含 string 的作业</span>
</span></span><span style=display:flex><span>%% 或 %+ <span style=color:#75715e># 当前作业（最近暂停或后台的）</span>
</span></span><span style=display:flex><span>$- <span style=color:#75715e># 前一个作业</span>
</span></span></code></pre></div><h4 id=信号控制>信号控制</h4><p><code>kill</code> 发送信号，默认发送<code>SIGTERM</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 发送信号到作业</span>
</span></span><span style=display:flex><span>$ kill %1 <span style=color:#75715e># 终止作业1</span>
</span></span><span style=display:flex><span>$ kill -SIGSTOP %1 <span style=color:#75715e># 暂停作业1</span>
</span></span><span style=display:flex><span>$ kill -SIGCONT %1 <span style=color:#75715e># 继续作业1</span>
</span></span></code></pre></div><h5 id=常用信号>常用信号</h5><ul><li><code>SIGINT</code>： ^C 中断</li><li><code>SIGTSTP</code>： ^Z 请求暂停，可捕获、可忽略</li><li><code>SIGQUIT</code>：core dump</li><li><code>SIGCONT</code>： 继续运行</li><li><code>SIGTERM</code>： 可清理退出</li><li><code>SIGKILL</code>： 内核强杀</li><li><code>SIGSTOP</code>：强制暂停，不可捕获，不可忽略</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>kill -STOP pid
</span></span></code></pre></div><ul><li><code>SIGTTIN</code>：后台进程读终端，默认暂停</li><li><code>SIGTTOU</code>：后台进程写终端（部分情况），默认暂停</li><li><code>SIGHUP</code>：控制终端挂断，shell退出时发给作业</li></ul><h4 id=防止作业被挂起信号暂停>防止作业被挂起信号暂停</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 使用 nohup 运行作业</span>
</span></span><span style=display:flex><span>$ nohup command &amp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 或</span>
</span></span><span style=display:flex><span>$ command &amp;
</span></span><span style=display:flex><span>$ disown <span style=color:#75715e># 从作业表中移除</span>
</span></span></code></pre></div><h4 id=监视后台作业>监视后台作业</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 等待后台作业完成</span>
</span></span><span style=display:flex><span>$ wait %1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 等待所有后台作业</span>
</span></span><span style=display:flex><span>$ wait
</span></span></code></pre></div><h4 id=退出shell时保持作业运行>退出Shell时保持作业运行</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 使用 disown</span>
</span></span><span style=display:flex><span>$ disown %1 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 或使用 setsid</span>
</span></span><span style=display:flex><span>$ setsid command
</span></span></code></pre></div><h4 id=示例>示例</h4><h5 id=下载文件时编辑文档>下载文件时编辑文档</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 开始下载大文件</span>
</span></span><span style=display:flex><span>$ wget http://example.com/large-file.zip &amp;
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#ae81ff>12345</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 编辑文档</span>
</span></span><span style=display:flex><span>$ vim notes.txt
</span></span><span style=display:flex><span><span style=color:#75715e># 暂停vim</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> + <span style=color:#ae81ff>12346</span> suspended vim notes.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看下载进度</span>
</span></span><span style=display:flex><span>$ jobs
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> - <span style=color:#ae81ff>12345</span> Running wget http://example.com/large-file.zip
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> + <span style=color:#ae81ff>12346</span> Stopped vim notes.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回vim编辑</span>
</span></span><span style=display:flex><span>$ fg %2 
</span></span></code></pre></div><h5 id=编译项目>编译项目</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 后台编译</span>
</span></span><span style=display:flex><span>$ make all &amp;
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#ae81ff>12347</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 继续其他工作</span>
</span></span><span style=display:flex><span>$ ls -la 
</span></span><span style=display:flex><span>$ grep <span style=color:#e6db74>&#34;pattern&#34;</span> *.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 检查编译状态</span>
</span></span><span style=display:flex><span>$ jobs
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> + <span style=color:#ae81ff>12347</span> Running make all
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 如果有错误，带回前台查看</span>
</span></span><span style=display:flex><span>$ fg %1
</span></span></code></pre></div></div><nav class=post-nav><a href=/unixlike/file/linux/boot/ class=hover:underline>pre: linux boot</a>
<a href=/unixlike/file/linux/clipboard/ class=hover:underline>next: linux clipboard</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><a href=#linux-clicommand-line-interface>Linux CLI(Command Line Interface)</a><ul><li><a href=#命令提示符command-prompt>命令提示符（Command Prompt）</a><ul><li><a href=#命令提示符组成部分>命令提示符组成部分</a></li><li><a href=#bash的命令提示符ps1>Bash的命令提示符：PS1</a><ul><li><a href=#常用的ps1转义符>常用的<code>PS1</code>转义符</a></li><li><a href=#命令提示符的定制>命令提示符的定制</a><ul><li><a href=#颜色和样式>颜色和样式</a></li></ul></li><li><a href=#其他提示符设置>其他提示符设置</a><ul><li><a href=#ps2多行提示符>PS2（多行提示符）</a></li><li><a href=#ps3select命令的提示符>PS3（select命令的提示符）</a></li><li><a href=#ps4调试模式提示符>PS4（调试模式提示符）</a></li></ul></li></ul></li></ul></li><li><a href=#ttyteletypewriter>TTY(Teletypewriter)</a><ul><li><a href=#tty的类型>TTY的类型</a></li><li><a href=#tty与控制台>TTY与控制台</a></li><li><a href=#关键组件与工作流程>关键组件与工作流程</a><ul><li><a href=#数据流向简化示例在虚拟终端中>数据流向简化示例（在虚拟终端中）</a></li></ul></li><li><a href=#使用tty>使用TTY</a></li><li><a href=#相关的重要命令与文件>相关的重要命令与文件</a><ul><li><a href=#为什么ctrlc能终止程序>为什么<code>Ctrl+C</code>能终止程序</a></li></ul></li></ul></li><li><a href=#shell>Shell</a><ul><li><a href=#shell的类型>Shell的类型</a></li><li><a href=#shell的两种使用方式>Shell的两种使用方式</a></li><li><a href=#shell提供的功能>Shell提供的功能</a></li><li><a href=#shell脚本>Shell脚本</a><ul><li><a href=#shebang>Shebang</a><ul><li><a href=#shebang语法>Shebang语法</a></li><li><a href=#如何工作>如何工作</a></li><li><a href=#shebang存在的意义>Shebang存在的意义</a></li><li><a href=#shebang与文件权限>Shebang与文件权限</a></li><li><a href=#shebang与usrbinenv>Shebang与<code>/usr/bin/env</code></a></li><li><a href=#shebang的例外>Shebang的例外</a></li></ul></li><li><a href=#如何执行脚本>如何执行脚本</a></li><li><a href=#变量>变量</a><ul><li><a href=#定义和使用变量>定义和使用变量</a></li><li><a href=#只读变量和删除变量>只读变量和删除变量</a></li><li><a href=#环境变量和局部变量>环境变量和局部变量</a></li></ul></li><li><a href=#字符串操作>字符串操作</a></li><li><a href=#传递参数>传递参数</a></li><li><a href=#数组>数组</a></li><li><a href=#基本运算符>基本运算符</a><ul><li><a href=#算术运算符>算术运算符</a></li><li><a href=#关系运算符常用于或test命令>关系运算符（常用于<code>[[]]</code>或<code>test</code>命令）</a></li><li><a href=#字符串运算符>字符串运算符</a></li><li><a href=#文件测试运算符>文件测试运算符</a></li></ul></li><li><a href=#流程控制>流程控制</a><ul><li><a href=#条件语句if>条件语句<code>if</code></a></li><li><a href=#选择语句case>选择语句<code>case</code></a></li><li><a href=#循环语句>循环语句</a></li></ul></li><li><a href=#函数>函数</a></li><li><a href=#输入输出重定向>输入输出重定向</a></li><li><a href=#调试技巧>调试技巧</a></li></ul></li><li><a href=#bash>Bash</a></li></ul></li><li><a href=#terminal>Terminal</a><ul><li><a href=#定义>定义</a></li><li><a href=#组成>组成</a></li><li><a href=#功能>功能</a></li><li><a href=#常见的terminal仿真器>常见的Terminal仿真器</a></li></ul></li><li><a href=#job-control>Job Control</a><ul><li><a href=#基本概念>基本概念</a><ul><li><a href=#前台作业foreground-job>前台作业（Foreground Job）</a></li><li><a href=#后台作业background-job>后台作业（Background Job）</a></li><li><a href=#四层结构>四层结构</a><ul><li><a href=#1-进程process>1. 进程（process）</a></li><li><a href=#2-进程组process-group>2. 进程组（process group）</a></li><li><a href=#3-会话session>3. 会话（session）</a></li><li><a href=#4-作业job>4. 作业（job）</a></li></ul></li></ul></li><li><a href=#控制终端>控制终端</a></li><li><a href=#shell如何进行控制作业>Shell如何进行控制作业</a><ul><li><a href=#启动作业前台>启动作业（前台）</a></li><li><a href=#暂停作业>暂停作业</a></li></ul></li><li><a href=#命令>命令</a><ul><li><a href=#启动作业>启动作业</a></li><li><a href=#作业控制>作业控制</a></li><li><a href=#前后台切换>前后台切换</a></li><li><a href=#作业标识符>作业标识符</a></li><li><a href=#信号控制>信号控制</a><ul><li><a href=#常用信号>常用信号</a></li></ul></li><li><a href=#防止作业被挂起信号暂停>防止作业被挂起信号暂停</a></li><li><a href=#监视后台作业>监视后台作业</a></li><li><a href=#退出shell时保持作业运行>退出Shell时保持作业运行</a></li><li><a href=#示例>示例</a><ul><li><a href=#下载文件时编辑文档>下载文件时编辑文档</a></li><li><a href=#编译项目>编译项目</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>