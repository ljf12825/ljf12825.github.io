<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>linux file system</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/unixlike/>★</a></li><li><a href=/unixlike/lab/>Lab</a></li><li><a href=/unixlike/log/>Log</a></li><li><a href=/unixlike/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>linux file system<div class=meta>Update: 2026-01-14</div></div><div class=content><h1 id=file-system>File System</h1><p>Linux文件系统就像是整个操作系统的地基和骨架——所有数据都靠它来组织和存取。要理解它，需要同时把它当作一棵“倒挂的树”和一套“抽象层”</p><h2 id=整体视角一棵单一的大树统一的命名空间>整体视角：一棵单一的大树（统一的命名空间）</h2><p>在Linux里，不管有多少硬盘、分区、U盘，统统被挂到一个统一的目录树下</p><ul><li>根目录<code>/</code>是起点，类似于Windows的<code>C:\</code></li><li>其他设备（分区、外部存储）不会像Windows那样显示成<code>D:\ E:\</code>，而是通过挂载点(mount point)嵌入到树中，比如<code>/mnt/usb</code>, <code>/home</code>, <code>/media/cdrom</code></li><li>一切皆文件：设备、套接字、管道甚至进程接口（如<code>/proc</code>）都表现为文件<ul><li>这不仅是一种技术更是一种哲学。它意味着几乎所有资源和操作都可以通过一套统一的<code>open</code>, <code>read</code>, <code>write</code>, <code>close</code>, <code>ioctl</code>接口来访问和管理，把资源抽象为可流动的字节流</li></ul></li></ul><h2 id=linux常见目录结构fhs标准>Linux常见目录结构（FHS标准）</h2><p>熟悉目录相当于熟悉操作系统的器官功能</p><ul><li><code>/bin</code>：用户最基本的二进制可执行文件，比如<code>ls</code>, <code>cp</code>, <code>mv</code></li><li><code>/sbin</code>：系统管理工具（<code>ifconfig</code>, <code>mount</code>等）</li><li><code>/etc</code>：配置文件，整个系统的“设置中心”</li><li><code>/dev</code>：设备文件，例如<code>/dev/sda</code>硬盘、<code>/dev/tty</code>终端</li><li><code>/proc</code>：伪文件系统，实时反映内和和进程状态。比如<code>/proc/cpuinfo</code>, <code>/proc/meminfo</code></li><li><code>/sys</code>：sysfs，和内核设备树挂钩的接口</li><li><code>/var</code>：可变数据，日志，缓存，邮件队列</li><li><code>/usr</code>：用户级别程序和库，体量最大</li><li><code>/home</code>：用户主目录</li></ul><h3 id=dev><code>/dev</code></h3><h4 id=devnull><code>/dev/null</code></h4><p><code>dev/null</code>是Unix/Linux系统中的一个特殊设备文件，通常被称为“空设备(null device)”<br>从工程角度讲，它的语义非常明确：写入它的数据会被立即丢弃；从它读取永远得到EOF<br>它是一个字符设备文件，由内核实现，位于虚拟设备文件系统（<code>/dev</code>），它不是普通文件，不占磁盘空间，不保存任何数据</p><h5 id=行为模型>行为模型</h5><p>写入<code>/dev/null</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>echo <span style=color:#e6db74>&#34;hello&#34;</span> &gt; /dev/null 
</span></span></code></pre></div><p>结果</p><ul><li>写成功</li><li>数据直接消失</li><li>不报错</li></ul><p>内核行为等价于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>write</span>(fd, buf, len); <span style=color:#75715e>// 返回 len,但什么都没保存
</span></span></span></code></pre></div><p>从<code>/dev/null</code>读取</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>cat /dev/null 
</span></span></code></pre></div><p>结果</p><ul><li>立即EOF</li><li>无任何输出</li></ul><p>等价于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>read</span>(fd, buf, len); <span style=color:#75715e>// 立即返回 0 
</span></span></span></code></pre></div><h5 id=存在意义>存在意义</h5><p>Unix的一条核心哲学是：一切皆文件；既然标准输入/输出/错误都是“文件描述符”，那就需要一个合法的“什么都不做”的端点。<code>/dev/null</code>就是这个“黑洞”</p><h5 id=常见用途>常见用途</h5><ol><li>丢弃输出</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>make &gt; /dev/null 
</span></span></code></pre></div><p>只关心返回码，不关心输出</p><ol start=2><li>丢弃错误输出</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>cmd 2&gt; /dev/null 
</span></span></code></pre></div><p>忽略所有错误输出</p><ol start=3><li>同时丢弃stdout + stderr</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>cmd &gt; /dev/null 2&gt;&amp;<span style=color:#ae81ff>1</span> 
</span></span></code></pre></div><ol start=4><li>禁用程序读取输入</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>cmd &lt; /dev/null 
</span></span></code></pre></div><p>告诉程序：不要等用户输入</p><h5 id=设计哲学>设计哲学</h5><p><code>/dev/null</code>的意义在于：提供一个“合法但无副作用”的IO终点<br>这让</p><ul><li>shell重定向</li><li>管道</li><li>守护进程</li><li>构建系统</li><li>编译工具</li></ul><p>都可以不加分支地工作</p><h2 id=底层机制inode与block>底层机制：inode与block</h2><p>这是Linux文件系统的灵魂</p><ul><li>block（块）：存储数据的基本单位，通常4KB</li><li>inode（索引节点）：描述文件的元数据，存储文件大小、权限、所有者、时间戳、数据块位置</li><li>每个文件都有一个inode号，可以通过<code>ls-i</code>查看</li><li>目录本质上是“文件名 -> inode号”的映射表</li><li>文件名并不是文件本身，inode才是核心身份<ul><li>这就是为什么硬连接（hard link）可以让一个文件有多个名字——它们指向同一个inode</li></ul></li></ul><h3 id=inode结构>inode结构</h3><p>inode（索引节点）是Linux文件系统的灵魂。一个文件对应一个inode,里面存的是“元数据”，而不是文件名<br>典型的ext4 inode结构里包含：</p><ul><li>文件类型和权限（普通文件、目录、设备文件）</li><li>所有者（UID）、组（GID）</li><li>时间戳：创建、修改、访问时间（ext4支持纳秒级）</li><li>文件大小</li><li>指针数组（block pointers）：记录数据存放的位置</li></ul><p>指针机制是关键：</p><ul><li>12个直接指针（直接指向数据块）</li><li>1个间接指针（指向“数据块指针的块”）</li><li>1个双重间接指针（指向“指针块的指针块”）</li><li>1个三重间接指针（三级寻址，能管理超大文件）</li></ul><p>这就是为什么一个inode本身不存放数据，而是存放“数据的地图”</p><h3 id=inode本质>inode本质</h3><p>inode是文件系统设计的分水岭。早期系统（如FAT）只有“文件名 + 数据块列表”，无法支持硬链接或权限模型<br>inode的发明，让“名字”和“实体”解耦：</p><ul><li>目录项（dentry）存储名字</li><li>inode存储实体信息</li><li>数据块存储内容</li></ul><p>这种分离让Linux能支持：</p><ul><li>同一个文件多个名字（硬链接）</li><li>删除名字但文件仍然存在（进程持有fd时）</li><li>稳定的权限与时间戳机制</li><li>高级缓存与写回控制</li></ul><h3 id=文件名与目录>文件名与目录</h3><p>文件名其实不在inode里</p><ul><li>目录文件是一个特殊的文件，内容就是一张表：<code>文件名 -> inode号</code></li><li>当<code>ls</code>时，系统就是先读目录文件，找到inode. 再通过inode找到数据块</li><li>这也就是为什么文件名可以删掉（目录项消失），但inode和数据块还在（硬链接依旧存在）</li></ul><h2 id=虚拟文件系统vfs>虚拟文件系统（VFS）</h2><p>Linux内核引入了一个抽象层叫VFS（Virtual File System），程序调用<code>open/read/write</code>系统调用时，不用管底层是ext4还是XFS，VFS会帮忙翻译。它就像一个“通用接口”，底下可以换不同实现，这就是Linux能挂载不同文件系统的原因。VFS在内核中定义了一组所有文件都必须实现的通用接口（如<code>inode_operations</code>, <code>file_operations</code>）。当用户程序执行文件操作时，调用先到VFS,再由VFS根据文件所在的路径，路由到具体的文件系统实现去处理</p><h3 id=linux文件系统的三层抽象>Linux文件系统的三层抽象</h3><p>真正理解文件系统，需要看到三层“视角”</p><ol><li>用户空间（User Space）
程序看到的只是路径和文件描述符(<code>fd</code>)，并不直接感知inode或block。所有访问都要经过系统调用接口，比如<code>open()</code>, <code>read()</code>, <code>write()</code></li><li>内核抽象层（VFS层）
VFS是统一接口层，它让ext4, xfs, btrfs, procfs这些完全不同的实现都能“看起来像文件系统”<br>内核中，每种文件系统驱动都要注册一组操作函数（<code>super_operations</code>, <code>inode_operations</code>, <code>file_operations</code>）<br>这就像面向对象编程中的“虚函数表”：VFS只关心接口，不关心底层实现</li><li>存储层（Block Layer）
VFS最终调用具体的文件系统驱动（如ext4），它通过块设备层（Block I/O Layer）与物理设备交互<br>在这里出现的关键词包括：页缓存（Page Cache）、缓冲区（Buffer Head）、I/O调度器（Elevator Algorithm）、DMA（直接内存访问）</li></ol><p>这三层结构保证了可替换性与高性能。Linux可以在不改动应用程序的前提下挂载任意文件系统，也能用同一套机制管理网络文件、虚拟内存文件、甚至设备节点</p><h2 id=mount>mount</h2><p>Linux的目录树只是一个逻辑结构，它与物理存储设备（硬盘、分区、U盘、光盘）是解耦的</p><ul><li>Windows的思路：<code>C:\</code>, <code>D:\</code>, <code>E:\</code>这些盘符直接代表一块物理存储设备或分区。设备和逻辑视图是强绑定的</li><li>Linux的思路：只有一个<code>/</code>根。所有的物理存储设备都需要手动地、有组织地“映射”或“注入”到这棵单一的树中。这个“映射”的动作，就是挂载</li></ul><p><strong>官方定义：</strong> 挂载是指将一个存储设备（如硬盘分区）上的文件系统，关联到Linux目录树中的一个特定目录（称为挂载点，Mount Point）的过程<br>一旦挂载成功，对该挂载点目录的任何访问操作，都将被透明地重定向到该存储设备上的文件系统</p><h3 id=挂载的意义>挂载的意义</h3><ol><li>统一的视图：对用户和程序来说，无需关心文件具体在哪个物理设备上。它们只需要遵循统一的目录树结构即可找到所有文件。<code>/home/alice/Documents</code>可能在一个独立的SSD上，而<code>/var/log</code>可能在另一块老硬盘上，但用户完全无感</li><li>极致的灵活性：</li></ol><ul><li>可以把任何目录作为挂载点。常见的如<code>/home</code>, <code>/var</code>, <code>/opt</code></li><li>可以根据需求动态调整存储。如果<code>/home</code>空间不足，可以买块新硬盘，格式化后直接挂载到<code>/home</code>，空间就扩容了，无需移动任何用户数据</li><li>可以把远程网络存储（NFS, Samba）挂载到本地目录，像使用本地磁盘一样使用它</li></ul><h3 id=命令mount--umount>命令<code>mount</code> & <code>umount</code></h3><h4 id=mount-1>mount</h4><p>基本语法：<code>mount [选项] &lt;设备源> &lt;挂载点></code></p><ul><li>设备源：可以是设备文件（如<code>/dev/sdb1</code>），也可以是网络路径（如<code>server:/share</code>），甚至是一个镜像文件（使用<code>-o loop</code>选项）</li><li>挂载点：必须是一个已经存在的目录</li></ul><h5 id=示例>示例</h5><ol><li>挂载U盘（通常系统会自动完成，手动演示如下）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>## 首先，创建挂载点目录</span>
</span></span><span style=display:flex><span>sudo mkdir /mkt/my_usb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 然后，挂载设备（假设U盘被识别为 /dev/sdc1)</span>
</span></span><span style=display:flex><span>sudo mount /dev/sdc1 /mnt/my_usb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 现在，可以通过 /mnt/my_usb 访问U盘内容</span>
</span></span><span style=display:flex><span>ls /mnt/my_usb
</span></span></code></pre></div><ol start=2><li>挂载光盘</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sudo mount /dev/cdrom /media/cdrom
</span></span></code></pre></div><ol start=3><li>挂载一个镜像文件</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sudo mount -o loop ubuntu-22.04.iso /mnt/iso
</span></span></code></pre></div><h4 id=umount>umount</h4><p>卸载是为了确保所有数据都已写入设备，保证数据安全。直到拔掉设备可能导致数据损坏<br>语法：<code>umount &lt;挂载点或设备源></code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 通过挂载点卸载</span>
</span></span><span style=display:flex><span>sudo umount /mnt/my_usb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 或者通过设备源卸载</span>
</span></span><span style=display:flex><span>sudo umount /dev/sdc1
</span></span></code></pre></div><p>如果遇到<code>device is busy</code>报错，表示有进程正在使用挂载点下的文件。需要退出所有在该目录下的终端和程序，或用<code>lsof /mnt/my_sub</code>命令查看并结束相关进程</p><h3 id=自动挂载etcfstab文件>自动挂载：/etc/fstab文件</h3><p>每次开机都手动挂载非常麻烦。<code>/etc/fstab</code>（file systems table）文件就是用来配置启动时挂载的<br>它的每一行定义了一个需要挂载的文件系统，包含六个字段</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>&lt;设备源&gt; &lt;挂载点&gt; &lt;文件系统类型&gt; &lt;挂载选项&gt; &lt;dump备份标志&gt; &lt;fsck检查顺序&gt;
</span></span></code></pre></div><p>示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 将 /dev/sdb1 在启动时自动挂载到 /data 目录，使用 ext4 文件系统，默认选项</span>
</span></span><span style=display:flex><span>UUID<span style=color:#f92672>=</span>1234-abcd-5678 /data ext4 defaults <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><h3 id=临时文件系统tmpfs的挂载>临时文件系统（tmpfs）的挂载</h3><p>挂载的概念不仅用于物理设备，还可以用于内存</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 将一部分内存挂载到 /tmp目录，提高临时文件读写速度</span>
</span></span><span style=display:flex><span>sudo mount -t tmpfs -o size<span style=color:#f92672>=</span>512M tmpfs /tmp
</span></span></code></pre></div><p>这样，所有写入<code>/tmp</code>的文件实际上都写在内存里，速度极快，但重启后消失</p><h2 id=namespace>namespace</h2><p>namespace是Linux内核提供的一种资源隔离机制<br>它允许你把同一台机器的内核资源分成多个“视图”（view），每个进程只看到自己的那一份世界<br>这意味着两个进程可能：</p><ul><li>有相同的<code>/</code>根目录名，但实际上是不同的文件系统</li><li>各自有自己的PID=1</li><li>看不到彼此的网络接口</li><li>有独立的主机名</li><li>甚至有自己的用户ID映射</li></ul><p>每个namespace控制一类资源。Linux通过这些不同类型的namespace拼出“独立宇宙”</p><h3 id=namespace的类型>namespace的类型</h3><p>Linux支持几种不同类型的namespaces，每种类型负责隔离不同的资源</p><ol><li>Mount namespace(<code>mnt</code>)<ul><li>用来隔离文件系统的挂载点。每个挂载命名空间都有自己独立的挂载表，这意味着不同的命名空间可以有不同的挂载视图</li><li>举个例子，一个进程在一个命名空间中挂载的文件系统，并不会影响其他命名空间中的进程</li></ul></li><li>Process ID namespace(<code>pid</code>)<ul><li>用来隔离进程ID。每个命名空间中的进程有自己的进程ID号，并且在命名空间内看到的进程树是独立的</li><li>比如，在一个进程ID命名空间中，进程的PID从1开始，这使得容器中的进程与主机的进程互相独立</li></ul></li><li>Network namespace(<code>net</code>)<ul><li>用来隔离网络资源，每个命名空间都有独立的网络设备、IP地址、路由表等网络配置</li><li>这样，进程在不同命名空间中可以拥有不同的网络配置，相互之间无法直接通信</li></ul></li><li>IPC namespace(<code>ipc</code>)<ul><li>用来隔离进程间通信（IPC）资源。每个命名空间拥有独立的消息队列、信号量、共享内存等IPC资源</li><li>这样，进程在不同命名空间中无法直接使用其他命名空间的IPC资源</li></ul></li><li>UTS namespace(<code>uts</code>)<ul><li>用来隔离主机名和域名，每个命名空间中的进程可以有自己独立的主机名和域名，而不会影响到其他命名空间</li><li>这对于容器化应用特别有用，因为它可以让每个容器看起来像是独立的主机</li></ul></li><li>User namespace(<code>user</code>)<ul><li>用来隔离用户和组ID。每个命名空间中的进程可以有独立的用户ID（UID）和组ID（GID），这使得进程在不同命名空间中可以拥有不同的权限</li><li>在容器中，进程可以拥有root权限，但仅限于容器内，不会影响主机系统</li></ul></li><li>Cgroup namespace(<code>cgroup</code>)<ul><li>用来隔离进程的控制组(cgroup)信息。每个命名空间中的进程可以有自己独立的资源限制（如CPU、内存等）</li></ul></li></ol><h3 id=从进程的视角看隔离>从进程的视角看隔离</h3><p>每个进程都有自己的namespace集合，内核通过task_struct里的指针指向这些namespace，可以使用<code>lsns</code>或<code>cat /proc/$$/ns/</code>查看当前shell所处的各个命名空间</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>ipc -&gt; ipc:[4026531839]
</span></span><span style=display:flex><span>mnt -&gt; mnt:[4026531840]
</span></span><span style=display:flex><span>net -&gt; net:[4026531992]
</span></span><span style=display:flex><span>pid -&gt; pid:[4026531836]
</span></span><span style=display:flex><span>user -&gt; user:[4026531837]
</span></span><span style=display:flex><span>uts -&gt; uts:[4026531838]
</span></span></code></pre></div><p>这些数字是namespace的唯一标识符（实质上是内核对象）</p><p>多个进程如果指向同一个namespace,就共享那份“世界观”，如果不同，就各自在不同的宇宙</p><h3 id=使用namespace>使用namespace</h3><ul><li>创建命名空间
可以使用<code>unshare</code>命令或通过编程调用<code>clone()</code>系统调用来创建一个新的命名空间</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>unshare --net bash 
</span></span></code></pre></div><p>这回启动一个新的shell,运行在一个新的网络命名空间中，意味着它无法访问主机的网络资源</p><ul><li>查看命名空间
在<code>/proc/[pid]/ns</code>目录下，可以查看每个进程的命名空间信息。每种类型的命名空间都有对应的文件，如</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ls /proc/self/ns 
</span></span></code></pre></div><p>这里可以看到当前进程所属于的各个命名空间</p><h2 id=不同的linux文件系统类型>不同的Linux文件系统类型</h2><p>Linux有多个文件系统实现，各有优劣：</p><ul><li>ext2/ext3/ext4：最经典的文件系统，ext4最常用，支持journaling（日志机制）防止崩溃时丢数据</li><li>XFS：高性能文件系统，擅长处理超大文件，常用于服务器</li><li>Btrfs：新一代文件系统，支持快照、压缩、子卷，类似于ZFS的野心</li><li>tmpfs：内存中的临时文件系统，用于<code>/tmp</code>，掉电即失</li><li>procfs/sysfs：伪文件系统，数据来自内核而不是硬盘</li></ul><h3 id=ext4文件系统的大布局>ext4文件系统的大布局</h3><p>当在磁盘上格式化一个ext4分区时，它会分成几大区域</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span> <span style=color:#f92672>Boot</span> <span style=color:#f92672>Block</span><span style=color:#f92672>][</span> <span style=color:#f92672>Superblock</span> <span style=color:#f92672>][</span> <span style=color:#f92672>Block</span> <span style=color:#f92672>Group</span> <span style=color:#f92672>0</span> <span style=color:#f92672>][</span> <span style=color:#f92672>Block</span> <span style=color:#f92672>Group</span> <span style=color:#f92672>1</span> <span style=color:#f92672>]...</span>
</span></span></code></pre></div><ul><li>Boot Block：通常占用前1KB,可以存放引导程序（但一般给GRUB用）</li><li>Superblock（超级块）：文件系统的“身份证”，存储文件系统大小、inode数量、block大小、挂载次数等全局信息</li><li>Block Groups（块组）：整个文件系统被划分为一个个块组（类似分区里的“格子”）。每个块组内部都有自己的元数据和数据存储区</li></ul><h3 id=block-group的内部结构>Block Group的内部结构</h3><p>每个块组都包含以下部分</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span> <span style=color:#f92672>Superblock</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#f92672>副本</span><span style=color:#960050;background-color:#1e0010>）</span> <span style=color:#f92672>][</span> <span style=color:#f92672>Group</span> <span style=color:#f92672>Descriptor</span> <span style=color:#f92672>][</span> <span style=color:#f92672>Block</span> <span style=color:#f92672>Bitmap</span> <span style=color:#f92672>][</span> <span style=color:#f92672>Inode</span> <span style=color:#f92672>Bitmap</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> <span style=color:#f92672>Inode</span> <span style=color:#f92672>Table</span> <span style=color:#f92672>][</span> <span style=color:#f92672>Data</span> <span style=color:#f92672>Blocks</span> <span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li>Superblock副本：为了防止损坏，ext4会在不同块组里保存超级块的备份</li><li>Group Descriptor：描述当前块组的元信息，比如这个块组的空闲inode/块数量</li><li>Block Bitmap：记录哪些块被占用，哪些是空闲的</li><li>Inode Bitmap：记录哪些inode被占用</li><li>Inode Table：存放inode结构体数组</li><li>Data Blocks：真正存放文件内容的地方</li></ul><h3 id=ext4改进机制>ext4改进机制</h3><p>相比ext2/ext3, ext4加了很多现代特性</p><ul><li>Extents：替代传统的“每块一指针”，用一个“范围”来表示连续的数据块，大幅减少大文件的寻址开销</li><li>Journal（日志）：写操作先写入日志，再写到数据区，保证崩溃后能恢复一致性</li><li>延迟分配（delayed allocation）：写文件时先缓存，等缓冲区满了再写盘，提高性能</li><li>大文件/大分区支持：单文件最大16TB,分区最大1EB（1 exabyte = 1024 PB）</li></ul><h3 id=现代文件系统的趋势>现代文件系统的趋势</h3><p>Linux文件系统的演进方向，正在从“可靠 + 通用”转向“可验证 + 可回滚”</p><ol><li>ext4：稳定成熟，但本质是20世纪的架构</li><li>Btrfs/ZFS：Copy-on-Write（COW）架构，内置校验、快照、压缩。数据安全性高，但对写入延迟敏感</li><li>OverlayFS/UnionFS：容器时代的利器，可将多层文件系统叠加成一个视图（如Docker的镜像层）</li><li>FUSE（Filesystem in Userspace）：允许用户空间实现文件系统，典型如sshfs. AppImage, rclone
这体现了Linux哲学中的“机制优于策略”——内核只提供通用机制，不规定策略</li></ol><p>当代Linux的存储体系已经超越了传统磁盘概念：</p><ul><li>页缓存（Page Cache）和块缓存（Buffer Cache）是内核层的“第二层文件系统”</li><li><code>tmpfs</code>是“以内存为磁盘”的反向结构</li><li><code>over layfs</code>是“虚拟叠加”的组合</li><li><code>procfs / sysfs</code>是“状态即文件”的抽象</li></ul><p>换句话说，Linux的文件系统并不仅仅是管理数据的，而是管理抽象和语义的</p><h3 id=数据读写流程从抽象到具体>数据读写流程：从抽象到具体</h3><p>结合VFS和底层实现，一个<code>read</code>操作的大致流程如下</p><ol><li>系统调用：用户程序调用<code>read(fd, buf, count)</code></li><li>VFS层：内核通过文件描述符<code>fd</code>找到对应的<code>file</code>结构体，其中包含来指向VFS通用操作的指针</li><li>路由到具体文件系统：VFS根据文件所在的挂载点，确定其文件系统类型（如ext4），并调用ext4注册的<code>read</code>操作</li><li>页缓存（Page Cache）：如果缓存未命中，ext4开始工作。它根据VFS传来的偏移量，通过文件的inode中的指针（或Extents）计算出数据所在的块（block）号</li><li>块设备层：ext4向块设备层发起I/O请求，读取这些块</li><li>I/O调度：块设备层的I/O调度器会对多个请求进行合并和排序（如电梯算法），以优化磁盘磁头的移动路径</li><li>设备驱动：最终，请求被发送到具体的硬盘驱动程序，由驱动通过DMA等方式将数据从磁盘读入页缓存</li><li>完成：数据从页缓存复制到用户空间的<code>buf</code>，系统调用返回</li></ol><p>写入（<code>write</code>）操作也是类似的路径，但更复杂，涉及回写（Writeback）：数据通常先写到页缓存，内核线程再异步地将脏页刷回磁盘。这提升了性能，但也带来了数据一致性的考虑，这就是Journaling（日志）发挥作用的地方</p><h3 id=日志journaling机制的工作流程>日志（Journaling）机制的工作流程</h3><p>日志是防止文件系统在崩溃后陷入不一致状态的关键技术（如ext3/ext4的<code>data=ordered</code>模式）：</p><ol><li>记录日志：在真正向数据块写入用户内容之前，先将本次写入的元数据（如要写入哪些块、inode如何更新）作为一个“事务”追加到日志区域</li><li>提交日志：将日志事务标记为提交，确保日志记录是完整的</li><li>写入数据：开始真正的数据写入（Commit）</li><li>清理日志：数据写入成功后，清理日志中对应的记录</li></ol><p><strong>崩溃恢复</strong></p><ul><li>如果崩溃发生在步骤1-2,日志中的事务不完整，直接忽略</li><li>如果崩溃发生在步骤3-4,重启后文件系统检查日志，发现有一个已提交但未完成的事务，它会重放（replay）这个事务，确保元数据的一致性。这比传统的<code>fsck</code>扫描整个磁盘要快几个数量级</li></ul><h3 id=现代特性copy-on-writecow>现代特性：Copy-on-Write（COW）</h3><p>这是Btrfs和ZFS等新一代文件系统的核心思想，与传统的日志式文件系统（如ext4）有根本不同：</p><ul><li>原理：当需要修改一个数据块时，并不直接在原位置覆盖写入，而是将块复制到一个新位置，在新位置进行修改，最后更新指针指向块</li><li>优势：<ul><li>几乎即时的快照：快照只需记录当前的数据块指针，创建成本极低</li><li>数据一致性：避免了崩溃时“半新半旧”的块的问题</li><li>潜在的性能提升：适合并行写入</li></ul></li></ul><h2 id=权限与安全模型>权限与安全模型</h2><p>Linux的安全模型并不是一个附加功能，而是文件系统设计的一部分<br>每个文件的inode都存储着以下信息：</p><ul><li>所有者（user ID, UID）</li><li>所属组（group ID, GID）</li><li>权限位（permission bits）</li></ul><p>这些字段定义了系统中不同主体对文件的操作权</p><h3 id=基本权限>基本权限</h3><p>Linux将文件权限分为三组：所有者（user）/ 所属组（group）/其他用户（others）<br>每组有是三个权限位：</p><ul><li><code>r</code>（read）：读取文件内容或列出目录内容</li><li><code>w</code>（write）：修改文件内容或在目录中添加/删除文件</li><li><code>x</code>（execute）：执行文件（如果是程序），或进入目录（如果是目录）</li></ul><p>通过<code>ls -l</code>查看权限，显示为</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>-rwxr-x--- <span style=color:#ae81ff>1</span> user group size date filename 
</span></span></code></pre></div><p>前是个字符即为权限标志，每三个一组，分别对应user, group, others</p><ul><li>文件所有者：可读、可写、可执行</li><li>所属组：可读、可执行</li><li>其他用户：无权访问</li></ul><p>当执行<code>ls -l</code>后，最前面的字符表示文件的类型，而不是权限本身，比如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>drwxr-xr-x  <span style=color:#ae81ff>2</span> user user <span style=color:#ae81ff>4096</span> Oct <span style=color:#ae81ff>23</span>  folder
</span></span><span style=display:flex><span>-rw-r--r--  <span style=color:#ae81ff>1</span> user user <span style=color:#ae81ff>1024</span> Oct <span style=color:#ae81ff>23</span>  file.txt
</span></span><span style=display:flex><span>lrwxrwxrwx  <span style=color:#ae81ff>1</span> user user   <span style=color:#ae81ff>12</span> Oct <span style=color:#ae81ff>23</span>  link -&gt; /some/path
</span></span></code></pre></div><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>目录（directory）</td></tr><tr><td>-</td><td>普通文件（regular file）</td></tr><tr><td>l</td><td>符号链接（symbolic link）</td></tr><tr><td>c</td><td>字符设备（character device, 比如终端、串口）</td></tr><tr><td>b</td><td>块设备（block device, 比如硬盘、U盘）</td></tr><tr><td>p</td><td>管道（pipe）</td></tr><tr><td>s</td><td>套接字（socket）</td></tr></tbody></table><h4 id=权限与文件类型的交互>权限与文件类型的交互</h4><p>不同类型的文件，权限意义略有不同</p><table><thead><tr><th>文件类型</th><th><code>r</code></th><th><code>w</code></th><th><code>x</code></th></tr></thead><tbody><tr><td>普通文件</td><td>读内容</td><td>改内容</td><td>执行</td></tr><tr><td>目录</td><td>列出文件</td><td>新增/删除文件</td><td>进入目录</td></tr><tr><td>设备文件</td><td>允许I/O操作</td><td>允许写入设备</td><td>无意义</td></tr><tr><td>管道/套接字</td><td>允许读</td><td>允许写</td><td>无意义</td></tr></tbody></table><h3 id=权限修改>权限修改</h3><h4 id=chmodchange-mode>chmod(change mode)</h4><p>改变权限，有两种写法：</p><ol><li>符号式</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>chmod u+x file <span style=color:#75715e># 给用户增加执行权限</span>
</span></span><span style=display:flex><span>chmod g-w file <span style=color:#75715e># 移除组写权限</span>
</span></span><span style=display:flex><span>chmod o<span style=color:#f92672>=</span>r file <span style=color:#75715e># 设置其他用户只读</span>
</span></span><span style=display:flex><span>chmod a+x file <span style=color:#75715e># 给所有人加执行权限</span>
</span></span></code></pre></div><ol start=2><li>八进制式
三组权限用三位八进制数字表示：<ul><li>r=4, w=2, x=1</li><li>组合相加得出<ul><li><code>rwx</code>=7</li><li><code>rw-</code>=6</li><li><code>r-x</code>=5</li><li><code>r--</code>=4</li><li><code>-wx</code>=3</li><li><code>-w-</code>=2</li><li><code>--x</code>=1</li></ul></li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>chmod <span style=color:#ae81ff>755</span> file 
</span></span></code></pre></div><ul><li>user: rwx</li><li>group: r-x</li><li>other: r-x</li></ul><h4 id=chownchange-owner>chown（change owner）</h4><p>改变文件的拥有者</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sudo chown alice file.text <span style=color:#75715e># 改变所有者</span>
</span></span><span style=display:flex><span>sudo chown alice:developers file <span style=color:#75715e># 同时改组</span>
</span></span></code></pre></div><h4 id=chgrpchange-group>chgrp（change group）</h4><p>单独改组</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>chgrp developers file 
</span></span></code></pre></div><h3 id=特殊权限位>特殊权限位</h3><p>Linux文件权限不止<code>rwx</code>三种，还有三种特殊位用于控制执行时的行为</p><ol><li>setuid（Set User ID）
应用于可执行文件<br>当普通用户执行带setuid位的程序时，程序会以文件所有者的身份运行<br>常用于需要短暂提升权限的系统工具</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ls -l /usr/bin/passwd 
</span></span><span style=display:flex><span>-rwsr-xr-x <span style=color:#ae81ff>1</span> root root <span style=color:#ae81ff>54256</span> ...
</span></span></code></pre></div><p><code>rws</code>中的<code>s</code>表示setuid<br>这让用户能修改自己的密码（写入<code>/etc/shadow</code>），而不需要root权限</p><ol start=2><li>setgid（Set Group ID）
有两种作用：</li></ol><ul><li>对可执行文件：程序运行时继承文件所属组</li><li>对目录：新建文件自动继承该目录的组，而不是创建者的组</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>chmod g+s /shared_dir 
</span></span></code></pre></div><p>这样<code>/shared_dir</code>中的所有文件都属于同一组，方便团队协作</p><ol start=3><li>sticky bit
常用于共享目录（如<code>/tmp</code>）<br>表示目录中的文件只有文件所有者或root才能删除</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>chmod +t /tmp 
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>drwxrwxrwt <span style=color:#ae81ff>10</span> root root <span style=color:#ae81ff>4096</span> ...
</span></span></code></pre></div><p>末尾的<code>t</code>表示sticky bit</p><h3 id=总结>总结</h3><p>Linux权限系统体现了Unix的哲学：“最小权限原则”——默认拒绝，按需授予<br>系统中一切操作最终都由文件描述符驱动，权限控制是确保这个接口不会滥用的根机制<br>在现代系统中，这套传统权限模型还扩展为</p><ul><li>ACL（Access Control List）：更精细的权限控制</li><li>SELinux/AppArmor：基于安全的上下文的强制访问控制</li><li>cgroups + namespaces：容器级的资源与权限隔离</li></ul><h2 id=硬连接与软链接>硬连接与软链接</h2><h3 id=核心概念>核心概念</h3><ul><li>硬链接（hard link）：不同的目录项（不同名字）指向同一个inode（同一份数据）。没有“原始文件”这一说法，只有同一数据的多个名字</li><li>软链接（符号链接, symbolic link/symlink）：一个独立的小文件，内容是目标路径——访问它会跳转到目标路径上（类似快捷方式）</li></ul><h3 id=创建命令>创建命令</h3><ul><li>硬链接</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ln fileA fileB <span style=color:#75715e># fileB 是 fileA的硬链接</span>
</span></span></code></pre></div><ul><li>软连接</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ln -s targetpath linkname <span style=color:#75715e># 创建符号链接</span>
</span></span></code></pre></div><ul><li>删除链接：<code>rm linkname</code>（对硬链接是删除一个名字，对软连接是删除链接文件本身）</li></ul><h3 id=示例-1>示例</h3><p>假设有<code>file1</code>，inode假定为 1000</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>echo hello &gt; file1 
</span></span><span style=display:flex><span>ln file1 file_hard <span style=color:#75715e># 硬链接</span>
</span></span><span style=display:flex><span>ln -s file1 file_soft <span style=color:#75715e># 符号链接</span>
</span></span><span style=display:flex><span>ls -li 
</span></span></code></pre></div><ul><li><code>file1</code>与<code>file_hard</code>会显示相同的inode号，且link count（链接计数）会是2</li><li><code>file_soft</code>会以<code>l</code>开头（<code>lrwxrwxrwx</code>），并显示<code>file1 -> file1</code>，它有自己的inode,但内容只是路径字符串</li></ul><p>关键行为区别：</p><ul><li>修改<code>file_hard</code>的内容，<code>file1</code>看到的是相同内容（因为是同一inode）</li><li>删除<code>file</code>(<code>rm file1</code>)后，<code>file_hard</code>仍然存在并能读到数据（数据直到最后一个硬链接删除且没有打开的fd才释放）</li><li>删除<code>file1</code>后，<code>file_soft</code>变成断链（broken symlink），因为它指向的路径不存在</li></ul><h3 id=技术与限制>技术与限制</h3><ol><li><p>跨文件系统</p><ul><li>硬链接不能跨文件系统（必须在同一分区/同一文件系统内）</li><li>软连接可以指向任意路径（包括不同分区、网络挂载、甚至不存在的路径）</li></ul></li><li><p>目录链接</p><ul><li>普通用户不能对目录创建硬链接（历史守丧出于放置环和破坏树结构的考虑）。root也极少使用。软连接可以指向目录且很常用（例如<code>/ect/alternatives</code>、指向配置目录等）</li></ul></li><li><p>link count（链接计数）</p><ul><li>硬链接会增加inode的link count（<code>stat</code>或<code>ls -l</code>第二列显示）。只有当link count为0且没有进程持有该inode的打开文件描述符时，内核才回收数据块</li><li>软连接不会影响目标文件的link count</li></ul></li><li><p>权限与元数据</p><ul><li>硬链接与目标共享同一个inode,所有它们共享权限、所有者、时间戳等元数据（对其中一个改权限，另一个也变）</li><li>软链接本身有自己的权限位（通常<code>lrwxrwxrwx</code>），但系统在访问时会忽略这些，实际权限由目标文件决定（注意：<code>lstat</code>与<code>stat</code>的区别，可分别查看链接本身和目标）</li></ul></li><li><p>性能与实现成本</p><ul><li>硬链接只是多了一个目录项，几乎零成本（没有额外I/O除了目录项更新）</li><li>软连接需要一次额外的路径解析/跳转（一次额外查inode），成本极小且通常可忽略</li></ul></li><li><p>符号链接的相对/绝对路径问题</p><ul><li>绝对symlink（<code>/usr/bin/foo</code>）在移动包含该链接的整个目录后会失效</li><li>相对symlink（<code>../lib/foo</code>）在移动整个目录树时更稳健，推荐在项目内部/仓库使用相对链接</li></ul></li></ol><h3 id=检测与诊断命令>检测与诊断命令</h3><ul><li>查看inode和link count：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ls -li file1 file_hard file_soft 
</span></span><span style=display:flex><span>stat file1 
</span></span></code></pre></div><ul><li>找出与某inode关联的所有硬链接（假设inode=12345）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>find /path -xdev -inum <span style=color:#ae81ff>12345</span> -print 
</span></span></code></pre></div><p><code>-xdev</code>防止快文件系统搜索（可选）</p><ul><li>找出断开的软连接（可靠写法）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>find /path -type l | -exec test -e <span style=color:#f92672>{}</span> <span style=color:#ae81ff>\;</span> -print 
</span></span></code></pre></div><p>解释：找所有类型为symlink且<code>test -e</code>为假的（目标不存在）的项</p><ul><li>查看symlink指向</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>readlink linkname <span style=color:#75715e># 只输出目标路径</span>
</span></span><span style=display:flex><span>readlink -f linkname <span style=color:#75715e># 输出解析后的绝对真实路径（跟随所有中间链接）</span>
</span></span></code></pre></div><h3 id=常见误区与安全隐患>常见误区与安全隐患</h3><ul><li>误区：<code>ln -s</code>会复制文件？不会。它只创建路径指向。若想复制并保留链接属性，用<code>cp -a</code>（保留属性并复制链接本身）或<code>rsync -a</code>等工具并留意参数</li><li>Symlink TOCTOU与竞态攻击：当脚本以root权限操作文件名时，恶意用户可能替换为symlink来诱导操作到敏感位置（典型的临时文件/tmp/文件竞态攻击）。写脚本时要避免盲目用<code>tmp</code>中固定名字，或用<code>mktemp</code></li><li>备份工具行为差异：tar/rsync/cp等对链接的处理不同（有些会保存为链接，有些会解引用并复制目标）。使用前看清选项（<code>-h, -a, --copy-links</code>等）</li></ul><h3 id=何时用硬链接何时用软连接实战建议>何时用硬链接，何时用软连接（实战建议）</h3><ul><li>用硬链接当需要<ul><li>在同一分区内让同一份数据有多个名字（节省空间），需要完全等价的副本（同inode）</li><li>例如：同一日志文件放在两个目录同时可见</li></ul></li><li>用软连接当需要<ul><li>指向目录或跨分区/网络挂载目标</li><li>想要“快捷方式”或允许目标不存在（先建链接，稍后填目标）</li><li>在包管理、配置、版本切换场景（例如<code>python3 -> python3.10</code>）非常常用</li><li>想让链接在移动整个目录树时仍然有效时优先用相对symlink</li></ul></li></ul></div><nav class=post-nav><a href=/unixlike/file/linux/distributions/ class=hover:underline>pre: linux distributions</a>
<a href=/unixlike/file/linux/graphicscard/ class=hover:underline>next: linux graphics card</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><a href=#file-system>File System</a><ul><li><a href=#整体视角一棵单一的大树统一的命名空间>整体视角：一棵单一的大树（统一的命名空间）</a></li><li><a href=#linux常见目录结构fhs标准>Linux常见目录结构（FHS标准）</a><ul><li><a href=#dev><code>/dev</code></a><ul><li><a href=#devnull><code>/dev/null</code></a><ul><li><a href=#行为模型>行为模型</a></li><li><a href=#存在意义>存在意义</a></li><li><a href=#常见用途>常见用途</a></li><li><a href=#设计哲学>设计哲学</a></li></ul></li></ul></li></ul></li><li><a href=#底层机制inode与block>底层机制：inode与block</a><ul><li><a href=#inode结构>inode结构</a></li><li><a href=#inode本质>inode本质</a></li><li><a href=#文件名与目录>文件名与目录</a></li></ul></li><li><a href=#虚拟文件系统vfs>虚拟文件系统（VFS）</a><ul><li><a href=#linux文件系统的三层抽象>Linux文件系统的三层抽象</a></li></ul></li><li><a href=#mount>mount</a><ul><li><a href=#挂载的意义>挂载的意义</a></li><li><a href=#命令mount--umount>命令<code>mount</code> & <code>umount</code></a><ul><li><a href=#mount-1>mount</a><ul><li><a href=#示例>示例</a></li></ul></li><li><a href=#umount>umount</a></li></ul></li><li><a href=#自动挂载etcfstab文件>自动挂载：/etc/fstab文件</a></li><li><a href=#临时文件系统tmpfs的挂载>临时文件系统（tmpfs）的挂载</a></li></ul></li><li><a href=#namespace>namespace</a><ul><li><a href=#namespace的类型>namespace的类型</a></li><li><a href=#从进程的视角看隔离>从进程的视角看隔离</a></li><li><a href=#使用namespace>使用namespace</a></li></ul></li><li><a href=#不同的linux文件系统类型>不同的Linux文件系统类型</a><ul><li><a href=#ext4文件系统的大布局>ext4文件系统的大布局</a></li><li><a href=#block-group的内部结构>Block Group的内部结构</a></li><li><a href=#ext4改进机制>ext4改进机制</a></li><li><a href=#现代文件系统的趋势>现代文件系统的趋势</a></li><li><a href=#数据读写流程从抽象到具体>数据读写流程：从抽象到具体</a></li><li><a href=#日志journaling机制的工作流程>日志（Journaling）机制的工作流程</a></li><li><a href=#现代特性copy-on-writecow>现代特性：Copy-on-Write（COW）</a></li></ul></li><li><a href=#权限与安全模型>权限与安全模型</a><ul><li><a href=#基本权限>基本权限</a><ul><li><a href=#权限与文件类型的交互>权限与文件类型的交互</a></li></ul></li><li><a href=#权限修改>权限修改</a><ul><li><a href=#chmodchange-mode>chmod(change mode)</a></li><li><a href=#chownchange-owner>chown（change owner）</a></li><li><a href=#chgrpchange-group>chgrp（change group）</a></li></ul></li><li><a href=#特殊权限位>特殊权限位</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#硬连接与软链接>硬连接与软链接</a><ul><li><a href=#核心概念>核心概念</a></li><li><a href=#创建命令>创建命令</a></li><li><a href=#示例-1>示例</a></li><li><a href=#技术与限制>技术与限制</a></li><li><a href=#检测与诊断命令>检测与诊断命令</a></li><li><a href=#常见误区与安全隐患>常见误区与安全隐患</a></li><li><a href=#何时用硬链接何时用软连接实战建议>何时用硬链接，何时用软连接（实战建议）</a></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>