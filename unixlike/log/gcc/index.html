<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>GCC</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-lua.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-rust.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/unixlike/>★</a></li><li><a href=/unixlike/lab/>Lab</a></li><li><a href=/unixlike/log/>Log</a></li><li><a href=/unixlike/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a> |
<a href=https://isocpp.org/ target=_blank>isocpp</a> |
<a href=https://open-std.org target=_blank>open-std</a></p><p><a href=https://cmake.com/ target=_blank>cmake.org</a></p><p><a href=https://llvm.org/ target=_blank>llvm.org</a></p><p><a href=https://www.boost.org/ target=_blank>boost.org</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/ target=_blank>lua.org</a> |
<a href=https://www.luarocks.org/ target=_blank>luarocks.org</a> |
<a href=https://www.luajit.org/ target=_blank>luajit.org</a></p><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a></p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a></p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>GCC<div class=meta>Modified: 2025-12-31
| Author：ljf12825</div></div><div class=content><p>GCC(GNU Compiler Collection)是一个开源的编译器系统，支持多种编程语言，包括C、C++、Fortran、Ada、Go、D、Object-C和其他一些语言<br>它最初是由Richard Stallman在 1987年启动的，用于构建GNU操作系统的一部分，但现在已经发展成一个跨平台的工具，广泛应用于各类操作系统中\</p><p>GCC的主要特点是高效性、跨平台、开源，它支持多种体系结构，并且不断更新以支持新的编程语言和硬件架构</p><p><strong>GNU</strong><br>GNU(GNU&rsquo;s Not Unix)是一个由Richard Stallman于1983年发起的自由软件项目，旨在开发一个完全自由、开放源代码的操作系统。GNU项目的目标是替代Unix操作系统，但与Unix不同的是，GNU的所有组件都是自由的软件，用户可以自由地运行、复制、修改和分发这些程序
GNU的核心理念是自由软件，这意味着：</p><ol><li>自由使用：自由运行，自用/商用</li><li>自由学习和修改</li><li>自由分发</li><li>自由共享改进</li></ol><p>为了确保这些自由，GNU项目创建了GNU通用公共许可证（GPL），这时一种广泛使用的开源许可证，保证软件的自由性并促进自由软件的传播</p><p><strong>GNU的组成部分</strong></p><ol><li>GNU工具链</li></ol><ul><li>GNU项目提供了一套完整的工具，用于开发和管理软件。这些工具包括编译器、调试器、构建工具等</li><li>最著名的工具包括<ul><li>GCC（GNU Complier Collection）：一个支持多种编程语言的编译器</li><li>GDB（GNU Debugger）：一个强大的调试器，用于调试程序</li><li>Make：一个自动化构建工具，通常用于编译大型程序</li><li>Binutils：一组用于处理目标文件（如汇编、链接、反汇编等）的工具</li></ul></li></ul><ol start=2><li>GNU操作系统的核心组件</li></ol><ul><li>GNU C库（glibc）：一个实现了POSIX标准的C标准库，许多Linux系统和其他操作系统都依赖于它</li><li>GNU Bash：一个广泛使用的shell（命令行解释器），为用户提供命令行接口</li><li>GNU Core Utilities：包括文件操作、文本处理、文件权限管理等常见的命令，如<code>ls</code>、<code>cp</code>、<code>rm</code>等</li></ul><ol start=3><li>GNU的图形环境</li></ol><ul><li>GNU 项目并未单独开发完整的图形界面系统，而是与其他项目合作，例如 X Window System，这为其用户提供图形界面环境</li><li>GNU Emacs：一个强大的文本编辑器，最初由 Richard Stallman 开发，是 GNU 项目中的一个标志性工具</li><li>GNOME：一个现代的桌面环境，虽然它最初是由 GNOME 项目开发，但它是基于 GNU 工具链和库的，广泛用于 Linux 桌面环境</li></ul><p><strong>GNU于Linux的关系</strong><br>GNU 项目本身并没有完成一个完整的操作系统内核。在 GNU 项目启动之初，Linux 内核并不存在。随着 Linux 内核（由 Linus Torvalds 于 1991 年发布）的出现，GNU 项目的一些工具与 Linux 内核结合，形成了今天我们所说的 Linux 操作系统。</p><p>实际上，许多人将 Linux 系统误称为 GNU/Linux，因为它是由 Linux 内核与 GNU 项目的工具链共同组成的。尽管如此，Linux 内核并非由 GNU 项目开发，因此，“GNU/Linux”更能准确反映系统的组成。</p><p><strong>主要的GNU许可证：GPL</strong><br>GNU 项目的一个重要组成部分就是 GNU 通用公共许可证（GPL）。GPL 是一种强制开源的软件许可证，确保用户的自由使用、修改和分享软件。根据 GPL，任何修改或分发软件的行为都必须公开源代码，并且使用相同的许可证。</p><ul><li>GPL v2：第二版许可证，广泛应用于许多开源项目中（例如 Linux 内核）。</li><li>GPL v3：更新版，增加了对软件专利和硬件限制的保护。</li></ul><p><strong>GNU项目的影响和意义</strong>\</p><ol><li>开源运动的奠基</li></ol><ul><li>GNU项目是现代开源软件运动的先驱之一。它的成功促使了大量的开源项目和社区的崛起</li></ul><ol start=2><li>自由软件基金会（FSF）</li></ol><ul><li>由Richard Stallman创办的自由软件基金会（FSF）支持GNU项目，并推动自由软件的法律、教育和社会倡导</li></ul><ol start=3><li>Linux和开源生态</li></ol><ul><li>GNU项目于Linux内核的结合，形成了世界上最广泛使用的操作系统之一，也就是GNU/Linux系统。基于这一系统，许多开源项目和企业得到了极大的发展</li></ul><ol start=4><li>科学和教育领域的推广</li></ol><ul><li>GNU项目不仅为个人用户提供了自由软件，还在科学研究和教育领域得到了广泛的应用。很多学术机构和实验室都使用GNU工具链和开源软件进行研究</li></ul><p><strong>GCC的结构</strong><br>GCC是一个由多个组件构成的编译器集合。其主要结构可以分为以下几个部分：</p><ol><li>前端（Front-End）</li></ol><ul><li>前端负责处理源代码的语法和语义分析，将源代码转换为中间表示（IR）</li><li>GCC有不同的前端，支持多种编程语言</li><li>每个前端都包括词法分析器、语法分析器、语义分析器</li></ul><ol start=2><li>中间层（Middle-End）</li></ol><ul><li>GCC的中间层主要处理中间表示（IR）的优化和转换</li><li>GCC使用GIMPLE和RTL（Register Transfer Language）两种中间表示</li><li>这个阶段的主要目标是提高程序的执行效率，包括常见的优化，如常量传播、循环优化、死代码消除等</li></ul><ol start=3><li>后端（Back-End）</li></ol><ul><li>后端将经过优化的中间表示（IR）转换成目标平台的机器代码</li><li>GCC支持多种硬件架构，后端会根据目标架构的指令集来生成对应的汇编代码</li><li>后端还负责处理与具体平台相关的任务，如寄存器分配、指令选择等</li></ul><ol start=4><li>代码生成（Code Generation）</li></ol><ul><li>最终，GCC的后端将优化后的IR转化为汇编预言家，然后通过汇编器（Assembler）生成机器代码</li></ul><ol start=5><li>链接（Linker）</li></ol><ul><li>GCC通常会调用链接器，将多个对象文件和库文件链接成一个最终可执行的程序</li></ul><p><strong>GCC的主要功能</strong></p><ol><li>编译和优化</li></ol><ul><li>GCC不仅能够将源代码编译为机器代码，还能执行大量的优化以提高程序的执行效率</li><li>支持的优化包括：循环优化、函数内联、代码移除、分支预测等</li></ul><ol start=2><li>跨平台支持</li></ol><ul><li>GCC支持多种操作系统和硬件平台，包括x86、x64、ARM、MIPS、PowerPC、RISC-V等</li><li>通过调整目标架构，GCC可以生成不同平台上运行的可执行文件</li></ul><ol start=3><li>调试信息支持</li></ol><ul><li>GCC可以生成调试信息，支持GDB（GNU Dubugger）等调试工具，帮助开发者调试程序</li></ul><ol start=4><li>静态分析和诊断</li></ol><ul><li>GCC提供了强大的诊断信息，能够帮助开发者发现潜在的错误（如未初始化的变量、类型不匹配等）</li><li>还支持静态分析工具，如<code>-Wall</code>（启用所有警告）和<code>-Wextra</code>（启用额外警告）</li></ul><ol start=5><li>多语言支持</li></ol><ul><li>GCC支持多种编程语言，并且可以在同一个项目中混合使用不同语言编写的代码</li></ul><ol start=6><li>生成可执行文件、库文件和目标文件</li></ol><ul><li>GCC支持生成可执行文件、静态库、动态库、目标文件等</li></ul><p><strong>GCC的工作流程</strong></p><ol><li>编译阶段</li></ol><ul><li>GCC首先会对源代码进行预处理，处理宏定义、头文件引用等</li><li>然后，源代码被转换成汇编代码</li></ul><ol start=2><li>汇编阶段</li></ol><ul><li>汇编器将汇编代码转换为目标文件（<code>.o</code>文件）</li></ul><ol start=3><li>链接阶段</li></ol><ul><li>链接器将目标文件和库文件链接在一起，生成最终的可执行文件</li></ul><p><strong>GCC的扩展和插件</strong><br>GCC还支持通过插件机制扩展编译器的功能。开发者可以编写自己的插件，添加新的分析、优化或代码生成特性。这个功能使得GCC在一些特定领域（如静态分析、代码检查等）非常灵活和强大</p><p><strong>GCC在现代编程中的地位</strong><br>GCC是开源软件开发中的重要工具，尤其是在嵌入式开发、操作系统开发等领域有广泛应用。由于其高度优化、跨平台能力以及开源特性，它在编译器领域有着举足轻重的地位</p><p>GCC也是愈多其他项目的工具和基础，例如Linux内核就是用GCC编译的。同时，许多学术研究、编程语言的开发等也依赖GCC</p><h3 id=gcc工具链的安装>GCC工具链的安装</h3><p><strong>通过版管理器安装</strong><br>以Ubuntu为例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt update
</span></span><span style=display:flex><span>sudo apt install build-essential gdb binutils
</span></span></code></pre></div><ul><li><code>build-essential</code>：包含<code>gcc</code>、<code>g++</code>、<code>make</code>、<code>libc-dev</code>等基本工具</li><li><code>gdb</code>：GNU调试器</li><li><code>binutils</code>：包含<code>ld</code>（链接器）、<code>as</code>（汇编器）、<code>objdump</code>等工具</li></ul><p><strong>验证安装</strong>\</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>gcc --version
</span></span><span style=display:flex><span>g++ --version
</span></span><span style=display:flex><span>gdb --version
</span></span><span style=display:flex><span>ld --version
</span></span></code></pre></div><p>如果这些命令输出版本信息，说明安装成功</p><p><strong>可选组件</strong><br>安装特定版本的GCC<br>如果系统自带的GCC版本比较旧，可以手动安装新版</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt install gcc-15 g++-15 <span style=color:#6272a4># 例如安装GCC 15</span>
</span></span><span style=display:flex><span>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc -15 <span style=color:#bd93f9>100</span>
</span></span><span style=display:flex><span>sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-15 <span style=color:#bd93f9>100</span>
</span></span></code></pre></div><p>然后使用<code>sudo update-alternatives --config gcc</code>切换版本</p><p><strong>手动编译安装</strong><br>如果需要最新版或自定义配置，可以从源码编译</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 下载源码</span>
</span></span><span style=display:flex><span>wget https://ftp.gnu.org.gnu/gcc/gcc-15.1.0/gcc-15.1.0.tar.gz
</span></span><span style=display:flex><span>tar -xzf gcc-15.1.0.tar.gz
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>cd</span> gcc-15.1.0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 安装依赖</span>
</span></span><span style=display:flex><span>./contrib/download_prerequisites
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 编译安装（较耗时）</span>
</span></span><span style=display:flex><span>mkdir build <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#8be9fd;font-style:italic>cd</span> build
</span></span><span style=display:flex><span>../configure --prefix<span style=color:#ff79c6>=</span>/usr/local/gcc-15.1.0 --enable-languages<span style=color:#ff79c6>=</span>c, c++ --disable-multilib
</span></span><span style=display:flex><span>make -j<span style=color:#ff79c6>$(</span>nproc<span style=color:#ff79c6>)</span> <span style=color:#6272a4># 并行编译，加快速度</span>
</span></span><span style=display:flex><span>sudo make install
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 添加到PATH</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#39;export PATH=/usr/local/gcc-15.1.0/bin:$PATH&#39;</span> &gt;&gt; ~/.bashrc
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>source</span> ~/.bashrc
</span></span></code></pre></div><p>GCC的全称是 GNU Compiler Collection（GNU 编译器集合），它是一套编译器集合，而不仅仅是单个编译器</p><ul><li>历史：它最初名为 GNU C Compiler，只用于编译 C 语言。随着时间推移，它扩展支持了C++、Fortran、Ada、Go、D等多种语言，因此在 1999 年更名为现在的名字</li><li>核心地位：它是 GNU 工具链的核心组成部分，也是 Linux 生态的基石。几乎所有Linux发行版上的软件都是用 GCC 编译的</li><li>跨平台与开源：GCC 是自由软件，遵循 GPL 许可证。它支持几乎所有主流处理器架构（x86, ARM, RISC-V, MIPS等）和操作系统（Linux, Windows, macOS, BSD等）</li></ul><p><strong>GCC 支持的语言</strong><br>GCC是一个家族，包含多个前端编译器：</p><ul><li><code>gcc</code>：用于编译 C 程序</li><li><code>g++</code>：C++</li><li><code>gfortran</code>：Fortran （取代了旧的<code>g77</code>）</li><li><code>gnat</code>：Ada</li><li><code>gccgo</code>：Go</li><li><code>gdc</code>：D</li></ul><p>通常说“用 GCC 编译”，大多数指的是使用<code>gcc</code>或<code>g++</code></p><h2 id=gcc的编译过程>GCC的编译过程</h2><p>GCC隐式地经历了四个主要阶段：</p><ol><li>预处理（Preprocessing）</li></ol><ul><li>执行者：<code>cpp</code>（C Preprocessor）</li><li>工作：<ul><li>展开所有的宏（<code>#define</code>）</li><li>处理所有条件编译指令（<code>#if</code>, <code>ifdef</code>, <code>#endif</code>等）</li><li>包含头文件（<code>include</code>）的内容</li><li>删除所有注释和空行</li></ul></li><li>命令：<code>gcc -E main.c -o main.i</code>（输出<code>.i</code>文件）</li></ul><ol start=2><li>编译（Compilation）</li></ol><ul><li>工作：将预处理后的代码（高级语言）翻译成汇编语言（特定于目标CPU的低级代码）</li><li>命令：<code>gcc -S main.i -o main.s</code>（输出<code>.s</code>文件）</li><li>注意：这里的“编译”是狭义上的，广义上的编译指整个从源码到二进制的过程</li></ul><ol start=3><li>汇编（Assembly）</li></ol><ul><li>执行者：<code>as</code>（汇编器）</li><li>工作：将汇编代码<code>.s</code>文件翻译成机器指令，生成目标文件（<code>.o</code>或<code>.obj</code>文件）。目标文件是二进制格式，但还不能直接运行</li><li>命令：<code>gcc -c main.s -o main.o</code>（输出<code>.o</code>文件）</li></ul><ol start=4><li>链接（Linking）</li></ol><ul><li>执行者：<code>ld</code>（链接器，GCC会调用它）</li><li>工作：<ul><li>将多个目标文件（<code>.o</code>）合并成一个可执行文件</li><li>解析库文件（如 C 标准库<code>libc.so</code>）中函数引用（例如<code>prinf</code>函数在哪）</li><li>解决所有符号（函数、变量）的地址</li></ul></li><li>命令：<code>gcc main.o utils.o -o myapp</code>（输出为可执行文件）</li></ul><p><code>gcc main.c -o main</code>，GCC自动完成了以上所有四个步骤</p><h2 id=常用gcc选项>常用GCC选项</h2><table><thead><tr><th>类别</th><th>选项</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>常用选项</td><td><code>-o &lt;file></code></td><td>指定输出文件名</td><td><code>gcc main.c -o myapp</code></td></tr><tr><td></td><td><code>-c</code></td><td>只编译不链接，生成<code>.o</code>文件</td><td><code>gcc -c main.c</code> -> <code>main.o</code></td></tr><tr><td></td><td><code>-g</code></td><td>添加调试信息，便于使用GDB调试</td><td><code>gcc -g main.c -o main</code></td></tr><tr><td>警告选项</td><td><code>Wall</code></td><td>开启大部分常用警告（W all）</td><td><code>gcc -Wall main.c</code></td></tr><tr><td></td><td><code>-Wextra</code></td><td>开启额外的警告</td><td><code>gcc -Wall -Wextra main.c</code></td></tr><tr><td></td><td><code>-Werror</code></td><td>将所有警告视为错误，强制要求代码0警告</td><td><code>gcc -Wall -Werror main.c</code></td></tr><tr><td>优化选项</td><td><code>-O0</code></td><td>不优化（默认），编译快，适合调试</td><td><code>gcc -O0 -g main.c</code></td></tr><tr><td></td><td><code>-O1</code>, <code>-O2</code></td><td>不同级别的优化，<code>-O2</code>最常用</td><td><code>gcc -O2 main.c</code></td></tr><tr><td></td><td><code>-O3</code></td><td>最高级别优化，可能激进地改变代码</td><td><code>gcc -O3 main.c</code></td></tr><tr><td></td><td><code>-Os</code></td><td>优化代码大小（Optimize for size）</td><td></td></tr><tr><td>目录选项</td><td><code>-I&lt;dir></code></td><td>添加头文件搜索路径</td><td><code>gcc -I./include main.c</code></td></tr><tr><td></td><td><code>-L&lt;dir></code></td><td>添加库文件搜索路径</td><td><code>gcc -L./lib main.o -lfoo</code></td></tr><tr><td>链接选项</td><td><code>-l&lt;library></code></td><td>链接指定的库</td><td><code>gcc main.o -lm</code>（链接数学库）</td></tr><tr><td></td><td><code>-static</code></td><td>静态链接，将库打包进最终程序</td><td><code>gcc -static main.c</code></td></tr><tr><td></td><td><code>-shared</code></td><td>生成共享库（<code>.so</code>）而不是可执行文件</td><td><code>gcc -shared -o libfoo.so foo.c</code></td></tr></tbody></table><h2 id=示例>示例</h2><p>假设项目结构如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>my_project/
</span></span><span style=display:flex><span>├── src/
</span></span><span style=display:flex><span>│   ├── main.c
</span></span><span style=display:flex><span>│   └── utils.c
</span></span><span style=display:flex><span>├── include/
</span></span><span style=display:flex><span>│   └── utils.h
</span></span><span style=display:flex><span>└── lib/
</span></span><span style=display:flex><span>    └── thirdparty.a
</span></span></code></pre></div><p>手动分步编译：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 1. 编译源文件为目标文件，并指定头文件路径</span>
</span></span><span style=display:flex><span>gcc -c src/main.c -I./include -o build/main.o
</span></span><span style=display:flex><span>gcc -c src/utils.c -I./include -o build/utils.o
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 2. 链接所有目标文件和第三方库，生成可执行程序</span>
</span></span><span style=display:flex><span>gcc build/main.o build/utils.o -L./lib -lthirdparty -o bin/myapp
</span></span></code></pre></div><p>一条指令完成（GCC自动处理中间步骤）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>gcc src/main.c src/utils.c -I./include -L./lib -lthirdparty -o bin/myapp
</span></span></code></pre></div><h2 id=gcc-and-g><code>gcc</code> and <code>g++</code></h2><p><code>gcc</code>和<code>g++</code>都是GNU编译器套件里的前端驱动程序，不是单独的编译器，而是“驱动”不同后端编译工具链的入口。它们的主要区别体现在默认行为和语言支持上</p><ol><li><code>gcc</code></li></ol><ul><li>原名是GNU C Compiler，但后来扩展成了 GNU Compiler Collection</li><li>主要职责：默认当作 C 编译器来使用</li><li>行为特点：<ul><li>如果输入<code>.c</code>文件：当成C源文件处理</li><li>如果输入<code>.cpp</code>/<code>.cc</code>/<code>.cxx</code>文件：也会尝试用C++编译器，但不会自动连接C++标准库（libstdc++）</li><li>编译C++文件时，需要手动加上<code>-lstdc++</code>，否则使用C++标准库的程序（例如用<code>std::cout</code>）会报连接错误</li></ul></li></ul><p>示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>gcc test.cpp -o <span style=color:#8be9fd;font-style:italic>test</span> <span style=color:#6272a4># 可能会报错：未定义引用 std::cout</span>
</span></span><span style=display:flex><span>gcc test.cpp -o <span style=color:#8be9fd;font-style:italic>test</span> -lstdc++ <span style=color:#6272a4># 手动指定链接C++库，才能运行</span>
</span></span></code></pre></div><ol start=2><li><code>g++</code></li></ol><ul><li>是专门针对C++的编译驱动程序</li><li>主要职责：把输入文件当作C++源代码来处理</li><li>行为特点：<ul><li>输入<code>.c</code>或<code>.cpp</code>文件时，都会默认按C++语法处理</li><li>编译和链接会自动加上C++标准库（libstdc++）</li><li>适合C++项目编译，不用额外指定库</li></ul></li></ul><p>示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>g++ test.cpp -o <span style=color:#8be9fd;font-style:italic>test</span> <span style=color:#6272a4># 自动链接 stdc++，直接可以用 std::cout</span>
</span></span></code></pre></div><h3 id=实际建议>实际建议</h3><ul><li>如果写纯C：用<code>gcc</code></li><li>如果写C++：用<code>g++</code>，避免手动添加库的麻烦</li><li>如果写混合项目（C&amp;C++）：通常使用<code>g++</code>做最终链接（因为要链上<code>libstdc++</code>），中间的<code>.o</code>文件可以用<code>gcc -c</code>或<code>g++ -c</code>来生成</li></ul><h2 id=文档与帮助>文档与帮助</h2><p>查阅GCC选项的详细内容，可以通过以下几种方式</p><h3 id=方法一使用help选项最快捷>方法一：使用<code>help</code>选项（最快捷）</h3><p>这是最快、最直接的方式，用于在终端中快速查看所有选项的概览</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>gcc --help
</span></span></code></pre></div><p>这会输出一个很长的列表，按类别（如优化选项、警告选项等）列出所有可用的命令行选项以及其简要说明<br>如果想查看某个特定类别的选项，可以使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>gcc --help<span style=color:#ff79c6>=</span>optimizers <span style=color:#6272a4># 查看所有优化选项</span>
</span></span><span style=display:flex><span>gcc --help<span style=color:#ff79c6>=</span>warnings <span style=color:#6272a4># 查看所有警告悬念</span>
</span></span><span style=display:flex><span>gcc --help<span style=color:#ff79c6>=</span>target <span style=color:#6272a4># 查看目标平台相关选项</span>
</span></span><span style=display:flex><span>gcc --help<span style=color:#ff79c6>=</span>common <span style=color:#6272a4># 查看通用选项</span>
</span></span></code></pre></div><p>优点：极其快速，无需联网，随编译器自带<br>缺点：说明非常简短，没有详细解释和示例</p><h3 id=方法二使用man手册页最常用最详细>方法二：使用<code>man</code>手册页（最常用、最详细）</h3><p>这是Linux/Unix系统下查询命令和工具详情的标准方法。<code>man</code>（manual）页面提供了非常详尽的文档</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>man gcc
</span></span></code></pre></div><p>这会打开一个完整的、结构化的手册。可以使用键盘进行导航</p><ul><li>上下箭头：逐行滚动</li><li>Page Up / Page Down：翻页</li><li><code>/</code>：搜索。例如，输入<code>/O2</code>然后按回车，可以跳转到<code>-O2</code>选项的解释</li><li><code>n</code>：跳转到下一个搜索匹配项</li><li><code>q</code>：退出手册页</li></ul><p><strong>手册页结构：</strong>
手册页通常包含以下部分，对于查找选项非常有用：</p><ul><li>NAME：名称和简要描述</li><li>SYNOPSIS：语法概要</li><li>DESCRIPTION：详细描述（重点阅读部分）</li><li>OPTIONS：所有选项的详细解释</li><li>SEE ALSO：相关参考</li></ul><p>优点：信息非常详细，包含每个选项的行为、注意事项和与其他选项的交互。离线可用<br>缺点：内容量大，需要一定的阅读和搜索技巧</p><h3 id=方法三使用info文档最完整最权威>方法三：使用<code>info</code>文档（最完整、最权威）</h3><p>GNU项目的官方文档格式是<code>info</code>，它比<code>man</code>页面更结构化、更超文本化，内容也通常更新、更全</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>info gcc
</span></span></code></pre></div><p>这会启动一个基于文本的超文本浏览器。导航方式类似<code>man</code>，但更强大：</p><ul><li>方向键：移动光标</li><li>回车：进入带有<code>*</code>标记的节点（超链接）</li><li><code>l</code>（小写L）：返回到上一个节点</li><li><code>u</code>：向上移动一层</li><li><code>q</code>：退出</li></ul><p>在<code>info gcc</code>中，可以找到关于GCC的所有一切，包括完整的内部实现原理、每种支持语言的细节、以及每个选项的最终权威解释</p><p>优点：最完整、最权威的GCC文档，是GUN的官方手册<br>缺点：结构复杂，信息量大</p><h3 id=方法四在线查询官方文档>方法四：在线查询官方文档</h3><p>GNU GCC官网提供了完整的<a href=https://gcc/gnu.org/onlinedocs>在线文档</a>，阅读体验通常比终端更好<br>其中包含：</p><ul><li>当前稳定的版本</li><li>所有历史版本文档</li><li>多种格式（HTML, PDF等）</li></ul><p>在线文档的结构和内容与<code>info</code>基本相同，但有了网页的便利性</p><h3 id=方法五询问编译器本身-q---helpxxx>方法五：询问编译器本身（<code>-Q --help=xxx</code>）</h3><p>这是一个非常强大的技巧，可以让GCC告诉你它默认启用了哪些选项，或者不同优化级别具体包含了哪些子选项</p><ol><li>查看激活的优化选项：
<code>-O2</code>与<code>-O3</code>有什么区别</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 查看使用 -O2 时，哪些优化器被开启了</span>
</span></span><span style=display:flex><span>gcc -Q -O2 --help<span style=color:#ff79c6>=</span>optimizers
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 与 -O3 进行对比</span>
</span></span><span style=display:flex><span>gcc -Q -O3 --help<span style=color:#ff79c6>=</span>optimizers
</span></span></code></pre></div><p>输出会是一个很长的列表，显示每个优化选项是 <code>[enabled]</code> 还是 <code>[disabled]</code>。通过对比，你就可以清晰地看到 <code>-O3</code> 比 <code>-O2</code> 多开启了哪些具体的优化</p><ol start=2><li>查看默认启用的警告</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>gcc -Q --help<span style=color:#ff79c6>=</span>warnings | grep enabled
</span></span></code></pre></div><p>这个命令可以查看哪些警告选项默认情况下是开启的（即使没有指定<code>-Wall</code>）</p><h3 id=实战技巧>实战技巧</h3><p>假设遇到了一个<code>-fPIC</code>选项，想知道它是干什么的</p><ol><li>快速瞥一眼（<code>--help</code>）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>gcc --help | grep -i fpic
</span></span></code></pre></div><p>输出可能只有简单的一行：<code>-fPIC Generate position-independent code if possible</code>知道了它和“位置无关代码”有关</p><ol start=2><li>查阅详细解释（<code>man</code>）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>man gcc
</span></span></code></pre></div><p>在<code>man</code>页面中，按下<code>/</code>，输入<code>-fPIC</code>，按回车，反复按<code>n</code>键直到找到最匹配的解释。会看到更详细的描述</p><ol start=3><li>查阅最权威的解释（<code>info</code>）</li></ol><h3 id=关于文档和帮助>关于文档和帮助</h3><p>可以把“掌握GCC”分为几个层次：</p><h4 id=层次一掌握使用文档可以基本覆盖>层次一：掌握“使用”（文档可以基本覆盖）</h4><p>这是<strong>文档能帮你达到的主要目标</strong>。通过 <code>man gcc</code>、<code>info gcc</code> 和在线文档，你可以：</p><ul><li><strong>查找任何选项的含义</strong>：比如 <code>-fstack-protector-strong</code> 是做什么的。</li><li><strong>了解正确的命令行语法</strong>：如何组合选项来编译、链接一个项目。</li><li><strong>理解主要功能</strong>：如何使用不同的优化级别（<code>-O0</code> vs <code>-O2</code>），如何生成调试信息（<code>-g</code>），如何链接静态库和动态库（<code>-l</code>, <code>-L</code>, <code>-static</code>）。</li><li><strong>解决大多数编译和链接错误</strong>：通过文档理解错误背后的原因，并找到正确的选项来修复它（例如，链接失败时知道要加 <code>-lm</code>）。</li></ul><p><strong>在这个层次上，文档是终极百科全书，反复查阅和实践可以让你变得非常熟练。</strong></p><h4 id=层次二掌握原理与洞察文档是基础但需更多>层次二：掌握“原理与洞察”（文档是基础，但需更多）</h4><p>这是超越“用户手册”，进入“工程师思维”的层次。文档是起点，但远非终点。</p><ul><li><strong>编译/链接模型</strong>：文档告诉你 <code>-c</code> 和 <code>-o</code> 的用法，但要真正“掌握”，你需要理解<strong>为什么需要分离编译和链接</strong>？头文件（<code>.h</code>）和库文件（<code>.a</code>/<code>.so</code>）在编译和链接阶段各自扮演什么角色？符号表（Symbol Table）是什么？</li><li><strong>ABI（应用程序二进制接口）</strong>：不同的优化选项（如 <code>-fPIC</code>）如何影响生成的代码？为什么用不同编译器或不同选项编译的库有时无法混用？这需要理解平台ABI。</li><li><strong>底层工具链</strong>：GCC 只是一个驱动程序（driver），它背后调用了预处理器（<code>cpp</code>）、编译器本身（<code>cc1</code>）、汇编器（<code>as</code>）、链接器（<code>ld</code>）。要真正掌控它，你需要了解这个工具链的每个环节。文档会提及，但深度有限。</li><li><strong>与操作系统的交互</strong>：程序如何启动（<code>_start</code> 入口点）？静态链接和动态链接在操作系统加载时有何不同？这超出了 GCC 文档的范围，涉及操作系统知识。</li></ul><p><strong>在这个层次上，文档是你地图上的标注，但你需要自己去探索整个地形。</strong></p><h4 id=层次三掌握内部机制文档几乎无能为力>层次三：掌握“内部机制”（文档几乎无能为力）</h4><p>这是 GCC 开发者的领域。</p><ul><li><strong>编译器架构</strong>：GCC 的前端、中端（优化）、后端是如何工作的？</li><li><strong>中间表示（GIMPLE, RTL）</strong>：源代码是如何被转换成这些内部结构并进行优化的？</li><li><strong>机器描述（<code>.md</code>文件）</strong>：如何为一种新的CPU架构添加GCC支持？</li></ul><p><strong>对于这个层次，GCC 文档的作用很小，你需要去读源码、读专门的论文和书籍。</strong></p><hr><h3 id=那么如何才能真正掌握gcc实践路线图>那么，如何才能真正“掌握”GCC？（实践路线图）</h3><p>文档是核心，但必须配合其他方式：</p><ol><li><strong>将文档作为案头必备工具，不会就查</strong>。这是基础。</li><li><strong>从实践中带来问题，带着问题去读文档</strong>。这是最高效的方法。<ul><li>不要试图通读所有文档。而是当你遇到一个看不懂的警告、一个链接错误、一个性能问题时，<strong>主动去 <code>man gcc</code> 里搜索相关的选项</strong>。</li><li>例如，遇到 <code>undefined reference</code> 错误，就去查 <code>-l</code> 和 <code>-L</code>；发现程序调试不了，就去深入研究 <code>-g</code>；想知道两个优化级别的区别，就用 <code>gcc -Q -O2 --help=optimizers</code> 对比。</li></ul></li><li><strong>拆解编译过程，加深理解</strong>。<ul><li>使用 <code>-E</code>、<code>-S</code>、<code>-c</code> 选项<strong>手动执行每一步</strong>，并查看生成的 <code>.i</code>（预处理后）、<code>.s</code>（汇编）、<code>.o</code>（目标）文件内容。这是理解编译原理最直观的方式。</li></ul></li><li><strong>学习辅助工具</strong>。<ul><li><strong><code>objdump</code></strong>： 反汇编，看生成的实际代码。</li><li><strong><code>nm</code></strong>： 查看目标文件或库中的符号。</li><li><strong><code>readelf</code></strong>： 查看ELF格式文件的详细信息。</li><li><strong><code>strace</code></strong>： 跟踪GCC执行时调用了哪些系统调用和命令。</li><li>这些工具能帮你验证文档里的知识，并看到背后的真相。</li></ul></li><li><strong>阅读相关经典书籍</strong>。<ul><li>例如《深入理解计算机系统》（CS:APP）、《程序员的自我修养——链接、装载与库》等。它们会系统性地讲解GCC工具链背后的计算机原理。</li></ul></li></ol><p>GCC 只是一个“工具”，真正强大的是通过学习和使用它所建立的<strong>对整个软件构建过程、系统底层知识的深刻理解</strong></p></div><nav class=post-nav><a href=/unixlike/log/gc/ class=hover:underline>pre: gc</a>
<a href=/unixlike/log/gdb/ class=hover:underline>next: GDB</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#gcc工具链的安装>GCC工具链的安装</a></li></ul></li><li><a href=#gcc的编译过程>GCC的编译过程</a></li><li><a href=#常用gcc选项>常用GCC选项</a></li><li><a href=#示例>示例</a></li><li><a href=#gcc-and-g><code>gcc</code> and <code>g++</code></a><ul><li><a href=#实际建议>实际建议</a></li></ul></li><li><a href=#文档与帮助>文档与帮助</a><ul><li><a href=#方法一使用help选项最快捷>方法一：使用<code>help</code>选项（最快捷）</a></li><li><a href=#方法二使用man手册页最常用最详细>方法二：使用<code>man</code>手册页（最常用、最详细）</a></li><li><a href=#方法三使用info文档最完整最权威>方法三：使用<code>info</code>文档（最完整、最权威）</a></li><li><a href=#方法四在线查询官方文档>方法四：在线查询官方文档</a></li><li><a href=#方法五询问编译器本身-q---helpxxx>方法五：询问编译器本身（<code>-Q --help=xxx</code>）</a></li><li><a href=#实战技巧>实战技巧</a></li><li><a href=#关于文档和帮助>关于文档和帮助</a><ul><li><a href=#层次一掌握使用文档可以基本覆盖>层次一：掌握“使用”（文档可以基本覆盖）</a></li><li><a href=#层次二掌握原理与洞察文档是基础但需更多>层次二：掌握“原理与洞察”（文档是基础，但需更多）</a></li><li><a href=#层次三掌握内部机制文档几乎无能为力>层次三：掌握“内部机制”（文档几乎无能为力）</a></li></ul></li><li><a href=#那么如何才能真正掌握gcc实践路线图>那么，如何才能真正“掌握”GCC？（实践路线图）</a></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>