<!doctype html><html lang=en><head><meta charset=UTF-8><title>.git/</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/unixlike/>★</a></li><li><a href=/unixlike/lab/>Lab</a></li><li><a href=/unixlike/lib/>Lib</a></li><li><a href=/unixlike/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/system/ href=/system/>System</a>          |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |                                |
|                        /    |                                |
|                       /     |                                |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |                <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |                <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                          <a class=nav-item data-path=/csbasic/ href=/csbasic/>CSBasic</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>.git/<div class=meta>Modified: 2025-12-31
| Author：ljf12825</div></div><div class=content><h1 id=git>.git/</h1><p><code>.git/</code>是Git仓库的核心，包含了所有版本控制信息。它是一个隐藏的目录，位于每个Git仓库的根目录下<br>Git通过<code>.git/</code>来存储项目的历史记录、配置信息、分支信息等，是整个版本管理系统的核心，是整个Git系统的缩影<br>每次执行git命令，实际上都是在对<code>.git/</code>文件夹中的内容进行修改或读取</p><h2 id=主要目录结构>主要目录结构</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>.git/
</span></span><span style=display:flex><span>|__ HEAD 
</span></span><span style=display:flex><span>|__ config 
</span></span><span style=display:flex><span>|__ description 
</span></span><span style=display:flex><span>|__ COMMIT_EDITMSG 
</span></span><span style=display:flex><span>|__ FETCH_HEAD 
</span></span><span style=display:flex><span>|__ ORIG_HEAD 
</span></span><span style=display:flex><span>|__ MERGE_HEAD, MERGE_MODE, MERGE_MSG
</span></span><span style=display:flex><span>|__ index 
</span></span><span style=display:flex><span>|__ packed-refs 
</span></span><span style=display:flex><span>|__ hooks/ 
</span></span><span style=display:flex><span>|__ info/ 
</span></span><span style=display:flex><span>|__ logs/ 
</span></span><span style=display:flex><span>|__ objects/ 
</span></span><span style=display:flex><span>|__ refs/ 
</span></span><span style=display:flex><span>|__ rebase-apply/, rebase-merge/
</span></span><span style=display:flex><span>|__ branches/
</span></span><span style=display:flex><span>|__ worktrees/
</span></span></code></pre></div><h3 id=head>HEAD</h3><ul><li>作用：记录当前检出的分支的引用。这个文件指向当前分支或提交的对象（通常是<code>refs/heads/branch-name</code>或某个具体的提交哈希值）</li><li>用途：Git使用它来确定当前的工作状态，即当前在哪个分支或哪个提交上</li></ul><h4 id=基本概念>基本概念</h4><ul><li>HEAD是一个指针，指向当前检出的分支或者直接指向某个具体提交（commit）</li><li>可以把它理解为Git仓库当前“活跃状态”的代表：它告诉Git当前所在的分支或提交</li></ul><h4 id=head存储位置与内容>HEAD存储位置与内容</h4><p>HEAD是一个文本文件，位于<code>.git/HEAD</code>，内容通常有两种形式</p><h5 id=1-指向分支>1. 指向分支</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ref: refs/heads/master
</span></span></code></pre></div><ul><li><code>ref:</code>表示这是一个引用</li><li><code>refs/heads/master</code>表示当前检出的是<code>master</code>分支</li><li>Git会通过分支引用找到对应的最新提交</li></ul><h5 id=2-直接指向提交detached-head>2. 直接指向提交(Detached HEAD)</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>f4c3b00c8a6f9e5a2d3...
</span></span></code></pre></div><ul><li>HEAD指向一个具体的提交哈希值，而不是分支</li><li>这种状态下，对代码的修改不会影响任何分支，除非手动创建新分支或cherry-pick</li></ul><h4 id=head与分支的关系>HEAD与分支的关系</h4><ul><li>当HEAD指向分支时<ul><li>你所做的提交会更新分支引用</li><li>分支总是指向最新提交</li></ul></li><li>当HEAD是Detached（分离头指针）状态时<ul><li>提交不会更新任何分支</li><li>临时提交可以被丢弃，如果不创建分支保存，会被垃圾回收</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>HEAD -&gt; refs/heads/feature 
</span></span><span style=display:flex><span>feature -&gt; commit c 
</span></span></code></pre></div><p>当执行<code>git commit</code></p><ul><li>新提交C1产生</li><li>feature分支指针更新到C1</li><li>HEAD仍然指向feature分支</li></ul><p>如果是 detached HEAD</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>HEAD -&gt; commit B 
</span></span></code></pre></div><ul><li>新提交 C2 产生</li><li>HEAD指向C2,但没有分支引用跟随</li><li>如果没有新分支保存，C2将可能被丢弃</li></ul><h4 id=head的常用操作>HEAD的常用操作</h4><ol><li>切换分支</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout branch_name 
</span></span></code></pre></div><p>更新HEAD指向新的分支</p><ol start=2><li>临时切换到历史提交</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout &lt;commit_hash&gt; 
</span></span></code></pre></div><p>HEAD进入Detached状态</p><ol start=3><li>创建新分支并切换</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout -b new_branch 
</span></span></code></pre></div><p>HEAD指向新分支，分支指针初始化为当前提交</p><ol start=4><li>重置HEAD</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>git reset --hard HEAD~1
</span></span></code></pre></div><p>HEAD和当前分支指针一起退回一个提交，工作区和暂存区会同步更新（&ndash;hard）</p><h4 id=head与git内部机制的关系>HEAD与Git内部机制的关系</h4><p>HEAD决定了索引（index）和工作区的基准提交，当执行<code>git commit</code>，Git会</p><ul><li>找到HEAD指向的分支或提交</li><li>将index（暂存区）的内容生成新提交对象</li><li>更新HEAD所指向的分支引用（如果HEAD指向分支）</li></ul><p>HEAD是Git版本控制的入口点，所有diff, merge, reset等操作都是基于HEAD的状态来计算的</p><h3 id=config>config</h3><p><code>config</code>是<code>.git</code>里的“意识形态”文件，它决定了：这个仓库”怎么思考、怎么行动、遵守什么规则“<br><code>.git/config</code>是这个仓库的局部Git世界观，它不关心历史，不关心代码内容，只关心三件事：</p><ul><li>你是谁</li><li>你和远程仓库怎么相处</li><li>这个仓库有哪些“特例规则”</li></ul><h4 id=config在git配置体系里的位置>config在Git配置体系里的位置</h4><p>Git的配置是分层覆盖模型，不是单一文件</p><ul><li>system级（整台机器<code>/etc/gitconfig</code>）</li><li>global级（当前用户<code>~/.gitconfig</code>）</li><li>local级（当前仓库，也就是<code>.git/config</code>）</li></ul><p><code>.git/config</code>优先级最高<br>system -> global -> local 覆盖<br>这意味着：可以在同一台机器、同一个用户下，让不同仓库表现出完全不同的行为</p><h4 id=config的物理本质>config的物理本质</h4><p><code>.git/config</code>是一个INI风格的纯文本文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[section &#34;subsection&#34;]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>key</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>value</span>
</span></span></code></pre></div><p>Git内部不是“魔法”，就是字符串解析 + 查表</p><h4 id=config的核心模块>config的核心模块</h4><h5 id=core-git的基础行为><code>[core]</code>—— Git的基础行为</h5><p>这是Git的“操作系统参数”，core决定Git如何理解“文件系统现实”</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[core]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>repositoryformatversion</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>0
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    filemode = true
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    bare = false 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    ignorecase = false </span>
</span></span></code></pre></div><ul><li><p><code>filemode</code>
决定Git是否跟踪文件权限变化，在Linux下很重要</p></li><li><p><code>ignorecase</code>
在大小写敏感文件系统下必须是false</p></li><li><p><code>bare</code>
决定这个仓库有没有工作区，裸仓库（bare repo）就是靠这个标志存在的</p></li><li><p><code>repositoryformatversion</code>
定义仓库的格式版本，确保Git客户端能正确处理仓库数据</p><ul><li><code>version0</code>(默认值)<ul><li>最原始和最广泛兼容的格式</li><li>不支持扩展功能</li><li>所有现代Git版本都兼容</li></ul></li><li><code>version1</code>(添加扩展支持)<ul><li>添加了扩展机制，支持可选功能</li><li>允许向后兼容的扩展</li></ul></li></ul><p>当<code>repositoryformatversion = 1</code>时，可以启用以下扩展</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[extensions]</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 与提交钩子索引</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>precomposeunicode</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 部分克隆支持</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>partialclone</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>true </span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 提交图（commit-graph）</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>commit-graph</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 文件系统监视</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fsmonitor</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>true </span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 使用SHA-256进行哈希计算</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>objectFormat</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>sha256</span>
</span></span></code></pre></div><ul><li>常见使用场景<ul><li>新功能启用：某些Git功能（如commit-graph, fsmonitor）需要version1</li><li>仓库迁移：升级仓库格式以支持新特性</li><li>兼容性检查：确保Git客户端能正确处理仓库</li></ul></li><li>注意事项<ul><li>谨慎修改：通常不需要手动修改此值，Git会在必要时自动更新</li><li>向后兼容：高版本Git可以读取低版本仓库，但反过来不行</li><li>克隆影响：仓库格式版本会影响克隆和共享仓库的行为</li></ul></li></ul></li></ul><h4 id=user--提交的身份来源><code>[user]</code> —— 提交的身份来源</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[user]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>ljf12825
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    email = ljf12825@graingen.com </span>
</span></span></code></pre></div><p>关键不是“名字和邮箱”，而是</p><ul><li>提交对象（commit）永久写入</li><li>一旦进入历史，就不可更改（除非重写历史）</li></ul><p>这意味着：config不是配置，是历史的签名器</p><h4 id=remote--远程仓库定义><code>[remote]</code> —— 远程仓库定义</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[remote &#34;origin&#34;]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>git@github.com:xxx/yyy.git 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    fetch = +refs/heads/*:refs/remotes/origin/*</span>
</span></span></code></pre></div><p>这段东西解释了Git的一个底层事实：Git不存在“服务器”，只存在引用同步规则</p><p><code>fetch</code>这一行定义了</p><ul><li>远程那些ref</li><li>映射成本地哪些ref</li></ul><p>远程不是概念，是ref映射表</p><h4 id=branch--分支行为配置><code>[branch]</code> —— 分支行为配置</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[branch &#34;main&#34;]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>remote</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>origin 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    merge = refs/heads/main </span>
</span></span></code></pre></div><p>这解释了一个常被误解的点</p><p><code>git pull</code>并不是“魔法操作”，而是：</p><ul><li>fetch（由remote决定）</li><li>merge/rebase（由branch config决定）</li></ul><p>branch本身只是一个ref, branch config 才决定它“怎么长大”</p><h4 id=pullmergerebase><code>[pull]/[merge]/[rebase]</code></h4><p>控制<code>git pull</code>的默认策略，不修改历史数据，只修改操作方式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[pull]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rebase</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>true</span>
</span></span></code></pre></div><h4 id=alias><code>[alias]</code></h4><p>记录别名，只是命令展开，不影响Git内部逻辑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[alias]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>st</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>status 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    co = checkout </span>
</span></span></code></pre></div><h3 id=description>description</h3><p><code>.git/description</code>是一个“仓库描述字符串文件”<br>它的作用只有一个：给仓库本身提供一段简短说明，用于某些Git仓库浏览工具提示；它不参与任何Git行为</p><h4 id=文件本质>文件本质</h4><p>它是一个单行纯文本文件，比如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Unnamed repository; edit this file &#39;description&#39; to name the repository.
</span></span></code></pre></div><p>可以改成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>My personal compiler experiments
</span></span></code></pre></div><p>没有格式、没有语法、没有解析规则，就是原样读取</p><h4 id=使用场景>使用场景</h4><ol><li><p>GitWeb/cgit/老式仓库浏览器
通常显示在仓库列表页，仓库标题或简介位置</p></li><li><p>裸仓库(bare repository)里更常见
在bare repo中</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>project.git/
</span></span><span style=display:flex><span>|__ HEAD 
</span></span><span style=display:flex><span>|__ objects/
</span></span><span style=display:flex><span>|__ refs/
</span></span><span style=display:flex><span>|__ description
</span></span></code></pre></div><p>这种仓库没有工作区，也没有README给人看，<code>description</code>就成了“唯一的自我介绍”</p><h4 id=存在原因>存在原因</h4><p>历史原因：</p><ul><li>Git最早服务对象是<ul><li>内核开发</li><li>自建Git服务器</li><li>GitWeb</li></ul></li></ul><p>那个时代没有README预览，没有Web UI的仓库简介栏，<code>description</code>就是当年的“仓库简介字段”</p><h4 id=实用建议>实用建议</h4><ul><li><p>普通开发仓库
不用管，甚至可以忽略它的存在</p></li><li><p>裸仓库/自建Git服务
可以认真写一句话，方便列表页识别</p></li><li><p>公共仓库
用README,平台描述，不用<code>description</code></p></li></ul><h3 id=commit_editmsg>COMMIT_EDITMSG</h3><p>这个临时文件保存了在<code>git commit</code>操作过程中编辑的提交信息。每次提交时，Git会自动在这个文件中写入提交信息，直到提交完成</p><h4 id=内容>内容</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>fix parser bug
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- handle empty token
</span></span><span style=display:flex><span>- add boundary check
</span></span></code></pre></div><h4 id=出现时机>出现时机</h4><ul><li>执行<code>git commit</code>（不带<code>-m</code>）</li><li>Git启动编辑器前，把模板写进这个文件</li><li>保存并退出编辑器后：<ul><li>Git读取这个文件</li><li>生成commit对象</li><li>文件内容写入 commit message</li></ul></li></ul><h4 id=关键点>关键点</h4><p>它不是历史，它不是缓存，它只是“这一次commit的输入缓冲区“</p><p>提交完成后，文件通常还在，内容会被下次commit覆盖</p><h3 id=fetch_head>FETCH_HEAD</h3><ul><li>作用：这个文件记录了最后一次<code>git fetch</code>操作中拉取的远程分支信息。它包含了远程仓库分支的最新状态</li></ul><p>内容</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>a1b2c3d4 refs/heads/main from origin
</span></span></code></pre></div><p>在执行<code>git pull</code>(pull = fetch + merge/rebase)或<code>git merge</code>时，Git会参考这个文件</p><p>它记录了远程分支的最新提交，但不等于远程分支引用</p><ul><li><code>refs/remotes/origin/main</code> -> 持久的远程跟踪分支</li><li><code>FETCH_HEAD</code> -> 这一次fetch的临时结果</li></ul><h4 id=存在意义>存在意义</h4><p>因为Git支持这种操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch origin 
</span></span><span style=display:flex><span>git merge FETCH_HEAD
</span></span></code></pre></div><p>也就是说：FETCH_HEAD是”这次fetch的结果指针“</p><p>它有以下特点</p><ul><li>会被反复覆盖</li><li>不保证完整</li><li>不参与历史</li><li>是pull/merge的输入源</li></ul><h3 id=orig_head>ORIG_HEAD</h3><p>Git在执行可能改变历史的操作：</p><ul><li><code>git reset</code></li><li><code>git merge</code></li><li><code>git rebase</code></li><li><code>git pull</code>（部分情况）</li></ul><p>会将之前的<code>HEAD</code>记录在<code>ORIG_HEAD</code>中，作为回滚点；提供一个回滚的机会，允许恢复到执行该操作之前的状态</p><p>示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>git reset --hard HEAD~3
</span></span><span style=display:flex><span><span style=color:#75715e># 回退错误</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>git reset --hard ORIG_HEAD
</span></span></code></pre></div><p>只要ORIG_HEAD还在，就能回去</p><h3 id=merge_head-merge_mode-merge_msg>MERGE_HEAD, MERGE_MODE, MERGE_MSG</h3><p>这三个文件都属于合并过程中的“临时状态文件”<br>特点：</p><ul><li>只在merge进行中存在</li><li>合并完成或中止后删除</li><li>不进入历史</li><li>不参与对象存储</li></ul><p>它们的存在目的只有一个：让一次“多阶段”的merge操作可以被中断、恢复、继续</p><h4 id=merge_head><code>MERGE_HEAD</code></h4><p>当前正在被合并进来的提交（或多个提交）的SHA-1列表，octopus merge（多分支合并）时可能有多行</p><h5 id=存在意义-1>存在意义</h5><p>合并不是一个原子操作</p><ol><li>切换index</li><li>尝试自动合并</li><li>可能发生冲突</li><li>等待解决冲突</li><li>再创建merge commit</li></ol><p>Git必须记住：“我原本是打算把谁合进来”，<code>MERGE_HEAD</code>就是这个答案</p><h5 id=写入时机>写入时机</h5><ul><li>执行<code>git merge &lt;other-branch></code></li><li>在真正生成commit之前</li><li>且merge尚未完成</li></ul><h5 id=使用方式>使用方式</h5><p>当解决冲突后执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>git commit 
</span></span></code></pre></div><p>Git会</p><ul><li>读取<code>MERGE_HEAD</code></li><li>把里面的commit hash 作为第二父提交</li><li>生成merge commit</li></ul><h4 id=merge_mode><code>MERGE_MODE</code></h4><p>记录当前merge的模式（strategy flags）</p><h5 id=存在意义-2>存在意义</h5><p>Git的merge有多种行为</p><ul><li>fast-forward</li><li>no-ff</li><li>squash</li><li>不同 strategy（recursive, ort等）</li></ul><p>一旦merge被中断（冲突），Git必须记住“当初你打算怎么合”，<code>MERGE_MODE</code>就是保存这个决策的</p><h5 id=示例>示例</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>git merge --no-ff feature
</span></span></code></pre></div><p>如果发生冲突：</p><ul><li><code>MERGE_MODE</code>=<code>no-ff</code></li><li>解决冲突后继续commit</li><li>Git仍然按no-ff生成merge commit</li></ul><h5 id=注意>注意</h5><p>不是所有merge都会有这个文件，只有在需要保留策略语义时才会写入</p><h4 id=merge_msg><code>MERGE_MSG</code></h4><p>合并提交的默认提交信息草稿</p><h5 id=生成时间>生成时间</h5><ul><li>merge开始时</li><li>在commit尚未发生之前</li></ul><h5 id=作用>作用</h5><p>当执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>git commit 
</span></span></code></pre></div><p>如果检测到<code>MERGE_HEAD</code>存在，且没有指定<code>-m</code>，Git会读取<code>MERGE_MSG</code>，作为commit message初始内容</p><h4 id=三者如何协同工作>三者如何协同工作</h4><p>以一次有冲突的merge为例</p><ol><li><code>git merge feature</code></li><li>Git写入<ul><li><code>MERGE_HEAD</code></li><li><code>MERGE_MODE</code></li><li><code>MERGE_MSG</code></li></ul></li><li>自动合并失败，停下来</li><li>解决冲突，<code>git add</code></li><li>执行<code>git commit</code></li><li>Git:<ul><li>读取<code>MERGE_HEAD</code> -> 父提交</li><li>读取<code>MERGE_MODE</code> -> 决定提交形态</li><li>读取<code>MERGE_MSG</code> -> 充填message</li></ul></li><li>生成merge commit</li><li>删除这三个文件</li></ol><h3 id=index>index</h3><p><code>.git/index</code>是Git的暂存区数据库文件，是下一次提交(commit)将要使用的文件状态表，它是Git三态模型里的“中间态”</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>HEAD(上一次提交) -&gt; index（下一次提交）-&gt; working tree（工作区）
</span></span></code></pre></div><h4 id=物理形态>物理形态</h4><ul><li>路径<code>.git/index</code></li><li>类型：二进制文件</li><li>由Git直接读写，人工不可编辑</li><li>格式有版本（v2/v3/v4）</li></ul><p>可以用命令查看逻辑内容</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>git ls-files --stage 
</span></span></code></pre></div><h4 id=index文件内部结构>index文件内部结构</h4><p><code>.git/index</code>并不是一个简单的列表，它是一个结构化的二进制文件，大致由以下部分组成</p><h5 id=header>Header</h5><ul><li>magic：<code>DIRC</code></li><li>version：2/3/4</li><li>entry count：条目数量</li></ul><h5 id=entry>Entry</h5><p>每一个被跟踪的文件，对应一个entry，每个entry记录</p><ul><li>文件路径</li><li>文件模式（100644/100755/120000）</li><li>对应的blob对象hash</li><li>文件大小</li><li>时间戳（ctime/mtime）</li><li>stage（0-3，用于merge）</li></ul><blockquote><p>index里存的是“路径 -> blob”的映射</p></blockquote><h5 id=extensions>Extensions</h5><p>用于性能优化和高级功能</p><ul><li>cache-tree（加速tree构建）</li><li>resolve-undo（merge冲突回退）</li><li>fsmonitor</li><li>sparse-checkout</li></ul><p>这些扩展让index即是数据表，又是状态机</p><h5 id=checksum>Checksum</h5><ul><li>整个index文件的SHA-1</li><li>用于一致性校验</li></ul><h4 id=stage的真实含义>stage的真实含义</h4><p>index支持同一路径多条记录，靠stage区分</p><table><thead><tr><th>stage</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>正常文件</td></tr><tr><td>1</td><td>merge base</td></tr><tr><td>2</td><td>ours</td></tr><tr><td>3</td><td>theirs</td></tr></tbody></table><p>这就是Git能“暂停在冲突中”的根本原因</p><h4 id=核心命令如何操作gitindex>核心命令如何操作<code>.git/index</code></h4><h5 id=git-add><code>git add</code></h5><p>内部流程</p><ol><li>读取工作区文件</li><li>写入blob对象</li><li>更新index中该路径的entry</li></ol><p>如果多次add</p><ul><li>后一次直接覆盖前一次entry</li></ul><h5 id=git-commit><code>git commit</code></h5><ol><li>读取 index</li><li>按路径构建tree对象</li><li>tree + parent + message -> commit</li></ol><p>commit 只看 index,不看working tree</p><h5 id=git-reset><code>git reset</code></h5><ul><li><code>--soft</code>：不碰index</li><li><code>--mixed</code>：HEAD -> index</li><li><code>--hard</code>：HEAD -> index -> working tree</li></ul><h5 id=git-checkout><code>git checkout</code></h5><ul><li>checkout 分支<ul><li>tree -> index -> working tree</li></ul></li><li>checkout 文件<ul><li>index -> working tree</li></ul></li></ul><h4 id=index存在意义>index存在意义</h4><p>没有index会发生什么</p><ul><li>不能分批提交</li><li>不能部分add</li><li>merge冲突无法建模</li><li>commit必须直接基于working tree</li></ul><p>index的本质是：把历史构建与工作修改解耦</p><h4 id=index与性能的关系>index与性能的关系</h4><p>index不是简单表，而是高度优化的数据结构</p><ul><li>路径排序</li><li>哈希加速</li><li>cache-tree</li><li>fsmonitor</li></ul><p>这也是Git在超大仓库下仍然可用的原因之一</p><h3 id=packed-refs>packed-refs</h3><p><code>.git/packed-refs</code>是Git的“引用压缩表”<br>它存储的是大量refs（分支、标签等） -> commit hash的集中映射<br>本质上，它是对<code>.git/refs/</code>目录树的一个只读快照优化</p><h4 id=存在意义-3>存在意义</h4><p>早期的Git每个ref一个文件，ref数量一多，文件操作成本极高，<code>stat/open</code>成为瓶颈<br>解决方案：把大量ref打包成一个文件，减少inode和系统调用，这就是<code>packed-refs</code></p><h4 id=packed-refs生成时机><code>packed-refs</code>生成时机</h4><p>它不是实时更新的，而是在这些场景生成或更新</p><ul><li><code>git pack-refs</code></li><li><code>git gc</code></li><li>某些fetch/prune操作</li><li>ref数量达到阈值</li></ul><p>生成后：</p><ul><li>原来的ref文件可能被删除</li><li>也可能和loose refs混合存在</li></ul><h4 id=文件格式>文件格式</h4><p><code>packed-refs</code>是纯文本文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span># pack-refs with: peeled fully-peeled
</span></span><span style=display:flex><span>a1b2c3d4e5f6 refs/tags/v1.0
</span></span><span style=display:flex><span>^b7c8d9e0f1a2
</span></span><span style=display:flex><span>c3d4e5f6a1b2 refs/heads/main
</span></span></code></pre></div><h5 id=注释行>注释行</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span># pack-refs with: peeled fully-peeled
</span></span></code></pre></div><ul><li>已包含tag的peeled（解引用）结果</li></ul><h5 id=普通ref行>普通ref行</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>&lt;hash&gt; &lt;refname&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>c3d4e5f6a1b2 refs/heads/main
</span></span></code></pre></div><ul><li><code>main</code>分支指向该commit</li></ul><h5 id=行annotated-tag><code>^</code>行（annotated tag）</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>a1b2c3... refs/tags/v1.0
</span></span><span style=display:flex><span>^deadbeef...
</span></span></code></pre></div><ul><li>第一行：tag对象</li><li><code>^</code>行：tag最终指向的commit</li></ul><p>这是为了避免反复解引用tag</p><h4 id=loose-refs-vs-packed-refs>loose refs vs packed refs</h4><p>Git同时支持两种形式</p><p>loose refs</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>.git/refs/heads/main 
</span></span></code></pre></div><ul><li>一个 ref一个文件</li><li>适合频繁修改</li></ul><p>packed refs</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>.git/packed-refs
</span></span></code></pre></div><ul><li>集中存储</li><li>只读</li><li>适合大量、稳定refs</li></ul><p>Git查找顺序：先查loose refs,再查packed-refs；loose ref会覆盖packed ref</p><h4 id=为什么packed-refs是只读的>为什么packed-refs是只读的</h4><p>改写一个ref != 改写一行文本，需要原子性、锁、并发安全<br>所有Git的策略是：更新ref -> 写loose ref，定期 -> 打包进packed-refs<br>这保证了：正确性，性能，并发安全</p><h4 id=packed-refs不存什么>packed-refs不存什么</h4><p>不存HEAD, 不存index,不存reflog,不存remote配置，它只存ref -> object的最终映射</p><h3 id=hooks>hooks/</h3><p>见<code>./Hooks.md</code></p><h3 id=info>info/</h3><p><code>info/</code>用来存放“只对当前仓库生效，但不进入版本控制”的辅助配置与规则</p><ul><li>不污染提交历史</li><li>不影响远端</li><li>不影响其他clone</li><li>只影响当前working tree 的Git行为</li></ul><h4 id=info中的内容><code>info/</code>中的内容</h4><p>默认情况下，<code>info/</code>目录很小，甚至可能只有一个文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>.git/info/
</span></span><span style=display:flex><span>└── exclude
</span></span></code></pre></div><p>以及在特定功能开启时</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>.git/info/
</span></span><span style=display:flex><span>├── exclude
</span></span><span style=display:flex><span>└── sparse-checkout
</span></span></code></pre></div><h4 id=gitinfoexclude><code>.git/info/exclude</code></h4><p>这是<code>info/</code>目录最核心、最常见的文件<br>它是仓库级<code>.gitignore</code>，但不参与版本控制，语义完全等价于<code>.gitignore</code>，但作用域不同</p><p>Git忽略规则的优先级顺序是</p><ol><li><code>.git/info/exclude</code>（最高）</li><li><code>.gitignore</code>（项目内）</li><li>全局ignore（<code>~/.config/git/ignore</code>）</li></ol><h5 id=典型使用场景>典型使用场景</h5><ul><li>本地IDE配置</li><li>临时生成文件</li><li>私有测试脚本</li><li>本地调试产物</li></ul><p>而你不想</p><ul><li>提交</li><li>修改<code>.gitignore</code></li><li>影响团队</li></ul><h4 id=gitinfosparse-checkout><code>.git/info/sparse-checkout</code></h4><p>当启用sparse checkout时，Git会用到这个文件<br>它描述working tree中“哪些路径需要被检出”<br>Git根据<code>info/sparse-checkout</code>动态构造index的可见子集，其他路径在工作区消失</p><blockquote><p>info/是escape hatch，是为极端/高级用户准备的，不鼓励团队依赖</p></blockquote><h3 id=logs>logs/</h3><p>logs/记录的是引用（refs）如何随时间变化的历史，它是reflog的物理存储</p><h4 id=logs的目录结构><code>logs/</code>的目录结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>.git/logs/
</span></span><span style=display:flex><span>├── HEAD
</span></span><span style=display:flex><span>└── refs/
</span></span><span style=display:flex><span>    ├── heads/
</span></span><span style=display:flex><span>    │   ├── main
</span></span><span style=display:flex><span>    │   └── dev
</span></span><span style=display:flex><span>    └── remotes/
</span></span><span style=display:flex><span>        └── origin/
</span></span><span style=display:flex><span>            └── main
</span></span></code></pre></div><ul><li><code>logs/HEAD</code>：HEAD的移动历史</li><li><code>logs/refs/...</code>：每个ref的移动历史</li></ul><p>详见<code>reflog.md</code></p><h3 id=objects>objects/</h3><p>Git是一个内容寻址的对象数据库，<code>objects/</code>就是这个数据库本身，存储了仓库中的所有对象（提交对象、树对象、文件对象等）;每次提交、合并等操作时，Git会将提交和文件的内容以对象形式存储在这个目录中，使用SHA-1哈希值唯一标识每个对象<br>它存储的是Git的四种基础对象</p><ol><li>blob —— 文件内容</li><li>tree —— 目录结构</li><li>commit —— 一次快照 + 元信息</li><li>tag —— 对某个对象的命名与注释</li></ol><h4 id=git对象的共同特征>Git对象的共同特征</h4><p>所有Git对象都满足</p><ol><li>不可变（immutable）</li><li>内容寻址（content-addressed）</li><li>压缩存储（zlib）</li><li>无类型引用关系（靠hash连接）</li></ol><p>Git不关心名字，只关心内容</p><h4 id=对象的真实物理格式>对象的真实物理格式</h4><p>一个Git对象在写入磁盘前，会先变成这样</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>&#34;&lt;type&gt; &lt;size&gt;\0&lt;content&gt;&#34;
</span></span></code></pre></div><p>然后</p><ul><li>计算hash</li><li>zlib压缩</li><li>写入<code>.git/objects/</code></li></ul><p>示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>blob 14\0Hello, world!\n 
</span></span></code></pre></div><p>hash对应的文件名完全由内容决定</p><h4 id=blob>blob</h4><ul><li>只存文件内容</li><li>不存文件名</li><li>不存权限（部分）</li></ul><p>同一个内容在不同路径，不同文件名，只存一次；这是Git高效的根本原因之一</p><h4 id=tree>tree</h4><p>tree对象存的是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>&lt;mode&gt; &lt;name&gt;\0&lt;hash&gt;
</span></span></code></pre></div><p>例如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>100644 main.c\0&lt;blob-hash&gt; 
</span></span><span style=display:flex><span>040000 src\0&lt;tree-hash&gt;
</span></span></code></pre></div><p>tree = 目录快照</p><h4 id=commit>commit</h4><p>commit对象包含</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>tree &lt;tree-hash&gt; 
</span></span><span style=display:flex><span>parent &lt;parent-hash&gt; 
</span></span><span style=display:flex><span>author ...
</span></span><span style=display:flex><span>committer ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commit message 
</span></span></code></pre></div><ul><li>commit 不直接指向文件，commit -> tree -> blob</li></ul><h4 id=tag>tag</h4><p>轻量tag不是对象，只是ref<br>annotated tag本身也是对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>object &lt;hash&gt;
</span></span><span style=display:flex><span>type commit 
</span></span><span style=display:flex><span>tag v1.0 
</span></span><span style=display:flex><span>tagger ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>message 
</span></span></code></pre></div><h4 id=目录结构>目录结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>.git/objects/
</span></span><span style=display:flex><span>├── info/
</span></span><span style=display:flex><span>├── pack/
</span></span><span style=display:flex><span>├── ab/
</span></span><span style=display:flex><span>│   └── cdef1234...
</span></span><span style=display:flex><span>├── 9f/
</span></span><span style=display:flex><span>│   └── 01ab5678...
</span></span></code></pre></div><p>规则</p><ul><li>对象按SHA-1/SHA-256哈希分片存储</li><li>前2位作为目录名</li><li>后面作为文件名</li></ul><p>这是为了避免单目录下文件过多</p><h5 id=objectsinfo><code>objects/info/</code></h5><p>用途很小，历史遗留</p><ul><li><code>alternates</code></li><li><code>commit-graph</code>（新Git）</li></ul><p>用于跨仓库共享对象，优化遍历</p><h5 id=objectspack><code>objects/pack</code></h5><p>当loose objects 太多</p><ul><li>Git会进行pack</li><li>合并成<code>.pack</code>文件</li><li>生成<code>.idx</code>索引</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>.git/objects/pack/
</span></span><span style=display:flex><span>├── pack-xxxx.pack
</span></span><span style=display:flex><span>└── pack-xxxx.idx
</span></span></code></pre></div><p>这就是Git能处理百万级对象的关键</p><h6 id=loose-objects-vs-packed-objects>loose objects vs packed objects</h6><table><thead><tr><th>类型</th><th>loose</th><th>pack</th></tr></thead><tbody><tr><td>存储</td><td>单文件</td><td>聚合</td></tr><tr><td>修改</td><td>快</td><td>满</td></tr><tr><td>查找</td><td>慢</td><td>快</td></tr><tr><td>数量</td><td>少</td><td>多</td></tr></tbody></table><p>Git的策略：写 -> loose, 稳定 -> pack</p><h5 id=gc与objects>GC与objects</h5><p>Git判断一个对象是否该删除</p><ul><li>是否可达</li><li>从哪些ref/reflog出发可达</li></ul><p>不可达对象</p><ul><li>进入“宽限期”</li><li>最终被<code>git gc</code>删除</li></ul><h3 id=refs>refs/</h3><p>存储Git的引用（refs）</p><ul><li><code>heads/</code>：本地分支的引用</li><li><code>tags</code>：标签的引用</li><li><code>remotes</code>：远程仓库分支的引用</li></ul><p>是对Git对象的命名，是对 人类可读名称 -> 不可变对象hash 的映射</p><h4 id=refs内容>refs内容</h4><p>一个ref文件的内容极其简单</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>&lt;40-byte hash&gt;\n 
</span></span></code></pre></div><p>例如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>a1b2c3d4e5f6...
</span></span></code></pre></div><p>含义：这个名字当前指向哪个对象（通常是commit）</p><h4 id=refs目录结构>refs/目录结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>.git/refs/
</span></span><span style=display:flex><span>├── heads/
</span></span><span style=display:flex><span>│   ├── main
</span></span><span style=display:flex><span>│   └── dev
</span></span><span style=display:flex><span>├── tags/
</span></span><span style=display:flex><span>│   └── v1.0
</span></span><span style=display:flex><span>└── remotes/
</span></span><span style=display:flex><span>    └── origin/
</span></span><span style=display:flex><span>        └── main
</span></span></code></pre></div><h4 id=三类核心refs>三类核心refs</h4><ol><li><code>refs/heads/*</code>：本地分支<ul><li>可读可写</li><li>会随着commit/reset移动</li><li>HEAD通常指向这里</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>refs/heads/main 
</span></span></code></pre></div><ol start=2><li><code>refs/tags/*</code>：标签
轻量标签</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>refs/tags/v1.0 -&gt; commit hash 
</span></span></code></pre></div><p>只是ref,没有对象</p><p>注释标签</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>refs/tags/v1.0 -&gt; tag object -&gt; commit 
</span></span></code></pre></div><ol start=3><li><code>refs/remotes/*</code>：远端跟踪分支
只读语义（不能直接commit），由fetch更新，表示上次看到的远端的状态</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>refs/remotes/origin/main 
</span></span></code></pre></div><h4 id=head与refs的关系>HEAD与refs的关系</h4><p>HEAD不是ref本身，但是ref的入口</p><ol><li>正常状态（symbolic ref）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>HEAD -&gt; refs/heads/main 
</span></span></code></pre></div><p>HEAD文件内容</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ref: refs/heads/main 
</span></span></code></pre></div><ol start=2><li>detached HEAD</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>HEAD -&gt; commit hash 
</span></span></code></pre></div><p>此时</p><ul><li>不指向refs</li><li>commit 不会被任何分支自动引用</li></ul><h4 id=symbolic-ref符号引用>symbolic ref（符号引用）</h4><p>一些ref不存hash,而是指向另一个ref，例如HEAD<br>这类ref本身不是状态，只是转发，Git内部称之为symbolic ref</p><h4 id=refs的写入协议非常关键>refs的写入协议（非常关键）</h4><p>Git更新ref时不是直接写文件，会进行如下流程</p><ol><li>写<code>.lock</code>文件</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>refs/heads/main.lock 
</span></span></code></pre></div><ol start=2><li>fsync</li><li>原子<code>rename</code></li><li>删除lock</li></ol><p>保证</p><ul><li>崩溃安全</li><li>并发安全</li><li>不出现半写状态</li></ul><h3 id=rebase-apply-rebase-merge>rebase-apply/, rebase-merge/</h3><p><code>rebase-apply</code>和<code>rebase-merge</code>是Git在rebase过程中用于保存“执行进度、上下文和中间态”的临时目录</p><ul><li><code>rebase-apply</code>：基于patch apply的rebase（早期/简单）</li><li>rebase-merge：基于merge machinery的rebase（现代/默认）</li></ul><h4 id=rebase目录存在意义>rebase目录存在意义</h4><p>rebase本质做的是：取出一串commit -> 按顺序“重放”到新的base上 -> 生成一串新commit<br>这是一个多步、可中断、可恢复的过程，所以Git必须</p><ul><li>记住做到第几步</li><li>保存原始commit信息</li><li>保存当前冲突状态</li><li>能<code>--continue / --abort / --skip</code></li></ul><p>这些信息就落在<code>.git/rebase-*</code>里</p><h4 id=rebase-applyapply模式><code>rebase-apply</code>（apply模式）</h4><h5 id=使用场景-1>使用场景</h5><p>触发条件之一</p><ul><li>旧版本Git</li><li><code>git rebase --apply</code></li><li>使用<code>git am</code>风格的重做</li></ul><p>核心机制：把commit转成patch,然后apply</p><h5 id=目录结构-1>目录结构</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>.git/rebase-apply/
</span></span><span style=display:flex><span>├── apply-opt
</span></span><span style=display:flex><span>├── next
</span></span><span style=display:flex><span>├── last
</span></span><span style=display:flex><span>├── head-name
</span></span><span style=display:flex><span>├── orig-head
</span></span><span style=display:flex><span>├── patch
</span></span><span style=display:flex><span>├── message
</span></span><span style=display:flex><span>└── abort-safety
</span></span></code></pre></div><ul><li><code>patch</code>：当前正在apply的patch</li><li><code>next</code>/<code>last</code>：当前第几个patch/总patch数</li><li><code>orig-head</code>：rebase前HEAD</li><li><code>head-name</code>：原分支名</li><li><code>message</code>：commit message草稿</li></ul><h5 id=apply模式的局限>apply模式的局限</h5><ul><li>基于diff,语义弱</li><li>冲突处理能力有限</li><li>对rename.binary支持差</li></ul><p>所以现在很少单独使用</p><h4 id=rebase-mergemerge模式主流><code>rebase-merge</code>（merge模式，主流）</h4><h5 id=使用场景-2>使用场景</h5><ul><li>现代Git默认</li><li><code>git rebase -i</code></li><li>需要处理复杂历史、交互式操作</li></ul><p>核心机制：用merge machinery 重放每个commit</p><h5 id=目录结构-2>目录结构</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>.git/rebase-merge/
</span></span><span style=display:flex><span>├── git-rebase-todo
</span></span><span style=display:flex><span>├── git-rebase-todo.backup
</span></span><span style=display:flex><span>├── done
</span></span><span style=display:flex><span>├── msgnum
</span></span><span style=display:flex><span>├── end
</span></span><span style=display:flex><span>├── orig-head
</span></span><span style=display:flex><span>├── head-name
</span></span><span style=display:flex><span>├── onto
</span></span><span style=display:flex><span>├── message
</span></span><span style=display:flex><span>├── author-script
</span></span><span style=display:flex><span>└── stopped-sha
</span></span></code></pre></div><ul><li><code>git-rebase-todo</code>：rebase的“执行脚本”</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>pick a1b2c3 commit message
</span></span><span style=display:flex><span>reword d4e5f6 another commit
</span></span><span style=display:flex><span>squash ...
</span></span></code></pre></div><p>这是rebase的程序本身</p><ul><li><code>done</code>：已经执行完成的步骤</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>pick a1b2c3 ...
</span></span></code></pre></div><ul><li><p><code>msgnum</code>/<code>end</code></p><ul><li>当前执行到几步</li><li>总步数</li></ul></li><li><p><code>onto</code>：rebase的目标base commit</p></li><li><p><code>orig-head</code>：开始前HEAD</p></li><li><p><code>head-name</code>：原分支名（symbolic ref）</p></li><li><p><code>stopped-sha</code>：当冲突发生时，记录当前commit，用于<code>--continue</code></p></li><li><p><code>author-script</code>：在重写commit时恢复作者信息</p></li><li></li></ul><h3 id=branches>branches/</h3><p><code>.git/branches/</code>是一个几乎已经被废弃的历史遗留目录<br>在现代Git中</p><ul><li>它默认不存在</li><li>即使存在，也不参与核心流程</li><li>真正的分支早已全部由<code>refs/heads/*</code>管理</li></ul><h4 id=历史定位>历史定位</h4><p>这是Git非常早期（pre-1.5时代）的设计产物<br>当时Git还没有现在这种</p><ul><li>清晰的refs命名空间</li><li>完整的remote tracking分支体系</li></ul><p>于是引入了<code>.git/branches/</code>，用于存放分支对应的远端信息</p><h4 id=gitbranches作用><code>.git/branches/</code>作用</h4><p>在早期Git中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>.git/branch/&lt;branch-name&gt; 
</span></span></code></pre></div><p>文件内容通常是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>&lt;remote-repo-URL&gt;
</span></span></code></pre></div><p>含义是：这个本地分支，默认对应哪个远端仓库</p><p>也就是说</p><ul><li>它不存commit hash</li><li>也不是分支指针</li><li>而是pull/push的隐式配置</li></ul><h4 id=淘汰原因>淘汰原因</h4><p>随着Git演进，几个关键变化出现了</p><ol><li>引入了完整的<code>refs/remotes</code>
远端分支有了明确位置</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>refs/remotes/origin/main 
</span></span></code></pre></div><ol start=2><li>引入了<code>branch.&lt;name>.*</code>配置</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[branch &#34;main&#34;]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>remote</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>origin 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    merge = refs/heads/main </span>
</span></span></code></pre></div><p>这些信息被统一收敛到<code>.git/config</code></p><ol start=3><li>配置与数据彻底分离
Git的成熟架构是</li></ol><ul><li>数据 -> <code>object</code></li><li>引用 -> <code>refs</code></li><li>策略/行为 -> <code>config</code></li></ul><p><code>.git/branches</code> 明显不符合这一分层</p><p>在现代Git中，<code>.git/branches/</code>仍保留兼容读取逻辑，但优先级非常低，仅用于支持非常老的仓库格式，几乎不可能在新仓库里看到它</p><h3 id=worktrees>worktrees/</h3><ul><li>作用<ul><li>当使用Git工作树（git worktrees）功能时，这个目录会出现</li><li>它记录了当前仓库关联的额外工作树信息</li><li>工作树允许你在同一个Git仓库中，创建多个独立的工作目录，每个工作目录可以检出不同的分支，而不干扰主工作目录</li></ul></li><li>典型内容<ul><li>每个子目录对应一个附加工作树，包含<ul><li>关联的分支名称</li><li>HEAD指针</li><li>工作树路径</li></ul></li></ul></li><li>用途示例</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 添加一个新的工作树</span>
</span></span><span style=display:flex><span>git worktree add ../feature-branch feature 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看当前仓库的所有工作树</span>
</span></span><span style=display:flex><span>git worktree list 
</span></span></code></pre></div><p>上面的命令会在<code>git/worktrees</code>下生成记录信息，Git会通过这些信息管理多个工作树的状态</p></div><nav class=post-nav><a href=/unixlike/lib/add/ class=hover:underline>next: add</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><a href=#git>.git/</a><ul><li><a href=#主要目录结构>主要目录结构</a><ul><li><a href=#head>HEAD</a><ul><li><a href=#基本概念>基本概念</a></li><li><a href=#head存储位置与内容>HEAD存储位置与内容</a><ul><li><a href=#1-指向分支>1. 指向分支</a></li><li><a href=#2-直接指向提交detached-head>2. 直接指向提交(Detached HEAD)</a></li></ul></li><li><a href=#head与分支的关系>HEAD与分支的关系</a></li><li><a href=#head的常用操作>HEAD的常用操作</a></li><li><a href=#head与git内部机制的关系>HEAD与Git内部机制的关系</a></li></ul></li><li><a href=#config>config</a><ul><li><a href=#config在git配置体系里的位置>config在Git配置体系里的位置</a></li><li><a href=#config的物理本质>config的物理本质</a></li><li><a href=#config的核心模块>config的核心模块</a><ul><li><a href=#core-git的基础行为><code>[core]</code>—— Git的基础行为</a></li></ul></li><li><a href=#user--提交的身份来源><code>[user]</code> —— 提交的身份来源</a></li><li><a href=#remote--远程仓库定义><code>[remote]</code> —— 远程仓库定义</a></li><li><a href=#branch--分支行为配置><code>[branch]</code> —— 分支行为配置</a></li><li><a href=#pullmergerebase><code>[pull]/[merge]/[rebase]</code></a></li><li><a href=#alias><code>[alias]</code></a></li></ul></li><li><a href=#description>description</a><ul><li><a href=#文件本质>文件本质</a></li><li><a href=#使用场景>使用场景</a></li><li><a href=#存在原因>存在原因</a></li><li><a href=#实用建议>实用建议</a></li></ul></li><li><a href=#commit_editmsg>COMMIT_EDITMSG</a><ul><li><a href=#内容>内容</a></li><li><a href=#出现时机>出现时机</a></li><li><a href=#关键点>关键点</a></li></ul></li><li><a href=#fetch_head>FETCH_HEAD</a><ul><li><a href=#存在意义>存在意义</a></li></ul></li><li><a href=#orig_head>ORIG_HEAD</a></li><li><a href=#merge_head-merge_mode-merge_msg>MERGE_HEAD, MERGE_MODE, MERGE_MSG</a><ul><li><a href=#merge_head><code>MERGE_HEAD</code></a><ul><li><a href=#存在意义-1>存在意义</a></li><li><a href=#写入时机>写入时机</a></li><li><a href=#使用方式>使用方式</a></li></ul></li><li><a href=#merge_mode><code>MERGE_MODE</code></a><ul><li><a href=#存在意义-2>存在意义</a></li><li><a href=#示例>示例</a></li><li><a href=#注意>注意</a></li></ul></li><li><a href=#merge_msg><code>MERGE_MSG</code></a><ul><li><a href=#生成时间>生成时间</a></li><li><a href=#作用>作用</a></li></ul></li><li><a href=#三者如何协同工作>三者如何协同工作</a></li></ul></li><li><a href=#index>index</a><ul><li><a href=#物理形态>物理形态</a></li><li><a href=#index文件内部结构>index文件内部结构</a><ul><li><a href=#header>Header</a></li><li><a href=#entry>Entry</a></li><li><a href=#extensions>Extensions</a></li><li><a href=#checksum>Checksum</a></li></ul></li><li><a href=#stage的真实含义>stage的真实含义</a></li><li><a href=#核心命令如何操作gitindex>核心命令如何操作<code>.git/index</code></a><ul><li><a href=#git-add><code>git add</code></a></li><li><a href=#git-commit><code>git commit</code></a></li><li><a href=#git-reset><code>git reset</code></a></li><li><a href=#git-checkout><code>git checkout</code></a></li></ul></li><li><a href=#index存在意义>index存在意义</a></li><li><a href=#index与性能的关系>index与性能的关系</a></li></ul></li><li><a href=#packed-refs>packed-refs</a><ul><li><a href=#存在意义-3>存在意义</a></li><li><a href=#packed-refs生成时机><code>packed-refs</code>生成时机</a></li><li><a href=#文件格式>文件格式</a><ul><li><a href=#注释行>注释行</a></li><li><a href=#普通ref行>普通ref行</a></li><li><a href=#行annotated-tag><code>^</code>行（annotated tag）</a></li></ul></li><li><a href=#loose-refs-vs-packed-refs>loose refs vs packed refs</a></li><li><a href=#为什么packed-refs是只读的>为什么packed-refs是只读的</a></li><li><a href=#packed-refs不存什么>packed-refs不存什么</a></li></ul></li><li><a href=#hooks>hooks/</a></li><li><a href=#info>info/</a><ul><li><a href=#info中的内容><code>info/</code>中的内容</a></li><li><a href=#gitinfoexclude><code>.git/info/exclude</code></a><ul><li><a href=#典型使用场景>典型使用场景</a></li></ul></li><li><a href=#gitinfosparse-checkout><code>.git/info/sparse-checkout</code></a></li></ul></li><li><a href=#logs>logs/</a><ul><li><a href=#logs的目录结构><code>logs/</code>的目录结构</a></li></ul></li><li><a href=#objects>objects/</a><ul><li><a href=#git对象的共同特征>Git对象的共同特征</a></li><li><a href=#对象的真实物理格式>对象的真实物理格式</a></li><li><a href=#blob>blob</a></li><li><a href=#tree>tree</a></li><li><a href=#commit>commit</a></li><li><a href=#tag>tag</a></li><li><a href=#目录结构>目录结构</a><ul><li><a href=#objectsinfo><code>objects/info/</code></a></li><li><a href=#objectspack><code>objects/pack</code></a><ul><li><a href=#loose-objects-vs-packed-objects>loose objects vs packed objects</a></li></ul></li><li><a href=#gc与objects>GC与objects</a></li></ul></li></ul></li><li><a href=#refs>refs/</a><ul><li><a href=#refs内容>refs内容</a></li><li><a href=#refs目录结构>refs/目录结构</a></li><li><a href=#三类核心refs>三类核心refs</a></li><li><a href=#head与refs的关系>HEAD与refs的关系</a></li><li><a href=#symbolic-ref符号引用>symbolic ref（符号引用）</a></li><li><a href=#refs的写入协议非常关键>refs的写入协议（非常关键）</a></li></ul></li><li><a href=#rebase-apply-rebase-merge>rebase-apply/, rebase-merge/</a><ul><li><a href=#rebase目录存在意义>rebase目录存在意义</a></li><li><a href=#rebase-applyapply模式><code>rebase-apply</code>（apply模式）</a><ul><li><a href=#使用场景-1>使用场景</a></li><li><a href=#目录结构-1>目录结构</a></li><li><a href=#apply模式的局限>apply模式的局限</a></li></ul></li><li><a href=#rebase-mergemerge模式主流><code>rebase-merge</code>（merge模式，主流）</a><ul><li><a href=#使用场景-2>使用场景</a></li><li><a href=#目录结构-2>目录结构</a></li></ul></li></ul></li><li><a href=#branches>branches/</a><ul><li><a href=#历史定位>历史定位</a></li><li><a href=#gitbranches作用><code>.git/branches/</code>作用</a></li><li><a href=#淘汰原因>淘汰原因</a></li></ul></li><li><a href=#worktrees>worktrees/</a></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>