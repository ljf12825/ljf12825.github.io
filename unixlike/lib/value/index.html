<!doctype html><html lang=en><head><meta charset=UTF-8><title>Value</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/unixlike/>★</a></li><li><a href=/unixlike/lab/>Lab</a></li><li><a href=/unixlike/lib/>Lib</a></li><li><a href=/unixlike/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/system/ href=/system/>System</a>          |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |                                |
|                        /    |                                |
|                       /     |                                |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |                <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |                <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                          <a class=nav-item data-path=/csbasic/ href=/csbasic/>CSBasic</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Value<div class=meta>Update: 2025-12-31
>> Creator：ljf12825</div></div><div class=content><h1 id=value>Value</h1><h2 id=variable>Variable</h2><blockquote><p>定义：
C中的变量 = 一个有名字的，可寻址的存储区域 + 一组由类型定义的解释规则</p></blockquote><p>拆开来看</p><table><thead><tr><th>维度</th><th>含义</th></tr></thead><tbody><tr><td>名字</td><td>符号（symbol），供程序员与编译器使用</td></tr><tr><td>存储区域</td><td>实实在在的内存（或寄存器）</td></tr><tr><td>类型</td><td>决定：大小，对齐，读写方式，解释方式</td></tr></tbody></table><p>变量不是值，值只是变量在某一刻内存中的比特状态</p><table><thead><tr><th>概念</th><th>含义</th></tr></thead><tbody><tr><td>标识符（identifier）</td><td>名字本身，比如<code>x</code></td></tr><tr><td>对象（object）</td><td>一块存储区域</td></tr><tr><td>变量（variable)</td><td>具名对象（有名字的object）</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span></code></pre></div><ul><li><code>x</code>：标识符</li><li><code>int x</code>：定义了一个对象</li><li><code>x</code>：这个对象是变量（具名对象）</li></ul><h2 id=变量的本质分类维度>变量的本质分类维度</h2><p>C中变量不是靠一种方式分类的，而是多维度叠加的</p><h3 id=按存储期storage-duration分类核心>按存储期（Storage Duration）分类（核心）</h3><p>这是理解C的第一关键点</p><h4 id=自动存储期automatic>自动存储期（automatic）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>f</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>分配时间</td><td>进入作用域时</td></tr><tr><td>释放时间</td><td>离开作用域时</td></tr><tr><td>典型位置</td><td>栈</td></tr><tr><td>默认初始化</td><td>未初始化（垃圾值）</td></tr></tbody></table><h4 id=静态存储期static>静态存储期（static）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> y; 
</span></span></code></pre></div><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>生命周期</td><td>整个程序运行期间</td></tr><tr><td>分配位置</td><td><code>.data</code>/<code>.bss</code></td></tr><tr><td>默认初始化</td><td>初始化 0</td></tr><tr><td>作用域</td><td>看声明位置</td></tr></tbody></table><p>包括：全局变量，<code>static</code>局部变量，文件级<code>static</code></p><h4 id=动态存储期dynamic>动态存储期（dynamic）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span></code></pre></div><p>| 特性 | 说明 |
| 分配 | 运行时 |
| 释放 | <code>free</code> |
| 管理者 | 程序员 |
| 存储位置 | 堆 |</p><p><code>p</code>是自动变量，<code>*p</code>指向的对象是动态存储期</p><h3 id=按作用域scope分类>按作用域（Scope）分类</h3><h4 id=块作用域block-scope>块作用域（block scope）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>只在<code>{}</code>内可见</p><h4 id=文件作用域file-scope>文件作用域（file scope）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> g;
</span></span></code></pre></div><p>从声明点到文件末尾</p><h4 id=函数原型作用域>函数原型作用域</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> x);
</span></span></code></pre></div><p><code>x</code>只在参数列表中有效</p><h3 id=按链接属性linkage分类>按链接属性（Linkage）分类</h3><p>这是编译/链接阶段的核心概念</p><table><thead><tr><th>链接属性</th><th>说明</th></tr></thead><tbody><tr><td>无链接</td><td>仅在当前作用域</td></tr><tr><td>内部链接</td><td>当前翻译单元</td></tr><tr><td>外部链接</td><td>跨翻译单元</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> y;
</span></span></code></pre></div><p>链接属性决定：符号是否能被Id看见</p><h3 id=按类型type分类值的解释规则>按类型（Type）分类（值的解释规则）</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> y;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> S s;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> p;
</span></span></code></pre></div><p>类型决定</p><ul><li>占用字节数</li><li>对齐方式</li><li>运算规则</li><li>是否可修改</li><li>是否可别名（alias）</li></ul><p>类型是“解释规则”，不是内存本身</p><h2 id=定义-vs-声明>定义 vs 声明</h2><h3 id=定义definition>定义(Definition)</h3><p>分配存储空间</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> x;
</span></span></code></pre></div><h3 id=声明declaration>声明(Declaration)</h3><p>告诉编译器“它存在”</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> x;
</span></span></code></pre></div><p>一个变量只能定义一次，可以声明多次</p><h2 id=初始化的本质>初始化的本质</h2><p>自动变量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> x; <span style=color:#75715e>// 未初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 读取未初始化的自动对象的值是未定义行为
</span></span></span></code></pre></div><p>静态变量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> x; <span style=color:#75715e>// 自动初始化为0
</span></span></span></code></pre></div><p>原因不是“语法规则”，而是：静态存储期变量在程序加载时由运行时系统清零</p><h2 id=变量与内存>变量与内存</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span></code></pre></div><p>本质</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>地址 A:
</span></span><span style=display:flex><span>0000000A 00 00 00 
</span></span></code></pre></div><ul><li><code>x</code> -> 符号 -> 地址A</li><li><code>10</code> -> 比特模式</li><li><code>int</code> -> 如何解释这4个字节</li></ul><p>C中的变量是：由编译器管理的符号 + 存储期 + 作用域 + 链接属性 + 类型解释规则，本质是对一段内存的而语言级约束</p><h1 id=constant>Constant</h1><p>C语言中没有“真正不可变的变量”这个概念<br>常量 != 只读内存，常量 != <code>const</code></p><p>在C中，“常量”是一个语义概念，而不是一个统一的实体</p><h2 id=c中的常量分类>C中的常量分类</h2><h3 id=字面量literal-constant>字面量（Literal Constant）</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ae81ff>42</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3.14</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;a&#39;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;hello&#34;</span>
</span></span></code></pre></div><p>本质：编译期就确定的值</p><p>分类</p><table><thead><tr><th>类型</th><th>示例</th><th>存储</th></tr></thead><tbody><tr><td>整数字面量</td><td><code>42</code>, <code>0xFF</code></td><td>通常直接嵌入指令</td></tr><tr><td>浮点字面量</td><td><code>3.14</code></td><td>只读数据段</td></tr><tr><td>字符字面量</td><td><code>'a'</code></td><td>整型常量</td></tr><tr><td>字符串字面量</td><td><code>"hello"</code></td><td>静态存储区（只读）</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span>;
</span></span><span style=display:flex><span>p[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;H&#39;</span>; <span style=color:#75715e>// 未定义行为
</span></span></span></code></pre></div><p>字符串字面量不是数组变量，而是静态只读对象</p><h3 id=define宏常量><code>#define</code>宏常量</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define N 100 
</span></span></span></code></pre></div><p>本质：预处理阶段的纯文本替换</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> a[N]; <span style=color:#75715e>// 等价于 int a[100];
</span></span></span></code></pre></div><p>特点：</p><ul><li>不占用存储</li><li>无类型</li><li>无作用域（作用于文本范围）</li><li>不是调试器友好</li></ul><p>编译器根本不知道它“是常量”</p><h3 id=const修饰的对象><code>const</code>修饰的对象</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span></code></pre></div><p><code>const</code>不是“常量”，而是“通过该名字不可修改”<br>也就是说</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span></code></pre></div><ul><li><code>x</code>是一个变量</li><li>有存储</li><li>可能被放在只读区，也可能不</li></ul><p>反例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>y;
</span></span><span style=display:flex><span><span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>; <span style=color:#75715e>// 编译错误
</span></span></span><span style=display:flex><span>y <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>; <span style=color:#75715e>// 合法
</span></span></span></code></pre></div><p><code>const</code>约束的是访问路径（lvalue），不是对象本身</p><h3 id=enum枚举常量><code>enum</code>枚举常量</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>enum</span> { A <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, B <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> };
</span></span></code></pre></div><ul><li><code>A</code>, <code>B</code>是编译期整型常量</li><li>不占内存</li><li>可用于数组长度、case标签</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> arr[A]; <span style=color:#75715e>// 合法
</span></span></span></code></pre></div><p>在很多底层代码中，<code>enum</code>被当作类型安全的宏常量</p><h2 id=常量和变量在内存中的真实样子>常量和变量在内存中的真实样子</h2><p>典型内存布局</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>.text 代码
</span></span><span style=display:flex><span>.rodata 字符串字面量 / const 对象（可能）
</span></span><span style=display:flex><span>.data 已初始化全局变量
</span></span><span style=display:flex><span>.bss 未初始化全局变量
</span></span><span style=display:flex><span>.stack 自动变量
</span></span><span style=display:flex><span>.heap 动态分配
</span></span></code></pre></div><p>C标准并不规定const一定放在只读区，这是编译器行为，不是语言保证</p><h2 id=初始化-vs-赋值>初始化 vs 赋值</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// 初始化
</span></span></span><span style=display:flex><span>x <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; <span style=color:#75715e>// 赋值
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> arr[n]; <span style=color:#75715e>// 在C中不一定合法，C90/C99不允许，C99VLA或C11开启VLA允许
</span></span></span></code></pre></div><p>原因</p><ul><li><code>n</code>不是编译期常量</li><li>即使<code>n</code>的值不变，它仍是运行期对象</li></ul><p>GCC扩展可能允许，但这不是标准C</p><h2 id=编译期-vs-运行期>编译期 vs 运行期</h2><ul><li>编译期：程序还没有变成可执行文件之前，所有“由编译器完成的计算与决策”</li><li>运行期：程序已经开始执行，由CPU + 操作系统参与的所有行为</li></ul><h3 id=编译期行为>编译期行为</h3><p>严格说，编译期 != 只有compiler,它是一个阶段链</p><h4 id=1-预处理期preprocessing>1. 预处理期（Preprocessing）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define N 10 
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt; </span><span style=color:#75715e>
</span></span></span></code></pre></div><p>发生的事情：</p><ul><li>宏替换</li><li>条件编译</li><li>头文件展开</li></ul><p>这一阶段</p><ul><li>没有类型</li><li>没有变量</li><li>没有作用域</li><li>只是文本</li></ul><h4 id=2-编译期狭义的compiler>2. 编译期（狭义的compiler）</h4><p>编译器做的事</p><ul><li>词法/语法分析</li><li>语义分析（类型检查）</li><li>常量折叠（const folding）</li><li>生成中间表示（IR）</li><li>优化</li><li>生成目标代码（.o）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>; <span style=color:#75715e>// 编译期算成17 
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>enum</span> { N <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> a[N]; <span style=color:#75715e>// OK 
</span></span></span></code></pre></div><p>但</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> a[n]; <span style=color:#75715e>// 标准C不行，n是运行期对象，不是编译期常量
</span></span></span></code></pre></div><h4 id=3-链接期linking>3. 链接期（Linking）</h4><ul><li>符号解析</li><li>地址重定位</li><li>合并段</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> g;
</span></span></code></pre></div><p>此时</p><ul><li>才知道<code>g</code>的最终地址</li><li>才能确定跨文件符号</li></ul><h3 id=运行期>运行期</h3><p>运行期开始于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>程序被 OS 加载
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>main() 开始执行
</span></span></code></pre></div><p>运行期发生的事情</p><ul><li>栈帧建立/销毁</li><li>变量分配</li><li>函数调用</li><li>分支跳转</li><li>内存读写</li><li>系统调用</li><li>线程调度</li></ul><h3 id=总结>总结</h3><p>永远问三个问题</p><ol><li>这东西有没有对象</li><li>它的值是不是在编译时就确定</li><li>是否需要运行时指令来获得</li></ol><p>只要第3个是YES,那就是运行期</p><p>编译期决定“形状”，运行期决定“状态”</p><ul><li>编译期：代码长什么样</li><li>运行期：代码怎么跑</li></ul><table><thead><tr><th>问题</th><th>编译期</th><th>运行期</th></tr></thead><tbody><tr><td>是否有 CPU 指令在跑</td><td>❌</td><td>✅</td></tr><tr><td>是否有内存地址</td><td>部分（符号）</td><td>全部</td></tr><tr><td>是否能访问变量值</td><td>❌</td><td>✅</td></tr><tr><td>是否能调用函数</td><td>❌</td><td>✅</td></tr><tr><td>是否能分配栈</td><td>❌</td><td>✅</td></tr><tr><td>是否能决定数组大小</td><td>✅（需常量表达式）</td><td>❌</td></tr><tr><td>是否能优化代码</td><td>✅</td><td>❌</td></tr></tbody></table><p>从汇编角度的一句判断法：只要需要生成“运行时指令去算”的，就是运行期</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a[n]; <span style=color:#75715e>// 运行期分配
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译器必须生成</p><ul><li>计算<code>n</code></li><li>调整<code>rsp</code></li><li>恢复栈</li></ul><h2 id=编译器编辑器语言语义程序分析边界>编译器、编辑器、语言语义、程序分析边界</h2><p>编辑器/IDE可以在编辑期发现<strong>一部分</strong>编译器<strong>必然</strong>错误，但原则上无法在编辑期可靠地发现<strong>依赖运行期状态</strong>的错误\</p><h3 id=为什么编辑器能报编译期错误>为什么编辑器能报编译期错误</h3><p>编译器并不是猜，而是在调用编译器能力<br>现代编辑器（VS Code, CLion, Vim + clangd）做的事情是</p><ul><li>实时分析源码</li><li>运行语法分析 + 语义分析</li><li>使用与编译器相同或相似的前端</li></ul><p>例如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abc&#34;</span>; <span style=color:#75715e>// 类型错误
</span></span></span></code></pre></div><p>这是一个不依赖输入，不依赖环境，对所有执行路径都成立的错误<br>这种错误在任何运行期都会失败 -> 可在编辑期100%确定</p><p>这类错误的共同特征</p><ul><li>不需要执行程序</li><li>不依赖输入</li><li>不依赖分支</li><li>对所有路径成立</li></ul><p>因此，编辑器可以提前报错，本质是静态分析</p><h3 id=为什么编辑器不能报出运行期错误>为什么编辑器不能报出运行期错误</h3><p>典型例子</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>问题</p><ul><li>当<code>x == 0</code> -> 崩溃</li><li>当<code>x != 0</code> -> 正常</li></ul><p>编辑器在编辑器无法知道</p><ul><li><code>x</code>是来自哪里</li><li>用户输入是什么</li><li>走哪条分支</li></ul><p>这是一个理论上的不可能性，这里不是“技术不够好”，而是计算理论极限<br>核心问题：停机问题（Halting Problem）：不存在一个程序，能够对任意程序，判断它是否在运行时发生错误</p><p>运行期错误本质上是</p><ul><li>程序行为</li><li>状态演化</li><li>动态路径</li></ul><p>这些都属于不可完全静态判定的问题</p><h4 id=为什么有时编辑器好像能发现运行期问题>为什么有时编辑器好像能发现运行期问题</h4><p>编辑器有时候会提示空指针、越界等行为，这是因为，编辑器做的是保守静态分析<br>例如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span><span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span></code></pre></div><p>这是100%必然的运行期错误，不需要输入，不存在分支，所有路径必崩，因此可以在编辑期报错</p><p>但一旦引入条件，就不再是”必然“</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> (p <span style=color:#f92672>!=</span> NULL)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span></code></pre></div><p>是否安全取决于<code>p</code>的来源，取决于执行路径；编辑器此时只能给warning或保持沉默</p><h3 id=编辑器编译器的能力边界>编辑器/编译器的”能力边界“</h3><p>能做到的（静态、确定性）</p><ul><li>语法错误</li><li>类型错误</li><li>必然的未定义行为</li><li>明显越界（常量索引）</li><li>明显空指针解引用</li></ul><p>做不到的（动态、路径相关）</p><ul><li>输入相关崩溃</li><li>数据竞争（大多数情况）</li><li>逻辑错误</li><li>时序问题</li><li>资源泄漏（完全精确）</li></ul><p>这也就是为什么需要”运行期工具“，既然编辑期/编译期有理论极限，工程上怎么解决</p><ol><li><p>运行期检测（动态分析）</p><ul><li>AddressSanitizer</li><li>Valgrind</li><li>ThreadSanitizer</li></ul><p>它们的特点：需要执行，基于真实路径，有性能开销（插桩）</p></li><li><p>类型系统作为”前移防线“
例如<code>const</code>, <code>restrict</code>，不可空指针（其他语言），能在编译期消灭一类运行期错误</p></li></ol></div><nav class=post-nav><a href=/unixlike/lib/undefinedbehaviour/ class=hover:underline>pre: Undefined Behaviours</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><a href=#value>Value</a><ul><li><a href=#variable>Variable</a></li><li><a href=#变量的本质分类维度>变量的本质分类维度</a><ul><li><a href=#按存储期storage-duration分类核心>按存储期（Storage Duration）分类（核心）</a><ul><li><a href=#自动存储期automatic>自动存储期（automatic）</a></li><li><a href=#静态存储期static>静态存储期（static）</a></li><li><a href=#动态存储期dynamic>动态存储期（dynamic）</a></li></ul></li><li><a href=#按作用域scope分类>按作用域（Scope）分类</a><ul><li><a href=#块作用域block-scope>块作用域（block scope）</a></li><li><a href=#文件作用域file-scope>文件作用域（file scope）</a></li><li><a href=#函数原型作用域>函数原型作用域</a></li></ul></li><li><a href=#按链接属性linkage分类>按链接属性（Linkage）分类</a></li><li><a href=#按类型type分类值的解释规则>按类型（Type）分类（值的解释规则）</a></li></ul></li><li><a href=#定义-vs-声明>定义 vs 声明</a><ul><li><a href=#定义definition>定义(Definition)</a></li><li><a href=#声明declaration>声明(Declaration)</a></li></ul></li><li><a href=#初始化的本质>初始化的本质</a></li><li><a href=#变量与内存>变量与内存</a></li></ul></li><li><a href=#constant>Constant</a><ul><li><a href=#c中的常量分类>C中的常量分类</a><ul><li><a href=#字面量literal-constant>字面量（Literal Constant）</a></li><li><a href=#define宏常量><code>#define</code>宏常量</a></li><li><a href=#const修饰的对象><code>const</code>修饰的对象</a></li><li><a href=#enum枚举常量><code>enum</code>枚举常量</a></li></ul></li><li><a href=#常量和变量在内存中的真实样子>常量和变量在内存中的真实样子</a></li><li><a href=#初始化-vs-赋值>初始化 vs 赋值</a></li><li><a href=#编译期-vs-运行期>编译期 vs 运行期</a><ul><li><a href=#编译期行为>编译期行为</a><ul><li><a href=#1-预处理期preprocessing>1. 预处理期（Preprocessing）</a></li><li><a href=#2-编译期狭义的compiler>2. 编译期（狭义的compiler）</a></li><li><a href=#3-链接期linking>3. 链接期（Linking）</a></li></ul></li><li><a href=#运行期>运行期</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#编译器编辑器语言语义程序分析边界>编译器、编辑器、语言语义、程序分析边界</a><ul><li><a href=#为什么编辑器能报编译期错误>为什么编辑器能报编译期错误</a></li><li><a href=#为什么编辑器不能报出运行期错误>为什么编辑器不能报出运行期错误</a><ul><li><a href=#为什么有时编辑器好像能发现运行期问题>为什么有时编辑器好像能发现运行期问题</a></li></ul></li><li><a href=#编辑器编译器的能力边界>编辑器/编译器的”能力边界“</a></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>