<!doctype html><html lang=en><head><meta charset=UTF-8><title>Scene System</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Scene System" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Scene System<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>Unity Scene System是Unity中用于组织和管理游戏世界的基础结构，Unity支持多个Scene的加载与卸载，允许构建出大型、分块化的世界</p><h2 id=scene>Scene</h2><p>Scene是Unity游戏项目中的一个基础构建单元，它就像游戏世界中的一个“地图”或“关卡”，一个Scene就是一个逻辑/物理空间的容器，包含了：</p><ul><li>GameObject</li><li>地形、UI、声音</li><li>脚本、组件</li><li>光照信息、烘焙数据等</li></ul><p>在Unity中，一个Scene对应一个<code>.unity</code>文件</p><h3 id=scene-生命周期>Scene 生命周期</h3><p>1.创建或打开场景（<code>.unity</code>文件）</p><p>2.布置场景内容</p><p>3.保存场景</p><p>4.构建和加载场景（Build Settings里添加场景）</p><p>5.运行时加载和卸载场景</p><h3 id=场景最佳实践>场景最佳实践</h3><ul><li>保持每个场景的职责单一（比如UI与游戏逻辑分离）</li><li>使用Prefab来管理重复对象</li><li>使用场景加载器或管理器来控制场景切换和数据传递</li><li>合理使用DontDestroyOnLoad来跨场景保存数据或对象</li></ul><h2 id=multi-scene>Multi Scene</h2><p>多场景允许你同时加载和管理多个场景，不同场景可以同时存在并且运行在游戏中，允许你灵活地处理加载、切换和卸载场景的需求</p><ol><li>加载和卸载场景</li></ol><ul><li>Additive加载：可以在现有场景的基础上加载新的场景，这种方式不会卸载当前场景，而是将多个场景叠加在一起</li><li>Single加载：可以将一个场景替换当前场景，这种方式会卸载当前场景并加载新的场景</li></ul><ol start=2><li>常见的多场景应用场景</li></ol><ul><li>主菜单 + 游戏场景：主菜单和游戏场景可以同时加载，用户操作菜单时，游戏场景依然在后台运行</li><li>动态加载关卡：可以根据游戏的进度或玩家行为动态加载或卸载不同的场景，比如一个大世界分为多个小场景，按需加载</li><li>UI和游戏场景分离：UI可以独立于游戏场景加载，确保UI始终可用，而不受游戏场景加载状态的影响</li></ul><h3 id=加载场景additive-和-single>加载场景（Additive 和 Single）</h3><ul><li><code>Additive</code>加载：将新场景加载到现有场景中，保持当前场景不变</li></ul><p><code>Additive</code>加载意味着将一个新场景加载到现有场景的基础上，当前场景不会被卸载，而是与新场景一起共存。使用这种方式可以让多个场景并行运行，从而实现一些复杂的场景管理，例如分割大型场景，或者在后台加载新的场景内容</p><p>使用场景：</p><ul><li>动态加载关卡：例如一个开放世界游戏，场景可以按需加载。加载一个新的区域时，现有区域不会被卸载</li><li>UI 和游戏分离：UI 可以作为一个单独的场景加载并保持活跃，而游戏逻辑场景则可以独立运行</li><li>多人游戏：在多人游戏中，玩家可能在多个子场景中互动，Additive 加载可以实现多个玩家在多个区域间的无缝切换</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Additive</span>
</span></span><span style=display:flex><span>SceneManager.LoadScene(<span style=color:#e6db74>&#34;NewScene&#34;</span>, LoadSceneMode.Additive);
</span></span></code></pre></div><ul><li><code>Single</code>加载：加载一个新场景并卸载当前场景</li></ul><p><code>Single</code>加载模式表示加载一个新场景并卸载当前的场景。这是传统的场景切换方式，通常用于当你需要完全切换到另一个场景时</p><p>使用场景：</p><ul><li>关卡切换：当玩家从一个关卡进入另一个关卡时，Single 加载通常是最常用的方式</li><li>游戏状态管理：如果你的游戏有明确的关卡结构或状态，切换到新场景时，可以使用 Single 模式来清空当前场景，加载一个全新的游戏状态</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 加载场景（Single）</span>
</span></span><span style=display:flex><span>SceneManager.LoadScene(<span style=color:#e6db74>&#34;NewScene&#34;</span>, LoadSceneMode.Single);
</span></span></code></pre></div><h3 id=卸载场景>卸载场景</h3><p>如果你使用了<code>Additive</code>加载多个场景，可以选择卸载某个场景</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 卸载场景</span>
</span></span><span style=display:flex><span>SceneManager.UnloadSceneAsync(<span style=color:#e6db74>&#34;OldScene&#34;</span>);
</span></span></code></pre></div><h3 id=多场景加载的复杂性和管理>多场景加载的复杂性和管理</h3><p>在使用<code>Additive</code>加载时，场景之间的资源管理尤为重要。不同场景之间共享资源，可能会导致以下问题：</p><ul><li>资源冲突：多个场景中可能会使用相同的资源（如材质、纹理、音效等），如果没有适当的管理，可能会发生资源覆盖或重复加载</li><li>性能瓶颈：加载多个场景会增加内存使用量，尤其是在大型场景中。如果不及时卸载不需要的场景，可能会导致性能下降</li></ul><p><strong>避免场景间资源冲突</strong></p><ol><li><p>资源打包：利用Unity的资源打包系统（例如Asset Bundles或Addressables），可以让每个场景只加载所需的资源，避免多个场景之间的资源冲突</p></li><li><p>场景划分与依赖管理：避免场景间有过强的依赖关系。例如，将游戏逻辑与UI、背景和音效分开，确保每个场景只包含特定职责的内容</p></li><li><p>共享资源：通过<code>DontDestroyOnLoad</code>来管理那些需要跨场景的共享资源（如音频管理器、玩家数据管理器等）</p></li></ol><h3 id=切换场景并保持场景之间的交互>切换场景并保持场景之间的交互</h3><p>使用多场景时，有时候你希望不同的场景之间可以交互。比如，可以在一个场景中控制另一个场景中的对象。<br>可以通过<code>SceneManager.GetSceneByName</code>或<code>SceneManager.GetSceneAt</code>获取其他加载的场景，然后通过<code>Scene.GetRootGameObjects()</code>获取该场景中的所有根级对象，进一步操作它们</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 获取其他场景的根物体</span>
</span></span><span style=display:flex><span>Scene otherScene = SceneManager.GetSceneByName(<span style=color:#e6db74>&#34;OtherScene&#34;</span>);
</span></span><span style=display:flex><span>GameObject[] rootObjects = otherScene.GetRootGameObjects();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 操作场景中的物体</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (GameObject obj <span style=color:#66d9ef>in</span> rootObjects) obj.SetActive(<span style=color:#66d9ef>false</span>); <span style=color:#75715e>// 隐藏物体</span>
</span></span></code></pre></div><ul><li>场景切换动画：为了避免切换场景时的黑屏，你可以在场景切换之前播放一个加载动画或者过渡动画</li></ul><h3 id=异步加载场景>异步加载场景</h3><h4 id=为什么使用异步加载>为什么使用异步加载</h4><p>异步加载允许你在场景加载的过程中保持游戏的流畅运行。异步加载时，Unity会在后台加载场景，不会阻塞主线程，因此可以避免游戏界面卡顿或掉帧<br>异步加载常用于：</p><ul><li>避免卡顿：在加载大型场景或资源时，异步加载可以有效减少游戏界面卡顿的现象</li><li>展示加载进度：可以展示进度条或者加载动画，提升用户体验</li></ul><h4 id=异步加载基础>异步加载基础</h4><p>通过<code>SceneManager.LoadSceneAsync</code>可以异步加载场景，可以使用<code>AsyncOperation</code>对象来监控加载进度</p><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerator LoadSceneAsync(<span style=color:#66d9ef>string</span> sceneName)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 异步加载场景</span>
</span></span><span style=display:flex><span>    AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(sceneName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 等待场景加载完成</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (!asyncLoad.isDone)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 显示加载进度</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> progress = Mathf.Clamp01(asyncLoad.progress / <span style=color:#ae81ff>0.9f</span>); <span style=color:#75715e>// 进度值[0, 1]</span>
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;Loading progress: &#34;</span> + progress);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 可以在这里更新进度条UI</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// 每帧执行</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=async和await异步加载><code>async</code>和<code>await</code>异步加载</h4><p>Unity在2017之后对C#的异步功能支持更好，支持使用<code>async</code>和<code>await</code>来简化异步操作。你可以将异步加载过程包装成一个异步方法，从而避免繁琐的协程逻辑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>saync Task LoadSceneAsync(<span style=color:#66d9ef>string</span> sceneName)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(sceneName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 等待加载完成</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (!asyncLoad.isDone)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> progress = Mathf.Clamp01(asyncLoad.progress / <span style=color:#ae81ff>0.9f</span>);
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;Loading progress: &#34;</span> + progress);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Task.Yield(); <span style=color:#75715e>// 等待下一帧</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=资源顺序加载>资源顺序加载</h4><p>有时候，我们希望保证某些资源或场景按特定顺序加载，或者在某些资源完全加载后才能加载其他资源。使用异步加载时，<code>async</code>和<code>await</code>可以让你控制加载的顺序</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>async</span> Task LoadSceneInOrider()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加载第一个场景</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> LoadSceneAsync(<span style=color:#e6db74>&#34;Scene1&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加载第二个场景</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> LoadSceneAsync(<span style=color:#e6db74>&#34;Scene2&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 继续加载其他资源</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=避免资源加载顺序问题>避免资源加载顺序问题</h4><p>确保在加载多个场景时，场景中的资源顺序正确。对于大型场景或者有依赖关系的资源，可以使用<code>Addressables</code>系统来更细粒度地控制资源的加载顺序</p><h4 id=资源优化>资源优化</h4><p>异步加载场景和资源时，性能优化是非常重要的。可以使用以下方法：</p><ul><li>使用<code>async</code>和<code>await</code>配合加载不同类型的资源：例如先加载场景，然后在后台加载音频、纹理等资源</li><li>场景切换前缓冲资源：提前加载必要的资源，避免在切换场景时发生卡顿</li><li>分步加载资源：不必一次性加载所有资源，可以分批次地进行加载，确保用户界面的流畅性</li></ul><h3 id=多场景注意事项>多场景注意事项</h3><ul><li>场景间的依赖：确保每个场景的独立性。如果一个场景依赖于另一个场景中的对象，加载时可能会出现问题，特别是在异步加载时</li><li>内存管理：加载多个场景会消耗更多内存，尤其是大型场景。确保合理管理内存，及时卸载不再需要的场景</li></ul><h3 id=实例多场景管理器>实例：多场景管理器</h3><p>可以创建一个管理多个场景加载的系统</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.SceneManagement;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MultiSceneManager</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> mainScene = <span style=color:#e6db74>&#34;MainScene&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> uiScene = <span style=color:#e6db74>&#34;UIScene&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 加载主场景和UI场景</span>
</span></span><span style=display:flex><span>        LoadMainScene();
</span></span><span style=display:flex><span>        LoadUIScene();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> LoadMainScene() =&gt; SceneManager.LoadScene(mainScene, LoadSceneMode.Additive);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> LoadUIScene() =&gt; SceneManager.LoadScene(uiScene, LoadSceneMode.Additive);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> UnloadMainScene() =&gt; SceneManager.UnloadSceneAsync(mainScene);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> UnloadUIScene() =&gt; SceneManager.UnloadSceneAsync(uiScene);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=scenemanager>SceneManager</h3><p><code>SceneManager</code>是Unity中用来管理场景加载、卸载和切换的一个类。它提供了许多用于操作场景的方法，比如异步加载场景、场景之间切换、场景的同步加载、查询场景信息等。</p><p><code>SceneManager</code>是<code>UnityEngine.SceneManagement</code>命名空间的一部分</p><h4 id=常用api>常用API</h4><h5 id=加载场景>加载场景</h5><ul><li>加载单一场景</li></ul><p><code>SceneManager.LoadScene</code>用于加载指定的场景</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>SceneManager.LoadScene(<span style=color:#e6db74>&#34;SceneName&#34;</span>);
</span></span></code></pre></div><ul><li>异步加载场景</li></ul><p>异步加载场景是为了避免在加载时阻塞主线程，可以提高游戏体验</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>AsyncOperation asyncOp = SceneManager.LoadSceneAsync(<span style=color:#e6db74>&#34;SceneName&#34;</span>);
</span></span></code></pre></div><p>异步加载场景时，可以通过<code>AsyncOperation</code>对象来获取加载进度，甚至可以控制场景是否在加载完成后自动激活</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>asyncOp.allowSceneActivation = <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// 控制场景是否自动激活</span>
</span></span></code></pre></div><h5 id=卸载场景-1>卸载场景</h5><ul><li>卸载当前场景</li></ul><p><code>SceneManager.UnloadSceneAsync</code>用于卸载一个场景，通常用于切换场景时</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>SceneManager.UnloadSceneAsync(<span style=color:#e6db74>&#34;SceneName&#34;</span>);
</span></span></code></pre></div><p>这个方法是异步的，因此可以在后台卸载场景，不会影响游戏的运行</p><h5 id=获取当前场景>获取当前场景</h5><ul><li>获取当前激活的场景</li></ul><p><code>SceneManager.GetActiveScene</code>用于获取当前激活的场景，返回的是一个<code>Scene</code>对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Scene currentScene = SceneManager.GetActiveScene();
</span></span></code></pre></div><p>可以通过<code>Scene</code>对象获取场景的名称、路径、索引等信息</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>string</span> sceneName = currentScene.name;
</span></span></code></pre></div><h5 id=场景切换>场景切换</h5><ul><li>加载多个场景</li></ul><p>可以使用<code>SceneManager.LoadScene</code>来加载多个场景，这对于一些需要同时存在多个场景的情况（如多人联机或大场景加载）非常有用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>SceneManager.LoadScene(<span style=color:#e6db74>&#34;Scene1&#34;</span>, LoadSceneMode.Additive); <span style=color:#75715e>// 加载一个附加场景</span>
</span></span></code></pre></div><p>通过<code>LoadSceneMode.Additive</code>，新的场景会叠加到现有场景上</p><ul><li>切换场景</li></ul><p>如果你要切换到一个新的场景并卸载当前场景，可以在加载新场景时使用<code>LoadSceneMode.Single</code>，它会在加载新场景的同时卸载当前场景</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>SceneManager.LoadScene(<span style=color:#e6db74>&#34;NewScene&#34;</span>, LoadSceneMode.Single);
</span></span></code></pre></div><h5 id=场景索引>场景索引</h5><p>可以通过<code>Scene</code>对象来查询更多关于场景的信息：</p><ul><li>获取场景的名称</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>string</span> sceneName = currentScene.name
</span></span></code></pre></div><ul><li>获取场景的索引</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> sceneIndex = currentScene.buildIndex
</span></span></code></pre></div><ul><li>获取场景的根游戏对象</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>GameObject[] rootObjects = currentScene.GetRootGameObjects();
</span></span></code></pre></div><h5 id=事件和回调>事件和回调</h5><p>Unity提供了一些事件和回调来监听场景加载的状态</p><ul><li><code>SceneManager.sceneLoaded</code>事件</li></ul><p>这个事件会在场景加载完成时触发，你可以通过订阅这个事件来执行场景加载后的操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>SceneManger.sceneLoaded += OnSceneLoaded;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> OnSceneLoaded(Scene scene, LoadSceneMode mode)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Debug.Log(<span style=color:#e6db74>&#34;Scene &#34;</span> + scene.name + <span style=color:#e6db74>&#34; loaded.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>SceneManager.sceneUnloaded</code>事件</li></ul><p>这个事件会在场景卸载时触发</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>SceneManager.sceneUnloaded += OnSceneUnloaded;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> OnSceneUnloaded(Scene scene) =&gt; Debug.Log(<span style=color:#e6db74>&#34;Scene &#34;</span> + scene.name + <span style=color:#e6db74>&#34; unloaded.&#34;</span>);
</span></span></code></pre></div><p><a href=https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html>UnityScripting SceneManager</a></p><h3 id=dontdestroyonload>DontDestroyOnLoad</h3><p><code>DontDestroyOnLoad</code>是Unity中一个非常使用的函数，它可以将某个对象在加载新场景时保持不被销毁。这对于需要在多个场景间共享的对象（如音频管理器、玩家数据等）非常有用</p><p>1.基本使用</p><p>通过<code>DontDestroyOnLoad</code>，你可以使一个游戏对象在场景切换时不被销毁。当你加载一个新场景时，默认情况下，当前场景中所有对象都会被卸载。但如果某个对象调用了<code>DontDestroyOnLoad</code>，它就会被保留，直到手动销毁它</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> Start() =&gt; DontDestroyOnLoad(gameObject); <span style=color:#75715e>// 保持这个对象不被销毁</span>
</span></span></code></pre></div><p>2.适用场景</p><p><code>DontDestroyOnLoad</code>通常适用于以下情况：</p><ul><li>音频管理器：游戏中有一个音频管理器对象，需要在不同场景之间共享音乐和音效设置。通过<code>DontDestroyOnLoad</code>，你可以确保音频管理器在场景切换时不被销毁</li><li>玩家数据：例如，玩家的得分、背包内容、任务进度等需要在多个场景之间保持一致。在这种情况下，你可以将数据存储在一个不销毁的对象中</li><li>全局控制器：如果你有一个控制器或管理器（例如游戏状态控制器、广告管理器等），这些也可以通过<code>DontDestroyOnLoad</code>保持跨场景存在</li></ul><p>3.注意事项</p><p><strong>可能引起的问题</strong></p><ul><li>对象重复创建：<code>DontDestroyOnLoad</code>会让对象保持在所有场景之间。但是，如果在多个场景中分别创建了同样的对象，这可能会导致重复的对象。例如，如果你在一个场景中已经有一个音频管理器，并且在加载另一个场景时有创建了一个新的音频管理器，结果可能时两个音频管理器同时存在。为了避免这种情况，需要确保只有一个对象调用了<code>DontDestroyOnLoad</code></li></ul><p>解决办法：通常做法是在脚本中加上一个检查，确保只有第一个创建的对象调用<code>DontDestroyOnLoad</code>，而其他对象则销毁自己</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (FindObjectsOfType(<span style=color:#66d9ef>typeof</span>(MyManager)).Length &gt; <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        Destroy(gameObject); <span style=color:#75715e>// 如果场景中已经有一个该类型的对象，销毁当前对象</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> DontDestroyOnLoad(gameObject); <span style=color:#75715e>// 否则保留该对象</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>使用<code>DontDestroyOnLoad</code>时的对象管理</strong></p><ul><li>生命周期管理：虽然<code>DontDestroyOnLoad</code>防止对象在场景切换时销毁，但它并不会阻止对象在运行时被销毁，如果想在特定时刻销毁该对象，需要手动调用<code>Destroy()</code></li></ul><p><strong>跨场景对象命名问题</strong>
<code>DontDestroyOnLoad</code>对象仍然存在于内存中，因此你需要特别注意它们的名字。为了避免在多个场景中有相同名称的对象，通常可以将<code>DontDestroyOnLoad</code>对象的名称修改为唯一的标识符</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (FindObjectOfType&lt;MyManager&gt;() == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        gameObject.name = <span style=color:#e6db74>&#34;UniqueManager&#34;</span>;
</span></span><span style=display:flex><span>        DontDestroyOnLoad(gameObject);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> Destroy(gameObject);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=底层实现推测>底层实现（推测）</h4><p>Unity的底层实现并没有公开<code>DontDestroyOnLoad</code>的具体源码，但我们可以推测它的工作原理基于以下几个步骤：</p><ul><li>场景对象管理器：当Unity进行场景切换时，它会遍历场景中的所有对象，并将标记为<code>DontDestroyOnLoad</code>的对象移除场景的管理队列</li><li>全局管理容器：这些标记为不销毁的对象会被一如一个全局的容器中，保持在内存中，直到程序结束或手动销毁这些对象</li><li>不被卸载：这些对象的生命周期与当前场景无关，它们会在Unity的内部管理中维持直到销毁</li></ul><h3 id=场景打包与构建设置>场景打包与构建设置</h3><h4 id=构建设置>构建设置</h4><h5 id=访问构建设置>访问构建设置</h5><p>构建设置可以通过Unity编辑器的菜单访问：</p><ul><li><code>File</code> -> <code>Build Settings</code></li></ul><p>构建设置窗口列出了所有可用的场景、平台选项、打包模式、构建设置等。你可以通过它来管理场景、选择构建平台、设置构建选项</p><p><img src=/images/Blog/BuildSettings.jpg alt="Build Settings"></p><h5 id=场景的添加与移除>场景的添加与移除</h5><p>在构建设置中，所有需要包含在游戏构建中的场景都必须被添加到场景列表中</p><ul><li>添加场景：点击<code>Add Open Scenes</code>按钮，Unity会将当前打开的场景添加到场景列表中</li><li>移除场景：点击场景旁边的<code>-</code>按钮，移除该场景</li></ul><p>场景顺序：场景在构建设置中的顺序很重要。Unity会按顺序加载这些场景，并且默认加载列表中的第一个场景作为游戏启动场景</p><h5 id=构建平台选择>构建平台选择</h5><p>Unity支持多个平台的构建，包括PC、Mac、Linux、WebGL、iOS、Android、Console等，可以选择目标平台并进行构建。不同平台可能会有不同的构建要求</p><ul><li>选择平台：在构建设置窗口中，点击平台名称（例如PC，Mac & Linux Standalone）来选择目标平台</li><li>平台切换：点击<code>Switch Platform</code>按钮来切换目标平台，Unity会根据选择的平台进行相应的调整</li></ul><h5 id=场景打包模式>场景打包模式</h5><p>在构建设置中，场景的加载方式分为两种模式：</p><ul><li>Additive</li><li>Single</li></ul><p>通常情况下，需要选择不同的加载模式来优化内存管理和加载时间</p><h4 id=场景构建与打包优化>场景构建与打包优化</h4><h5 id=资源优化-1>资源优化</h5><p>优化游戏的场景和资源打包时提升游戏性能的重要步骤，以下是常见的优化方法：</p><ul><li>精简资源：确保每个场景中只包含必要的资源，避免冗余的材质、纹理、音频等</li><li>静态合批：将场景中的静态物体合并成一个大网格，减少draw call，提升渲染效率</li><li>光照与阴影：减少场景中动态光源数量，合理使用光照贴图（Lightmaps）来优化性能</li></ul><h5 id=场景打包设置>场景打包设置</h5><p>Unity提供了对场景打包的一些设置，帮助你控制场景打包的方式：</p><ul><li>压缩选项：可以选择是否对场景中的资源进行压缩，通常选择压缩可以减少打包文件的大小</li><li>场景的内存管理：在构建设置中，你可以选择是否将场景资源分离到不同的资源包中（例如Asset Bundles或Addressables），这样可以减少初始加载时间，并按需加载资源</li></ul><h5 id=多平台支持>多平台支持</h5><p>Unity支持在不同平台上进行构建。你可以针对每个平台选择不同的场景优化策略：</p><ul><li>PC和Mac：通常场景中的资源较大，可以通过压缩和剔除不必要的内容来减小文件体积</li><li>移动平台：对于移动平台，通常需要更严格的内存管理和性能优化，避免过大的场景和冗余资源</li><li>WebGL：Web平台通常有更严格的内存和资源限制，因此需要优化场景资源，减少加载时间</li></ul><h5 id=构建设置中的其他选项>构建设置中的其他选项</h5><ul><li>Player Settings：可以对每个平台的构建进行详细配置，例如分辨率、图形设置、资源加载策略等</li><li>Development Build：启用此选项可以使构建版本包含调试信息，用于开发和调试</li><li>Script Debugging：启用后，可以进行脚本调试，适用于开发阶段</li></ul><h3 id=场景分块加载>场景分块加载</h3><p>对于大型游戏，特别是开放世界类型的游戏，将场景分割成小的块（Chunk）是非常重要的，这样可以按需加载场景，从而减小内存消耗并提高游戏性能</p><p>分块加载场景的优势：</p><ul><li>按需加载：根据玩家的位置或游戏进度，动态加载和卸载场景</li><li>减少内存占用：只加载当前玩家需要的场景，减少不必要的内存消耗</li></ul><h4 id=如何实现场景分块加载>如何实现场景分块加载：</h4><ol><li>将一个大场景拆分成多个小场景（例如，分成多个区域）</li><li>使用<code>SceneManager.LoadScene</code>或<code>SceneManger.LoadSceneAsync</code>按需加载这些小场景</li><li>使用<code>LoadSceneMode.Additive</code>加载多个场景，而不卸载当前场景</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 异步加载多个场景</span>
</span></span><span style=display:flex><span>IEnumerator LoadChunksAsync()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(<span style=color:#e6db74>&#34;Chunk1&#34;</span>, LoadSceneMode.Additive);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(!asyncLoad.isDone) <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    asyncLoad = SceneManager.LoadSceneAsync(<span style=color:#e6db74>&#34;Chunk2&#34;</span>, LoadSceneMode.Additive);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (!asyncLoad.isDone) <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=场景分层管理>场景分层管理</h4><p>通过分层管理来控制场景的加载，主要将游戏内容和UI、背景音乐等资源分离，可以提高场景的加载效率，例如：</p><ul><li>游戏场景：包含主游戏逻辑、任务、敌人、地形等</li><li>UI场景：包含主菜单、设置、游戏暂停界面等</li><li>音频场景：音频资源可以独立成一个场景，保证游戏时音效不会受到场景切换的影响</li></ul><h3 id=触发器加载机制>触发器加载机制</h3><h3 id=addressable与场景加载>Addressable与场景加载</h3><h4 id=addressable-asset-system>Addressable Asset System</h4><p>Unity的Addressable Asset System是一个非常强大的资源管理和加载系统，可以让你更精确地控制资源的加载、卸载、分发和优化。它可以用于按需加载资源，特别适合大规模场景的动态加载</p><p>主要特点：</p><ul><li>按需加载：通过地址引用来加载资源，而不需要将所有资源打包在场景中</li><li>优化加载：支持异步加载和缓存优化，减少内存消耗</li></ul><p>在构建场景时，可以通过Addressable资源来管理和加载场景文件及资源。例如，可以将场景预先打包为Addressable，并在运行时加载它</p><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.AddressableAssets;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.ResourceManagement.AsyncOperations;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> LoadSceneWithAddressable(<span style=color:#66d9ef>string</span> sceneName)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用Addressable加载场景</span>
</span></span><span style=display:flex><span>    AsyncOperationHandle&lt;SceneInstance&gt; handle = Addressables.LoadSceneAsync(sceneName, LoadSceneMode.Additive);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 可以监听加载过程</span>
</span></span><span style=display:flex><span>    handle.Completed += (op) =&gt; { Debug.Log(<span style=color:#e6db74>&#34;Scene Loaded: &#34;</span> + sceneName);};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=场景打包为addressable>场景打包为Addressable</h4><p>将场景打包为Addressable可以极大地优化场景的加载过程，特别是在资源分发和网络加载时，Unity提供了专门的工具来标记场景为Addressable，并管理它们的加载</p><ol><li>在Addressable中创建一个项目条目</li><li>通过Asset Bundle管理器，将场景资源标记为<code>Addressable</code></li><li>使用异步加载方法来加载场景并优化内存使用</li></ol></div><nav class=post-nav><a href=/blog/rigidbody/ class=hover:underline>pre: Rigidbody</a>
<a href=/blog/scriptableobject/ class=hover:underline>next: ScriptableObject</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#scene>Scene</a><ul><li><a href=#scene-生命周期>Scene 生命周期</a></li><li><a href=#场景最佳实践>场景最佳实践</a></li></ul></li><li><a href=#multi-scene>Multi Scene</a><ul><li><a href=#加载场景additive-和-single>加载场景（Additive 和 Single）</a></li><li><a href=#卸载场景>卸载场景</a></li><li><a href=#多场景加载的复杂性和管理>多场景加载的复杂性和管理</a></li><li><a href=#切换场景并保持场景之间的交互>切换场景并保持场景之间的交互</a></li><li><a href=#异步加载场景>异步加载场景</a><ul><li><a href=#为什么使用异步加载>为什么使用异步加载</a></li><li><a href=#异步加载基础>异步加载基础</a></li><li><a href=#async和await异步加载><code>async</code>和<code>await</code>异步加载</a></li><li><a href=#资源顺序加载>资源顺序加载</a></li><li><a href=#避免资源加载顺序问题>避免资源加载顺序问题</a></li><li><a href=#资源优化>资源优化</a></li></ul></li><li><a href=#多场景注意事项>多场景注意事项</a></li><li><a href=#实例多场景管理器>实例：多场景管理器</a></li><li><a href=#scenemanager>SceneManager</a><ul><li><a href=#常用api>常用API</a><ul><li><a href=#加载场景>加载场景</a></li><li><a href=#卸载场景-1>卸载场景</a></li><li><a href=#获取当前场景>获取当前场景</a></li><li><a href=#场景切换>场景切换</a></li><li><a href=#场景索引>场景索引</a></li><li><a href=#事件和回调>事件和回调</a></li></ul></li></ul></li><li><a href=#dontdestroyonload>DontDestroyOnLoad</a><ul><li><a href=#底层实现推测>底层实现（推测）</a></li></ul></li><li><a href=#场景打包与构建设置>场景打包与构建设置</a><ul><li><a href=#构建设置>构建设置</a><ul><li><a href=#访问构建设置>访问构建设置</a></li><li><a href=#场景的添加与移除>场景的添加与移除</a></li><li><a href=#构建平台选择>构建平台选择</a></li><li><a href=#场景打包模式>场景打包模式</a></li></ul></li><li><a href=#场景构建与打包优化>场景构建与打包优化</a><ul><li><a href=#资源优化-1>资源优化</a></li><li><a href=#场景打包设置>场景打包设置</a></li><li><a href=#多平台支持>多平台支持</a></li><li><a href=#构建设置中的其他选项>构建设置中的其他选项</a></li></ul></li></ul></li><li><a href=#场景分块加载>场景分块加载</a><ul><li><a href=#如何实现场景分块加载>如何实现场景分块加载：</a></li><li><a href=#场景分层管理>场景分层管理</a></li></ul></li><li><a href=#触发器加载机制>触发器加载机制</a></li><li><a href=#addressable与场景加载>Addressable与场景加载</a><ul><li><a href=#addressable-asset-system>Addressable Asset System</a></li><li><a href=#场景打包为addressable>场景打包为Addressable</a></li></ul></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>