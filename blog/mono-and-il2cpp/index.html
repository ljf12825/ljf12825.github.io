<!doctype html><html lang=en><head><meta charset=UTF-8><title>Mono and IL2CPP</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Mono and IL2CPP" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Mono and IL2CPP<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p><code>Mono</code>和<code>IL2CPP</code>都是Unity的脚本运行后端（Scripting Backend），它们是两中IL语言的处理方式；Mono的处理方式类似C#程序的执行，而IL2CPP则是将其转化为C++代码，交由C++编译器处理</p><h2 id=mono>Mono</h2><p>Mono是一个跨平台的.NET运行时实现，最初由Xamarin公司开发，用来在非Windows平台上运行C#程序；Unity在早期就选择了Mono作为C#脚本运行环境</p><p><strong>核心组件：</strong></p><ul><li>Mono运行时：执行托管代码的核心引擎</li><li>即时编译器（JIT）：在运行时将IL代码编译为原生机器码</li><li>提前编译器（AOT）：可选功能，在运行前编译部分代码</li><li>类库：实现.NET基础类库</li></ul><p><strong>特点：</strong></p><ul><li>解释执行 + JIT<ul><li>脚本代码（C#） -> 编译成CIL（Common Intermediate Language，通用中间语言）</li><li>Mono会在运行时JIT（即时编译）把CIL编译成机器码执行</li></ul></li><li>跨平台性强：一次编译的C#程序可以在多个平台跑</li><li>反射支持强：很多第三方库依赖反射，Mono可以支持</li><li>灵活，但性能不如原生代码：因为JIT/解释执行比不上直接生成平台原生代码</li></ul><p><strong>局限性：</strong></p><ul><li>性能开销：JIT编译和GC可能引起卡顿</li><li>安全风险：IL代码较容易被反编译</li><li>平台限制：某些平台（如iOS）不允许JIT编译</li></ul><h2 id=il2cpp>IL2CPP</h2><p>IL2CPP是Unity自己研发的脚本后端，意为：</p><ul><li>IL -> C++ -> 平台原生代码（AOT编译）</li></ul><p><strong>工作流程：</strong></p><ol><li>C#脚本 -> 编译成IL（和Mono一样的中间语言）</li><li>Unity的IL2CPP工具链把IL翻译成C++代码</li><li>使用C++编译器编译生成目标平台的机器码</li><li>最终得到一个完全原生的二进制可执行文件</li></ol><p><strong>特点：</strong></p><ul><li>AOT（Ahead of Time编译）：运行前就已经编译成机器码，运行时无需JIT</li><li>性能更高：执行效率比Mono/JIT方案高，平均有1.2-2倍的性能提升</li><li>平台兼容性更好：特别是iOS上，苹果严格限制JIT，IL2CPP就成了唯一选择</li><li>更安全：因为代码已经转成C++，反编译难度更大（虽然还是能逆向，但比Mono的CIL难得多）</li><li>内存效率：更好的内存布局和缓存利用率</li></ul><p><strong>局限性：</strong></p><ul><li>构建时间延长：额外的转换和编译步骤</li><li>调试困难：生成的C++代码难以直接调试</li><li>灵活性降低：不支持运行时代码生成</li><li>体积增大：最终二进制文件通常更大</li></ul><h2 id=总体流程>总体流程</h2><ol><li>从C#到IL（中间语言）
无论是Mono还是IL2CPP，第一步都是一样的：</li></ol><ul><li>C#脚本（例如<code>Player.cs</code>）</li><li>Unity调用Roslyn编译器（csc.exe）把C#源码编译成IL（中间语言，Common Intermediate Language）<ul><li>输出结果是一个或多个.dll程序集（如<code>Assembly-CSharp.dll</code>）</li></ul></li></ul><p>这一步和普通.NET程序是一样的</p><ol start=2><li>Mono路线（编辑器/Debug模式常用）
Mono的工作流是：</li></ol><ul><li>加载程序集：Unity编辑器或游戏运行时，Mono加载你的<code>Assembly-Csharp.dll</code></li><li>JIT编译：Mono运行时逐个把IL转换成本地机器码，存在内存里<ul><li>执行时翻译 -> 所以叫JIT（Just-In-Time）</li></ul></li><li>执行机器码：CPU直接执行</li></ul><p>特点：</p><ul><li>编译快：改一行代码 -> 重新编译成dll -> Mono直接跑</li><li>运行稍慢：因为每次方法第一次调用时，Mono都要现编译一下</li><li>调试友好：断点、反射、热重载都支持</li></ul><ol start=3><li>IL2CPP路线（发布版本常用）
IL2CPP的流程比Mono多几步</li></ol><ul><li>C#编译成IL(.dll)（和上一步一样）</li><li>IL2CPP工具链把.dll里的IL代码转换成C++源码<ul><li>例如<code>Player.cs</code> -> <code>Assembly-CSharp.dll</code> -> <code>il2cpp</code> -> <code>Assembly-CSharp.cpp</code></li></ul></li><li>C++编译器（Clang/MSVC/GCC）把生成的C++源码编译成目标平台的原生机器码（.exe/.apk/.ipa/.so/.dll等）</li><li>运行时执行：游戏运行时直接执行已经编译好的机器码</li></ul><p>特点</p><ul><li>性能好：不需要JIT，运行时就是纯机器码，接近C++程序的速度</li><li>安全性高：反编译难度比Mono大很多</li><li>编译慢：因为每次都要跑C++编译器</li></ul><p><img src=/images/Blog/MonoandIL2CPP.png alt=流程图></p><hr><h2 id=mono-vs-il2cpp>Mono vs IL2CPP</h2><table><thead><tr><th>特性</th><th>Mono</th><th>IL2CPP</th></tr></thead><tbody><tr><td>编译方式</td><td>JIT / 解释执行</td><td>AOT（IL → C++ → 原生机器码）</td></tr><tr><td>性能</td><td>中等，依赖 JIT 优化</td><td>高，接近 C++ 原生性能</td></tr><tr><td>平台支持</td><td>跨平台，但某些平台有限制（如 iOS 禁止 JIT）</td><td>全平台，尤其是移动端和主机端首选</td></tr><tr><td>反射</td><td>完整支持</td><td>部分受限，需要 <code>link.xml</code> 保留</td></tr><tr><td>编译时间</td><td>快，开发迭代效率高</td><td>慢，需要 C++ 编译整个工程</td></tr><tr><td>安全性</td><td>容易被反编译（ILSpy 直接看源码）</td><td>较难逆向（但不是绝对安全）</td></tr></tbody></table><hr><p><strong>使用场景：</strong><br>选择Mono的情况</p><ul><li>开发阶段快速迭代</li><li>需要动态加载代码或使用反射</li><li>目标平台允许JIT执行</li><li>项目对性能要求不高</li><li>需要最小化构建体积</li></ul><p>选择IL2CPP的情况</p><ul><li>发布到iOS平台</li><li>需要最大化运行时性能</li><li>项目对安全性要求高</li><li>目标设备内存有限</li><li>使用复杂泛型或值类型</li></ul><p><strong>Unity的选择</strong></p><ul><li>编辑器模式/PC Debug模式 -> Mono（调试快、编译快）</li><li>iOS/主机平台/大多数正式发布版本 -> IL2CPP（性能、安全性）</li><li>Android -> 可以选Mono或IL2CPP（推荐IL2CPP）</li></ul><p>Unity的策略其实是</p><ul><li>开发时用Mono提高迭代效率</li><li>打包发布时用IL2CPP提高性能和安全</li></ul><hr><p><strong>迁移注意事项：</strong>
从Mono迁移到IL2CPP时需要注意：</p><ul><li>反射限制：某些反射操作可能不再工作</li><li>序列化变化：二进制序列化可能有差异</li><li>平台特定代码：需要检查平台相关代码的兼容性</li><li>第三方库：确保所有插件支持IL2CPP</li><li>构建配置：可能需要调整链接器设置</li></ul><p><a href=%7B%7Bsite.baseurl%7D%7D/posts/2025-07-18-Unity-Packaging-and-Building/>Unity Packaging and Building</a></p><p>在Unity中构建时，无法直接修改Mono或IL2CPP的底层C/C++代码，因为它们是与Unity引擎核心打包在一起的编译好的二进制库<br>但是，Mono和IL2CPP的选择并非一个简单的构建选项切换，<br>它是一项核心的架构决策，直接影响项目的性能特征、内存模型、平台兼容性以及后期优化策略<br>所以理解它们的行为差异，并以此指导上层C#代码编写、项目架构设计和性能优化策略很重要</p><h3 id=内存管理>内存管理</h3><h4 id=gc的深层机制对比>GC的深层机制对比</h4><h5 id=mono-1>Mono</h5><p>Mono使用的是BoehmGC</p><p>BoehmGC全称：Boehm-Demers-Weiser Conservative Garbage Collector，由Hans Boehm（HP实验室）编写，它是一种保守式垃圾回收器（Conservative Garbage Collector），它的主要作用是为C/C++/其他非托管语言提供垃圾回收支持；Mono在早期（Unity 4.x ~ 2018.1之前）选择直接集成现成的、稳定的BoehmGC作为默认垃圾回收器</p><p><strong>BoehmGC的工作原理</strong><br>和现代.NET CLR / Unity新GC不一样，BoehmGC是保守式GC，它具有以下特点</p><ul><li>保守式（Conservative）<ul><li>BoehmGC不严格知道哪些是指针，哪些是普通函数</li><li>它通过扫描堆栈、寄存器、全局变量的值，看起来像“指针”的东西就当作指针</li><li>好处：兼容C/C++等没有精确元数据的语言</li><li>坏处：可能会误判 -> 内存无法释放（内存泄漏风险）</li></ul></li><li>标记-清除（Mark-Sweep）<ul><li>GC暂停程序（Stop-the-world）</li><li>从根（root）对象触发，递归标记能到达的对象</li><li>未被标记的对象回收（释放内存）</li></ul></li><li>非分代（Non-generational）<ul><li>没有分代优化（不像.NET/Java那样有Gen0/Gen1/Gen2）</li><li>所以回收性能较差，容易造成长时间卡顿</li></ul></li></ul><p><strong>BoehmGC in Unity</strong>\</p><ul><li>在Unity4.x/5.x/2017.x里，C#脚本跑在Mono + BoehmGC上</li><li>问题<ul><li>GC卡顿明显（Stop-the-world很长）<ul><li>GC暂停时间与堆大小线性相关，无法规避。需将堆大小控制在严格阈值内</li><li>吞吐量较低，暂停时间不可预测；应避免在性能关键帧如（Update）中进行任何可能触发主GC的分配</li></ul></li><li>频繁分配内存（尤其是string、List<t>、Lambda）会造成就帧率抖动<ul><li>会产生大量内存碎片，且不会被压缩。这就导致长期运行后，即使总内存充足，也可能找不到连续控件而分配失败，必须重启</li></ul></li><li>没有分代 -> 小对象也要和大对象一起回收，效率差</li></ul></li></ul><p>这就是为什么老Unity游戏经常出现掉帧/卡顿，原因之一就是BoehmGC的GC暂停</p><ul><li>Mono团队后来实现了 SGen GC（Simple Generational GC）；<ul><li>分代收集器（Gen0，Gen1，Gen2）性能更好</li><li>适合C#程序的高分配频率场景</li></ul></li><li>Unity从2018.1开始引入了增量式GC（Incremental GC）：<ul><li>仍基于Boehm/SGen，但支持分步执行回收，减少一次性卡顿</li></ul></li><li>Unity未来方向：完全替换为更现代的GC（类似CoreCLR的GC），但目前仍在迭代中</li></ul><h5 id=il2cpp-1>IL2CPP</h5><p>IL2CPP不是一个运行时，它只是IL -> C++ -> 机器码的转换工具链<br>真正执行的时候，Unity还是需要一个托管内存的GC来帮忙管理C#对象，它会绑定到Unity内置的GC实现</p><ul><li>Unity2017及之前<ul><li>IL2CPP使用BoehmGC，和Mono一样</li></ul></li><li>Unity2018 ~ 现在<ul><li>IL2CPP默认使用Unity集成的libgc（基于Boehm/SGen改进版）</li><li>并且支持增量式GC（Incremental GC）</li></ul></li><li>Unity2021之后<ul><li>引入了新的可选GC模式，更接近.NET Core的分代GC思路（但还没有完全一致）</li><li>移动端、主机端IL2CPP都能用Incremental GC，减少卡顿</li></ul></li></ul><p>IL2CPP编译出来的C++代码</p><ul><li>对象分配会走Unity提供的GC_malloc等API</li><li>Unity内置的GC（基于Boehm/SGen/Incremental GC）接管这些分配</li><li>GC会在合适的时间做标记-清除或增量扫描</li></ul><h5 id=现实意义>现实意义</h5><ul><li>开发者角度<ul><li>不管是Mono还是IL2CPP，平时写C#代码都用<code>new</code>、不用手动释放对象，Unity的GC都会帮助回收</li><li>差别在于运行时体验（Mono更容易卡顿，IL2CPP + IncrementalGC更平滑）</li></ul></li><li>优化角度<ul><li>在Mono下，频繁分配会立刻暴露GC卡顿</li><li>在IL2CPP下，GC机制更强，但仍要避免频繁分配大对象（如<code>string</code>拼接、临时List）</li></ul></li></ul><h4 id=高级优化策略>高级优化策略</h4><ul><li>自定义内存分配策略：<ul><li>结构体（Struct）的极致运用：使用<code>struct</code>构建数据导向设计（DOD），将热点数据连续存储在原生数组（<code>NativeArray</code>）或栈上，彻底规避GC和缓存不命中</li><li>非托管内存（Unsafe Code）：在机制性能要求的场景（如网格处理、复杂算法），使用<code>stackalloc</code>、<code>NativeArray</code>（与Burst编译器结合）或直接<code>Marshal.AllocHGlobal</code>在非托管堆分配，完全脱离GC管辖</li></ul></li><li>GC行为预测与主动管理<ul><li>在预计的加载界面或过场动画中，主动调用<code>System.GC.Collect()</code>，在可控时机触发GC，避免在战斗或复杂场景中发生</li><li>使用Profiler监控<code>GC.Alloc</code>和<code>GC.Collect</code>调用，建立性能基线，并确保关键路径上的分配为零</li></ul></li></ul><h3 id=编译与链接>编译与链接</h3><h4 id=泛型代码共享的深层原理>泛型代码共享的深层原理</h4><ul><li>问题本质：AOT编译必须为所有泛型实例化生成具体代码</li><li>Mono（iOS AOT）：为所有值类型泛型（<code>List&lt;int></code>.<code>List&lt;MyStruct></code>）生成独立代码，导致代码爆炸</li><li>IL2CPP的解决方案：实现泛型代码共享（Generic Sharing）<ul><li>引用类型共享：<code>List&lt;AnyClass></code>共享同一份底层实现，通过运行时传入的“方法头”区分类型</li><li>值类型特定化：仍需为不同大小的值类型（如<code>int</code>, <code>long</code>,<code>MyStruct</code>）生成特定代码</li></ul></li></ul><h4 id=链接器linkerlinkxml与代码裁剪code-stripping>链接器（Linker），<code>link.xml</code>与代码裁剪（Code Stripping）</h4><h5 id=linker>Linker</h5><p>在Unity里，Linker是构建管线中的一个步骤：</p><ul><li>它的任务是分析当前C#程序集（.dll），移除未被使用的类型、方法、字段，减少最终包体大小</li><li>Unity用的是Mono Linker（后来升级为IL Linker，和.NET官方的ILLinker类似）</li></ul><h5 id=code-stripping>Code Stripping</h5><p>代码裁剪就是Linker的主要工作</p><p><strong>原理：</strong></p><ul><li>Linker会从入口点（如<code>Main()</code>、Unity的脚本生命周期方法）开始分析依赖</li><li>标记可达的类型和方法</li><li>没有被引用的代码会被裁剪掉</li></ul><p><strong>优点：</strong></p><ul><li>包体小很多（Unity自带的.NET库、第三方库很多时候只用到一点点）</li><li>运行时加载更快</li></ul><p><strong>缺点：</strong></p><ul><li>反射、序列化、动态调用的代码可能被误删，因为Linker静态分析不到<ul><li>例如：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> type = Type.GetType(<span style=color:#e6db74>&#34;MyNamespace.MyClass&#34;</span>);
</span></span><span style=display:flex><span>Activator.CreateInstance(type);
</span></span></code></pre></div>这里<code>MyClass</code>看起来没有直接引用 -> Linker可能会裁掉 -> 运行时崩溃</li></ul><h5 id=linkxml>link.xml</h5><p>为了解决“代码被误裁掉”的问题，Unity提供了link.xml配置文件，显式告诉Linker：哪些类/方法/程序集不要裁剪</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;linker&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!-- 保留整个程序集 --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;assembly</span> <span style=color:#a6e22e>fullname=</span><span style=color:#e6db74>&#34;MyGameAssembly&#34;</span> <span style=color:#a6e22e>preserve=</span><span style=color:#e6db74>&#34;all&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!-- 保留特定类型 --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;assembly</span> <span style=color:#960050;background-color:#1e0010>fullname&#34;UnityEngine&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;type</span> <span style=color:#a6e22e>fullname=</span><span style=color:#e6db74>&#34;UnityEngine.GameObject&#34;</span> <span style=color:#a6e22e>preserve=</span><span style=color:#e6db74>&#34;all&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/assembly&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!-- 保留某个类的特定方法 --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;assembly</span> <span style=color:#a6e22e>fullname=</span><span style=color:#e6db74>&#34;MyGameAssembly&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;type</span> <span style=color:#a6e22e>fullname=</span><span style=color:#e6db74>&#34;MyNamespace.MyClass&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;method</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;MyMethod&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/type&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/assembly&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/linker&gt;</span>
</span></span></code></pre></div><p><code>preserve</code>属性</p><ul><li><code>"all"</code>保留整个类型/程序集</li><li><code>"fields"</code>只保留字段</li><li><code>"methods"</code>只保留方法</li></ul><p>Unity规定：</p><ul><li><code>link.xml</code>必须放在Assets文件夹或它的子目录中<ul><li><code>Assets/link.xml</code></li><li>或<code>Assets/Configs/link.xml</code></li><li>或<code>Assets/Plugins/YourLib/link.xml</code></li></ul></li><li>名字必须是<code>link.xml</code>（不能改名，否则Unity不会识别）</li></ul><p>只要它在<code>Assets</code>目录下，Unity构建时就会自动收集并传递给Linker</p><p>多个link.xml的情况</p><ul><li>可以在项目里放置多个<code>link.xml</code>（比如第三方库自带一个，自己再写一个）</li><li>Unity构建时会合并所有link.xml文件</li><li>如果同一个类型/程序集在多个文件里都有配置，Unity会做并集，不会冲突</li></ul><p>构件时打开Editor log，会看到<code>link.xml</code>被解析的日志</p><h5 id=实际使用场景>实际使用场景</h5><p>需要写<code>link.xml</code>的情况</p><ol><li>反射：</li></ol><ul><li>Newtonsoft.Json/Odin Serializer / XLua这类库经常用反射动态创建类型</li><li>必须告诉Linker保留哪些类型</li></ul><ol start=2><li>序列化：</li></ol><ul><li>Unity的序列化（尤其是<code>ScriptableObject</code>、<code>JsonUtility</code>）可能用到未显式引用的字段</li></ul><ol start=3><li>热更新框架</li></ol><ul><li>HybridCLR/XLua/ILRuntime依赖反射加载C#，必须配合link.xml</li></ul><h5 id=调试与问题定位>调试与问题定位</h5><ul><li>构建后报错MissingMethodException/TypeLoadException 很可能是Linker裁掉了代码</li><li>解决方法：<ul><li>确认是不是动态调用的代码</li><li>在<code>link.xml</code>中声明保留</li><li>重新打包</li></ul></li></ul><h3 id=平台特定深度调优>平台特定深度调优</h3><ol><li><p>iOS</p></li><li><p>Android</p></li><li><p>WebGL</p></li></ol><hr><h3 id=未来发展趋势>未来发展趋势</h3><p>Unity正在持续改进IL2CPP，缩短构建时间、增强调试支持、改进泛型处理、更好的异常处理、增量构建支持等。随着Unity的发展，IL2CPP正成为更主流的选择，特别是在性能敏感和移动平台项目中</p><ul><li>CoreCLR：Unity正在投资将.NET Core运行时（CoreCLR）集成为第三个脚本后端。这将提供最新的C#语言特性、更高的性能和微软的官方支持。关注其进展，评估其与IL2CPP的性能差异</li><li>Burst编译器：对于机制性能的数学、图形算法，Burst是终极解决方案。它将C# Job编译为高度优化的原生代码，性能堪比C++<ul><li>高级用法：将Burst与IL2CPP结合，使用Burst处理计算密集型任务，IL2CPP处理游戏逻辑，形成高性能混合架构</li></ul></li></ul><p><strong>架构层面的考量</strong></p><ul><li>热更新需求：如果项目有强烈的热更新需求（如某些手游），Mono（在允许JIT的平台）配合像<code>HybridCLR</code>这样的方案是目前的主流选择。IL2CPP由于其AOT特性，热更新需要更复杂的技术（如Lua）</li></ul></div><nav class=post-nav><a href=/blog/model/ class=hover:underline>pre: Model</a>
<a href=/blog/monobehaviour/ class=hover:underline>next: MonoBehaviour</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#mono>Mono</a></li><li><a href=#il2cpp>IL2CPP</a></li><li><a href=#总体流程>总体流程</a></li><li><a href=#mono-vs-il2cpp>Mono vs IL2CPP</a><ul><li><a href=#内存管理>内存管理</a><ul><li><a href=#gc的深层机制对比>GC的深层机制对比</a><ul><li><a href=#mono-1>Mono</a></li><li><a href=#il2cpp-1>IL2CPP</a></li><li><a href=#现实意义>现实意义</a></li></ul></li><li><a href=#高级优化策略>高级优化策略</a></li></ul></li><li><a href=#编译与链接>编译与链接</a><ul><li><a href=#泛型代码共享的深层原理>泛型代码共享的深层原理</a></li><li><a href=#链接器linkerlinkxml与代码裁剪code-stripping>链接器（Linker），<code>link.xml</code>与代码裁剪（Code Stripping）</a><ul><li><a href=#linker>Linker</a></li><li><a href=#code-stripping>Code Stripping</a></li><li><a href=#linkxml>link.xml</a></li><li><a href=#实际使用场景>实际使用场景</a></li><li><a href=#调试与问题定位>调试与问题定位</a></li></ul></li></ul></li><li><a href=#平台特定深度调优>平台特定深度调优</a></li><li><a href=#未来发展趋势>未来发展趋势</a></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>