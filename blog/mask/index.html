<!doctype html><html lang=en><head><meta charset=UTF-8><title>Mask</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=Mask class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Mask<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>遮罩，用于实现遮挡效果，控制子物体的显示区域</p><p><img src=/assets/images/MaskPanel.jpg alt=MaskPanel></p><h2 id=mask>Mask</h2><p><code>Mask</code>用于裁剪UI子元素的显示区域，通常搭配图片、Scroll View、头像裁剪等使用</p><h3 id=核心功能和行为>核心功能和行为</h3><table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td>子物体只在 Mask 图像区域内显示</td><td>超出部分不可见（不销毁，只裁剪）</td></tr><tr><td>遮罩区域基于 <code>Image</code> 的透明度</td><td>非透明部分就是显示区域</td></tr><tr><td>不支持软遮罩（软边缘）</td><td>默认是硬裁剪，想要软遮罩需用 Shader 或 <code>UIEffect</code> 等插件</td></tr></tbody></table><h3 id=使用方法>使用方法</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>MaskParent(Image + Mask)
</span></span><span style=display:flex><span>|___Content(Text / Image /等UI)
</span></span></code></pre></div><ul><li>父物体挂<code>Image</code> + <code>Mask</code>，并设置图片为遮罩区域</li><li>子物体放置UI内容，超出遮罩图形范围会被裁剪</li></ul><h3 id=常见用途>常见用途</h3><table><thead><tr><th>场景</th><th>使用方式</th></tr></thead><tbody><tr><td>ScrollView 滚动列表</td><td>Viewport 挂 <code>Image + Mask</code>，内容只显示在视窗中</td></tr><tr><td>圆形头像裁剪</td><td>使用圆形 <code>Image + Mask</code> 裁剪方形头像图片</td></tr><tr><td>进度条遮罩</td><td>遮罩下滑动另一个图片或文字，实现“擦除”或“揭示”效果</td></tr><tr><td>文字遮挡/选中效果</td><td>对文字进行遮罩只显示一部分或高亮部分</td></tr></tbody></table><h3 id=裁剪区域>裁剪区域</h3><p><code>Mask</code>裁剪的区域由挂载<code>Mask</code>的GameObject的<code>Image</code>的Alpha通道决定</p><table><thead><tr><th>Image 类型</th><th>Mask 效果</th></tr></thead><tbody><tr><td>Sprite (Alpha通道)</td><td>透明处裁剪，实色处显示</td></tr><tr><td>Sprite (无 Alpha 通道)</td><td>整张图片为裁剪区域</td></tr><tr><td>没有 Image 组件</td><td><code>Mask</code> 不起作用（它依赖 <code>Image</code>）</td></tr></tbody></table><blockquote><p>Image的<code>Raycast Target</code>设置不影响裁剪，但影响事件响应</p></blockquote><h2 id=rect-mask-2d>Rect Mask 2D</h2><p><code>RectMask2D</code>是Unity UI中专为矩形区域裁剪而设计的遮罩组件，功能和<code>Mask</code>类似，但更高效、轻量，只适用于矩形裁剪</p><table><thead><tr><th>特性</th><th><code>RectMask2D</code></th><th><code>Mask</code></th></tr></thead><tbody><tr><td><strong>遮罩形状</strong></td><td>只能是矩形</td><td>任意形状（基于 alpha 通道）</td></tr><tr><td><strong>性能</strong></td><td>高效</td><td>相对较低（使用 Stencil Buffer）</td></tr><tr><td><strong>软遮罩支持</strong></td><td>不支持</td><td>也不支持（需 Shader 实现）</td></tr><tr><td><strong>需要 Image 吗</strong></td><td>不需要</td><td>必须有 Image（带 alpha）</td></tr><tr><td><strong>ScrollView 默认用谁？</strong></td><td><code>RectMask2D</code></td><td>不是默认组件</td></tr></tbody></table><ul><li>Softness：控制边缘模糊程度，让裁剪区域的边缘不再是生硬的“硬切线”，而是具有渐隐的柔和效果，也就是软遮罩</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>RectMask2D.softness = new Vector2(x, y);
</span></span></code></pre></div><table><thead><tr><th>分量</th><th>含义</th></tr></thead><tbody><tr><td><code>x</code></td><td>左右边缘的模糊像素距离</td></tr><tr><td><code>y</code></td><td>上下边缘的模糊像素距离</td></tr></tbody></table><ul><li>单位是像素数（会随Canvas的Pixel-Per-Unit放大缩小）</li><li>值越大，模糊过渡越宽</li><li>值为0时，表现为传统的硬遮罩</li></ul><h3 id=结构示例聊天滚动列表>结构示例：聊天滚动列表</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Scroll View
</span></span><span style=display:flex><span>|——Viewport(RectMask2D)
</span></span><span style=display:flex><span>      |__Content（垂直布局 + 自动扩展）
</span></span></code></pre></div><ul><li><code>Viewport</code>是可视区域，挂<code>RectMask2D</code></li><li>子元素（Content）会被限制在Viewport范围内，超出部分不可见</li></ul><h3 id=工作原理>工作原理</h3><ul><li>裁剪区域 = RectTransform可视区域</li><li>所有超出这个矩形范围的子元素将不被渲染</li><li>实现方式基于剪裁矩形，无需stencil buffer，比<code>Mask</code>性能更高</li><li>不依赖图片、不使用alpha通道</li></ul><h2 id=sprite-mask>Sprite Mask</h2><p><code>Sprite Mask</code>时Unity中专为2D精灵系统设计的遮罩组件，用来让某些Sprite按遮罩的形状显示或隐藏，相比UI中的传统<code>Mask</code>和<code>RectMask2D</code>，它属于2D渲染层级遮罩机制，用于SpriteRenderer渲染对象的裁剪</p><p><code>Sprite Mask</code>是一个形状遮罩，允许受控的Sprite只在遮罩区域内渲染，超出部分将不可见</p><p>它通常用于：</p><ul><li>地图”探索雾“</li><li>道具高亮显示</li><li>角色潜行、隐身剪影</li><li>Sprite动画部分揭示</li><li>类似”圆形裁剪头像“的2D实现</li></ul><h3 id=使用结构示例>使用结构示例</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>SpriteMask (Mask 控制区域)
</span></span><span style=display:flex><span>└── SpriteA (Renderer 被遮罩)
</span></span></code></pre></div><p>或者平行结构也可以</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>SpriteMask
</span></span><span style=display:flex><span>SpriteA (设置受 Sprite Mask 控制)
</span></span></code></pre></div><h3 id=使用方法-1>使用方法</h3><p>1.添加Sprite Mask</p><ul><li>添加一个空物体，挂<code>Sprite Mask</code>组件</li><li>设置遮罩图形：选择一个带alpha的Sprite（通常是圆形/自定义形状）</li></ul><p>2.被遮罩的Sprite设置：<br>在<code>Sprite Renderer</code>上：</p><ul><li>Mask Interaction设置为：<ul><li><code>None</code>：不受任何遮罩影响</li><li><code>Visible Inside Mask</code>：仅在遮罩区域内可见</li><li><code>Visible Outside Mask</code>：仅在遮罩区域外可见</li></ul></li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><strong>Sprite</strong></td><td>遮罩形状，使用 Sprite 的 alpha 通道</td></tr><tr><td><strong>Alpha Cutoff</strong></td><td>判定透明与非透明的阈值</td></tr><tr><td><strong>Custom Range</strong></td><td>设置可见层范围（Sorting Layer 和 Order）</td></tr><tr><td><strong>Sprite Sort Point</strong></td><td>以哪个点作为Sprite的排序基准点</td></tr></tbody></table><h3 id=示例>示例</h3><h4 id=地图探索雾系统>地图探索雾系统</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>地图遮罩 (SpriteMask：黑色圆形)
</span></span><span style=display:flex><span>角色头顶 (Sprite：Visible Inside Mask)
</span></span><span style=display:flex><span>→ 角色周围区域可见，其余为黑
</span></span></code></pre></div><h4 id=裁剪头像>裁剪头像</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>头像边框 (圆形 SpriteMask)
</span></span><span style=display:flex><span>头像图片 (SpriteRenderer：Visible Inside Mask)
</span></span></code></pre></div><h4 id=潜行效果>潜行效果</h4><p>遮罩外隐藏角色：</p><ul><li>SpriteRenderer设置为<code>Visible Inside Mask</code></li><li>动画移动<code>SpriteMask</code>即可动态揭示角色</li></ul></div><nav class=post-nav><a href=/blog/loose-coupling/ class=hover:underline>pre: Loose Coupling</a>
<a href=/blog/mesh/ class=hover:underline>next: Mesh</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#mask>Mask</a><ul><li><a href=#核心功能和行为>核心功能和行为</a></li><li><a href=#使用方法>使用方法</a></li><li><a href=#常见用途>常见用途</a></li><li><a href=#裁剪区域>裁剪区域</a></li></ul></li><li><a href=#rect-mask-2d>Rect Mask 2D</a><ul><li><a href=#结构示例聊天滚动列表>结构示例：聊天滚动列表</a></li><li><a href=#工作原理>工作原理</a></li></ul></li><li><a href=#sprite-mask>Sprite Mask</a><ul><li><a href=#使用结构示例>使用结构示例</a></li><li><a href=#使用方法-1>使用方法</a></li><li><a href=#示例>示例</a><ul><li><a href=#地图探索雾系统>地图探索雾系统</a></li><li><a href=#裁剪头像>裁剪头像</a></li><li><a href=#潜行效果>潜行效果</a></li></ul></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>