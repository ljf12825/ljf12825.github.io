<!doctype html><html lang=en><head><meta charset=UTF-8><title>Mesh</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=Mesh class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Mesh<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>Unity中的Mesh（网格）是一切3D模型、地形、角色、道具、甚至某些UI元素的几何基础，是“物体的骨架”<br>包含顶点、面、法线、UV、颜色等数据，是3D图形渲染的核心单位</p><h2 id=mesh的构成>Mesh的构成</h2><table><thead><tr><th>数据</th><th>作用</th></tr></thead><tbody><tr><td><strong>顶点（Vertices）</strong></td><td>网格的点，构成形状的基础</td></tr><tr><td><strong>三角形（Triangles）</strong></td><td>每三个顶点组成一个三角面，是渲染最小单元</td></tr><tr><td><strong>法线（Normals）</strong></td><td>每个顶点的方向，用于光照计算</td></tr><tr><td><strong>UV 坐标（UVs）</strong></td><td>纹理坐标，用来决定贴图怎么铺在模型上</td></tr><tr><td><strong>顶点色（Colors）</strong></td><td>每个顶点的颜色，用于特效、调色</td></tr><tr><td><strong>切线（Tangents）</strong></td><td>用于法线贴图的方向辅助向量</td></tr></tbody></table><p>这些数据最终会交给GPU，进行渲染</p><h2 id=mesh在unity中的用途>Mesh在Unity中的用途</h2><table><thead><tr><th>用途</th><th>举例</th></tr></thead><tbody><tr><td>渲染模型</td><td>静态模型、角色模型、环境场景</td></tr><tr><td>自定义几何体</td><td>Procedural Mesh（如地形、波浪、水面）</td></tr><tr><td>碰撞体数据</td><td>Mesh Collider 也使用 Mesh</td></tr><tr><td>特效/轨迹</td><td>线性 Mesh（如剑气轨迹、能量波）</td></tr><tr><td>角色换装</td><td>动态换装系统中组合不同 Mesh</td></tr></tbody></table><h2 id=如何创建操作mesh>如何创建、操作Mesh</h2><p>Unity提供<code>Mesh</code>类，支持自定义几何体</p><h3 id=示例创建一个简单三角形mesh>示例：创建一个简单三角形Mesh</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Mesh mesh = <span style=color:#66d9ef>new</span> Mesh();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Vector3[] vertices = <span style=color:#66d9ef>new</span> Vector3[]
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>[] triangles = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[] {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mesh.vertices = vertices;
</span></span><span style=display:flex><span>mesh.triangles = triangles;
</span></span><span style=display:flex><span>mesh.RecalculateNormals(); <span style=color:#75715e>// 自动生成法线</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>GetComponent&lt;MeshFilter&gt;().mesh = mesh;
</span></span></code></pre></div><h2 id=meshfilter-和-meshrenderer>MeshFilter 和 MeshRenderer</h2><p>在Unity中，<code>MeshFilter</code>和<code>MeshRenderer</code>是构成立体物体（3D模型）渲染的核心组件</p><ul><li><code>MeshFilter</code>：提供集合形状（顶点、三角形等）</li><li><code>MeshRenderer</code>：将形状渲染到屏幕上（使用材质、光照等）</li></ul><p><img src=/assets/images/MeshFilterandMeshRenderer.jpg alt=MeshFilterandMeshRenderer>;</p><h3 id=meshfilter提供模型数据>MeshFilter：提供模型数据</h3><ul><li>MeshFilter包含一个Mesh对象，这是3D模型的几何体，比如立方体、球体、角色模型等</li><li>这些Mesh是<code>.fbx</code>、<code>.obj</code>导入的，或运行时通过代码生成</li></ul><p>可以通过以下方式获取或赋值Mesh</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>MeshFilter mf = GetComponenet&lt;MeshFilter&gt;();
</span></span><span style=display:flex><span>Mesh mesh = mf.mesh; <span style=color:#75715e>// 当前使用的实例化mesh</span>
</span></span><span style=display:flex><span>mf.mesh = someOtherMesh; <span style=color:#75715e>// 替换为新的Mesh</span>
</span></span></code></pre></div><blockquote><p><code>.mesh</code>是一个实例副本，你修改它不会影响原始资源；<code>.sharedMesh</code>是共享原始资源</p></blockquote><h3 id=meshrenderer负责把模型画出来>MeshRenderer：负责把模型画出来</h3><ul><li>MeshRenderer负责把<code>MeshFilter</code>提供的几何体渲染到屏幕上</li><li>控制材质、阴影、光照、剔除、光照探针等参数</li></ul><h4 id=面板参数>面板参数</h4><h5 id=element-0-1>Element 0, 1&mldr;</h5><ul><li>控制使用哪个材质渲染对应子网格</li><li>通常一个对象只有一个材质，如果是多个SubMesh，会有多个材质槽
适用场景：</li><li>多材质角色：身体/衣服/装备使用不同的材质</li><li>不同部件不同特效：一个材质透明，一个闪光</li></ul><h5 id=lighting>Lighting</h5><p><strong>Cast Shadows(投射阴影)</strong></p><ul><li>控制该物体是否想地面等对象投影</li><li>选项：<ul><li><code>On</code>：始终投射阴影</li><li><code>Off</code>：不投影</li><li><code>Two Sided</code>：背面也能投影（适用于双面平面）</li><li><code>Shadows Only</code>：只显示阴影，不渲染模型本体（隐形）</li></ul></li></ul><p><strong>Receive Shadows(接收阴影)</strong></p><ul><li>是否接收其他物体的阴影（比如树被房子挡住时）</li><li>关闭可提升性能，但视觉上可能不真实</li></ul><h5 id=probes探针相关环境光间接光>Probes（探针相关，环境光/间接光）</h5><p>在Unity中，<code>Probes</code>是一类帮助处理间接光照和环境反射的技术，目的是让动态物体（如角色、道具）在光照和反射效果上看起来更自然，融入环境</p><p><strong>为什么需要探针</strong></p><p>Unity中有两类光照</p><ul><li>直接光照：来自灯光（如Dirctional Light）</li><li>间接光照：来自物体间的反弹、环境照明</li></ul><p>对于静态物体，Unity可以烘焙光照贴图（Lightmap）来记录间接光照<br>但动态物体（移动的角色、道具）不能使用烘焙光照贴图，这时候就需要探针来帮它“感受环境的光”</p><blockquote><p>探针是一种轻量级采样方式，让动态物体获得类似烘焙光照/环境反射的技术，从而避免使用高开销的实时光照和实时反射</p></blockquote><p><strong>Light Probes</strong></p><ul><li>是否接受光照探针（动态光照采样，用于小物体，如动态角色）</li><li>一般设置为<code>Blend Probes</code>（自动采样探针）</li></ul><p><strong>Reflection Probes</strong></p><ul><li>是否使用反射探针（环境反射用）</li><li>选项：<ul><li><code>Off</code></li><li><code>Blend Probes</code>（常用）</li><li><code>Simple</code>（不混合，只是用最近一个）</li></ul></li></ul><h5 id=additional-settings附加设置>Additional Settings（附加设置）</h5><p><strong>Motion Vectors</strong></p><ul><li>控制是否为该物体生成运动矢量（供后处理如动态模糊使用）</li><li>推荐开启：<code>Per Object Motion</code></li></ul><p><strong>Lightmap Static</strong></p><ul><li>如果你将对象标记为静态，会自动启用Lightmap烘焙支持</li><li>静态光照适用于不动的建筑、地面等</li></ul></div><nav class=post-nav><a href=/blog/mask/ class=hover:underline>pre: Mask</a>
<a href=/blog/ml-agents/ class=hover:underline>next: ML Agents</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#mesh的构成>Mesh的构成</a></li><li><a href=#mesh在unity中的用途>Mesh在Unity中的用途</a></li><li><a href=#如何创建操作mesh>如何创建、操作Mesh</a><ul><li><a href=#示例创建一个简单三角形mesh>示例：创建一个简单三角形Mesh</a></li></ul></li><li><a href=#meshfilter-和-meshrenderer>MeshFilter 和 MeshRenderer</a><ul><li><a href=#meshfilter提供模型数据>MeshFilter：提供模型数据</a></li><li><a href=#meshrenderer负责把模型画出来>MeshRenderer：负责把模型画出来</a><ul><li><a href=#面板参数>面板参数</a><ul><li><a href=#element-0-1>Element 0, 1&mldr;</a></li><li><a href=#lighting>Lighting</a></li><li><a href=#probes探针相关环境光间接光>Probes（探针相关，环境光/间接光）</a></li><li><a href=#additional-settings附加设置>Additional Settings（附加设置）</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved</p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>