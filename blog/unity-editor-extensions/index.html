<!doctype html><html lang=en><head><meta charset=UTF-8><title>Unity Editor Extensions</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Unity Editor Extensions" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Unity Editor Extensions<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>Unity编辑器扩展就是用C#编写一些工具或界面，去增强Unity自带的编辑器功能，从而让开发流程更高效、更可控<br>它的本质是：利用UnityEditor API在编辑模式下定制Inspector、菜单、窗口、场景视图、资源导入等功能</p><h2 id=基础概念>基础概念</h2><ul><li>运行时脚本 vs 编辑器脚本<ul><li>运行时脚本：放在普通文件夹，打包后在游戏里运行</li><li>编辑器脚本：放在<code>Editor</code>文件夹下，只在编辑器运行，不会打包进游戏</li><li>编辑器脚本需要引用<code>UnityEditor</code>命名空间（注意它在运行时不可用）</li></ul></li><li>目的<ul><li>节省重复操作时间（比如批量设置材质、自动生成Prefab）</li><li>提供更直观的可视化编辑界面</li><li>增强调试能力（自定义日志、场景可视化）</li></ul></li></ul><h2 id=常见扩展方式>常见扩展方式</h2><p><strong>自定义Inspector</strong><br>让某个组件在Inspector面板中显示定制的界面</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[CustomEditor(typeof(MyComponent))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyComponentEditor</span> : Editor
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInspectorGUI()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> myComp = (MyComponent)target;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        EditorGUILayout.LabelField(<span style=color:#e6db74>&#34;自定义字段&#34;</span>);
</span></span><span style=display:flex><span>        myComp.health = EditorGUILayout.IntSlider(<span style=color:#e6db74>&#34;生命值&#34;</span>, myComp.health, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;重置生命值&#34;</span>)) myComp.health = <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果值改变，标记为脏数据</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (GUI.changed) EditorUtility.SetDirty(myComp);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>优点：</p><ul><li>把复杂数据可视化</li><li>增加按钮、滑条等直接操作数据</li></ul><p><strong>自定义窗口（EditorWindow）</strong><br>可以创建一个独立的工具窗口，比如批量修改工具、关卡生成器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyToolWindow</span> : EditorWindow
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> newName = <span style=color:#e6db74>&#34;Object&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [MenuItem(&#34;Tools/批量改名工具&#34;)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> ShowWindow() =&gt; GetWindow&lt;MyToolWindow&gt;(<span style=color:#e6db74>&#34;批量改名&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnGUI()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        GUILayout.Label(<span style=color:#e6db74>&#34;改名设置&#34;</span>, EditorStyles.boldLabel);
</span></span><span style=display:flex><span>        newName = EditorGUILayout.TextField(<span style=color:#e6db74>&#34;新名字&#34;</span>, newName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;改名选中物体&#34;</span>))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> obj <span style=color:#66d9ef>in</span> Selection.objects) obj.name = newName;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>菜单扩展</strong>
在Unity顶部菜单栏或右键菜单添加功能</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[MenuItem(&#34;GameObject/重置位置&#34;, false, 0)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> ResetPosition()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Selection.activeTransform != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        Selection.activeTransform.position = Vector3.zero;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>参数解释<ul><li>路径<code>"GameObject/重置位置"</code>决定菜单位置</li><li>第二个参数是是否加到菜单最上面（true为优先）</li><li>第三个参数是排序优先级</li></ul></li></ul><p><strong>SceneView扩展</strong><br>在场景视图中绘制自定义Gizmos或工具按钮</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[CustomEditor(typeof(Transform))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TransformGizmo</span> : Editor
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnSceneGUI()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Handles.Label(((Transform)target).position + Vector3.up * <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;这是一个提示&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以绘制线条、形状、文字等辅助开发</p><p><strong>资源导入扩展（AssetPostprocessor）</strong>
拦截模型、贴图、音频导入过程，自动修改导入设置</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyTextureImporter</span> : AssetPostprocessor
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnPreprocessTexture()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> importer = (TextureImporter)assetImporter;
</span></span><span style=display:flex><span>        importer.textureType = TextureImporterType.Sprite;
</span></span><span style=display:flex><span>        importer.mipmapEnabled = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>适合团队统一资源规划（比如所有贴图都关掉mipmap）</li></ul><h2 id=unityeditor>UnityEditor</h2><p><code>UnityEditor</code>是Unity提供的一套专门用于编辑器扩展的API，这些类和方法只能在编辑器里运行，不会包含在游戏打包中；所以，所有用到<code>UnityEditor</code>的代码，必须放在Editor文件夹下</p><ul><li><code>UnityEngine</code>：运行时API（游戏打包也能用）</li><li><code>UnityEditor</code>：编辑器API（只能在编辑器中使用）</li></ul><h3 id=核心作用>核心作用</h3><p>主要分成五大类功能</p><ol><li>自定义Inspector和窗口</li></ol><ul><li><code>Editor</code>：写自定义Inspector的基类</li><li><code>EditorWindow</code>：写独立工具窗口的基类</li><li><code>EditorGUILayout</code>/<code>EditorGUI</code>：绘制各种控件（按钮、滑条、文本框等）</li><li><code>PropertyDrawer</code>：为字段/属性写统一的自定义显式</li></ul><ol start=2><li>菜单和快捷工具</li></ol><ul><li><code>MenuItem</code>：给Unity顶部菜单栏或右键菜单加功能</li><li><code>EditorUtility</code>：提供一些编辑器辅助功能（弹窗、选择路径、标记对象为Dirty）</li><li><code>EditorApplication</code>：控制编辑器运行，比如监听playMode切换、编译回调</li></ul><ol start=3><li>资源与导入</li></ol><ul><li><code>AssetDatabase</code>：操作资源（创建、删除、移动、加载、刷新）</li><li><code>AssetPostprocessor</code>：拦截资源导入事件（模型、材质、贴图、音频等）</li><li><code>PrefabUtility</code>：处理Prefab（应用修改、还原、实例化）</li></ul><ol start=4><li>场景与物体操作</li></ol><ul><li><code>Handles</code>：在Scene视图中绘制辅助线、按钮、文本</li><li><code>SceneView</code>：扩展场景视图，监听事件或绘制GUI</li><li><code>Selection</code>：获取/设置当前选中的对象</li><li><code>EditorSceneManager</code>：控制场景的保存、打开、新建</li></ul><ol start=5><li>调试与分析</li></ol><ul><li><code>EditorGUIUtility</code>：常用UI工具，比如加载内置图标</li><li><code>Profiler</code>：性能分析相关API（部分在UnityEditor下）</li><li><code>Debug</code>：（即在UnityEngine也在UnityEditor，有编辑器专用功能）</li></ul><h3 id=注意事项>注意事项</h3><ol><li>不要在运行时脚本里因哟个UnityEditor，否则打包错误</li></ol><ul><li>正确做法：把编辑器脚本放到<code>Editor/</code>文件夹</li><li>或者用<code>#if UNITY_EDITOR...#endif</code>包裹</li></ul><ol start=2><li>编辑器API不能在游戏运行时使用，比如<code>AssetDatabase.LoadAssetAtPath</code>打包后无效</li><li>一般项目里会把编辑器扩展集中到</li></ol><ul><li><code>Assets/Editor/</code></li><li>或者做成Unity Package的<code>Editor</code>文件夹</li></ul><h2 id=serializedobject--serializedproperty>SerializedObject / SerializedProperty</h2><p>在自定义Inspector的时候，通常会写类似这样的代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> myComp = (MyComponent)target;
</span></span><span style=display:flex><span>myComp.health = EditorGUILayout.IntField(<span style=color:#e6db74>&#34;生命值&#34;</span>, myComp.health);
</span></span></code></pre></div><p>这样确实能显式和修改数值，但有几个严重问题</p><ul><li>不支持Undo/Redo（撤销/重做功能会失效）</li><li>不支持多对象编辑（一次选中多个物体时，只会修改一个）</li><li>不保证序列化（有些数据Unity不会正确保存到磁盘）</li></ul><p>为了解决这些问题，Unity提供了序列化编辑API</p><ul><li>SerializedObject：代表一个序列化的对象（通常是<code>MonoBehaviour</code>、<code>ScriptableObject</code>等）</li><li>SerializedProperty：代表这个对象中的某个序列化字段</li></ul><h3 id=核心概念>核心概念</h3><table><thead><tr><th>类/方法</th><th>作用</th></tr></thead><tbody><tr><td><code>SerializedObject</code></td><td>打开 Unity 对象的序列化数据流，可同时针对多个对象</td></tr><tr><td><code>SerializedProperty</code></td><td>访问 SerializedObject 内的字段</td></tr><tr><td><code>ApplyModifiedProperties()</code></td><td>将修改写回对象，并触发 Undo/Prefab 系统</td></tr><tr><td><code>Update()</code></td><td>刷新 SerializedObject，如果对象在外部被修改过，需要先 Update</td></tr><tr><td><code>OnValidate()</code></td><td>MonoBehaviour 回调，确保数据合法性（如 Range）</td></tr></tbody></table><blockquote><p>通过<code>SerializedProperty</code>修改数据不会走属性setter，因此需要在<code>OnValidate()</code>或其他地方做数据校验</p></blockquote><h3 id=serializedobject>SerializedObject</h3><p><code>SerializedObject</code>就是把一个Unity对象包装成可序列化的版本</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>SerializedObject so = <span style=color:#66d9ef>new</span> SerializedObject(target);
</span></span></code></pre></div><ul><li><code>target</code>一般是<code>MonoBehaviour</code>或<code>ScriptableObject</code></li></ul><h3 id=serializedproperty>SerializedProperty</h3><p><code>SerializedProperty</code>是对单个字段的包装</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>SerializedProperty healthProp = so.FindProperty(<span style=color:#e6db74>&#34;health&#34;</span>);
</span></span></code></pre></div><p>关键点：这里用的是字符串名字（字段名必须是<code>public</code>或<code>[SerializeField]</code>）<br>然后用<code>EditorGUILayout.PropertyField</code>绘制</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>EditorGUILayout.PropertyField(healthProp, <span style=color:#66d9ef>new</span> GUIContent(<span style=color:#e6db74>&#34;生命值&#34;</span>));
</span></span></code></pre></div><h3 id=示例>示例</h3><p>假设有一个脚本</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyComponent</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> health = <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [SerializeField]</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> playerName = <span style=color:#e6db74>&#34;Hero&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对应的自定义Inspector</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngnine;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[CustomEditor(typeof(MyComponent))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyComponentEditor</span> : Editor
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    SerializedObject so;
</span></span><span style=display:flex><span>    SerializedProperty healthProp;
</span></span><span style=display:flex><span>    SerializedProperty nameProp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnEnable()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        so = <span style=color:#66d9ef>new</span> SerializedObject(target); <span style=color:#75715e>// 包装目标对象</span>
</span></span><span style=display:flex><span>        healthProp = so.FindProperty(<span style=color:#e6db74>&#34;health&#34;</span>);
</span></span><span style=display:flex><span>        nameProp = so.FindProperty(<span style=color:#e6db74>&#34;playerName&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInspectorGUI()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        so.Update(); <span style=color:#75715e>// 必须，包装数据最新</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        EditorGUILayout.PropertyField(healthProp);
</span></span><span style=display:flex><span>        EditorGUILayout.PropertyField(nameProp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;重置生命值&#34;</span>))
</span></span><span style=display:flex><span>            healthProp.intValue = <span style=color:#ae81ff>100</span>; <span style=color:#75715e>// 修改属性</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        so.ApplyModifiedProperties(); <span style=color:#75715e>// 必须，应用修改</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样做的好处</p><ul><li>Unity自动支持Undo/Redo</li><li>多选对象时，Unity会正确处理</li><li>支持Prefab override（预制体差异化显式）</li></ul><h3 id=注意事项-1>注意事项</h3><ol><li>多对象编辑</li></ol><ul><li><code>SerializedObject</code>可以针对多个对象</li><li>读取<code>SerializedProperty</code>的值只会返回第一个对象的值，赋值会应用到所有对象</li></ul><ol start=2><li>独立数据流</li></ol><ul><li>两个<code>SerializedObject</code>实例只想同一个目标对象时，数据流是独立的</li><li>如果跨多帧保存，需要手动调用<code>Update()</code>同步</li></ul><ol start=3><li>Undo与Prefab</li></ol><ul><li>使用<code>SerializedObject</code>自动支持Undo系统</li><li>支持Inspector的Prefab override样式</li></ul><ol start=4><li>字段合法性</li></ol><ul><li>属性setter不会生效</li><li>Range、Clamp等需要在<code>OnValidate()</code>中处理</li></ul><h2 id=editorguilayout-vs-guilayout>EditorGUILayout vs GUILayout</h2><ol><li>GUILayout</li></ol><ul><li>命名空间：<code>UnityEngine</code></li><li>用途：运行时（Runtime）或编辑器（Editor）中动态布局的GUI</li><li>特性：<ul><li>自动布局控件（自动排列，不需要自己计算位置）</li><li>可在<code>OnGUI()</code>中使用</li><li>支持按钮、标签、文本框、滑动条等控件</li></ul></li><li>常用场景：工具窗口、运行时调试界面、游戏内GUI</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> OnGUI()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    GUILayout.Label(<span style=color:#e6db74>&#34;Hello World!&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Click Me&#34;</span>))
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;Button clicked!&#34;</span>);
</span></span><span style=display:flex><span>    GUILayout.TextField(<span style=color:#e6db74>&#34;Input here&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>EditorGUILayout</li></ol><ul><li>命名空间：<code>UnityEditor</code></li><li>用途：专门用于自定义Inspector和编辑器窗口</li><li>特性：<ul><li>可以直接绑定<code>SerializedProperty</code>，自动支持Undo、Prefab、Inspector刷新</li><li>自动生成字段UI（包括对象引用、枚举、数组等）</li><li>自动处理类型（int, float, Vector3, Color, Object等）</li></ul></li><li>常用场景：自定义Inspector、自定义EditorWindow、Editor Tools</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[CustomEditor(typeof(MyComponent))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyComponentEditor</span> : Editor
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    SerializedProperty speedProp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnEnable() =&gt; speedProp = serializedObject.FindProperty(<span style=color:#e6db74>&#34;speed&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInspectorGUI()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        serializedObject.Update();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        EditorGUILayout.PropertyField(speedProp); <span style=color:#75715e>// 自动绘制 Inspector组件</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Reset Speed&#34;</span>)) <span style=color:#75715e>// EditorGUILayout 和 GUILayout都能用</span>
</span></span><span style=display:flex><span>            speedProp.floatValue = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        serializedObject.ApplyModifiedProperties();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><table><thead><tr><th>特性</th><th>GUILayout</th><th>EditorGUILayout</th></tr></thead><tbody><tr><td>所属命名空间</td><td><code>UnityEngine</code></td><td><code>UnityEditor</code></td></tr><tr><td>使用场景</td><td>Runtime 或 Editor GUI</td><td>编辑器 Inspector / EditorWindow</td></tr><tr><td>支持 SerializedProperty</td><td>直接绑定字段，需要手动操作</td><td>自动绑定 SerializedProperty，支持 Undo & Prefab</td></tr><tr><td>布局方式</td><td>自动布局</td><td>自动布局</td></tr><tr><td>控件类型</td><td>Button、Label、TextField、Slider 等</td><td>PropertyField、ObjectField、EnumPopup、Vector3Field 等</td></tr><tr><td>Undo/Inspector 自动刷新</td><td>no</td><td>yes</td></tr></tbody></table><p>核心点：<code>EditorGUILayout</code>是为编辑器量身定制的<code>GUILayout</code>，它的优势在于可以直接操作<code>SerializedProperty</code>，同时支持Undo、Prefab、Inspector自动刷新等功能</p><h3 id=使用关系>使用关系</h3><ul><li>EditorGUILayour基于GUILayout
实际上，EditorGUILayout内部也使用了GUILayout的布局系统，只是在它的控件上增加了对<code>SerializedProerty</code>和编辑器特性的支持</li><li>混合使用<ul><li>可以在自定义Inspector或EditorWindow中同时使用<code>GUILayout</code>和<code>EditorGUILayout</code></li><li>一般建议<ul><li>需要显示<code>SerializedProperty</code>用EditorGUILayout</li><li>仅做按钮或简单控件GUILayout也可以</li></ul></li></ul></li></ul><h2 id=undorecordobject>Undo.RecordObject</h2><h2 id=editor-coroutines>Editor Coroutines</h2><hr><p>完全没错，<code>UnityEditor</code> 绝对是一个 <strong>庞大而深入的主题</strong>，可以说它本身就是 <strong>Unity 编辑器扩展的核心</strong>，涉及的内容从基础到高级，范围非常广。我们可以把它拆解开来更系统地理解。</p><hr><h2 id=unityeditor-的本质><code>UnityEditor</code> 的本质</h2><ul><li><p><strong>命名空间</strong>：<code>UnityEditor</code>（只能在 Editor 环境下使用，不能打包到游戏运行时）</p></li><li><p><strong>功能</strong>：</p><ol><li>自定义 Inspector 界面。</li><li>自定义 Editor 窗口。</li><li>创建菜单、工具条按钮。</li><li>操作资源、Prefab、场景。</li><li>扩展 Unity 编辑器功能（如自动化处理、批量修改、调试工具）。</li></ol></li><li><p><strong>核心思想</strong>：把 Unity 自带编辑器功能开放给开发者，让你能通过代码 <strong>定制编辑器行为</strong>。</p></li></ul><hr><h2 id=核心模块>核心模块</h2><ol><li><p><strong>Editor 类与 CustomEditor</strong></p><ul><li><p><code>Editor</code>：用于自定义 Inspector。</p></li><li><p><code>[CustomEditor(typeof(MyComponent))]</code>：绑定你想自定义的组件。</p></li><li><p>核心方法：</p><ul><li><code>OnInspectorGUI()</code>：绘制 Inspector UI。</li><li><code>serializedObject</code> + <code>SerializedProperty</code>：安全修改组件字段。</li></ul></li></ul></li><li><p><strong>EditorWindow</strong></p><ul><li><p>自定义窗口（可以挂在 Unity 窗口系统里）。</p></li><li><p>核心方法：</p><ul><li><code>OnGUI()</code>：绘制窗口 UI。</li><li><code>Show()</code> / <code>GetWindow&lt;>()</code>：打开窗口。</li></ul></li><li><p>可用于做工具、调试面板、批量操作面板。</p></li></ul></li><li><p><strong>GUILayout / EditorGUILayout</strong></p><ul><li>自动布局的 GUI 系统。</li><li>EditorGUILayout 是专门支持 Inspector 的高级封装。</li></ul></li><li><p><strong>MenuItem & 工具栏扩展</strong></p><ul><li><code>[MenuItem("Tools/MyTool")]</code>：自定义菜单。</li><li>可以调用你的 EditorWindow 或工具逻辑。</li><li>支持快捷键。</li></ul></li><li><p><strong>Scene 交互</strong></p><ul><li><code>Handles</code>：在 Scene 视图中绘制可交互控件（如拖动 gizmo）。</li><li><code>EditorGUI</code> / <code>EditorGUILayout</code> 用于 Inspector，<code>Handles</code> 用于 Scene。</li></ul></li><li><p><strong>Asset / Prefab / Project 操作</strong></p><ul><li><code>AssetDatabase</code>：操作资源、导入、创建、重命名、删除。</li><li><code>PrefabUtility</code>：操作 Prefab 连接、替换、实例化。</li><li><code>EditorSceneManager</code>：操作场景（打开、保存、加载）。</li></ul></li><li><p><strong>调试与自动化</strong></p><ul><li><code>Debug</code>：编辑器内调试。</li><li><code>EditorApplication</code>：监听编辑器生命周期事件（如更新、播放模式切换）。</li><li>可做自动化批量处理（例如批量设置组件属性、生成资源、处理场景数据）。</li></ul></li></ol><hr><h2 id=使用层次感>使用层次感</h2><p>可以把 UnityEditor 理解成三层：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>UnityEditor
</span></span><span style=display:flex><span> ├─ Editor 类体系 → Inspector 自定义
</span></span><span style=display:flex><span> ├─ EditorWindow → 工具面板、独立窗口
</span></span><span style=display:flex><span> ├─ 编辑器 API → AssetDatabase, PrefabUtility, SceneManager, Handles
</span></span><span style=display:flex><span> └─ GUI 系统 → EditorGUILayout, EditorGUI, GUILayout
</span></span></code></pre></div><blockquote><p>核心逻辑：<strong>Editor 类控制 Inspector，EditorWindow 控制独立窗口，GUI 绘制工具（GUILayout / EditorGUILayout / Handles）显示 UI，其他 API 操作资源和场景。</strong></p></blockquote><hr><h2 id=学习建议>学习建议</h2><ol><li><p><strong>先从 Editor 与 Inspector 自定义入手</strong></p><ul><li>学会 <code>SerializedObject</code> + <code>SerializedProperty</code>，画出组件 Inspector。</li></ul></li><li><p><strong>进阶 EditorWindow</strong></p><ul><li>写独立工具，熟悉 GUILayout / EditorGUILayout。</li></ul></li><li><p><strong>Scene 编辑与 Handles</strong></p><ul><li>做可拖拽 gizmo，理解 Scene 交互。</li></ul></li><li><p><strong>Asset / Prefab / Project 操作</strong></p><ul><li>用 AssetDatabase 和 PrefabUtility 做批量工具。</li></ul></li><li><p><strong>事件与自动化</strong></p><ul><li>EditorApplication 生命周期，自动化工具和调试。</li></ul></li></ol><hr></div><nav class=post-nav><a href=/blog/unity-debug/ class=hover:underline>pre: Unity Debug</a>
<a href=/blog/unity-game-development-optimization/ class=hover:underline>next: Unity Game Development Optimization</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#基础概念>基础概念</a></li><li><a href=#常见扩展方式>常见扩展方式</a></li><li><a href=#unityeditor>UnityEditor</a><ul><li><a href=#核心作用>核心作用</a></li><li><a href=#注意事项>注意事项</a></li></ul></li><li><a href=#serializedobject--serializedproperty>SerializedObject / SerializedProperty</a><ul><li><a href=#核心概念>核心概念</a></li><li><a href=#serializedobject>SerializedObject</a></li><li><a href=#serializedproperty>SerializedProperty</a></li><li><a href=#示例>示例</a></li><li><a href=#注意事项-1>注意事项</a></li></ul></li><li><a href=#editorguilayout-vs-guilayout>EditorGUILayout vs GUILayout</a><ul><li><a href=#使用关系>使用关系</a></li></ul></li><li><a href=#undorecordobject>Undo.RecordObject</a></li><li><a href=#editor-coroutines>Editor Coroutines</a></li><li><a href=#unityeditor-的本质><code>UnityEditor</code> 的本质</a></li><li><a href=#核心模块>核心模块</a></li><li><a href=#使用层次感>使用层次感</a></li><li><a href=#学习建议>学习建议</a></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>