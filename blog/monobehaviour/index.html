<!doctype html><html lang=en><head><meta charset=UTF-8><title>MonoBehaviour</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=MonoBehaviour class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>MonoBehaviour<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p><code>MonoBehaviour</code>是Unity中最重要的基类之一，它是所有挂载到GameObject上的脚本的基础。每当在Unity编译器中创建也给C#脚本，并将其附加到一个GameObject时，这个脚本默认会继承<code>MonoBehaviour</code></p><p><code>MonoBehaviour</code>提供了一些非常强大的功能，尤其是在场景生命周期和事件处理方面</p><p><code>MonoBehaviour</code>继承自<code>Behaviour</code></p><h2 id=behaviour><code>Behaviour</code></h2><p><code>Behaviour</code>继承自<code>Component</code>，是<code>MonoBehaviour</code>、<code>Renderer</code>、<code>Collider</code>等类的基类，它为所有脚本提供了一些通用的启用/禁用功能和调度机制</p><h3 id=api>API</h3><p><strong>Properties</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>enabled</code></td><td><code>bool</code></td><td>决定了当前<code>Behaviour</code>是否启用，当启用时，该组件会响应更新（如<code>Update()</code>等声明周期方法），禁用则不会</td></tr><tr><td><code>isActiveAndEnable</code></td><td><code>bool</code></td><td>是一个只读属性，返回当前组件是否被启用并且它的GameObject也启用</td></tr></tbody></table><p><strong>示例</strong><br><code>enable</code>用法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 禁用这个脚本</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.enabled = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.enabled)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果脚本启用，这部分代码才会执行</span>
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;Script is enabled.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>enable</code>在继承时的行为<br>如果你继承自<code>Behaviour</code>，并且禁用该组件，那么Unity会停止调用该组件的方法。但是，如果<code>Behaviour</code>的父类被禁用，你仍然可以控制<code>enable</code>属性来启用或禁用某些组件行为</p><h4 id=启用和禁用的实际应用>启用和禁用的实际应用</h4><h5 id=控制游戏对象的行为>控制游戏对象的行为</h5><ul><li>动态启用/禁用：你可以根据游戏的状态动态启用或禁用脚本、组件或整个GameObject</li></ul><p>例如在游戏中按下按钮时禁用某些功能或暂停某些操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameController</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> GameObject player;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> PauseGame()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 禁用玩家脚本，暂停玩家控制</span>
</span></span><span style=display:flex><span>        player.GetComponent&lt;PlayerController&gt;().enabled = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> ResumeGame()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启用玩家脚本，恢复玩家控制</span>
</span></span><span style=display:flex><span>        player.GetComponenet&lt;PlayerController&gt;().enabled = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=控制物体动画与行为>控制物体动画与行为</h5><ul><li>暂停和恢复：在游戏中，可能会遇到暂停菜单时，禁用和启用某些脚本或动画</li></ul><h5 id=控制物理行为>控制物理行为</h5><ul><li>禁用物理计算：在某些情况下，你可能只希望在特定条件下启用物理计算</li></ul><h2 id=monobehaviour><code>MonoBehaviour</code></h2><p><code>MonoBehaviour</code>是Unity中最核心的类之一，它为游戏开发者提供了许多功能和特性，使得脚本能够与Unity引擎进行交互<br>通过继承<code>MonoBehaviour</code>，可以让自定义类称为Unity组件，并使用Unity引擎提供的生命周期方法、事件处理、协程支持等功能</p><p><strong><code>MonoBehaviour</code>会提供以下特性：</strong></p><h3 id=1生命周期方法>1.生命周期方法</h3><p><code>MonoBehaviour</code>提供了多个生命周期方法，让你能够在合适的时机执行代码。这些方法涵盖了Unity引擎中的许多重要事件，包括初始化、更新、碰撞检测等</p><p><a href=/assets/images/monobehaviour_flowchart.svg>生命周期函数示意图</a></p><h4 id=初始化阶段只执行一次>初始化阶段（只执行一次）</h4><p>初始化阶段的生命周期函数是游戏对象创建并激活后、正式开始游戏逻辑之前自动调用的一系列函数，主要用于初始化变量、加载资源、设置状态等操作</p><table><thead><tr><th>函数名</th><th>调用时机</th><th>用途</th><th>特点</th></tr></thead><tbody><tr><td><code>Awake()</code></td><td>脚本实例被 <strong>加载</strong> 后立刻调用（即使对象未启用也会调用）</td><td>初始化数据、引用等（最早）</td><td>初始化非依赖其他组件的逻辑</td></tr><tr><td><code>OnEnable()</code></td><td>对象启用时调用（<strong>每次启用都会调用</strong>）</td><td>脚本激活可以多次触发</td><td>常用于注册事件</td></tr><tr><td><code>Start()</code></td><td>所有对象的<code>Awake()</code>调用完后，在对象启用的第一帧调用一次</td><td>初始化逻辑，如加载资源、启动协程</td><td>初始化依赖其他组件/对象的逻辑</td></tr></tbody></table><ul><li><p><code>Awake()</code></p><ul><li>在脚本实例被加载时调用（即使对象未激活）</li><li>多个脚本中Awake的调用顺序是不确定的</li><li>通常用于<ul><li>分配资源</li><li>设置初始状态</li><li>创建单例</li></ul></li></ul></li><li><p><code>OnEnable()</code></p><ul><li>当对象或脚本被启用时调用</li><li>会在每次启用时重复调用</li><li>通常用于：<ul><li>注册事件</li><li>启动协程</li><li>绑定输入</li></ul></li></ul></li><li><p><code>Start()</code></p><ul><li>在启用的组件第一帧更新前调用，且只调用一次</li><li>所有<code>Awake()</code>执行完后才调用<code>Start()</code></li><li>通常用于<ul><li>获取其他组件</li><li>设置UI、初始化依赖关系</li></ul></li></ul></li></ul><h4 id=运行时循环阶段重复执行>运行时循环阶段（重复执行）</h4><table><thead><tr><th>函数名</th><th>调用频率</th><th>用途</th></tr></thead><tbody><tr><td><code>FixedUpdate()</code></td><td>每固定时间（如 0.02 秒）</td><td>物理计算、施加力、碰撞检测等</td></tr><tr><td><code>Update()</code></td><td>每帧</td><td>常规逻辑、输入处理、状态更新</td></tr><tr><td><code>LateUpdate()</code></td><td>每帧</td><td>摄像机追踪、骨骼动画等需要晚一点处理的逻辑</td></tr><tr><td><code>OnGUI()</code></td><td>每帧多次</td><td>IMGUI 绘图接口，用于旧 GUI 系统（已不推荐）</td></tr></tbody></table><h5 id=关于update>关于<code>Update()</code></h5><ul><li>适合做需要实时响应和更新的逻辑，例如输入检测、动画控制、AI决策等</li></ul><p><strong>在Update()中实现“时间无关”逻辑</strong>
由于帧率变化，直接写逻辑会导致游戏表现不同步<br>解决方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> moveSpeed = <span style=color:#ae81ff>5f</span>;
</span></span><span style=display:flex><span>    transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>Time.deltaTime</code>是上一帧到当前帧的时间差</li><li>乘以<code>deltaTime</code>可以保证无论帧率多少，运动速度都一样</li></ul><p><strong>常见用法</strong>
1.键盘输入控制移动</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> h = Input.GetAxis(<span style=color:#e6db74>&#34;Horizontal&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> v = Input.GetAxis(<span style=color:#e6db74>&#34;Vertical&#34;</span>);
</span></span><span style=display:flex><span>    Vector3 dir = <span style=color:#66d9ef>new</span> Vector3(h, <span style=color:#ae81ff>0</span>, v);
</span></span><span style=display:flex><span>    transform.Translate(dir * <span style=color:#ae81ff>5f</span> * Time.deltaTime);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>2.每帧检测条件触发事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Input.GetKeyDown(KeyCode.Space)) Jump();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>性能注意事项</strong></p><ul><li>频繁且复杂的操作放在<code>Update()</code>中会影响帧率</li><li>可以考虑<ul><li>减少<code>Update()</code>中的耗时计算</li><li>合理使用事件驱动替代轮询</li><li>利用<code>Coroutine</code>或<code>InvokeRepeating</code>控制调用频率</li><li>对复杂逻辑分帧处理或异步处理</li></ul></li></ul><p><strong>当关闭或禁用脚本时，Update()不会被调用，当GameObejct被禁用时，所有附加脚本的Update()都停止调用</strong></p><h4 id=关于lateupdate>关于<code>LateUpdate()</code></h4><ul><li>每帧调用一次，但始终在所有<code>Update()</code>函数调用之后调用</li><li>用于需要在所有<code>Update()</code>完成后再处理的逻辑</li></ul><h5 id=典型用途>典型用途</h5><p><strong>1.摄像机跟随</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FollowTarget</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Transform target;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> LateUpdate()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (target != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            transform.position = target.position + <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>5</span>, -<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>假设主角的位置在<code>Update()</code>中移动</li><li>如果摄像机在<code>Update()</code>中跟随，就会比角色“慢一帧”</li><li>用<code>LateUpdate()</code>可以确保摄像机总是跟着角色最终的位置</li></ul><p><strong>2.骨骼/动画后处理</strong></p><ul><li>动画系统也会在<code>Update()</code>后更新状态</li><li>用<code>LateUpdate()</code>来处理动画附属物的位置，如武器、特效等</li></ul><p><strong>3.平滑插值（Smooth Follow）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>void</span> LateUpdate()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    transform.position = Vector3.Lerp(transform.position, target.position, Time.deltaTime * <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>放在<code>LateUpdate()</code>可以让插值始终作用在最终位置上</li></ul><blockquote><p><code>LateUpdate()</code>是在每帧所有逻辑处理完之后调用的函数，适合做跟随、补偿、视觉同步、动画后处理等操作</p></blockquote><h4 id=关于fixedupdate>关于<code>FixedUpdate()</code></h4><ul><li><code>FixedUpdate()</code>是MonoBehaviour提供的生命周期函数</li><li>以固定的时间间隔执行，默认每0.02s，而不是每帧执行一次</li><li>适用于物理引擎相关的逻辑（刚体、碰撞器、重力等）</li><li>使用<code>Time.fixedDeltaTime</code>进行时间控制</li></ul><blockquote><p><code>FixedUpdate()</code>不一定每帧都调用，也可能在一帧内被调用多次（为了补上落后时间）</p></blockquote><h5 id=为什么物理逻辑必须放在fixedupdate>为什么物理逻辑必须放在<code>FixedUpdate()</code></h5><p>Unity的物理系统（Rigidbody、Collider等）是在物理引擎中执行的，它以固定步长（Fixed Timestep）计算模拟</p><p>如果你在<code>Update()</code>中对刚体施加力</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    rb.AddForce(Vector3.forward);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>每帧调用一次，但帧率变化会导致模拟不准确</li><li>如果FPS降低，你的物体就加速慢了</li></ul><p>正确做法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>void</span> FixedUpdate()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    rb.AddForce(Vector3.forward);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>固定时间模拟，物理表现就一致</li></ul><h5 id=时间控制>时间控制</h5><p>默认情况下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Time.fixedDeltaTime = 0.02f(每秒调用50次)
</span></span></code></pre></div><p>可以通过<code>Edit > Project Setting > Time</code>修改</p><p><strong>示例：让角色持续向前移动（基于物理）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Rigidbody rb;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Start() =&gt; rb = GetComponenet&lt;Rigidbody&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> FixedUpdate() =&gt; rb.MovePosition(rb.position + Vector3.forward * <span style=color:#ae81ff>5f</span> * Time.fixedDeltaTime);
</span></span></code></pre></div><ul><li>用<code>MovePosition()</code>更适合刚体控制</li><li><code>Time.fixedDeltaTime</code>保持匀速</li></ul><p><strong>注意事项</strong>
1.不要在<code>FixedUpdate()</code>中检测<code>Input.GetKey()</code><br>因为输入每帧更新，可能miss</p><p>2.与物理系统交互统一放在<code>FixedUpdate()</code><br>避免不一致和jitter</p><p>3.可能一帧内调用多次<code>FixedUpdate()</code>
这是为了追上物理时间进度</p><h4 id=碰撞触发事件>碰撞/触发事件</h4><p>发生在物理更新阶段（即<code>FixedUpdate()</code>阶段）之后调用，调用频率和FixedUpdate()一致，不受帧率的影响</p><p><strong>Rigidbody + Collider才能触发以下函数</strong></p><table><thead><tr><th>函数名</th><th>用途</th></tr></thead><tbody><tr><td><code>OnCollisionEnter(Collision col)</code></td><td>碰撞开始</td></tr><tr><td><code>OnCollisionStay(Collision col)</code></td><td>碰撞持续</td></tr><tr><td><code>OnCollisionExit(Collision col)</code></td><td>碰撞结束</td></tr><tr><td><code>OnTriggerEnter(Collider col)</code></td><td>触发器进入</td></tr><tr><td><code>OnTriggerStay(Collider col)</code></td><td>触发器内持续</td></tr><tr><td><code>OnTriggerExit(Collider col)</code></td><td>触发器离开</td></tr></tbody></table><p><a href=%7B%7Bsite.baseurl%7D%7D/posts/2025-06-03-Physics-System/>Unity物理系统</a></p><h4 id=渲染阶段>渲染阶段</h4><table><thead><tr><th>阶段</th><th>用途</th></tr></thead><tbody><tr><td><code>OnPreRender()</code></td><td>摄像机开始渲染前</td></tr><tr><td><code>OnRenderObject()</code></td><td>所有对象渲染时</td></tr><tr><td><code>OnPostRender()</code></td><td>摄像机完成渲染后</td></tr><tr><td><code>OnWillRenderObject()</code></td><td>对象将被摄像机渲染前</td></tr><tr><td><code>OnDrawGizmos()</code> / <code>OnDrawGizmosSelected()</code></td><td>编辑器中画 Gizmos</td></tr></tbody></table><h4 id=禁用销毁阶段>禁用/销毁阶段</h4><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td><code>OnDisable()</code></td><td>脚本被禁用时调用（如 <code>enabled = false</code> 或 <code>SetActive(false)</code>）</td></tr><tr><td><code>OnDestroy()</code></td><td>脚本被销毁前调用，用于释放资源、停止协程等</td></tr></tbody></table><h4 id=应用生命周期事件>应用生命周期事件</h4><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td><code>OnApplicationPause(bool pause)</code></td><td>应用暂停/恢复时调用（如手机切后台）</td></tr><tr><td><code>OnApplicationFocus(bool focus)</code></td><td>是否获得焦点（如切到其他应用）</td></tr><tr><td><code>OnApplicationQuit()</code></td><td>应用关闭前调用</td></tr></tbody></table><h2 id=自定义生命周期顺序>自定义生命周期顺序</h2><p>Unity默认调用顺序无法改变（例如A的Awake总在B前），但可以手动更改执行顺序</p><h3 id=方法一inspector设置执行顺序>方法一：Inspector设置执行顺序</h3><p>菜单栏：<code>Edit > Project Settings > Script Execution Order</code><br>把关键脚本设置为更早或更晚执行</p><h3 id=方法二代码显示调用推荐>方法二：代码显示调用（推荐）</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>void</span> Awake()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    manager = FindObjectOfType&lt;GameManager&gt;();
</span></span><span style=display:flex><span>    manager.Register(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2协程coroutine>2.协程（Coroutine）</h3><p><code>MonoBehaviour</code>提供了对协程的支持，协程允许你在多个帧之间暂停执行某些代码，而不会阻塞主线程。使用协程，你可以轻松实现延迟、定时任务、动画过渡等功能
<a href=%7B%7Bsite.baseurl%7D%7D/posts/2025-06-03-Coroutine/>Coroutine</a></p><h3 id=3输入处理>3.输入处理</h3><p><a href=%7B%7Bsite.baseurl%7D%7D/posts/2025-06-03-Input-System/>Input-System</a></p><h3 id=4物理与碰撞>4.物理与碰撞</h3><p><a href=%7B%7Bsite.baseurl%7D%7D/posts/2025-06-03-Physics-System/>Physics-System</a></p><h3 id=5组件管理>5.组件管理</h3><p>可以使用<code>GetComponent</code>和<code>AddComponent</code>等方法来访问和控制其他组件。例如，获取物体的Rigidbody`组件或添加新的组件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Rigidbody rb = GetComponent&lt;Rigidbody&gt;(); <span style=color:#75715e>// 获取组件</span>
</span></span><span style=display:flex><span>rb.AddForce(Vector3.up * <span style=color:#ae81ff>10f</span>); <span style=color:#75715e>// 应用力</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 动态添加组件</span>
</span></span><span style=display:flex><span>gameObject.AddComponent&lt;BoxCollider&gt;();
</span></span></code></pre></div><h3 id=6monobehaviour特性>6.<code>MonoBehaviour</code>特性</h3><ul><li>附加到GameObject上：通过<code>MonoBehaviour</code>，你可以将脚本附加到GameObject上，从而使该GameObject拥有行为</li><li>可在Inspector中配置：<code>MonoBehaviour</code>的公共字段（如<code>public</code>变量）可以在Unity编辑器的Inspector面板中查看和修改</li><li>生命周期管理：提供了许多生命周期方法，如<code>Awake</code>、 <code>Start</code>、<code>Update</code>，以及与物理和碰撞相关的方法</li></ul><h3 id=7其他功能>7.其他功能</h3><ul><li>场景管理:<a href=%7B%7Bsite.baseurl%7D%7D/posts/2025-06-08-Scene-System/>Scene-System</a></li><li>日志输出：<a href=%7B%7Bsite.baseurl%7D%7D/posts/2025-07-12-Debug/>Debug</a></li></ul></div><nav class=post-nav><a href=/blog/mono-and-il2cpp/ class=hover:underline>pre: Mono and IL2CPP</a>
<a href=/blog/native-layer-to-script-layer/ class=hover:underline>next: Native Layer to Script Layer</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#behaviour><code>Behaviour</code></a><ul><li><a href=#api>API</a><ul><li><a href=#启用和禁用的实际应用>启用和禁用的实际应用</a><ul><li><a href=#控制游戏对象的行为>控制游戏对象的行为</a></li><li><a href=#控制物体动画与行为>控制物体动画与行为</a></li><li><a href=#控制物理行为>控制物理行为</a></li></ul></li></ul></li></ul></li><li><a href=#monobehaviour><code>MonoBehaviour</code></a><ul><li><a href=#1生命周期方法>1.生命周期方法</a><ul><li><a href=#初始化阶段只执行一次>初始化阶段（只执行一次）</a></li><li><a href=#运行时循环阶段重复执行>运行时循环阶段（重复执行）</a><ul><li><a href=#关于update>关于<code>Update()</code></a></li></ul></li><li><a href=#关于lateupdate>关于<code>LateUpdate()</code></a><ul><li><a href=#典型用途>典型用途</a></li></ul></li><li><a href=#关于fixedupdate>关于<code>FixedUpdate()</code></a><ul><li><a href=#为什么物理逻辑必须放在fixedupdate>为什么物理逻辑必须放在<code>FixedUpdate()</code></a></li><li><a href=#时间控制>时间控制</a></li></ul></li><li><a href=#碰撞触发事件>碰撞/触发事件</a></li><li><a href=#渲染阶段>渲染阶段</a></li><li><a href=#禁用销毁阶段>禁用/销毁阶段</a></li><li><a href=#应用生命周期事件>应用生命周期事件</a></li></ul></li></ul></li><li><a href=#自定义生命周期顺序>自定义生命周期顺序</a><ul><li><a href=#方法一inspector设置执行顺序>方法一：Inspector设置执行顺序</a></li><li><a href=#方法二代码显示调用推荐>方法二：代码显示调用（推荐）</a></li><li><a href=#2协程coroutine>2.协程（Coroutine）</a></li><li><a href=#3输入处理>3.输入处理</a></li><li><a href=#4物理与碰撞>4.物理与碰撞</a></li><li><a href=#5组件管理>5.组件管理</a></li><li><a href=#6monobehaviour特性>6.<code>MonoBehaviour</code>特性</a></li><li><a href=#7其他功能>7.其他功能</a></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved</p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>