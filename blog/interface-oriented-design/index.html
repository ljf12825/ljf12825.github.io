<!doctype html><html lang=en><head><meta charset=UTF-8><title>Interface Oriented Design</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Interface Oriented Design" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Interface Oriented Design<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>&ldquo;Interface Oriented Design"面向接口设计，是软件架构中的一种重要思想，它强调通过接口而非具体实现进行编程</p><p>在Unity中，面向接口设计不仅有助于降低耦合、增强可测试性，还在组件化开发、热更架构、解耦系统中发挥了非常关键的作用</p><blockquote><p>定义行为接口，让对象只依赖接口而不是具体实现，从而实现解耦、扩展与测试的灵活性</p></blockquote><h2 id=unity中的典型应用场景>Unity中的典型应用场景</h2><ul><li>控制系统分离：<code>IInputHandler</code>抽象输入，无论是键盘、手柄还是虚拟按钮都统一处理</li><li>热更系统对接：ILRuntime、HybridCLR下通过接口对热更代码调用，避免直接依赖反射</li><li>AI行为系统：<code>IState</code>、<code>ITask</code>、<code>ICondition</code>组合行为树模块</li><li>资源加载系统：<code>IAssetLoader</code>抽象出不同加载器(Resources、Addressables、AB)</li><li>游戏流程系统：<code>IGameState</code>,<code>IFlowNode</code>构建状态流、任务流</li><li>特效触发系统：<code>ITrigger</code>,<code>IEffectReceiver</code>解耦触发与响应</li></ul><h2 id=interface的几个核心特性>Interface的几个核心特性</h2><ul><li>明确定义“行为契约”</li><li>不依赖具体类，从而实现松耦合</li><li>便于单元测试（可用mock实现）</li><li>可实现多态性与模块化组合</li><li>更适合插件式、模块式开发</li></ul><h2 id=示例输入控制器的面向接口设计>示例：输入控制器的面向接口设计</h2><p><strong>定义接口</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IInputHandler</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Vector2 GetMoveInput();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> IsJumpPressed();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>两种实现方式</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>KeyboardInput</span> : IInputHandler
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Vector2 GetMoveInput() =&gt; <span style=color:#66d9ef>new</span> Vector2(Input.GetAxis(<span style=color:#e6db74>&#34;Horizontal&#34;</span>), Input.GetAxis(<span style=color:#e6db74>&#34;Vertical&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsJumpPressed() =&gt; Input.GetKeyDown(KeyCode.Space);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MobileInput</span> : IInputHandler
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Vector2 GetMoveInput() =&gt; joystick.Direction;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsJumpPressed() =&gt; jumpButton.IsPressed;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>游戏角色逻辑只依赖接口</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PlayerController</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> IInputHandler input;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Vector2 move = input.GetMoveInput();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (input.IsJumpPressed()) Jump();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样就可以轻松替换不同输入源，而无需修改<code>PlayerController</code>的任何逻辑</p><h2 id=示例子弹造成伤害>示例：子弹造成伤害</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IDamageable</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> TakeDamage(<span style=color:#66d9ef>int</span> amount);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Enemy</span> : MonoBehaviour, IDamageable
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> TakeDamage(<span style=color:#66d9ef>int</span> amount) =&gt; Debug.Log(<span style=color:#e6db74>$&#34;Enemy took {amount} damage.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bullet</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnCollisionEnter(Collision collision)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> damageable = collision.gameObject.GetComponent&lt;IDamageable&gt;();
</span></span><span style=display:flex><span>        damageable?.TakeDamage(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Bullet不关心对象是不是Enemy，只在乎能不能被“伤害”</p><p>优点：</p><ol><li><p>松耦合
接口使得组件之间的耦合性降到最低。<code>Bullet</code>类并不知道<code>Enemy</code>类的实现细节，它只关心<code>Enemy</code>是否实现了<code>IDamageable</code>接口。这使得组件之间可以灵活地进行替换和扩展</p></li><li><p>可扩展性
如果以后需要增加新的可伤害对象，只需要让新的类实现<code>IDamageable</code>接口，而不需要修改已有的<code>Enemy</code>类</p></li><li><p>可维护性
当项目需要调整某些行为时，接口提供了一个良好的抽象层。例如，如果要改变<code>Bullet</code>伤害计算方式，只需要修改<code>Bullet</code>类，而不需要影响到其他类的交互</p></li><li><p>灵活性
接口可以被用作插件或模块化系统的基础。比如，游戏中有多个物品类型，它们都可能具有被攻击的行为。可以创建一个<code>IDamageable</code>接口，让这些物品实现不同的伤害逻辑，而不需要知道具体类型</p></li></ol><h2 id=unity中面向接口设计的典型架构模式>Unity中面向接口设计的典型架构模式</h2><table><thead><tr><th>模式</th><th>与接口结合点</th></tr></thead><tbody><tr><td><strong>策略模式 (Strategy)</strong></td><td>定义一组策略接口，如 <code>IMovementStrategy</code>, <code>ISkillStrategy</code></td></tr><tr><td><strong>状态模式 (State)</strong></td><td>定义 <code>IState</code>, 例如 <code>IdleState</code>, <code>AttackState</code>，用于 FSM 或流程控制</td></tr><tr><td><strong>事件发布订阅</strong></td><td><code>IEventListener&lt;T></code>，订阅不同类型事件</td></tr><tr><td><strong>服务定位器 (Service Locator)</strong></td><td>注册与获取 <code>IService</code> 接口实例</td></tr><tr><td><strong>依赖注入 (DI)</strong></td><td>将接口作为依赖注入类中，提升模块解耦性</td></tr></tbody></table><h2 id=interface-oriented-vs-inheritance-oriented>Interface Oriented vs Inheritance Oriented</h2><table><thead><tr><th>特性</th><th>面向接口</th><th>面向继承</th></tr></thead><tbody><tr><td>耦合度</td><td>低（只依赖接口）</td><td>高（依赖具体类）</td></tr><tr><td>多重继承</td><td>支持</td><td>C# 只支持单继承</td></tr><tr><td>可测试性</td><td>高</td><td>一般</td></tr><tr><td>扩展性</td><td>强</td><td>受限于父类设计</td></tr><tr><td>Unity 中建议</td><td>优先接口</td><td>谨慎继承 MonoBehaviour</td></tr></tbody></table><h2 id=建议>建议</h2><ol><li>尽量避免直接在逻辑中引用MonoBehaviour类</li></ol><ul><li>改为<code>interface + bridge</code>结构组合</li></ul><ol start=2><li>构建模块接口层</li></ol><ul><li>如<code>ISoundSystem</code>,<code>IResourceSystem</code>,<code>IGameFlowSystem</code>等</li></ul><ol start=3><li><p>配合ScriptableObject实现运行时数据配置</p></li><li><p>配合依赖注入容器实现自动绑定</p></li></ol></div><nav class=post-nav><a href=/blog/input-system/ class=hover:underline>pre: Input System</a>
<a href=/blog/job-system/ class=hover:underline>next: Job System</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#unity中的典型应用场景>Unity中的典型应用场景</a></li><li><a href=#interface的几个核心特性>Interface的几个核心特性</a></li><li><a href=#示例输入控制器的面向接口设计>示例：输入控制器的面向接口设计</a></li><li><a href=#示例子弹造成伤害>示例：子弹造成伤害</a></li><li><a href=#unity中面向接口设计的典型架构模式>Unity中面向接口设计的典型架构模式</a></li><li><a href=#interface-oriented-vs-inheritance-oriented>Interface Oriented vs Inheritance Oriented</a></li><li><a href=#建议>建议</a></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>