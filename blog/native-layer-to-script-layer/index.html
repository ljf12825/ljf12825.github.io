<!doctype html><html lang=en><head><meta charset=UTF-8><title>Native Layer to Script Layer</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Native Layer to Script Layer" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Native Layer to Script Layer<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><h2 id=the-bridge-between-native-layer-and-script-layer>The Bridge between Native Layer and Script Layer</h2><p>Unity引擎运行时，本质上是一个C++引擎内核 + C#脚本层的结构</p><p>所写的<code>MonoBehaviour</code>只是在C#中的一个代理对象，真正控制游戏运行的逻辑、渲染、物理等是C++层在执行</p><p>所以从<code>UnityEngine.Object</code>开始，Unity构建了一个“双向映射体系”</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>C++对象（native） &lt;--- instance ID --- UnityEngine.Object（C#托管对象）
</span></span><span style=display:flex><span>        ↑                                       ↑
</span></span><span style=display:flex><span>    内存资源                                   脚本代理
</span></span></code></pre></div><h3 id=从object到monobehaviour的完整继承链>从Object到MonoBehaviour的完整继承链</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>System.Object （纯托管）
</span></span><span style=display:flex><span>└── UnityEngine.Object （托管对象，桥梁类）
</span></span><span style=display:flex><span>    ├── GameObject（托管对象）
</span></span><span style=display:flex><span>    └── Component
</span></span><span style=display:flex><span>        ├── Transform / Renderer / Collider...（托管对象）
</span></span><span style=display:flex><span>        └── MonoBehaviour （托管行为对象，支持生命周期方法）
</span></span></code></pre></div><p>它们都不是普通的C#对象，它们都与C++侧的“实体”挂钩，甚至生命周期也是引擎控制的</p><h3 id=native-layer-与-script-layer的绑定方式>native layer 与 script layer的绑定方式</h3><p>Unity会通过一套机制将C++层对象暴露给C#层，这其中最关键的桥梁是：<code>instance ID + GCHandle + m_CachedPtr</code></p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td><code>m_CachedPtr</code></td><td><code>UnityEngine.Object</code>中保留的指针，指向C++对象的地址（Unsafe）</td></tr><tr><td><code>GCHandle</code></td><td>Unity用于保持托管对象不被GC收走，native端持有</td></tr><tr><td><code>Instance ID</code></td><td>每个 C++ native 对象的唯一标识，Unity使用它查找C#代理对象</td></tr><tr><td><code>ScriptingObject</code></td><td>C++对象的基类，用于和C#对象绑定（runtime下存在）</td></tr><tr><td><code>MonoObject*</code></td><td>指向 C# 对象的原生指针（Mono环境时）</td></tr></tbody></table><p>流程图：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>C++对象 (ScriptingObject)
</span></span><span style=display:flex><span>   ↕ instance ID
</span></span><span style=display:flex><span>C#对象（UnityEngine.Object） ← GCHandle ← C++
</span></span><span style=display:flex><span>         ↑
</span></span><span style=display:flex><span>      m_CachedPtr → C++对象
</span></span></code></pre></div><h3 id=instance-id>instance ID</h3><p>Unity通过使用<code>instance ID</code>统一管理对象</p><p>每个在C++层的Unity对象都有一个唯一的标识符，即<code>instance ID</code>，它用于区分不同的C++对象。这个标识符的作用类似于内存中的指针</p><ul><li>在C#中，可以通过<code>UnityEngine.Object.GetInstanceID()</code>获取该对象的<code>instance ID</code></li><li>在C++中，通过这个<code>instance ID</code>可以找到实际的对象。所有Unity引擎的原生对象都会被注册到一个全局的对象管理器中，这个管理器会维护<code>instance ID</code>和对象之间的映射</li></ul><p>可以把<code>instance ID</code>想象成一个类似于数据库中的“主键”，它指向C++层中的实际属性。在C#层，Unity通过<code>m_CachedPtr</code>或类似机制与C++对象建立联系。C#调用一个方法或访问一个属性时，实际上就是通过这个<code>instance ID</code>去C++层查找并操作相应对象的</p><h3 id=c层对象的生命周期管理>C++层对象的生命周期管理</h3><p>在Unity中，C++层的对象生命周期是由引擎控制的，而不是像普通的C#对象那样由GC自动回收。也就是说，C++对象在被销毁时，并不会立即被C#垃圾处理器回收，而是由Unity引擎自己管理</p><p>关键点：</p><ul><li>C++层对象的创建和销毁：Unity引擎在创建或销毁对象时，会在C#层为这些C++对象创建对应的托管代理。当你调用<code>Destroy()</code>或<code>DestroyImmediate()</code>时，Unity会标记这个对象为待销毁，但实际销毁操作会发生在引擎的下一帧</li><li>GCHandle和<code>instance ID</code>：为了防止C#垃圾回收器误回收正在被引擎使用的对象，Unity会使用<code>GCHandle</code>来防止C#层的对象被GC销毁。<code>GCHandle</code>是一个特定的标记，它告诉C#的垃圾回收器，这个对象在native层还有引用，不应该被回收</li><li>内存管理：一旦<code>GameObject</code>或其他对象在C++层销毁，Unity会通过管理器从托管层移除该对象，确保其不再被访问。此时，C#层的引用会变成<code>null</code>，也就无法再访问该对象了。若访问，C#层会返回<code>null</code>，这便是Unity的<code>fake null</code>行为</li></ul><h3 id=c和c的指针交互>C#和C++的指针交互</h3><p>在C#和C++之间，<code>m_CachedPtr</code>是Unity使用的一个关键字段，它保存了C++对象的指针。这个指针并不会直接暴露，而是通过<code>UnityEngine.Object</code>的方法间接访问</p><p>例如，当使用<code>Instantiate()</code>克隆一个对象时，C#层会创建一个新的对象，并将其<code>m_CachedPtr</code>指向一个新的C++对象。这种机制确保了C#和C++层可以同步管理对象的创建、销毁和引用</p><p>为什么不直接使用C++指针</p><ul><li>安全性：如果C#直接操作C++指针，那么内存管理将变得非常复杂，容易发生野指针错误（例如访问已销毁的对象）</li><li>跨平台：Unity需要支持多个平台，如果直接操作原始指针，会导致平台之间的不兼容</li></ul><h3 id=内存和资源管理native与managed内存>内存和资源管理：Native与Managed内存</h3><p>Unity对内存的管理通常分为两类：托管内存（Managed Memory）和原生内存（Native Memory）</p><p>托管内存：</p><ul><li>这是C#层的内存，由.NET的垃圾回收器负责管理。Unity中的许多类都在托管内存中分配</li><li>例如，通过<code>new GameObject()</code>创建一个对象时，它实际上是在托管内存中创建了一个<code>GameObject</code>代理类，该类最终通过<code>instance ID</code>和C++对象绑定</li></ul><p>原生内存：</p><ul><li>这是C++层的内存。Unity对这些内存进行严格管理，确保它们被正确地分配和释放</li><li>对于一个<code>GameObject</code>，它在C++层的实际数据都存在原生内存中。C#只能通过指针和绑定方法访问这些内存数据，而不能直接操作它</li></ul><h3 id=资源的加载与卸载的底层机制>资源的加载与卸载的底层机制</h3><p>Unity的资源管理在C++层也有对应的资源对象，它们通过资源路径和资源管理系统来加载和卸载</p><p>当使用<code>Resource.Load()</code>或<code>Addressables</code>加载资源时，Unity会在C++层将资源加载到内存中，并返回一个C#层的代理对象。这些资源的引用计数会由C++层管理，当没有对象再引用这些资源时，C++层会负责销毁这些内存并释放内存</p><h3 id=性能和优化>性能和优化</h3><ol><li><p>频繁的资源加载和卸载：如果你在每帧都调用 Resources.Load() 或频繁销毁对象，可能会导致性能瓶颈。推荐使用 Addressables 或 Object Pooling 技术来优化资源管理。</p></li><li><p>避免大量无效对象：例如，创建大量的 GameObject、MonoBehaviour，然后频繁销毁。这样不仅会增加垃圾回收的负担，还会在 C++ 层产生频繁的对象创建和销毁开销。可以使用对象池来减少这种开销。</p></li><li><p>内存泄漏问题：如果对象在 C++ 层没有正确销毁，可能导致内存泄漏。特别是 MonoBehaviour 等绑定对象，它们的销毁需要确保在 C# 层正确解除引用，否则即使对象在 C++ 层销毁，C# 层的引用仍会阻止 GC 回收。</p></li></ol><h3 id=对象创建过程>对象创建过程</h3><p>以创建一个<code>GameObject</code>为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>GameObject go = <span style=color:#66d9ef>new</span> GameObject(<span style=color:#e6db74>&#34;Hero&#34;</span>);
</span></span></code></pre></div><p>在背后发生了：</p><ol><li>C#调用UnityEngine的构造方法</li><li>Unity C#层调用了内部绑定的native构造函数（通过<code>[NativeMethod]</code>或<code>extern</code>实现）</li><li>C++中创建了一个<code>GameObject</code>对象，并注册<code>instance ID</code></li><li>Unity C++层为这个对象创建一个C#代理，分配内存，绑定<code>m_CachedPtr</code></li><li>如果启用脚本（MonoBehaviour），则Unity会通过反射或运行时代码绑定，自动挂载脚本（生成MonoObject，绑定）</li></ol><h2 id=monobehaviour的生命周期的控制>MonoBehaviour的生命周期的控制</h2><p>生命周期函数是Unity引擎每帧自动调度的：</p><ul><li>Unity在每帧中，遍历所有激活的<code>GameObject</code>和<code>Component</code></li><li>检查是否存在重写的生命周期函数</li><li>调用托管对象中的方法（通过反射或自动生成的绑定）</li></ul><h2 id=monobehaviour是怎么挂载的>MonoBehaviour是怎么挂载的</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>gameObject.AddComponent&lt;MyScript&gt;();
</span></span></code></pre></div><p>内部流程：</p><ol><li>C#调用泛型方法<code>AddComponent&lt;T>()</code></li><li>UnityC#层调用底层<code>AddComponent(Type t)</code>(native bridge)</li><li>引擎C++层创建一个<code>MonoBehaviour</code>实例（C++对象）</li><li>引擎创建对应的C#代理对象，并调用构造函数</li><li>将代理对象挂到该<code>GameObject</code>下，并添加到调度列表中</li><li>引擎在适当时机调用<code>Awake() -> Start() -> Update()</code></li></ol><p>所以不能用<code>new MyScript()</code>创建MonoBehaviour，它不是纯托管类，是托管↔native绑定类</p></div><nav class=post-nav><a href=/blog/navigation/ class=hover:underline>pre: Navigation</a>
<a href=/blog/monobehaviour/ class=hover:underline>next: MonoBehaviour</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#the-bridge-between-native-layer-and-script-layer>The Bridge between Native Layer and Script Layer</a><ul><li><a href=#从object到monobehaviour的完整继承链>从Object到MonoBehaviour的完整继承链</a></li><li><a href=#native-layer-与-script-layer的绑定方式>native layer 与 script layer的绑定方式</a></li><li><a href=#instance-id>instance ID</a></li><li><a href=#c层对象的生命周期管理>C++层对象的生命周期管理</a></li><li><a href=#c和c的指针交互>C#和C++的指针交互</a></li><li><a href=#内存和资源管理native与managed内存>内存和资源管理：Native与Managed内存</a></li><li><a href=#资源的加载与卸载的底层机制>资源的加载与卸载的底层机制</a></li><li><a href=#性能和优化>性能和优化</a></li><li><a href=#对象创建过程>对象创建过程</a></li></ul></li><li><a href=#monobehaviour的生命周期的控制>MonoBehaviour的生命周期的控制</a></li><li><a href=#monobehaviour是怎么挂载的>MonoBehaviour是怎么挂载的</a></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved</p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>