<!doctype html><html lang=en><head><meta charset=UTF-8><title>Layout</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=Layout class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Layout<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><h2 id=layout-system>Layout System</h2><p><img src=/assets/images/LayoutSystem.jpg alt=LayoutSystem></p><h3 id=layout-group>Layout Group</h3><p><code>Layout Group</code>是Unity UI自动布局系统的核心组件之一，用于在UI Canvas下自动排列其他子物体。它极大地简化了UI元素的排列和适配逻辑，让UI开发变得更结构化、响应式、更易维护</p><blockquote><p><code>Layout Group</code>是一类MonoBehaviour脚本，用于自动排列RectTransform子物体的位置与尺寸，不需要你手动拖动它们</p></blockquote><table><thead><tr><th>类型</th><th>说明</th><th>用途示例</th></tr></thead><tbody><tr><td><code>HorizontalLayoutGroup</code></td><td>子物体沿 <strong>水平方向排列</strong></td><td>菜单栏、工具条、横向列表</td></tr><tr><td><code>VerticalLayoutGroup</code></td><td>子物体沿 <strong>垂直方向排列</strong></td><td>聊天记录、竖向按钮组</td></tr><tr><td><code>GridLayoutGroup</code></td><td>子物体按 <strong>网格排列</strong>（行列）</td><td>背包格子、关卡选择界面</td></tr><tr><td><code>LayoutGroup</code></td><td>抽象基类</td><td>不直接使用</td></tr></tbody></table><h4 id=horizontal--vertical-layout-group>Horizontal / Vertical Layout Group</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>Padding</code></td><td>容器四周的边距</td></tr><tr><td><code>Spacing</code></td><td>子物体之间的间隔</td></tr><tr><td><code>Child Alignment</code></td><td>子物体在主轴上的对齐方式（左/中/右）</td></tr><tr><td><code>Reverse Arrangement</code></td><td>排列方向反转：从上到下 → 从下到上</td></tr><tr><td><code>Control Child Size</code></td><td>控制子物体是否填满空间</td></tr><tr><td><code>Use Child Scale</code></td><td>是否使用子物体的缩放比例</td></tr><tr><td><code>Child Force Expand</code></td><td>启用时多个子物体会调整间距，以填充满Width或Height</td></tr></tbody></table><blockquote><p>Horizontal Layout Group适用场景：菜单栏、Tab标签页、道具快捷栏等</p></blockquote><blockquote><p>Vertical Layout Group适用场景：排行榜列表、聊天内容、选项按钮组等</p></blockquote><h4 id=grid-layout-group>Grid Layout Group</h4><p>用于将子物体排列成规则网格，每个格子的大小统一</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>Padding</code></td><td>容器四周的边距</td></tr><tr><td><code>Cell Size</code></td><td>每个格子的宽高</td></tr><tr><td><code>Spacing</code></td><td>格子之间的间距</td></tr><tr><td><code>Start Corner</code></td><td>从哪个角开始排列</td></tr><tr><td><code>Start Axis</code></td><td>是优先横向填充还是纵向</td></tr><tr><td><code>Child Alignment</code></td><td>子物体整体对齐方式</td></tr><tr><td><code>Constraint</code></td><td>行数/列数限制（可固定行或列）</td></tr></tbody></table><blockquote><p>使用场景：背包系统、九宫格、商城道具、分页列表</p></blockquote><h4 id=常见问题>常见问题</h4><table><thead><tr><th>问题</th><th>原因 / 解决方式</th></tr></thead><tbody><tr><td>改了内容不刷新布局</td><td>调用 <code>LayoutRebuilder.ForceRebuildLayoutImmediate()</code></td></tr><tr><td>动态添加元素时抖动</td><td>先 <code>SetActive(false)</code> 再添加，最后 <code>SetActive(true)</code></td></tr><tr><td>动画或手动设置位置被覆盖</td><td>LayoutGroup 会自动控制，需禁用 LayoutGroup 才能手动操作</td></tr><tr><td>ContentSizeFitter + LayoutGroup 死循环</td><td>不要放在同一个 GameObject 上</td></tr></tbody></table><h3 id=layout-element>Layout Element</h3><p><code>Layout Element</code>用于告诉布局系统如何排布当前UI元素，它本身不会影响UI的大小或位置，而是为其所在的<code>Layout Group</code>提供布局建议（尺寸、优先级等），从而参与整个UI的自动布局流程</p><table><thead><tr><th>属性</th><th>含义</th><th>举例说明</th></tr></thead><tbody><tr><td><strong>Ignore Layout</strong></td><td>是否忽略布局系统</td><td>设置为 <code>true</code> 会让 Layout Group 忽略它</td></tr><tr><td><strong>Min Width / Height</strong></td><td>最小宽高</td><td>不小于这个尺寸</td></tr><tr><td><strong>Preferred Width / Height</strong></td><td>首选宽高</td><td>想要的尺寸（如果有空间）</td></tr><tr><td><strong>Flexible Width / Height</strong></td><td>灵活宽高</td><td>有多大就能占多大，类似“权重” ，多个元素剩余空间分配按权重计算</td></tr><tr><td><strong>Layout Priority</strong></td><td>优先级</td><td>如果GameObject上有多个布局相关组件，按优先级顺序计算，优先级与数值成正比</td></tr></tbody></table><h4 id=常见用途>常见用途</h4><table><thead><tr><th>场景</th><th>使用方式</th></tr></thead><tbody><tr><td>某个按钮不想自动拉伸</td><td>设置 <code>Flexible Width = 0</code></td></tr><tr><td>聊天条自动增长宽度</td><td>设置 <code>Preferred Width = Text 宽度</code></td></tr><tr><td>图片强制保持比例</td><td>设置 <code>Preferred Width/Height</code> 同步更新</td></tr><tr><td>某个子元素不参与布局</td><td>勾选 <code>Ignore Layout</code></td></tr></tbody></table><h3 id=content-size-fitter>Content Size Fitter</h3><p><code>Content Size Fitter</code>用于让UI元素根据其子元素或自身内容的大小，自动调整RectTransform的尺寸，是实现响应式UI的关键工具之一</p><p>比如：让聊天气泡、弹窗、按钮、文字背景根据内容自动扩展</p><table><thead><tr><th>属性名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><strong>Horizontal Fit</strong></td><td>enum</td><td>控制横向尺寸的自动适配方式</td></tr><tr><td><strong>Vertical Fit</strong></td><td>enum</td><td>控制纵向尺寸的自动适配方式</td></tr></tbody></table><p>每个方向的选项有三种：</p><ul><li><code>Unconstrained</code>（不自动适配，默认）</li><li><code>Min Size</code>（缩小到最小可用大小）</li><li><code>Preferred Size</code>（扩展到推荐大小）</li></ul><h4 id=常见用途-1>常见用途</h4><table><thead><tr><th>使用场景</th><th>使用方式</th></tr></thead><tbody><tr><td>聊天气泡自动撑开</td><td><code>Vertical Fit = Preferred Size</code>（文本高度）<br><code>Horizontal Fit = Preferred Size</code>（文本宽度）</td></tr><tr><td>按钮随文字自适应宽度</td><td>按钮 Image + Text + <code>ContentSizeFitter</code></td></tr><tr><td>ScrollView 内容自动撑开</td><td>在 Content 上加 <code>ContentSizeFitter</code> + <code>Layout Group</code></td></tr><tr><td>警告弹窗根据文本自动扩展大小</td><td>Text + 背景图 + ContentSizeFitter</td></tr></tbody></table><h4 id=常见问题-1>常见问题</h4><table><thead><tr><th>问题</th><th>原因 & 解决方案</th></tr></thead><tbody><tr><td>和 LayoutGroup 冲突</td><td><strong>不要把 ContentSizeFitter 和 LayoutGroup 放在同一个 GameObject 上</strong>，要分开：父挂 LayoutGroup，子挂 ContentSizeFitter</td></tr><tr><td>内容变了但尺寸没变</td><td>调用：<code>LayoutRebuilder.ForceRebuildLayoutImmediate(transform as RectTransform)</code> 手动刷新</td></tr><tr><td>不生效</td><td>子物体未使用 <code>LayoutElement</code> 或未正确设置 <code>Preferred Size</code></td></tr><tr><td>UI 抖动</td><td>动态内容更新太频繁，建议只在必要时刷新布局</td></tr></tbody></table><h4 id=示例>示例</h4><h5 id=动态文字撑开背景>动态文字撑开背景</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> TextMeshProUGUI messageText;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> RectTransform bubble;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> SetMessage(<span style=color:#66d9ef>string</span> msg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  messageText.text = msg;
</span></span><span style=display:flex><span>  LayoutRebuilder.ForceRebuildLayoutImmediate(bubble);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=聊天列表自动滚到底>聊天列表自动滚到底</h5><p>搭配<code>ScrollRect</code>：</p><ul><li>在<code>Content</code>上加<code>VerticalLayoutGroup + ContentSizeFitter</code></li><li>发送新消息后滚动到底部</li></ul><h3 id=aspect-ratio-fitter>Aspect Ratio Fitter</h3><p><code>Aspect Ratio Fitter</code>用于强制一个UI元素保持固定的宽高比（Aspect Ratio），无论父物体如何拉伸、屏幕怎么变化，它都能保持比例不变</p><p>通常用于：</p><ul><li>图片防拉伸</li><li>视频播放器窗口</li><li>正方形/圆形按钮保持比例</li><li>多分辨率适配中的UI统一性</li></ul><h4 id=属性说明>属性说明</h4><table><thead><tr><th>属性名</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><strong>Aspect Mode</strong></td><td>枚举</td><td>控制哪个方向跟随调整以维持宽高比</td></tr><tr><td><strong>Aspect Ratio</strong></td><td>float</td><td>目标宽高比（width / height）</td></tr></tbody></table><h5 id=aspect-mode>Aspect Mode</h5><table><thead><tr><th>模式</th><th>含义</th></tr></thead><tbody><tr><td><code>None</code></td><td>不启用比例适配</td></tr><tr><td><code>Width Controls Height</code></td><td>宽度不变，根据宽度调整高度</td></tr><tr><td><code>Height Controls Width</code></td><td>高度不变，根据高度调整宽度</td></tr><tr><td><code>Fit In Parent</code></td><td>保持比例并完全包含在父物体内（不裁剪）</td></tr><tr><td><code>Envelope Parent</code></td><td>保持比例并<strong>覆盖整个父物体</strong>（可能裁剪）</td></tr></tbody></table></div><nav class=post-nav><a href=/blog/loose-coupling/ class=hover:underline>pre: Loose Coupling</a>
<a href=/blog/layer/ class=hover:underline>next: Layer</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#layout-system>Layout System</a><ul><li><a href=#layout-group>Layout Group</a><ul><li><a href=#horizontal--vertical-layout-group>Horizontal / Vertical Layout Group</a></li><li><a href=#grid-layout-group>Grid Layout Group</a></li><li><a href=#常见问题>常见问题</a></li></ul></li><li><a href=#layout-element>Layout Element</a><ul><li><a href=#常见用途>常见用途</a></li></ul></li><li><a href=#content-size-fitter>Content Size Fitter</a><ul><li><a href=#常见用途-1>常见用途</a></li><li><a href=#常见问题-1>常见问题</a></li><li><a href=#示例>示例</a><ul><li><a href=#动态文字撑开背景>动态文字撑开背景</a></li><li><a href=#聊天列表自动滚到底>聊天列表自动滚到底</a></li></ul></li></ul></li><li><a href=#aspect-ratio-fitter>Aspect Ratio Fitter</a><ul><li><a href=#属性说明>属性说明</a><ul><li><a href=#aspect-mode>Aspect Mode</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved</p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>