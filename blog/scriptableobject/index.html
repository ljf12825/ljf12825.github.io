<!doctype html><html lang=en><head><meta charset=UTF-8><title>ScriptableObject</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><div class=container><p>ljf12825.github.io@ljf12825.github.io:~</p></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>ScriptableObject<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p><code>ScriptableObject</code> 是 Unity 中的一种特殊类型的对象，它是用于存储数据的，类似于普通的 C# 类，但它不需要与游戏对象（<code>GameObject</code>）关联</p><p><code>ScriptableObject</code> 主要用于节省内存、提高性能和简化数据的管理。它通常用来存储可重用的数据，如配置、设置、状态信息等</p><h2 id=基本概念>基本概念</h2><p><code>ScriptableObject</code> 是 Unity 提供的一种特殊对象类型，允许你将数据持久化到磁盘上，并能够在编辑器中方便地进行编辑和管理。这与普通的 MonoBehaviour 类（需要附加到 GameObject 上）不同，<code>ScriptableObject</code> 并不依赖于场景中的任何对象</p><p><strong>主要特点</strong></p><ul><li>独立于GameObject：<code>ScriptableObject</code>并不需要绑定到一个<code>GameObject</code>上，因此它可以轻松地存储全局数据</li><li>可在编辑器中编辑：可以在Unity编辑器中查看、编辑和保存<code>ScriptableObject</code>实例</li><li>性能优化：<code>ScriptableObject</code>实例是共享的，因此多个对象可以引用同一个<code>ScriptableObject</code>实例，这有助于减少内存消耗</li><li>数据持久化：<code>ScriptableObject</code>支持数据持久化，可以将其作为资源保存在磁盘上，便于管理和编辑</li></ul><h2 id=创建和使用>创建和使用</h2><ol><li>创建ScriptableObject类
要创建 ScriptableObject，首先需要继承 ScriptableObject 基类，并为它定义一个静态方法来实例化对象</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[CreateAssetMenu(fileName = &#34;NewCharacterData&#34;, menuName = &#34;ScriptableObjects/CharacterData&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CharacterData</span> : ScriptableObject
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> characterName;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> health;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> speed;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个例子中，定义了一个<code>CharacterData</code>类，存储角色的数据（如名字、生命值和速度）</p><p><code>CreateAssetMenu</code>特性使得可以通过右键点击创建该类型的<code>ScriptableObject</code>实例</p><ol start=2><li><p>创建实例
在Unity编辑器中，可以右键点击项目视图中的文件夹，并选择<code>Create</code> > <code>ScriptableObjects</code> > <code>CharacterData</code>，然后创建一个新的<code>CharacterData</code>实例。它将出现在项目文件中，并且可以像其他资源一样编辑</p></li><li><p>使用ScriptableObject
一旦创建了<code>ScriptableObject</code>实例，就可以通过代码引用它，或者将其赋值给其他对象的字段</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Character</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> CharacterData characterData;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Start() =&gt; Debug.Log(<span style=color:#e6db74>$&#34;{characterData.Name}, {characterData.health}, {characterData.Speed}&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个示例中，<code>Character</code>脚本引用了一个<code>CharacterData</code>类型的字段，并在<code>Start</code>方法中打印出角色的数据。在Unity编辑器中，可以将创建的<code>CharacterData</code>实例拖动到<code>Character</code>脚本的<code>characterData</code>字段上</p><h2 id=使用场景和优势>使用场景和优势</h2><ol><li><p>数据驱动设计
<code>ScriptableObject</code>非常适合用于数据驱动的设计模式，尤其是需要存储大量的静态数据时（例如游戏中的关卡配置、角色属性、武器属性等），使用<code>ScriptableObject</code>可以让你将这些数据与游戏逻辑分离，使其更加模块化和易于管理</p></li><li><p>节省内存
由于<code>ScriptableObject</code>实例是引用传递的，而不是每次都创建新对象，它可以显著减少内存开销。多个游戏对象可以共享同一个<code>ScriptableObject</code>实例，避免了每个对象都存储一份重复的数据</p></li><li><p>配置和设置
在游戏开发中，很多时候会需要管理一组设置，例如游戏难度、音效音量等，<code>ScriptableObject</code>可以很方便地存储这些配置，并且能在编辑器中直接查看和修改</p></li><li><p>序列化复杂数据结构
<code>ScriptableObject</code>支持序列化复杂的数据结构，包括数组、列表、字典等，可以轻松地管理这些数据</p></li></ol><h2 id=常见用法>常见用法</h2><ol><li>创建游戏配置数据
<code>ScriptableObject</code>在游戏配置中非常常见</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[CreateAssetMenu(fileName = &#34;GameSettings&#34;, menuName = &#34;ScriptableObjects/GameSettings&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameSettings</span> : ScriptableObject
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> musicVolume;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> sfxVolume;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> isFullscreen;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后可以在<code>GameSettings</code>资源中编辑这些值，或者通过脚本加载并应用它们</p><ol start=2><li>创建状态机（State Mechine）
每个状态可以是一个<code>ScriptableObject</code>实例</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>State</span> : ScriptableObject
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> Enter();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> Exit();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>对象池
在对象池模式中，<code>ScriptableObject</code>可以用来存储池中对象的配置和初始化数据，尤其是当希望将对象池的某些配置（例如对象的预设、初始化数量等）于对象池的管理逻辑分离时，这样做可以提高代码的可重用性、灵活性和维护性</li></ol><p>通过将对象池的配置数据存储在<code>ScriptableObject</code>中，我们可以方便地管理和修改池的配置，且无需修改池的实现代码。这种方式将数据和逻辑分离，符合单一职责原则</p><p>创建配置的ScriptableObject</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[CreateAssetMenu(fileName = &#34;ObjectPoolConfig&#34;, menuName = &#34;ScriptableObjects/ObjectPoolConfig&#34;, order = 1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObjectPoolConfig</span> : ScriptableObject
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Header(&#34;Pool Settings&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [SerializeField]</span> <span style=color:#66d9ef>private</span> GameObject prefab; <span style=color:#75715e>// 池中对象的预制体</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [SerializeField]</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> initialSize = <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// 初始池大小</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [SerializeField]</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> maxSize = <span style=color:#ae81ff>20</span>; <span style=color:#75715e>// 池的最大容量</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> GameObject Prefab =&gt; prefab;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> InitialSize =&gt; initialSize;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> MaxSize =&gt; maxSize;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个<code>ScriptableObject</code>负责存储对象池的配置信息，包括池中的对象预设、初始大小和最大容量</p><p>对象池实现</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObjectPool</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [serializeField]</span> <span style=color:#66d9ef>private</span> ObjectPoolConfig poolConfig; <span style=color:#75715e>// 引用配置文件</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Queue&lt;GameObject&gt; pool = <span style=color:#66d9ef>new</span> Queue&lt;GameObject&gt;(); <span style=color:#75715e>// 对象池</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化对象池</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Initialize()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = -; i &lt; poolConfig.InitialSize; ++i)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GameObject obj = Instantiate(poolConfig.Prefab);
</span></span><span style=display:flex><span>            obj.SetActive(<span style=color:#66d9ef>false</span>); <span style=color:#75715e>// 对象默认不可见</span>
</span></span><span style=display:flex><span>            pool.Enqueue(obj);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取一个对象</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> GameObject GetObject()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pool.Count &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GameObject obj = pool.Dequeue();
</span></span><span style=display:flex><span>            obj.SetActive(<span style=color:#66d9ef>true</span>); <span style=color:#75715e>// 激活对象</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> obj;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pool.Count &lt; poolConfig.MaxSize) <span style=color:#75715e>// 超过池的最大容量时不再创建新对象</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GameObject obj = Instantiate(poolConfig.Prefab);
</span></span><span style=display:flex><span>            obj.SetActive(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> obj;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// 如果池已满，返回null</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 回收对象</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ReturnObject(GameObject obj)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        obj.SetActive(<span style=color:#66d9ef>false</span>); <span style=color:#75715e>// 禁用对象</span>
</span></span><span style=display:flex><span>        pool.Enqueue(obj); <span style=color:#75715e>// 放回池中</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里，<code>ObjectPool</code>类引用了<code>ObjectPoolConfig</code>来获取对象池的配置信息，这样只需要通过编辑器调整<code>ObjectPoolConfig</code>的参数，就可以轻松控制对象池的行为</p><p>在Unity编辑器中，右键点击<code>Assets</code>目录，选择<code>Create > ScriptableObjects > ObjectPoolConfig</code>来创建一个新的<code>ObjectPoolConfig</code>文件，然后配置其中的属性</p><p>接着，将这个<code>ObjectPoolConfig</code>文件拖到<code>ObjectPool</code>脚本的<code>poolConfig</code>字段中，Unity就会在运行时使用这些配置来初始化对象池</p><p>优点</p><ul><li>灵活配置：直接在Inspector中修改参数</li><li>代码解耦：将配置和池逻辑分开，提高代码的可维护性，修改配置不用修改对象池的实现</li><li>复用性：同一个配置可被多个对象池实例共享，不需要每个对象池都重复定义相同的配置</li><li>可扩展性，可以通过<code>ScriptableObject</code>调整对象池的性能，初始化逻辑等</li></ul><ol start=4><li>作为消息中介
<code>ScriptableObject</code>可以用作消息中介，作为不同模块之间的通信桥梁。这种方式可以有效地解耦各个模块，使它们不直接依赖于彼此，提高系统灵活性和可维护性</li></ol><p>实现一个简单的游戏事件系统，允许不同的系统之间传递消息</p><p>自定义消息中介ScriptableObject\</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.Events;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[CreateAssetMenu(fileName = &#34;GameEvent&#34;, menuName = &#34;ScriptableObjects/GameEvent&#34;, order = 2)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameEvent</span> : ScriptableObject
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> List&lt;UnityAction&gt; listeners = <span style=color:#66d9ef>new</span> List&lt;UnityAction&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 注册监听器</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> RegisterListener(UnityAction listener) =&gt; listeners.Add(listener);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 移除监听器</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> UnregisterListener(UnityAction listener) =&gt; listeners.Remove(listener);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 触发事件</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Raise() =&gt; <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> listener <span style=color:#66d9ef>in</span> listeners) listener.Invoke();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>GameEvent</code>作为消息中介，维护一个监听器列表。当事件触发时，它会通知所有注册的监听器。监听器可以是任何方法，只要它们符合<code>UnityAction</code>委托的签名<br>自其他脚本中注册和触发事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Player</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [SerializeField]</span> <span style=color:#66d9ef>private</span> GameEvent playerHurtEvent;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> TakeDamage(<span style=color:#66d9ef>int</span> damage)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 角色受伤</span>
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;Player took damage: &#34;</span> + damage);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 触发受伤事件</span>
</span></span><span style=display:flex><span>        playerHurtEvent.Raise();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UIManager</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [SerializeField]</span> <span style=color:#66d9ef>private</span> GameEvent playerHurtEvent;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnEnable() =&gt; playerHurtEvent.RegisterListener(OnPlayerHurt); <span style=color:#75715e>// 注册监听事件</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnDisable() =&gt; playerHurtEvent.UnregisterListener(OnPlayerHurt); <span style=color:#75715e>// 移除事件监听</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnPlayerHurt() =&gt; Debug.Log(<span style=color:#e6db74>&#34;Player hurt, update UI&#34;</span>); <span style=color:#75715e>// 响应受伤事件</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>Player</code>脚本中，角色受到伤害时触发<code>playerHurtEvent</code>事件，在<code>UIManager</code>中，注册了这个事件，并在事件触发时更新UI</p><p>优点</p><ul><li>解耦：<code>ScriptableObject</code>充当事件的中介，避免系统之间的直接依赖关系，使得模块之间的通信变得松耦合</li><li>灵活性：可以轻松添加或移除事件监听器，而不需要改变系统的其他部分</li><li>易于扩展：可以通过多个<code>ScriptabelObject</code>实现不同的事件，从而扩展事件系统，支持多种类型的事件</li></ul><h2 id=注意事项>注意事项</h2><ul><li>生命周期管理：<code>ScriptableObject</code>不是MonoBehaviour，它并不绑定到游戏对象上，因此它的生命周期需要手动管理</li><li>避免修改数据：如果修改了一个<code>ScriptableObject</code>实例的数据，它会影响到所有引用了该实例的对象，因此需要小心管理，避免意外修改</li><li>场景与非场景资源：<code>ScriptableObject</code>不依赖于场景，保存为资源文件（例如<code>.asset</code>文件）。因此，可以在多个场景中共享相同的<code>ScriptableObject</code>实例</li></ul><h2 id=api>API</h2><p><code>ScriptableObject</code> inherites from <code>Object</code> Implemented in <code>UnityEngine.CoreModule</code></p><p><strong>Static Methods</strong></p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>CreateInstance</code></td><td>创建实例</td></tr></tbody></table><p><strong>Message</strong></p><table><thead><tr><th>Message</th><th>Description</th></tr></thead><tbody><tr><td><code>Awake</code></td><td>当实例被创建时调用</td></tr><tr><td><code>OnDestroy</code></td><td>当实例被销毁时调用</td></tr><tr><td><code>OnDisable</code></td><td>当超出范围时调用</td></tr><tr><td><code>OnEnable</code></td><td>当被加载时调用</td></tr><tr><td><code>OnValidate</code></td><td>仅在编辑器状态下，当脚本被加载或值发生改变时调用</td></tr><tr><td><code>Reset</code></td><td>恢复默认值</td></tr></tbody></table><h2 id=scriptableobject设计原理>ScriptableObject设计原理</h2><p><code>ScriptableObject</code>的原理涉及Unity引擎中的几个关键概念：资源管理、序列化、以及数据共享</p><h3 id=scriptableobject是unity引擎的资源系统的一部分>ScriptableObject是Unity引擎的资源系统的一部分</h3><p><code>ScriptableObject</code>继承自Unity的<code>UnityEngine.Object</code>，这是Unity中所有资源的基类；与普通的<code>MonoBehaviour</code>不同，<code>ScriptableObject</code>不直接绑定到<code>GameObject</code>上，它更像是一个独立的资源对象</p><h4 id=资源管理>资源管理</h4><p>在Unity中，资源是通过 Asset Database来管理的，而<code>ScriptableObject</code>是其中的一部分。它可以在Project视图中作为资源文件存在，通常是<code>.asset</code>文件。这些资源通过Unity的资源管理系统进行管理，在加载和卸载时可以更高效地共享和复用</p><p>每个<code>ScriptableObject</code>实例实际上是一个持久化的资源文件，这些文件与场景分离，能够在场景之间进行共享，甚至能在多个项目之间共享</p><h4 id=序列化>序列化</h4><p><code>ScriptableObject</code> 能够被 Unity 引擎 序列化。这意味着，它的字段可以被保存到磁盘上（比如 <code>.asset</code> 文件），并且可以通过 Unity 编辑器直接编辑和查看。Unity 通过其内置的序列化机制，使得 <code>ScriptableObject</code> 的数据可以在编辑器和运行时之间进行持久化存储。</p><p>与普通的 C# 类不同，<code>ScriptableObject</code> 对其字段的修改不需要手动管理存储或写入磁盘，它们会自动序列化到资源文件中。Unity 会根据字段类型将数据转化为可存储的形式（如整数、浮点数、字符串等），并且能够在资源文件中对这些数据进行持久化。</p><h4 id=内存共享>内存共享</h4><p>Unity 内部采用了对象池的机制来管理 <code>ScriptableObject</code> 实例。多个 <code>GameObjec</code> 或 <code>MonoBehaviour</code> 可以引用同一个 <code>ScriptableObject</code> 实例，而不需要为每个对象创建一个新的实例。这个共享机制显著降低了内存消耗，因为所有引用都指向同一个实例，而不是复制一份新的对象</p><h2 id=scriptableobject与单例模式>ScriptableObject与单例模式</h2><p><code>ScriptableObject</code>在某些情况下可以代替单例模式，但它和传统的单例模式有一些关键的区别，适用场景也不同</p><h3 id=相似性>相似性</h3><ul><li>全局数据管理：<code>ScriptableObject</code>可以用来存储全局数据，这使得它类似于单例模式中的静态实例，允许不同的对象共享相同的数据</li><li>避免重复创建：<code>ScriptableObject</code>实例在项目中是共享的，多个类可以引用同一个<code>ScriptableObject</code>实例，避免了多次创建相同的对象</li></ul><h3 id=区别>区别</h3><ol><li>生命周期和资源管理</li></ol><ul><li>单例模式：单例通常由程序控制其生命周期，通常在应用程序启动时创建，并在整个生命周期内存在。它会保持在内存中，直到应用程序结束</li><li>ScriptableObject：<code>ScriptableObject</code>是资源文件，它的生命周期由Unity管理，通常是与资源文件关联的，而不是直接由代码控制。它可以在场景之间共享，而且它的数据通常是持久化存储的。可以在编辑器中创建并编辑它，且它能通过引用在多个场景或对象之间共享</li></ul><ol start=2><li>用途和场景</li></ol><ul><li>单例模式：适用于一些全局管理的场景，如全局配置、应用程序级别的控制器等，特别是那些需要在整个应用程序生命周期内保持唯一且不变的实例的场合。</li><li>ScriptableObject：更多用于数据存储和共享，尤其适用于配置文件、游戏数据、状态机、资源管理等场景。它非常适合用于开发过程中可以被编辑和调整的数据，且数据是资源化的，可以在 Unity 编辑器中查看和修改。</li></ul><ol start=3><li>线程安全</li></ol><ul><li>单例模式：如果使用静态实例，你需要确保它是线程安全的，尤其是在多线程环境中。很多时候，单例实现中需要用到锁（如 <code>lock</code>）来保证线程安全</li><li>ScriptableObject：它本身不需要担心线程安全问题，因为 Unity 的大多数 API 只能在主线程中访问。<code>ScriptableObject</code> 更多是用于游戏的主线程数据管理</li></ul><ol start=4><li>序列化和编辑器功能</li></ol><ul><li>单例模式：通常，单例实例不是可序列化的，因此无法在 Unity 编辑器中直接编辑它们。单例通常需要使用 <code>Awake()</code> 或 <code>Start()</code> 方法来初始化。</li><li>ScriptableObject：可以在 Unity 编辑器中直接创建、编辑和保存为资源。它支持序列化，可以作为 <code>.asset</code> 文件保存，并且可以在多个场景中共享。</li></ul><h3 id=何时选择scriptableobject>何时选择<code>ScriptableObject</code></h3><ol><li><p>数据驱动的设计
如果需要在多个场景或多个对象之间共享数据，且这些数据不需要实时动态计算或修改，那么 <code>ScriptableObject</code> 是一个很好的选择。例如，角色配置、物品数据等，都可以使用 <code>ScriptableObject</code> 来代替单例模式</p></li><li><p>避免手动管理生命周期
<code>ScriptableObject</code> 会由 Unity 自动管理生命周期，无需手动控制它的创建和销毁。它的资源化特性非常适合于项目中需要持久化的共享数据</p></li><li><p>需要在编辑器中修改数据
如果数据需要频繁修改或调试，而不仅仅是运行时的数据，那么 <code>ScriptableObject</code> 会更加方便，因为它可以在 Unity 编辑器中直接编辑，并且会自动序列化为 <code>.asset</code> 文件进行保存</p></li></ol><h3 id=何时选择单例模式>何时选择单例模式</h3><ol><li><p>需要单一实例控制的场景
如果类需要保持唯一性并且不希望被多个场景或多个对象引用（例如全局游戏管理器，音频管理器等），传统的单例模式更为合适</p></li><li><p>无法进行编辑和修改的场景
如果数据在运行时需要根据某些动态条件调整，<code>ScriptableObject</code> 就不太合适。它通常用于静态数据，而动态计算和状态管理可能更适合单例模式</p></li></ol><h2 id=scriptablesingleton>ScriptableSingleton</h2><p>ScriptableSingleton 是一种结合了 <code>ScriptableObject</code> 和单例模式的设计模式，它继承自 <code>ScriptableObject</code> 利用了 <code>ScriptableObject</code> 的资源管理和共享特性，同时确保数据只有一个实例，并且可以全局访问。这种模式在 Unity 开发中非常常见，特别是在需要保持全局唯一的数据管理对象时</p><h3 id=概念>概念</h3><p><code>ScriptableSingleton</code> 本质上是一个<code>ScriptableObject</code>，但是它确保在整个项目中只有一个实例，它的使用方式类似于传统的单例模式</p><p>关键特点：</p><ul><li>唯一性：确保全局只有一个实例，可以在任何地方访问</li><li>资源化：与<code>ScriptableObject</code>类似，<code>ScriptableObject</code>作为资源存在，可以在Unity编辑器中查看和修改其数据</li><li>全局共享：它可以被多个对象引用而不会创建新的副本，因为它是一个<code>ScriptableObject</code>，Unity会自动共享它的实例</li></ul><h3 id=实现>实现</h3><ol><li>基础实现
创建一个继承自<code>ScriptableObject</code>的类，并在其中实现单例逻辑</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ScriptableSingleton</span>&lt;T&gt; : ScriptableObject <span style=color:#66d9ef>where</span> T : ScriptableObject
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> T _instance;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 保证在资源文件中只存在一个实例</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> T Instance
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (_instance == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 尝试从资源文件中加载该实例</span>
</span></span><span style=display:flex><span>                _instance = Resources.Load&lt;T&gt;(<span style=color:#66d9ef>typeof</span>(T).Name);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (_instance == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 如果不存在，创建新的实例并保存</span>
</span></span><span style=display:flex><span>                    _instance = CreateInstance&lt;T&gt;();
</span></span><span style=display:flex><span>                    Debug.LogWarning(<span style=color:#e6db74>$&#34;Creating new instance of {typeof(T).Name}.&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> _instance;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个基础实现中：</p><ul><li>通过<code>Instance</code>属性获取<code>ScriptableSingleton</code>的唯一实例</li><li>当第一次访问实例时，它会尝试从资源文件中加载该实例，如果加载不到，就会创建一个新的实例并保持其唯一性</li><li><code>Resources.Load&lt;T>(typeof(T).Name)</code>会从<code>Resource</code>文件夹中加载资源，如果没有该资源，则会使用<code>CreateInstance&lt;T>()</code>创建一个新的实例</li></ul><ol start=2><li>使用
当需要使用<code>ScriptableSingleton</code>时，只需创建一个继承自<code>ScriptableSingleton</code>的类</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[CreateAssetMenu(fileName = &#34;GameSettings&#34;, menuName = &#34;ScriptableObjects/GameSettings&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameSettings</span> : ScriptableSingleton&lt;GameSettings&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> musicVolume;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> sfxVolume;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样，<code>GameSetting</code>类就变成了一个<code>ScriptableSingleton</code></p><h3 id=api-1>API</h3><p><strong>Static Properties</strong></p><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody><tr><td><code>instance</code></td><td>获得单例的实例，当第一次使用这个属性时，Unity会创建这个单例的实例</td></tr></tbody></table><p><strong>Protected Methods</strong></p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>Save</code></td><td>保存当前单例的状态</td></tr></tbody></table><p><strong>Static Methods</strong></p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>GetFilePath</code></td><td>获得ScriptableSingleton的文件路径</td></tr></tbody></table></div><nav class=post-nav><a href=/blog/scriptlayer2nativelayer/ class=hover:underline>pre: Script Layer to Native Layer</a>
<a href=/blog/scriptedimporter/ class=hover:underline>next: ScriptedImporter</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#基本概念>基本概念</a></li><li><a href=#创建和使用>创建和使用</a></li><li><a href=#使用场景和优势>使用场景和优势</a></li><li><a href=#常见用法>常见用法</a></li><li><a href=#注意事项>注意事项</a></li><li><a href=#api>API</a></li><li><a href=#scriptableobject设计原理>ScriptableObject设计原理</a><ul><li><a href=#scriptableobject是unity引擎的资源系统的一部分>ScriptableObject是Unity引擎的资源系统的一部分</a><ul><li><a href=#资源管理>资源管理</a></li><li><a href=#序列化>序列化</a></li><li><a href=#内存共享>内存共享</a></li></ul></li></ul></li><li><a href=#scriptableobject与单例模式>ScriptableObject与单例模式</a><ul><li><a href=#相似性>相似性</a></li><li><a href=#区别>区别</a></li><li><a href=#何时选择scriptableobject>何时选择<code>ScriptableObject</code></a></li><li><a href=#何时选择单例模式>何时选择单例模式</a></li></ul></li><li><a href=#scriptablesingleton>ScriptableSingleton</a><ul><li><a href=#概念>概念</a></li><li><a href=#实现>实现</a></li><li><a href=#api-1>API</a></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>