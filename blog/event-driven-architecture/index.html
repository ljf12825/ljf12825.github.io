<!doctype html><html lang=en><head><meta charset=UTF-8><title>Event-Driven Architecture</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Event-Driven Architecture" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Event-Driven Architecture<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><h1 id=委托与事件>委托与事件</h1><p>Unity中的事件和委托机制是基于C#的语言特性实现的，用于对象之间的解耦通信。它们是实现观察者模式的核心方式，常用于UI更新、角色状态变化、触发器反应等场景</p><h2 id=委托delegate>委托（Delegate）</h2><p>委托是对函数的引用，可以把方法当作变量一样传递，就是C++中的函数指针</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> MyDelegate(<span style=color:#66d9ef>string</span> message); <span style=color:#75715e>// 声明一个委托类型</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> PrintMessage(<span style=color:#66d9ef>string</span> msg) =&gt; Debug.Log(msg);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> UseDelegate()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MyDelegate del = PrintMessage; <span style=color:#75715e>// 赋值</span>
</span></span><span style=display:flex><span>        dle(<span style=color:#e6db74>&#34;Hello Delegate!&#34;</span>); <span style=color:#75715e>// 调用</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>相当于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 函数指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>func)(string) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>PrintMessage;
</span></span></code></pre></div><h2 id=事件event>事件（Event）</h2><p>事件基于委托，是一种特殊的委托类型，但添加了访问限制，只能在声明它的类内部调用，允许其他对象订阅并响应某个特定的行为或状态变化</p><p>通常用于对象之间的通信，避免了直接调用，使代码更具解耦性</p><h3 id=基本使用>基本使用</h3><p>在Unity中，可以使用C#的<code>event</code>关键字来声明一个事件。事件的订阅和触发通常会在组件之间完成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 定义事件的委托类型</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> PlayerScored(<span style=color:#66d9ef>int</span> score);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameManager</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 声明一个事件</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>event</span> PlayerScored OnPlayerScored;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> PlayerScore(<span style=color:#66d9ef>int</span> score)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 触发事件</span>
</span></span><span style=display:flex><span>        OnPlayerScored?.Invoke(score);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UIManager</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> GameManager gameManager;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnEnable()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 订阅事件</span>
</span></span><span style=display:flex><span>        gameManager.OnPlayerScored += UpdateScoreDisplay;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDisable()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 取消订阅</span>
</span></span><span style=display:flex><span>        gameManager.OnPlayerScored -= UpdateScoreDisplay;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> UpdateScoreDisplay(<span style=color:#66d9ef>int</span> score)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 更新UI</span>
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;Player scored: &#34;</span> + score);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>事件的特点：</p><ul><li>解耦：<code>GameManager</code>不需要知道<code>UIManager</code>的存在，UIManager可以独立地响应得分变化</li><li>多播：一个事件可以有多个订阅者，也可以通过<code>+=</code>和<code>-=</code>来添加或移除订阅者</li><li>安全：通过<code>?.Invoke()</code>确保事件只在有订阅者时触发，避免空引用异常</li></ul><h3 id=unity中常见用法>Unity中常见用法</h3><ol><li>自定义事件传递数据</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Palyer</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> HealthChanged(<span style=color:#66d9ef>int</span> newHp);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>event</span> HealthChanged OnHealthChanged;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> hp = <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> TakeDamage(<span style=color:#66d9ef>int</span> damage)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        hp -= damage;
</span></span><span style=display:flex><span>        OnHealthChanged?.Invoke(hp);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>使用Action/Func/EventHandler简化写法（推荐）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Player</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>event</span> Action&lt;<span style=color:#66d9ef>int</span>&gt; OnHealthChanged;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> TakeDamage(<span style=color:#66d9ef>int</span> damage) =&gt; OnHealthChanged?.Invoke(<span style=color:#ae81ff>100</span> - damamge);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=示例>示例</h3><ol><li>UI更新</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HealthUI</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Player player;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Start() =&gt; player.OnHealthChanged += UpdateHealthBar;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> UpdateHealthBar(<span style=color:#66d9ef>int</span> hp)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 更新血条UI</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>输入控制器通知角色行为</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InputManager</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>event</span> Action OnJump;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Input.GetKeyDown(KeyCode.Space)) OnJump?.Invoke();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PlayerController</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnEnable() =&gt; InputManager.OnJump += Jump;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnDisable() =&gt; InputManager.OnJump -= Jump;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Jump()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行跳跃</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=c委托事件的优点>C#委托事件的优点</h3><ul><li>松耦合：组件A不需要直接引用组件B，只需要暴露事件接口，B只需要订阅即可。这减少了组件间的耦合，使得系统更加灵活</li><li>可扩展性：可以很容易地添加新的实践订阅者，无需更改已有的代码。例如，多个UI元素或音效系统可以同时监听相同的事件</li><li>响应灵活：委托和事件允许你在运行时动态地绑定方法。例如，UI按钮的带年纪事件可以通过委托绑定不同的处理方法，甚至可以从外部脚本动态添加和移除事件处理方法</li><li>避免重复执行：事件和委托可以确保方法只被执行一次，避免了多个事件处理方法同时执行同一操作的问题</li></ul><h3 id=注意事项>注意事项</h3><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>内存泄漏</td><td>如果事件订阅者未取消订阅，引用会一直存在，GC 无法释放</td></tr><tr><td>空检查</td><td><code>event?.Invoke()</code> 避免空引用异常</td></tr><tr><td>多次订阅</td><td>注意避免重复注册：可能会导致方法被执行多次</td></tr><tr><td>性能问题</td><td>事件系统比直接调用略慢，但利于解耦</td></tr></tbody></table><h1 id=事件驱动架构>事件驱动架构</h1><p>事件驱动架构（Event-Driven Architecture，简称EDA）是一种以事件作为系统运行核心驱动力的软件架构模式<br>它的思路是：</p><blockquote><p>当某个事件发生时，系统会通知对改事件感兴趣的组件，由它们决定如何响应
这种模式的重点是“触发→通知→响应”，而不是“调用→返回”</p></blockquote><h2 id=核心概念>核心概念</h2><ol><li>事件（Event）</li></ol><ul><li>事件是系统状态变化的记录</li><li>通常包含：<ul><li>事件类型（例如<code>"PlayerDied</code>、<code>"OrderCreated"</code>）</li><li>事件数据（如死亡位置、订单详情）</li></ul></li><li>事件是“一次性的事实”，不会被修改</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PlayerDiedEvent</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Vector3 deathPosition;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> PlayerDiedEvent(Vector3 pos) =&gt; deathPosition = pos;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>事件生产者（Event Producer）</li></ol><ul><li>负责检测某件事情发生，并发出事件</li><li>它只负责发出，不关心谁接收、怎么处理</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PlayerHealth</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>event</span> Action&lt;PlayerDiedEvent&gt; OnPlayerDied;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> TakeDamage(<span style=color:#66d9ef>int</span> amount)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 扣血逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#75715e>/*死亡条件*/</span>) OnPlayerDied?.Invoke(<span style=color:#66d9ef>new</span> PlayerDiedEvent(transform.position));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>事件消费者（Event Consumer）</li></ol><ul><li>订阅（Subscribe）某类事件，并在事件发生时响应</li><li>不直接调用生产者，而是等待事件通知</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameManager</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> PlayerHealth playerHealth;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnEnable() =&gt; playerHealth.OnPlayerDied += HandlePlayerDeath;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnDisable() =&gt; playerHealth.OnPlayerDied -= HandlePlayerDeath;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> HandlePlayerDeath(PlayerDiedEvent e)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>$&#34;玩家死亡，位置：{e.deathPosition}&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 触发游戏结束逻辑</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=特点>特点</h2><p>优点</p><ol><li>解耦：生产者和消费者互不依赖，降低模块耦合度</li><li>可扩展性强：新增功能只需新建事件监听者，无需更改生产者</li><li>异步性：事件可以异步处理，提高系统吞吐量（特别是在分布式系统里）</li><li>灵活性：可以有多个监听者对同一事件做出不同反应</li></ol><p>缺点</p><ol><li>调试困难：事件流是分散的，不能像函数调用链那样直观</li><li>事件风暴：事件过多或链式触发，可能引起性能问题</li><li>状态一致性：异步事件可能导致数据状态延迟更新</li></ol><h2 id=架构流程>架构流程</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>事件源（</span>Producer<span style=color:#960050;background-color:#1e0010>）</span> <span style=color:#f92672>--</span><span style=color:#960050;background-color:#1e0010>发出事件</span><span style=color:#f92672>-</span>-&gt; <span style=color:#960050;background-color:#1e0010>事件通道（</span>Event Bus<span style=color:#960050;background-color:#1e0010>）</span> <span style=color:#f92672>--</span><span style=color:#960050;background-color:#1e0010>分发</span><span style=color:#f92672>-</span>-&gt; <span style=color:#960050;background-color:#1e0010>事件监听者（</span>Consumer<span style=color:#960050;background-color:#1e0010>）</span>
</span></span></code></pre></div><p>可以用两种方式实现：</p><ol><li>直接回调（同进程、同步）：C#事件、委托</li><li>消息总线/事件总线（异步）：如<code>EventAggregator</code>、<code>MessageBus</code>、<code>RabbitMQ</code>、<code>Kafka</code></li></ol><p>在Unity中的应用场景</p><table><thead><tr><th>场景</th><th>示例事件</th><th>好处</th></tr></thead><tbody><tr><td>UI 更新</td><td><code>"ScoreChanged"</code></td><td>UI 只关心分数变化，不管谁改的分数</td></tr><tr><td>游戏状态</td><td><code>"GameOver"</code></td><td>所有相关系统（UI、音乐、AI）都能收到结束事件</td></tr><tr><td>AI 行为</td><td><code>"EnemySpotted"</code></td><td>AI 角色感知敌人后触发反应</td></tr><tr><td>资源管理</td><td><code>"ItemPickedUp"</code></td><td>背包系统和音效系统都能响应</td></tr></tbody></table><p>最佳实践</p><ol><li>事件名用过去式（如<code>PlayerDied</code>而不是<code>PlayerDie</code>）表示它已经发生</li><li>数据封装到事件类中，避免传一堆参数</li><li>解订阅事件，防止内存泄露（<code>OnDisable</code>里取消监听）</li><li>避免事件滥用，过多事件会导致性能下降和可维护性变差</li><li>集中管理事件（如使用<code>EventManager</code>）或第三方事件总线库</li></ol><p>事件驱动架构的精髓是让变化“广播”出去，由感兴趣的模块去响应，而不是让变化方直接控制接下来发生的事</p></div><nav class=post-nav><a href=/blog/event-bus-event-aggregator/ class=hover:underline>pre: Event Bus/Aggregator</a>
<a href=/blog/frame/ class=hover:underline>next: Frame</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><a href=#委托与事件>委托与事件</a><ul><li><a href=#委托delegate>委托（Delegate）</a></li><li><a href=#事件event>事件（Event）</a><ul><li><a href=#基本使用>基本使用</a></li><li><a href=#unity中常见用法>Unity中常见用法</a></li><li><a href=#示例>示例</a></li><li><a href=#c委托事件的优点>C#委托事件的优点</a></li><li><a href=#注意事项>注意事项</a></li></ul></li></ul></li><li><a href=#事件驱动架构>事件驱动架构</a><ul><li><a href=#核心概念>核心概念</a></li><li><a href=#特点>特点</a></li><li><a href=#架构流程>架构流程</a></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>