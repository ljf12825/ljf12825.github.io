<!doctype html><html lang=en><head><meta charset=UTF-8><title>Unity</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=Unity class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Unity<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><h1 id=引擎整体架构>引擎整体架构</h1><h2 id=unity-playerc引擎内核>Unity Player(C++引擎内核)</h2><p>Unity Player是Unity的心脏，它是引擎的底层C++实现，是多个底层模块的统称，负责把游戏逻辑变成实际在不同平台上运行的程序</p><h3 id=定位与作用>定位与作用</h3><ul><li>本质：Unity Player是一个用C++写的跨平台引擎核心</li><li>作用：提供底层系统功能，包括：<ul><li>渲染（Graphics）</li><li>物理（Physics）</li><li>音频（Audio）</li><li>网络（Networking）</li><li>输入（Input）</li><li>线程调度与内存管理</li></ul></li></ul><p>它本身不处理脚本逻辑，脚本逻辑最终会通过Scripting Runtime（Mono / IL2CPP）调用Player的C++接口</p><h3 id=核心模块>核心模块</h3><ol><li>渲染子系统</li></ol><ul><li>管理GPU渲染管线、材质、光照、Shader、后处理等</li><li>内置支持多个渲染管线（Built-in/URP/HDRP）</li><li>实现跨平台抽象：DirextX/Metal/Vulkan/OpenGL ES</li></ul><ol start=2><li>物理子系统</li></ol><ul><li>基于NVIDIA PhysX或自研物理库</li><li>提供刚体、碰撞、关节、角色控制器等功能</li><li>负责物理模拟循环，保证帧率稳定</li></ul><ol start=3><li>音频子系统</li></ol><ul><li>管理音源、3D音效、混音器、DSP效果等</li><li>提供低延迟音频播放和跨平台兼容</li></ul><ol start=4><li>输入系统</li></ol><ul><li>键盘、鼠标、触屏、手柄等输入统一抽象</li><li>新Input System封装事件驱动接口，旧Input类通过C++底层调用</li></ul><ol start=5><li>资源与内存管理</li></ol><ul><li>C++层负责原生内存的分配与管理</li><li>与托管内存（C#对象）协作，通过GCHandle或NativeArray管理托管与原生内存交互</li></ul><ol start=6><li>线程与任务调度</li></ol><ul><li>渲染、物理、脚本、音频等子系统可能在不同线程</li><li>Player负责线程安全、调度和同步</li></ul><h3 id=与scripting-runtime的关系>与Scripting Runtime的关系</h3><ul><li>Mono/IL2CPP负责执行C#脚本，但大部分游戏逻辑最终还是需要调用Player的底层C++接口</li><li>这层是桥梁：脚本调用 -> C++ Player -> 底层API（GPU、物理、音频）</li><li>IL2CPP的作用是把C#脚本编译为C++，再通过Player编译成机器码执行，提高性能</li></ul><h2 id=scripting-runtimemonoil2cpp>Scripting Runtime(Mono/IL2CPP)</h2><p>这是Unity中连接“脚本逻辑”和Unity Player的桥梁，属于中间层运行时系统\</p><h3 id=角色与定位>角色与定位</h3><p>Scripting Runtime负责</p><ul><li>执行C#脚本逻辑</li><li>管理托管内存（GC）</li><li>处理脚本与引擎C++层的互操作（bindings）</li></ul><p>它是Unity脚本世界的虚拟机，Unity提供两种实现方式</p><ul><li>Mono（传统的.NET运行时）</li><li>IL2CPP（把IL代码转成C++再编译为机器码）</li></ul><h3 id=monoil2cpp><a href=/content/blog/Mono&amp;IL2CPP.md>Mono&amp;IL2CPP</a></h3><h3 id=托管内存与gc机制>托管内存与GC机制</h3><p>无论是Mono还是IL2CPP，脚本层都运行在托管内存环境</p><ul><li>所有C#对象（GameObject、Component、ScriptableObject等）都受GC管理</li><li>GC暂停（Stop-the-world）会影响帧率，因此<ul><li>高频逻辑要减少分配</li><li>使用<code>object pool</code>对象池</li><li>避免频繁装箱/拆箱</li></ul></li></ul><p>Unity自2019起采用了增量式GC（Incremental GC），缓解了帧冻结问题</p><h3 id=脚本与c交互机制bindings>脚本与C++交互机制（Bindings）</h3><ul><li>Unity通过一套C++ &lt;-> C# 桥接系统实现引擎调用</li><li>在C#层看到的类，如<code>Transform</code>、<code>Rigidbody</code>、<code>Renderer</code>等，都是<ul><li>C#包装类（托管层）</li><li>对应C++引擎对象（原生层）</li></ul></li><li>绑定通过：<ul><li>内部调用（InternalCall）</li><li>P/Invoke（Platform Invocation）</li><li>Generated Bindings（新系统，自动生成高效桥接代码）</li></ul></li></ul><p><a href=/content/blog/ScriptLayer2NativeLayer.md>NativeLayer to ScriptLayer</a></p><p>脚本中<code>transform.position = new Vector3(1, 0, 0)</code><br>实际上是：C#对象 -> IL2CPP桥接 -> C++原生Transform -> 改变底层数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>C</span>#脚本<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>↓</span> <span style=color:#f92672>编译为IL</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>Mono</span> <span style=color:#f92672>/</span> <span style=color:#f92672>IL2CPP</span> <span style=color:#f92672>Runtime</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>↓</span> <span style=color:#f92672>调用桥接接口</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>C</span><span style=color:#f92672>++</span> <span style=color:#f92672>Engine</span> <span style=color:#f92672>Core</span> <span style=color:#f92672>(</span><span style=color:#f92672>Unity</span> <span style=color:#f92672>Player</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>底层系统</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#f92672>渲染</span> <span style=color:#f92672>/</span> <span style=color:#f92672>物理</span> <span style=color:#f92672>/</span> <span style=color:#f92672>音频</span> <span style=color:#f92672>/</span> <span style=color:#f92672>输入</span> <span style=color:#f92672>...]</span>
</span></span></code></pre></div><h2 id=平台抽象层platform-abstraction-layer-pal>平台抽象层（Platform Abstraction Layer, PAL）</h2><p>决定了跨平台能力和性能底线的部分</p><h3 id=定位与作用-1>定位与作用</h3><p>平台抽象层是Unity C++引擎中介于引擎通用逻辑和具体平台实现之间的中间层<br>它的核心使命是：屏蔽操作系统、硬件、API差异，给上层（Unity Player / Scripting Runtime）提供统一接口<br>Unity的跨平台本质上就是靠这层在做“同一接口，不同平台不同实现”</p><ul><li>选择对应平台实现</li><li>提供统一接口</li><li>封装所有系统调用</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>C</span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#f92672>脚本层</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>Scripting</span> <span style=color:#f92672>Runtime</span> <span style=color:#f92672>(</span><span style=color:#f92672>Mono</span><span style=color:#f92672>/</span><span style=color:#f92672>IL2CPP</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>Unity</span> <span style=color:#f92672>Player</span> <span style=color:#f92672>(</span><span style=color:#f92672>C</span><span style=color:#f92672>++</span> <span style=color:#f92672>引擎核心</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>平台抽象层</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#f92672>Platform</span> <span style=color:#f92672>Abstraction</span> <span style=color:#f92672>Layer</span><span style=color:#960050;background-color:#1e0010>）</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>操作系统</span> <span style=color:#f92672>/</span> <span style=color:#f92672>硬件</span> <span style=color:#f92672>/</span> <span style=color:#f92672>平台SDK</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>比如脚本调用<code>File.Open()</code></p><ul><li>C#调用到Player的文件接口</li><li>Player再调用PAL提供的“文件访问API”</li><li>PAL根据平台自动调用<code>fopen</code>/<code>CreateFileW</code>/<code>NSFileManager</code>/<code>AAssetManager</code></li></ul><h3 id=pal的主要模块>PAL的主要模块</h3><ol><li>图形抽象层（GfxDevice Layer）</li></ol><ul><li>统一封装GPU调用接口</li><li>支持多种渲染后端：DirextX/Metal/Vulkan/OpenGL/GNM</li><li>负责命令缓冲、资源绑定、渲染目标、Shader编译等</li><li>Unity中对应类：<code>GfxDevice</code>, <code>GfxContext</code>, <code>ShaderLab</code>, <code>ShaderCompilerPlatform</code></li></ul><ol start=2><li>文件系统抽象（FileSystem Layer）</li></ol><ul><li>统一文件路径、权限、读写接口</li><li>支持打包资源（AssetBundle、StreamingAssets、PersistentDataPath）</li><li>对平台路径分隔符、编码、权限进行适配</li></ul><ol start=3><li>输入抽象（Input Layer）</li></ol><ul><li>提供统一事件模型（鼠标、键盘、触屏、手柄）</li><li>新Input System直接基于这层进行事件采集与分发</li></ul><ol start=4><li>音频抽象（Audio Layer）</li></ol><ul><li>封装各平台音频API（OpenSL、CoreAudio、XAudio2等）</li><li>提供统一音频缓冲管理与混音接口</li></ul><ol start=5><li>线程与任务系统（Threading & Job System Layer）</li></ol><ul><li>封装pthread/Win32 thread / SDK thread</li><li>提供跨平台同步原语（mutex、semaphore、atomic等）</li></ul><ol start=6><li>网络抽象（Network Layer）</li></ol><ul><li>统一socket和网络接口调用</li><li>封装HTTP、WebSocket、UDP等</li></ul><ol start=7><li>时间与计时系统（Time Layer）</li></ol><ul><li>提供跨平台精确时间、帧时间、DeltaTime等</li></ul><h3 id=平台特化platform-specific-layer>平台特化（Platform Specific Layer）</h3><p>PAL之下，Unity针对每个平台都有特化实现，比如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>Runtime<span style=color:#f92672>/</span>PlatformDependent<span style=color:#f92672>/</span>Win<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>Runtime<span style=color:#f92672>/</span>PlatformDependent<span style=color:#f92672>/</span>Android<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>Runtime<span style=color:#f92672>/</span>PlatformDependent<span style=color:#f92672>/</span>iOS<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>Runtime<span style=color:#f92672>/</span>PlatformDependent<span style=color:#f92672>/</span>Linux<span style=color:#f92672>/</span>
</span></span></code></pre></div><p>这些目录中是</p><ul><li>文件系统实现（FileWin.cpp, FileAndroid.cpp&mldr;）</li><li>输入接口</li><li>平台启动代码（Entry Point）</li><li>特定编译选项、SDK调用</li></ul><p>Unity编译时通过宏开关（如<code>UNITY_ANDROID</code>, <code>UNITY_WIN</code>, <code>UNITY_IOS</code>）选择不同文件编译入引擎</p><h3 id=对游戏开发者的意义>对游戏开发者的意义</h3><p>虽然普通开发者看不到PAL，但它影响深远</p><ul><li>跨平台一致性：同样一份代码，能跑在不同系统上</li><li>性能优化边界：理解PAL能让你知道为什么不同平台表现差异</li><li>原生插件开发：写Native Plugin时必须遵循PAL的约定，否则Unity Player无法安全调用</li><li>自定义渲染管线/底层扩展：需要理解PAL如何连接系统GPU</li></ul><h2 id=渲染管线build-in--urp--hdrp>渲染管线（Build-in / URP / HDRP）</h2><p>渲染管线负责把场景数据（模型、光照、材质、相机）转换成图像像素的整个过程</p><h3 id=渲染管线本质>渲染管线本质</h3><p>渲染管线的本质是一条”数据流“</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>场景（Scene）-&gt; 摄像机（Camera）-&gt; 可见物体（Renderer）-&gt; Shader -&gt; GPU渲染 -&gt; 屏幕图像
</span></span></code></pre></div><p>它定义了：</p><ul><li>渲染顺序（先绘制什么、后绘制什么）</li><li>光照计算方式</li><li>材质和Shader如何结合</li><li>后处理（Bloom、ToneMapping、SSR等）</li><li>GPU命令提交与资源管理</li></ul><p>Unity之所以能输出不同风格（卡通、写实、移动端轻量、高端HDR），本质就是在更换渲染管线实现</p><h3 id=三代渲染管线的变化>三代渲染管线的变化</h3><p>Unity目前存在三种主流渲染管线</p><table><thead><tr><th>管线类型</th><th>名称</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Build-in Pipeline</td><td>内置管线（传统）</td><td>固定流程，难以自定义</td><td>老项目、教学、移动端轻量</td></tr><tr><td>URP</td><td>通用渲染管线（Universal Render Pipeline）</td><td>可扩展、跨平台优化</td><td>移动端、Switch、主机中端</td></tr><tr><td>HDRP</td><td>高清渲染管线（High Definition Render Pipeline）</td><td>高保真、PBR、物理级光照</td><td>高端PC、主机、电影级项目</td></tr></tbody></table><h3 id=build-in-pipeline传统内置管线>Build-in Pipeline（传统内置管线）</h3><p><strong>架构特点：</strong></p><ul><li>基于Unity早期固定渲染流程</li><li>使用Surface Shader + 内置光照模型（Blinn-Phong/Lambert）</li><li>所有渲染逻辑由Unity内部C++代码控制（不可修改）</li></ul><p><strong>优点：</strong></p><ul><li>稳定、成熟</li><li>上手简单、教程多</li></ul><p><strong>缺点：</strong></p><ul><li>可扩展性差（想改就得改ShaderLab内部定义）</li><li>不支持现代渲染特性（延迟光照、SRP批处理、GPU实例化受限）</li><li>光照模型不灵活（自定义PBR麻烦）</li></ul><blockquote><p>Build-in就是“Unity替你写好了渲染管线，你只能在Shader里打补丁”</p></blockquote><h3 id=urpuniversal-render-pipeline>URP（Universal Render Pipeline）</h3><p>URP是Unity为现代设备设计的“可编程渲染管线”，基于Scriptable Render Pipeline（SPR）架构</p><p><strong>架构核心：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mathematica data-lang=mathematica><span style=display:flex><span>C#<span style=color:#960050;background-color:#1e0010>层：</span>RenderPipelineAsset <span style=color:#f92672>/</span> RenderPipeline
</span></span><span style=display:flex><span>C<span style=color:#f92672>++</span><span style=color:#960050;background-color:#1e0010>层：</span>Unity Player <span style=color:#960050;background-color:#1e0010>渲染接口</span>
</span></span><span style=display:flex><span>GPU<span style=color:#960050;background-color:#1e0010>层：</span>Shader<span style=color:#960050;background-color:#1e0010>（</span>HLSL<span style=color:#960050;background-color:#1e0010>）</span>
</span></span></code></pre></div><p><strong>工作机制：</strong></p><ol><li>Unity在启动时加载URP的Pipeline Asset</li><li>C#代码通过RenderPipeline控制每一帧的渲染过程<ul><li>过滤可见对象</li><li>设置RenderTarget</li><li>执行渲染Pass</li></ul></li><li>URP内部执行优化<ul><li>SRP Batcher（批处理优化）</li><li>GPU Instancing（实例化）</li><li>Forward + 渲染（更高效的多光源渲染）</li><li>Shader Variant剔除</li></ul></li></ol><p><strong>特点：</strong></p><ul><li>完全可以自定义渲染逻辑（C#控制GPU流程）</li><li>跨平台表现一致（PC/移动/主机）</li><li>优化比较激进（统一Shader模板、管线级优化）</li></ul><p><strong>适用：</strong><br>移动游戏、中等规格主机、VR、独立游戏</p><blockquote><p>URP是“为性能和兼容性平衡而生的现代可编程管线”</p></blockquote><h3 id=hdrphigh-definition-render-pipeline>HDRP（High Definition Render Pipeline）</h3><p>HDRP是Unity面向高端平台的高保真管线，核心是物理化渲染（Physically-Based Rendering）</p><p><strong>核心特性：</strong></p><ul><li>真实光照模型（Energy-Conserving BRDF）</li><li>延迟渲染 + Tile/Cluster光照</li><li>屏幕空间反射（SSR）、全局光照（SSGI）</li><li>高级体积光（Volumetric Lighting）</li><li>多级后处理（Tone Mapping、Color Grading、Bloom、DOF）</li><li>支持DX12、Vulkan、Metal</li><li>支持光线追踪（Ray Tracing）</li></ul><p><strong>架构上：</strong></p><ul><li>同样基于SRP，但实现复杂度更高</li><li>拥有更强的Material/Lighting体系（Lit、StackLit、Decal等）</li><li>专为物理精度与高画质定制，不考虑老设备兼容性</li></ul><blockquote><p>HDRP是“写实画面的终极方案”，但代价是性能和开发复杂度</p></blockquote><h3 id=scriptalbe-render-pipelinesrp的统一思想>Scriptalbe Render Pipeline（SRP）的统一思想</h3><p>URP和HDRP都基于同一个框架：SRP<br>SRP让Unity的渲染管线“从硬编码” -> “脚本可编程”<br>可以写出自定义管线</p><p><strong>核心类：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>RenderPipelineAsset <span style=color:#75715e>// 管线资源配置</span>
</span></span><span style=display:flex><span>RenderPipeline <span style=color:#75715e>// 每帧执行逻辑</span>
</span></span><span style=display:flex><span>RenderPass / RenderFeature <span style=color:#75715e>//扩展模块</span>
</span></span></code></pre></div><p>这意味着：</p><ul><li>你可以定义Camera如何渲染</li><li>可以插入自定义Pass（轮廓描边、体积雾、屏幕特效）</li><li>完全控制渲染顺序和命令</li></ul><p>SRP的出现让Unity从“游戏引擎”进化成“渲染框架”</p><h2 id=物理与动画子系统>物理与动画子系统</h2><h3 id=物理子系统physics>物理子系统（Physics）</h3><p>物理子系统负责模拟真实世界的力学行为，包括刚体、碰撞、关节、角色控制器等</p><h4 id=核心组成>核心组成</h4><ol><li>刚体（Rigidbody）<ul><li>表示一个受力的物体</li><li>属性：质量、阻力、重力、速度等</li><li>控制方式：<ul><li>通过物理力（AddForce）驱动</li><li>直接修改位置（会跳过物理）</li></ul></li></ul></li><li>碰撞器（Collider）<ul><li>定义物体形状，用于检测碰撞</li><li>类型：<ul><li>基本形状：Box, Sphere, Capsule</li><li>MeshCollider（复杂模型）</li></ul></li></ul></li><li>物理引擎核心</li></ol><ul><li>Unity主要使用NVIDIA PhysX（PC、主机）作为底层实现</li><li>Android/iOS/主机平台上可能有优化或自研替代</li><li>负责：<ul><li>碰撞检测</li><li>刚体动力学</li><li>关节约束</li><li>碰撞回调（OnCollisionEnter, OnTriggerEnter）</li></ul></li></ul><ol start=4><li>场景集成<ul><li>每帧固定更新（FixedUpdate）物理世界</li><li>与渲染循环独立，保证模拟稳定性</li><li>支持多进程计算（Job System + Burst优化）</li></ul></li></ol><h4 id=脚本层交互>脚本层交互</h4><p>C#层的<code>Rigidbody</code>, <code>Collider</code>等都是托管对象，内部绑定对应C++的原生PhysX对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Rigidbody rb = GetComponent&lt;Rigidbody&gt;();
</span></span><span style=display:flex><span>rb.AddForce(Vector3.up * <span style=color:#ae81ff>10f</span>);
</span></span></code></pre></div><ul><li>C#调用 -> IL2CPP/Mono桥接 -> C++ PhysX对象 -> 物理计算 -> 更新Transform</li><li>最终渲染层拿到Transform更新位置</li></ul><h3 id=动画子系统animation>动画子系统（Animation）</h3><p>动画子系统负责角色、物体的运动表现，包括骨骼动画、Blend、State Machine等</p><h4 id=核心模块-1>核心模块</h4><ol><li>Animator/Animation组件<ul><li><code>Animator</code>使用Mecanim系统，支持状态机和Blend Tree</li><li><code>Animation</code>是旧动画系统，主要用于简单动画</li></ul></li><li>骨骼动画（Skinned Mesh）<ul><li>Mesh通过骨骼（Bones）驱动顶点变形</li><li>支持GPU skinning加速</li></ul></li><li>状态机（Animator Controller）<ul><li>控制动画播放逻辑（Idle -> Walk -> Run）</li><li>支持条件转换（Triggers, Booleans, Floats）</li><li>每帧更新在Update/AnimatorUpdate模式下执行</li></ul></li><li>Blend Tree<ul><li>混合多种动画，实现平滑过渡</li><li>用于复杂动作组合，如走跑切换、方向移动</li></ul></li><li>IK/动态调整<ul><li>Inverse Kinematics（逆向运动学）</li><li>让角色手、脚自然接触地面或环境</li></ul></li></ol><h4 id=脚本曾交互>脚本曾交互</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Animator anim = GetComponent&lt;Animator&gt;();
</span></span><span style=display:flex><span>anim.SetFloat(<span style=color:#e6db74>&#34;Speed&#34;</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>anim.SetTrigger(<span style=color:#e6db74>&#34;Jump&#34;</span>);
</span></span></code></pre></div><ul><li>C# -> IL2CPP/Mono -> C++动画核心</li><li>动画子系统会计算骨骼矩阵</li><li>更新Skinned Mesh</li><li>最终渲染系统拿到最终顶点数据</li></ul><h3 id=物理与动画的协作>物理与动画的协作</h3><ol><li>Rigidbody与Animator<ul><li>Animator默认不影响物理（“根运动 Root Motion”可选）</li><li>Root Motion开启时，动画驱动Rigidbody位置</li><li>Root Motion关闭时，脚本驱动Rigidbody位置，而Animator只负责骨骼动画</li></ul></li><li>碰撞与动画<ul><li>动画过程中可以触发碰撞事件</li><li>游戏逻辑可以根据碰撞/触发器调整动画状态</li></ul></li></ol><h3 id=总结>总结</h3><ul><li>物理子系统 = “模拟真实世界的力学”</li><li>动画子系统 = “控制物体或角色运动表现”</li><li>它们都属于C++原生引擎模块，C#层只是包装和控制接口</li><li>脚本层与这两者的交互都依赖Scripting Runtime桥接</li></ul><h2 id=editor扩展层>Editor扩展层</h2><p>这是Unity架构中连接用户编辑操作和底层引擎的部分<br>它不影响游戏运行时逻辑，但对于提高生产效率、开发工具、定制工作流至关重要</p><h3 id=定位与作用-2>定位与作用</h3><ul><li>位置：位于Unity Player + Scripting Runtime之上，是C#层的Editor专用模块</li><li>核心作用：<ul><li>提供可视化编辑界面（Inspecor、Hierarchy、Scene视图）</li><li>扩展Unity编辑器功能（自定义工具、窗口、菜单）</li><li>与底层C++引擎交互，实现资源操作、场景管理、渲染预览</li></ul></li></ul><blockquote><p>Editor扩展层 = “Unity的可编程工作台”，开发者可以改造编辑器来提升效率或定制工作流</p></blockquote><h3 id=核心模块-2>核心模块</h3><ol><li>Editor Window/Editor GUI<ul><li>自定义窗口、面板、工具栏</li><li>基于IMGUI或UIElements绘制界面</li><li>可以访问Unity对象（GameObject、ScriptableObject、Asset）</li></ul></li><li>Inspector / Property Drawer<ul><li>Inspector窗口显示对象属性</li><li>PropertyDrawer允许自定义组件属性的显示和编辑方式</li></ul></li><li>Editor Utility<ul><li>文件操作、资源管理、序列化、日志、调试工具</li><li>ScriptableWizard、MenuItem、EditorCoroutine</li></ul></li><li>Scene View/Gizmos<ul><li>直接在Scene视图绘制辅助信息</li><li>自定义Gizmos显示逻辑，如碰撞体、路径、AI节点</li></ul></li><li>Custom Asset Pipeline<ul><li>自定义资源导入器（ScriptedInporter）</li><li>自动处理特定资源格式、生成AssetBundle、Addressable资源</li></ul></li><li>Play Mode Simulation<ul><li>编辑器模式下模拟运行</li><li>PlayMode下的资源加载、脚本执行、物理和动画系统都调用底层Player</li></ul></li></ol><h3 id=脚本层交互-1>脚本层交互</h3><p>Editor扩展层完全在C#托管环境，与游戏运行层使用不同运行上下文：</p><ul><li>游戏运行时（Play Mode）：调用Player + Runtime</li><li>编辑器模式（Edit Mode）：调用Editor扩展层</li></ul><p>它们都通过Scripting Runtime桥接C++引擎，但编辑器扩展有额外API层用于编辑器操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyWindow</span> : EditorWindow
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>  [MenuItem(&#34;Tools/My Window&#34;)]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> ShowWindow() =&gt; GetWindow&lt;MyWindow&gt;(<span style=color:#e6db74>&#34;My Window&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> OnGUI()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Create Cube&#34;</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
</span></span><span style=display:flex><span>      Undo.RegisterCreateObjectUndo(cube, <span style=color:#e6db74>&#34;Create Cube&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>自定义窗口 -> 显示按钮 -> 调用Player API创建Cube</li><li>Undoo系统也通过Editor层统一管理</li></ul><h3 id=editor扩展与工具链>Editor扩展与工具链</h3><ul><li>打通C#编辑器脚本的底层C++引擎</li><li>支持自定义工作流，例如：<ul><li>自动生成场景/预制件</li><li>自定义Inspector显示复杂数据</li><li>编辑器内资源管理和打包</li><li>可视化调试AI、物理或动画</li></ul></li></ul><h3 id=总结-1>总结</h3><ul><li>Editor扩展本质上是C#层的编辑器专用API集合</li><li>它依赖Player + Scripting Runtime提供底层功能</li><li>不影响最终游戏运行时逻辑，但大幅提高开发效率</li><li>对于游戏开发者来说：<ul><li>初级阶段：只会用现有窗口、Inspector、菜单即可</li><li>进阶阶段：可以自定义工具、窗口、资源处理逻辑</li><li>高级阶段：可以写全套编辑器插件或Pipeline工具</li></ul></li></ul><blockquote><p>Editor扩展层是“可编程编辑器 + 工具接口”，是Unity生产力和自动化的核心</p></blockquote><h1 id=运行时结构>运行时结构</h1><h2 id=gameobject--component系统>GameObject & Component系统</h2><h2 id=scene--asset管理>Scene & Asset管理</h2><h2 id=生命周期管理>生命周期管理</h2><h2 id=脚本绑定与执行机制>脚本绑定与执行机制</h2><h2 id=内存模型与gc管理>内存模型与GC管理</h2></div><nav class=post-nav><a href=/blog/ui-system/ class=hover:underline>pre: UI System</a>
<a href=/blog/unity-asynchronous-and-coroutine/ class=hover:underline>next: Unity Asynchronous and Coroutine</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><a href=#引擎整体架构>引擎整体架构</a><ul><li><a href=#unity-playerc引擎内核>Unity Player(C++引擎内核)</a><ul><li><a href=#定位与作用>定位与作用</a></li><li><a href=#核心模块>核心模块</a></li><li><a href=#与scripting-runtime的关系>与Scripting Runtime的关系</a></li></ul></li><li><a href=#scripting-runtimemonoil2cpp>Scripting Runtime(Mono/IL2CPP)</a><ul><li><a href=#角色与定位>角色与定位</a></li><li><a href=#monoil2cpp>Mono&amp;IL2CPP</a></li><li><a href=#托管内存与gc机制>托管内存与GC机制</a></li><li><a href=#脚本与c交互机制bindings>脚本与C++交互机制（Bindings）</a></li></ul></li><li><a href=#平台抽象层platform-abstraction-layer-pal>平台抽象层（Platform Abstraction Layer, PAL）</a><ul><li><a href=#定位与作用-1>定位与作用</a></li><li><a href=#pal的主要模块>PAL的主要模块</a></li><li><a href=#平台特化platform-specific-layer>平台特化（Platform Specific Layer）</a></li><li><a href=#对游戏开发者的意义>对游戏开发者的意义</a></li></ul></li><li><a href=#渲染管线build-in--urp--hdrp>渲染管线（Build-in / URP / HDRP）</a><ul><li><a href=#渲染管线本质>渲染管线本质</a></li><li><a href=#三代渲染管线的变化>三代渲染管线的变化</a></li><li><a href=#build-in-pipeline传统内置管线>Build-in Pipeline（传统内置管线）</a></li><li><a href=#urpuniversal-render-pipeline>URP（Universal Render Pipeline）</a></li><li><a href=#hdrphigh-definition-render-pipeline>HDRP（High Definition Render Pipeline）</a></li><li><a href=#scriptalbe-render-pipelinesrp的统一思想>Scriptalbe Render Pipeline（SRP）的统一思想</a></li></ul></li><li><a href=#物理与动画子系统>物理与动画子系统</a><ul><li><a href=#物理子系统physics>物理子系统（Physics）</a><ul><li><a href=#核心组成>核心组成</a></li><li><a href=#脚本层交互>脚本层交互</a></li></ul></li><li><a href=#动画子系统animation>动画子系统（Animation）</a><ul><li><a href=#核心模块-1>核心模块</a></li><li><a href=#脚本曾交互>脚本曾交互</a></li></ul></li><li><a href=#物理与动画的协作>物理与动画的协作</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#editor扩展层>Editor扩展层</a><ul><li><a href=#定位与作用-2>定位与作用</a></li><li><a href=#核心模块-2>核心模块</a></li><li><a href=#脚本层交互-1>脚本层交互</a></li><li><a href=#editor扩展与工具链>Editor扩展与工具链</a></li><li><a href=#总结-1>总结</a></li></ul></li></ul></li><li><a href=#运行时结构>运行时结构</a><ul><li><a href=#gameobject--component系统>GameObject & Component系统</a></li><li><a href=#scene--asset管理>Scene & Asset管理</a></li><li><a href=#生命周期管理>生命周期管理</a></li><li><a href=#脚本绑定与执行机制>脚本绑定与执行机制</a></li><li><a href=#内存模型与gc管理>内存模型与GC管理</a></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>