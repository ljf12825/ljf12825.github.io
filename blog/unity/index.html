<!doctype html><html lang=en><head><meta charset=UTF-8><title>Unity</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=Unity class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Unity<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><h1 id=引擎整体架构>引擎整体架构</h1><p>引擎中有什么，系统如何被设计出来（静态结构），系统模块关系、职责划分、调用层级</p><h2 id=unity-playerc引擎内核>Unity Player(C++引擎内核)</h2><p>Unity Player是Unity的心脏，它是引擎的底层C++实现，是多个底层模块的统称，负责把游戏逻辑变成实际在不同平台上运行的程序</p><h3 id=定位与作用>定位与作用</h3><ul><li>本质：Unity Player是一个用C++写的跨平台引擎核心</li><li>作用：提供底层系统功能，包括：<ul><li>渲染（Graphics）</li><li>物理（Physics）</li><li>音频（Audio）</li><li>网络（Networking）</li><li>输入（Input）</li><li>线程调度与内存管理</li></ul></li></ul><p>它本身不处理脚本逻辑，脚本逻辑最终会通过Scripting Runtime（Mono / IL2CPP）调用Player的C++接口</p><h3 id=核心模块>核心模块</h3><ol><li>渲染子系统</li></ol><ul><li>管理GPU渲染管线、材质、光照、Shader、后处理等</li><li>内置支持多个渲染管线（Built-in/URP/HDRP）</li><li>实现跨平台抽象：DirextX/Metal/Vulkan/OpenGL ES</li></ul><ol start=2><li>物理子系统</li></ol><ul><li>基于NVIDIA PhysX或自研物理库</li><li>提供刚体、碰撞、关节、角色控制器等功能</li><li>负责物理模拟循环，保证帧率稳定</li></ul><ol start=3><li>音频子系统</li></ol><ul><li>管理音源、3D音效、混音器、DSP效果等</li><li>提供低延迟音频播放和跨平台兼容</li></ul><ol start=4><li>输入系统</li></ol><ul><li>键盘、鼠标、触屏、手柄等输入统一抽象</li><li>新Input System封装事件驱动接口，旧Input类通过C++底层调用</li></ul><ol start=5><li>资源与内存管理</li></ol><ul><li>C++层负责原生内存的分配与管理</li><li>与托管内存（C#对象）协作，通过GCHandle或NativeArray管理托管与原生内存交互</li></ul><ol start=6><li>线程与任务调度</li></ol><ul><li>渲染、物理、脚本、音频等子系统可能在不同线程</li><li>Player负责线程安全、调度和同步</li></ul><h3 id=与scripting-runtime的关系>与Scripting Runtime的关系</h3><ul><li>Mono/IL2CPP负责执行C#脚本，但大部分游戏逻辑最终还是需要调用Player的底层C++接口</li><li>这层是桥梁：脚本调用 -> C++ Player -> 底层API（GPU、物理、音频）</li><li>IL2CPP的作用是把C#脚本编译为C++，再通过Player编译成机器码执行，提高性能</li></ul><h2 id=scripting-runtimemonoil2cpp>Scripting Runtime(Mono/IL2CPP)</h2><p>这是Unity中连接“脚本逻辑”和Unity Player的桥梁，属于中间层运行时系统\</p><h3 id=角色与定位>角色与定位</h3><p>Scripting Runtime负责</p><ul><li>执行C#脚本逻辑</li><li>管理托管内存（GC）</li><li>处理脚本与引擎C++层的互操作（bindings）</li></ul><p>它是Unity脚本世界的虚拟机，Unity提供两种实现方式</p><ul><li>Mono（传统的.NET运行时）</li><li>IL2CPP（把IL代码转成C++再编译为机器码）</li></ul><h3 id=monoil2cpp><a href=/content/blog/Mono&amp;IL2CPP.md>Mono&amp;IL2CPP</a></h3><h3 id=托管内存与gc机制>托管内存与GC机制</h3><p>无论是Mono还是IL2CPP，脚本层都运行在托管内存环境</p><ul><li>所有C#对象（GameObject、Component、ScriptableObject等）都受GC管理</li><li>GC暂停（Stop-the-world）会影响帧率，因此<ul><li>高频逻辑要减少分配</li><li>使用<code>object pool</code>对象池</li><li>避免频繁装箱/拆箱</li></ul></li></ul><p>Unity自2019起采用了增量式GC（Incremental GC），缓解了帧冻结问题</p><h3 id=脚本与c交互机制bindings>脚本与C++交互机制（Bindings）</h3><ul><li>Unity通过一套C++ &lt;-> C# 桥接系统实现引擎调用</li><li>在C#层看到的类，如<code>Transform</code>、<code>Rigidbody</code>、<code>Renderer</code>等，都是<ul><li>C#包装类（托管层）</li><li>对应C++引擎对象（原生层）</li></ul></li><li>绑定通过：<ul><li>内部调用（InternalCall）</li><li>P/Invoke（Platform Invocation）</li><li>Generated Bindings（新系统，自动生成高效桥接代码）</li></ul></li></ul><p><a href=/content/blog/ScriptLayer2NativeLayer.md>NativeLayer to ScriptLayer</a></p><p>脚本中<code>transform.position = new Vector3(1, 0, 0)</code><br>实际上是：C#对象 -> IL2CPP桥接 -> C++原生Transform -> 改变底层数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>C</span>#脚本<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>↓</span> <span style=color:#f92672>编译为IL</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>Mono</span> <span style=color:#f92672>/</span> <span style=color:#f92672>IL2CPP</span> <span style=color:#f92672>Runtime</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>↓</span> <span style=color:#f92672>调用桥接接口</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>C</span><span style=color:#f92672>++</span> <span style=color:#f92672>Engine</span> <span style=color:#f92672>Core</span> <span style=color:#f92672>(</span><span style=color:#f92672>Unity</span> <span style=color:#f92672>Player</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>底层系统</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#f92672>渲染</span> <span style=color:#f92672>/</span> <span style=color:#f92672>物理</span> <span style=color:#f92672>/</span> <span style=color:#f92672>音频</span> <span style=color:#f92672>/</span> <span style=color:#f92672>输入</span> <span style=color:#f92672>...]</span>
</span></span></code></pre></div><h3 id=c与c之间的调用成本interop-overhead>C#与C++之间的调用成本（Interop Overhead）</h3><p>这是Unity性能优化的一个“隐形税收点”<br>当C#调用C++时会产生上下文切换和封送（marshalling）开销，比如：</p><ul><li>结构体、字符串、数组再托管与原生之间需要拷贝</li><li>每次调用都要执行安全检查与栈切换</li></ul><p>Unity为此推出了Generated Bindings系统，让IL2CPP能自动生成“零封送”接口，大幅减少了调用开销。这也是Unity越来越接近原生引擎性能的关键</p><h2 id=平台抽象层platform-abstraction-layer-pal>平台抽象层（Platform Abstraction Layer, PAL）</h2><p>决定了跨平台能力和性能底线的部分</p><h3 id=定位与作用-1>定位与作用</h3><p>平台抽象层是Unity C++引擎中介于引擎通用逻辑和具体平台实现之间的中间层<br>它的核心使命是：屏蔽操作系统、硬件、API差异，给上层（Unity Player / Scripting Runtime）提供统一接口<br>Unity的跨平台本质上就是靠这层在做“同一接口，不同平台不同实现”</p><ul><li>选择对应平台实现</li><li>提供统一接口</li><li>封装所有系统调用</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>C</span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#f92672>脚本层</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>Scripting</span> <span style=color:#f92672>Runtime</span> <span style=color:#f92672>(</span><span style=color:#f92672>Mono</span><span style=color:#f92672>/</span><span style=color:#f92672>IL2CPP</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>Unity</span> <span style=color:#f92672>Player</span> <span style=color:#f92672>(</span><span style=color:#f92672>C</span><span style=color:#f92672>++</span> <span style=color:#f92672>引擎核心</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>平台抽象层</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#f92672>Platform</span> <span style=color:#f92672>Abstraction</span> <span style=color:#f92672>Layer</span><span style=color:#960050;background-color:#1e0010>）</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>操作系统</span> <span style=color:#f92672>/</span> <span style=color:#f92672>硬件</span> <span style=color:#f92672>/</span> <span style=color:#f92672>平台SDK</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>比如脚本调用<code>File.Open()</code></p><ul><li>C#调用到Player的文件接口</li><li>Player再调用PAL提供的“文件访问API”</li><li>PAL根据平台自动调用<code>fopen</code>/<code>CreateFileW</code>/<code>NSFileManager</code>/<code>AAssetManager</code></li></ul><h3 id=pal的主要模块>PAL的主要模块</h3><ol><li>图形抽象层（GfxDevice Layer）</li></ol><ul><li>统一封装GPU调用接口</li><li>支持多种渲染后端：DirextX/Metal/Vulkan/OpenGL/GNM</li><li>负责命令缓冲、资源绑定、渲染目标、Shader编译等</li><li>Unity中对应类：<code>GfxDevice</code>, <code>GfxContext</code>, <code>ShaderLab</code>, <code>ShaderCompilerPlatform</code></li></ul><ol start=2><li>文件系统抽象（FileSystem Layer）</li></ol><ul><li>统一文件路径、权限、读写接口</li><li>支持打包资源（AssetBundle、StreamingAssets、PersistentDataPath）</li><li>对平台路径分隔符、编码、权限进行适配</li></ul><ol start=3><li>输入抽象（Input Layer）</li></ol><ul><li>提供统一事件模型（鼠标、键盘、触屏、手柄）</li><li>新Input System直接基于这层进行事件采集与分发</li></ul><ol start=4><li>音频抽象（Audio Layer）</li></ol><ul><li>封装各平台音频API（OpenSL、CoreAudio、XAudio2等）</li><li>提供统一音频缓冲管理与混音接口</li></ul><ol start=5><li>线程与任务系统（Threading & Job System Layer）</li></ol><ul><li>封装pthread/Win32 thread / SDK thread</li><li>提供跨平台同步原语（mutex、semaphore、atomic等）</li></ul><ol start=6><li>网络抽象（Network Layer）</li></ol><ul><li>统一socket和网络接口调用</li><li>封装HTTP、WebSocket、UDP等</li></ul><ol start=7><li>时间与计时系统（Time Layer）</li></ol><ul><li>提供跨平台精确时间、帧时间、DeltaTime等</li></ul><h3 id=平台特化platform-specific-layer>平台特化（Platform Specific Layer）</h3><p>PAL之下，Unity针对每个平台都有特化实现，比如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>Runtime<span style=color:#f92672>/</span>PlatformDependent<span style=color:#f92672>/</span>Win<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>Runtime<span style=color:#f92672>/</span>PlatformDependent<span style=color:#f92672>/</span>Android<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>Runtime<span style=color:#f92672>/</span>PlatformDependent<span style=color:#f92672>/</span>iOS<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>Runtime<span style=color:#f92672>/</span>PlatformDependent<span style=color:#f92672>/</span>Linux<span style=color:#f92672>/</span>
</span></span></code></pre></div><p>这些目录中是</p><ul><li>文件系统实现（FileWin.cpp, FileAndroid.cpp&mldr;）</li><li>输入接口</li><li>平台启动代码（Entry Point）</li><li>特定编译选项、SDK调用</li></ul><p>Unity编译时通过宏开关（如<code>UNITY_ANDROID</code>, <code>UNITY_WIN</code>, <code>UNITY_IOS</code>）选择不同文件编译入引擎</p><h3 id=对游戏开发者的意义>对游戏开发者的意义</h3><p>虽然普通开发者看不到PAL，但它影响深远</p><ul><li>跨平台一致性：同样一份代码，能跑在不同系统上</li><li>性能优化边界：理解PAL能让你知道为什么不同平台表现差异</li><li>原生插件开发：写Native Plugin时必须遵循PAL的约定，否则Unity Player无法安全调用</li><li>自定义渲染管线/底层扩展：需要理解PAL如何连接系统GPU</li></ul><blockquote><p>Unity的核心结构是一种“三明治模型”：
C#托管逻辑（上层）&lt;-> C++引擎内核（中层）&lt;-> 系统平台接口（底层）
这种设计的关键价值是可移植性与扩展性。C++层保持跨平台的引擎逻辑一致性，而PAL层“翻译”系统调用。这样Unity能再不同设备上跑同一逻辑，而脚本开发者甚至无需关心平台差异</p></blockquote><h2 id=渲染管线build-in--urp--hdrp>渲染管线（Build-in / URP / HDRP）</h2><p>渲染管线负责把场景数据（模型、光照、材质、相机）转换成图像像素的整个过程</p><h3 id=渲染管线本质>渲染管线本质</h3><p>渲染管线的本质是一条”数据流“</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>场景（Scene）-&gt; 摄像机（Camera）-&gt; 可见物体（Renderer）-&gt; Shader -&gt; GPU渲染 -&gt; 屏幕图像
</span></span></code></pre></div><p>它定义了：</p><ul><li>渲染顺序（先绘制什么、后绘制什么）</li><li>光照计算方式</li><li>材质和Shader如何结合</li><li>后处理（Bloom、ToneMapping、SSR等）</li><li>GPU命令提交与资源管理</li></ul><p>Unity之所以能输出不同风格（卡通、写实、移动端轻量、高端HDR），本质就是在更换渲染管线实现</p><h3 id=三代渲染管线的变化>三代渲染管线的变化</h3><p>Unity目前存在三种主流渲染管线</p><table><thead><tr><th>管线类型</th><th>名称</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Build-in Pipeline</td><td>内置管线（传统）</td><td>固定流程，难以自定义</td><td>老项目、教学、移动端轻量</td></tr><tr><td>URP</td><td>通用渲染管线（Universal Render Pipeline）</td><td>可扩展、跨平台优化</td><td>移动端、Switch、主机中端</td></tr><tr><td>HDRP</td><td>高清渲染管线（High Definition Render Pipeline）</td><td>高保真、PBR、物理级光照</td><td>高端PC、主机、电影级项目</td></tr></tbody></table><h3 id=build-in-pipeline传统内置管线>Build-in Pipeline（传统内置管线）</h3><p><strong>架构特点：</strong></p><ul><li>基于Unity早期固定渲染流程</li><li>使用Surface Shader + 内置光照模型（Blinn-Phong/Lambert）</li><li>所有渲染逻辑由Unity内部C++代码控制（不可修改）</li></ul><p><strong>优点：</strong></p><ul><li>稳定、成熟</li><li>上手简单、教程多</li></ul><p><strong>缺点：</strong></p><ul><li>可扩展性差（想改就得改ShaderLab内部定义）</li><li>不支持现代渲染特性（延迟光照、SRP批处理、GPU实例化受限）</li><li>光照模型不灵活（自定义PBR麻烦）</li></ul><blockquote><p>Build-in就是“Unity替你写好了渲染管线，你只能在Shader里打补丁”</p></blockquote><h3 id=urpuniversal-render-pipeline>URP（Universal Render Pipeline）</h3><p>URP是Unity为现代设备设计的“可编程渲染管线”，基于Scriptable Render Pipeline（SPR）架构</p><p><strong>架构核心：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mathematica data-lang=mathematica><span style=display:flex><span>C#<span style=color:#960050;background-color:#1e0010>层：</span>RenderPipelineAsset <span style=color:#f92672>/</span> RenderPipeline
</span></span><span style=display:flex><span>C<span style=color:#f92672>++</span><span style=color:#960050;background-color:#1e0010>层：</span>Unity Player <span style=color:#960050;background-color:#1e0010>渲染接口</span>
</span></span><span style=display:flex><span>GPU<span style=color:#960050;background-color:#1e0010>层：</span>Shader<span style=color:#960050;background-color:#1e0010>（</span>HLSL<span style=color:#960050;background-color:#1e0010>）</span>
</span></span></code></pre></div><p><strong>工作机制：</strong></p><ol><li>Unity在启动时加载URP的Pipeline Asset</li><li>C#代码通过RenderPipeline控制每一帧的渲染过程<ul><li>过滤可见对象</li><li>设置RenderTarget</li><li>执行渲染Pass</li></ul></li><li>URP内部执行优化<ul><li>SRP Batcher（批处理优化）</li><li>GPU Instancing（实例化）</li><li>Forward + 渲染（更高效的多光源渲染）</li><li>Shader Variant剔除</li></ul></li></ol><p><strong>特点：</strong></p><ul><li>完全可以自定义渲染逻辑（C#控制GPU流程）</li><li>跨平台表现一致（PC/移动/主机）</li><li>优化比较激进（统一Shader模板、管线级优化）</li></ul><p><strong>适用：</strong><br>移动游戏、中等规格主机、VR、独立游戏</p><blockquote><p>URP是“为性能和兼容性平衡而生的现代可编程管线”</p></blockquote><h3 id=hdrphigh-definition-render-pipeline>HDRP（High Definition Render Pipeline）</h3><p>HDRP是Unity面向高端平台的高保真管线，核心是物理化渲染（Physically-Based Rendering）</p><p><strong>核心特性：</strong></p><ul><li>真实光照模型（Energy-Conserving BRDF）</li><li>延迟渲染 + Tile/Cluster光照</li><li>屏幕空间反射（SSR）、全局光照（SSGI）</li><li>高级体积光（Volumetric Lighting）</li><li>多级后处理（Tone Mapping、Color Grading、Bloom、DOF）</li><li>支持DX12、Vulkan、Metal</li><li>支持光线追踪（Ray Tracing）</li></ul><p><strong>架构上：</strong></p><ul><li>同样基于SRP，但实现复杂度更高</li><li>拥有更强的Material/Lighting体系（Lit、StackLit、Decal等）</li><li>专为物理精度与高画质定制，不考虑老设备兼容性</li></ul><blockquote><p>HDRP是“写实画面的终极方案”，但代价是性能和开发复杂度</p></blockquote><h3 id=scriptalbe-render-pipelinesrp的统一思想>Scriptalbe Render Pipeline（SRP）的统一思想</h3><p>URP和HDRP都基于同一个框架：SRP<br>SRP让Unity的渲染管线“从硬编码” -> “脚本可编程”<br>可以写出自定义管线</p><p><strong>核心类：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>RenderPipelineAsset <span style=color:#75715e>// 管线资源配置</span>
</span></span><span style=display:flex><span>RenderPipeline <span style=color:#75715e>// 每帧执行逻辑</span>
</span></span><span style=display:flex><span>RenderPass / RenderFeature <span style=color:#75715e>//扩展模块</span>
</span></span></code></pre></div><p>这意味着：</p><ul><li>你可以定义Camera如何渲染</li><li>可以插入自定义Pass（轮廓描边、体积雾、屏幕特效）</li><li>完全控制渲染顺序和命令</li></ul><p>SRP的出现让Unity从“游戏引擎”进化成“渲染框架”</p><p>可拔插渲染框架思想（RenderGraph + GPU Driven Rendering）的趋势：</p><blockquote><p>Unity正在逐渐把SRP向RenderGraph体系演化，用命令图（Command Graph）组织GPU Pass，未来会更接近Unreal的RDG或自研引擎的GPU-driven架构</p></blockquote><p>渲染正在从“指令式”走向“数据驱动 + 并行调度”</p><h2 id=物理与动画子系统>物理与动画子系统</h2><h3 id=物理子系统physics>物理子系统（Physics）</h3><p>物理子系统负责模拟真实世界的力学行为，包括刚体、碰撞、关节、角色控制器等</p><h4 id=核心组成>核心组成</h4><ol><li>刚体（Rigidbody）<ul><li>表示一个受力的物体</li><li>属性：质量、阻力、重力、速度等</li><li>控制方式：<ul><li>通过物理力（AddForce）驱动</li><li>直接修改位置（会跳过物理）</li></ul></li></ul></li><li>碰撞器（Collider）<ul><li>定义物体形状，用于检测碰撞</li><li>类型：<ul><li>基本形状：Box, Sphere, Capsule</li><li>MeshCollider（复杂模型）</li></ul></li></ul></li><li>物理引擎核心</li></ol><ul><li>Unity主要使用NVIDIA PhysX（PC、主机）作为底层实现</li><li>Android/iOS/主机平台上可能有优化或自研替代</li><li>负责：<ul><li>碰撞检测</li><li>刚体动力学</li><li>关节约束</li><li>碰撞回调（OnCollisionEnter, OnTriggerEnter）</li></ul></li></ul><ol start=4><li>场景集成<ul><li>每帧固定更新（FixedUpdate）物理世界</li><li>与渲染循环独立，保证模拟稳定性</li><li>支持多进程计算（Job System + Burst优化）</li></ul></li></ol><h4 id=脚本层交互>脚本层交互</h4><p>C#层的<code>Rigidbody</code>, <code>Collider</code>等都是托管对象，内部绑定对应C++的原生PhysX对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Rigidbody rb = GetComponent&lt;Rigidbody&gt;();
</span></span><span style=display:flex><span>rb.AddForce(Vector3.up * <span style=color:#ae81ff>10f</span>);
</span></span></code></pre></div><ul><li>C#调用 -> IL2CPP/Mono桥接 -> C++ PhysX对象 -> 物理计算 -> 更新Transform</li><li>最终渲染层拿到Transform更新位置</li></ul><h3 id=动画子系统animation>动画子系统（Animation）</h3><p>动画子系统负责角色、物体的运动表现，包括骨骼动画、Blend、State Machine等</p><h4 id=核心模块-1>核心模块</h4><ol><li>Animator/Animation组件<ul><li><code>Animator</code>使用Mecanim系统，支持状态机和Blend Tree</li><li><code>Animation</code>是旧动画系统，主要用于简单动画</li></ul></li><li>骨骼动画（Skinned Mesh）<ul><li>Mesh通过骨骼（Bones）驱动顶点变形</li><li>支持GPU skinning加速</li></ul></li><li>状态机（Animator Controller）<ul><li>控制动画播放逻辑（Idle -> Walk -> Run）</li><li>支持条件转换（Triggers, Booleans, Floats）</li><li>每帧更新在Update/AnimatorUpdate模式下执行</li></ul></li><li>Blend Tree<ul><li>混合多种动画，实现平滑过渡</li><li>用于复杂动作组合，如走跑切换、方向移动</li></ul></li><li>IK/动态调整<ul><li>Inverse Kinematics（逆向运动学）</li><li>让角色手、脚自然接触地面或环境</li></ul></li></ol><h4 id=脚本层交互-1>脚本层交互</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Animator anim = GetComponent&lt;Animator&gt;();
</span></span><span style=display:flex><span>anim.SetFloat(<span style=color:#e6db74>&#34;Speed&#34;</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>anim.SetTrigger(<span style=color:#e6db74>&#34;Jump&#34;</span>);
</span></span></code></pre></div><ul><li>C# -> IL2CPP/Mono -> C++动画核心</li><li>动画子系统会计算骨骼矩阵</li><li>更新Skinned Mesh</li><li>最终渲染系统拿到最终顶点数据</li></ul><h3 id=物理与动画的协作>物理与动画的协作</h3><ol><li>Rigidbody与Animator<ul><li>Animator默认不影响物理（“根运动 Root Motion”可选）</li><li>Root Motion开启时，动画驱动Rigidbody位置</li><li>Root Motion关闭时，脚本驱动Rigidbody位置，而Animator只负责骨骼动画</li></ul></li><li>碰撞与动画<ul><li>动画过程中可以触发碰撞事件</li><li>游戏逻辑可以根据碰撞/触发器调整动画状态</li></ul></li></ol><h3 id=总结>总结</h3><ul><li>物理子系统 = “模拟真实世界的力学”</li><li>动画子系统 = “控制物体或角色运动表现”</li><li>它们都属于C++原生引擎模块，C#层只是包装和控制接口</li><li>脚本层与这两者的交互都依赖Scripting Runtime桥接</li></ul><h2 id=editor扩展层>Editor扩展层</h2><p>这是Unity架构中连接用户编辑操作和底层引擎的部分<br>它不影响游戏运行时逻辑，但对于提高生产效率、开发工具、定制工作流至关重要</p><h3 id=定位与作用-2>定位与作用</h3><ul><li>位置：位于Unity Player + Scripting Runtime之上，是C#层的Editor专用模块</li><li>核心作用：<ul><li>提供可视化编辑界面（Inspecor、Hierarchy、Scene视图）</li><li>扩展Unity编辑器功能（自定义工具、窗口、菜单）</li><li>与底层C++引擎交互，实现资源操作、场景管理、渲染预览</li></ul></li></ul><blockquote><p>Editor扩展层 = “Unity的可编程工作台”，开发者可以改造编辑器来提升效率或定制工作流</p></blockquote><h3 id=核心模块-2>核心模块</h3><ol><li>Editor Window/Editor GUI<ul><li>自定义窗口、面板、工具栏</li><li>基于IMGUI或UIElements绘制界面</li><li>可以访问Unity对象（GameObject、ScriptableObject、Asset）</li></ul></li><li>Inspector / Property Drawer<ul><li>Inspector窗口显示对象属性</li><li>PropertyDrawer允许自定义组件属性的显示和编辑方式</li></ul></li><li>Editor Utility<ul><li>文件操作、资源管理、序列化、日志、调试工具</li><li>ScriptableWizard、MenuItem、EditorCoroutine</li></ul></li><li>Scene View/Gizmos<ul><li>直接在Scene视图绘制辅助信息</li><li>自定义Gizmos显示逻辑，如碰撞体、路径、AI节点</li></ul></li><li>Custom Asset Pipeline<ul><li>自定义资源导入器（ScriptedInporter）</li><li>自动处理特定资源格式、生成AssetBundle、Addressable资源</li></ul></li><li>Play Mode Simulation<ul><li>编辑器模式下模拟运行</li><li>PlayMode下的资源加载、脚本执行、物理和动画系统都调用底层Player</li></ul></li></ol><h3 id=脚本层交互-2>脚本层交互</h3><p>Editor扩展层完全在C#托管环境，与游戏运行层使用不同运行上下文：</p><ul><li>游戏运行时（Play Mode）：调用Player + Runtime</li><li>编辑器模式（Edit Mode）：调用Editor扩展层</li></ul><p>它们都通过Scripting Runtime桥接C++引擎，但编辑器扩展有额外API层用于编辑器操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyWindow</span> : EditorWindow
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>  [MenuItem(&#34;Tools/My Window&#34;)]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> ShowWindow() =&gt; GetWindow&lt;MyWindow&gt;(<span style=color:#e6db74>&#34;My Window&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> OnGUI()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Create Cube&#34;</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
</span></span><span style=display:flex><span>      Undo.RegisterCreateObjectUndo(cube, <span style=color:#e6db74>&#34;Create Cube&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>自定义窗口 -> 显示按钮 -> 调用Player API创建Cube</li><li>Undoo系统也通过Editor层统一管理</li></ul><h3 id=editor扩展与工具链>Editor扩展与工具链</h3><ul><li>打通C#编辑器脚本的底层C++引擎</li><li>支持自定义工作流，例如：<ul><li>自动生成场景/预制件</li><li>自定义Inspector显示复杂数据</li><li>编辑器内资源管理和打包</li><li>可视化调试AI、物理或动画</li></ul></li></ul><h3 id=总结-1>总结</h3><ul><li>Editor扩展本质上是C#层的编辑器专用API集合</li><li>它依赖Player + Scripting Runtime提供底层功能</li><li>不影响最终游戏运行时逻辑，但大幅提高开发效率</li><li>对于游戏开发者来说：<ul><li>初级阶段：只会用现有窗口、Inspector、菜单即可</li><li>进阶阶段：可以自定义工具、窗口、资源处理逻辑</li><li>高级阶段：可以写全套编辑器插件或Pipeline工具</li></ul></li></ul><blockquote><p>Editor扩展层是“可编程编辑器 + 工具接口”，是Unity生产力和自动化的核心</p></blockquote><h1 id=运行时结构>运行时结构</h1><p>运行时结构指的是————程序在运行过程中各个模块之间的组织方式、生命周期、以及数据和控制流的关系<br>它回答了三个问题：</p><ul><li>程序运行时，系统里“有哪些东西”</li><li>这些东西是“怎么互相作用”的</li><li>整个系统是“怎么从启动到退出”保持运作的（动态行为）</li></ul><p>Unity在游戏启动后会维持一个完整的“虚拟世界”的组织体系<br>当游戏从可执行文件启动时，Unity会依次初始化引擎模块、加载场景、实例化对象、执行脚本、维护帧循环，再到最终退出。</p><h2 id=gameobject--component系统>GameObject & Component系统</h2><p>Unity的运行时世界由GameObject和Component构成</p><ul><li>GameObject：场景中的“实体”，仅仅是容器，不包含逻辑</li><li>Component：组件，决定物体的行为和外观。Transform、Renderer、Collider、Script都是组件</li></ul><p>在C++层，每个GameObject对应一个<code>GameObject</code>结构体实例，内部维护组件列表（C#层表现为<code>GetComponent</code>、<code>AddComponent</code>接口）<br>脚本层的组件（MonoBehaviour）只是托管包装，实际行为逻辑通过绑定机制连接C++对象</p><blockquote><p>Unity世界 = 对象树（Transform Hierarchy）+ 组件系统（Behavior Modules）</p></blockquote><h2 id=scene--asset管理>Scene & Asset管理</h2><p>场景（Scene）是对象的集合</p><ul><li>当运行时加载场景时，Unity会<ol><li>解析序列化文件（.unity/.scene）</li><li>实例化GameObject与Component</li><li>加载依赖的Asset（纹理、Mesh、材质、音频等）</li><li>建立引用关系（GUID到对象映射）</li></ol></li></ul><p>资源加载有三种主要路径：</p><ul><li>内嵌资源（Build-in Asset）：打包时直接编入</li><li>AssetBundle/Addressable：运行时按需加载</li><li>Resources.Load()：动态从Resources文件夹中读入</li></ul><blockquote><p>Scene系统本质是“对象状态的快照”，运行时通过反序列化重建整个世界</p></blockquote><h2 id=生命周期管理>生命周期管理</h2><p>Unity的运行时生命周期可以分为三个层面：<br><strong>引擎启动层面</strong><br><code>RuntimeInitialize</code> -> 初始化Player -> 初始化模块（渲染、物理、音频、输入等） -> 加载第一个场景</p><p><strong>对象层面</strong><br>每个MonoBehaviour实例会经历：<br><code>Awake()</code> -> <code>OnEnable()</code> -> <code>Start()</code> -> <code>Update()</code>/<code>FixedUpdate()</code>/<code>LateUpdate()</code> -> <code>OnDisable()</code> -> <code>OnDestroy()</code><br>C++对象（Transform、Renderer等）在销毁时会触发托管对象解绑（GCHandle释放）</p><p><strong>帧循环层面</strong><br>每一帧：</p><ol><li>处理输入（InputSystem）</li><li>执行物理更新（FixedUpdate）</li><li>调用脚本逻辑（Update/LateUpdate）</li><li>执行动画系统</li><li>渲染提交（Camera.Render）</li><li>提交GPU命令 -> 显示输出</li></ol><blockquote><p>生命周期系统维持了Unity世界的“持续运作”，是时间与逻辑的主线</p></blockquote><h2 id=脚本绑定与执行机制>脚本绑定与执行机制</h2><p>Unity脚本运行在托管层（Mono/IL2CPP），核心机制是托管对象 &lt;-> 原生对象绑定（Binding）</p><p>运行时流程：</p><ol><li>C#编译为IL字节码</li><li>Mono或IL2CPP执行</li><li>脚本调用C# API，如<code>transform.position</code></li><li>通过绑定接口（InternalCall或Generated Bindings）访问C++对象</li><li>修改底层引擎数据</li></ol><p><code>Transform</code>、<code>Rigidbody</code>、<code>Renderer</code>等对象其实是C#包装 + C++实体<br>脚本层操作的是“代理”，数据变更最终反映在C++引擎核心中</p><blockquote><p>脚本驱动引擎，而引擎执行结果再反馈回脚本世界</p></blockquote><h2 id=内存模型与gc管理>内存模型与GC管理</h2><p>Unity的运行时有双层内存体系</p><p>| 层级 | 语言 | 管理方式 | 内容 |
| 托管层 | C#(Mono/IL2CPP) | GC | 脚本对象、数据逻辑 |
| 原生层 | C++(Unity Player) | 手动分配/释放 | 渲染资源、物理数据、引擎核心 |</p><p>C#层对象通过<code>GCHandle</code>或<code>NativeArray</code>等结构与原生内存交互<br>GC采用增量式GC（Incremental GC），分帧执行，降低卡顿</p><p>高性能开发要点：</p><ul><li>避免频繁分配（尤其在Update中）</li><li>使用对象池（Object Pool）</li><li>利用<code>struct</code>与<code>NativeController</code>（如Burst + JobSystem）绕过GC压力</li></ul><blockquote><p>GC是Unity运行时世界的“代谢系统”，要控制频率、减少毒素</p></blockquote><h2 id=系统协作与调度system-collaboration--scheduling>系统协作与调度（System Collaboration & Scheduling）</h2><p>系统协作与调度决定了每个子系统何时启动、如何交互、谁先谁后、怎样同步</p><h3 id=核心理念playerloop驱动的分层世界>核心理念：PlayerLoop驱动的分层世界</h3><p>Unity运行时的根本调度机制就是一个多层嵌套的循环体系：PlayerLoop<br>它是整个运行时的“心跳”</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scss data-lang=scss><span style=display:flex><span><span style=color:#f92672>while</span> <span style=color:#f92672>(</span><span style=color:#f92672>ApplicationRunning</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>EarlyUpdate</span><span style=color:#f92672>()</span>;   <span style=color:#75715e>// 输入、时间、任务调度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>FixedUpdate</span><span style=color:#f92672>()</span>;   <span style=color:#75715e>// 物理系统（定时器驱动）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>Update</span><span style=color:#f92672>()</span>;        <span style=color:#75715e>// 脚本与AI逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>LateUpdate</span><span style=color:#f92672>()</span>;    <span style=color:#75715e>// 动画、摄像机、后处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>RenderFrame</span><span style=color:#f92672>()</span>;   <span style=color:#75715e>// 渲染提交与同步
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>这是真实存在于Unity C++层的PlayerLoopSystem结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>PlayerLoopSystem
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  type;
</span></span><span style=display:flex><span>  subSystemList[];
</span></span><span style=display:flex><span>  updateDelegate;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>每一帧中，Unity会遍历这些系统树，依序调用每个系统注册的更新函数<br>这样，不同模块可以通过注册<code>PlayerLoopSystem</code>来参与调度，而不需要硬编码耦合<br>这就是Unity架构的关键哲学：可重组的帧调度系统</p><h3 id=时间维度的分层协作monobehaviour生命周期><a href=/home/ljf12825linux/ljf12825.github.io/content/blog/MonoBehaviour.md>时间维度的分层协作(MonoBehaviour生命周期)</a></h3><h3 id=系统之间的协作链>系统之间的协作链</h3><p>以一次典型帧为例，系统之间的数据与依赖链如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scss data-lang=scss><span style=display:flex><span><span style=color:#f92672>InputSystem</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>ScriptSystem</span> <span style=color:#f92672>(</span><span style=color:#f92672>MonoBehaviour</span><span style=color:#a6e22e>.Update</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>PhysicsSystem</span> <span style=color:#f92672>(</span><span style=color:#f92672>FixedUpdate</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>AnimationSystem</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>TransformSystem</span> <span style=color:#f92672>(</span><span style=color:#f92672>同步位置</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>CameraSystem</span> <span style=color:#f92672>(</span><span style=color:#f92672>确定视角矩阵</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>RenderSystem</span> <span style=color:#f92672>(</span><span style=color:#f92672>生成渲染命令</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>GPU</span> <span style=color:#f92672>(</span><span style=color:#f92672>执行渲染</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>这条链并非严格线性，而是通过 **任务系统（Job System）和依赖图（Dependency Graph）**并行调度；例如：动画计算，粒子模拟，骨骼蒙皮都可以异步执行，只要它们不依赖同一份数据</p><h3 id=数据同步与job调度>数据同步与Job调度</h3><p>Unity的Job System是运行时的多线程调度核心<br>它的工作原理大致是：</p><ul><li>每个系统提交若干条任务（Job）</li><li>Job之间通过依赖关系（Dependency）控制执行顺序</li><li>调度器动态分配任务到多个线程执行</li><li>最后在主线程同步结果（Sync Point）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>TransformJob</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>├─依赖-&gt;</span> <span style=color:#e6db74>AnimationJob</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>└─依赖-&gt;</span> <span style=color:#e6db74>PhysicsJob</span>
</span></span></code></pre></div><p>这意味着：在执行<code>TransformSystem</code>之前，动画与物理系统必须先完成它们的计算。这种模型的优势是高并行性和低耦合，但也要求架构层具备明确的数据所有权与生命周期管理</p><h3 id=渲染与主循环的协同>渲染与主循环的协同</h3><p>渲染系统是调度中的特殊角色<br>Unity在渲染时会：</p><ol><li>收集场景数据（Cilling）</li><li>生成Draw Call队列（CommandBuffer）</li><li>提交给渲染线程（Graphics Jobs）</li><li>GPU异步执行（Command Buffer）</li></ol><p>这部分采用“双缓冲帧同步”</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>CPU: Frame N+1 在准备中
</span></span><span style=display:flex><span>GPU: Frame N 在渲染中
</span></span></code></pre></div><p>这种机制确保GPU和CPU并行工作，不互相阻塞<br>Unity通过Fence同步点控制帧节奏，使物理、脚本、渲染三者稳定配合</p><h3 id=playerloop的可扩展性>PlayerLoop的可扩展性</h3><p>开发者可以通过<code>PlayerLoop.SetPlayerLoop()</code>修改Unity的帧调度表<br>例如插入自定义系统</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> loop = playerLoop.GetCurrentPlayerLoop();
</span></span><span style=display:flex><span>InsertSystemAfter(<span style=color:#66d9ef>ref</span> loop, <span style=color:#66d9ef>typeof</span>(UnityEngine.PlayerLoop.Update), <span style=color:#66d9ef>typeof</span>(MyCustomSystem));
</span></span><span style=display:flex><span>PlayerLoop.SetPlayerLoop(loop);
</span></span></code></pre></div><p>这意味着：Unity的调度系统是开放的<br>这也是DOTS、Entity Component System、以及SRP（Scriptable Render Pipeline）能独立运作的根本原因</p><h1 id=数据流动>数据流动</h1><p>数据流动是Unity引擎中的核心机制，Unity的本质是“数据驱动的引擎”，数据流贯穿编辑器与运行时<br>在Unity中，数据流动是指游戏或应用在运行时，从输入到输出的数据如何在不同系统和模块之间传递。每一帧的数据流动涉及了多个层级，从外部输入、逻辑计算，到最终的渲染输出</p><h2 id=输入到处理>输入到处理</h2><h3 id=1-输入数据流>1. 输入数据流</h3><p>首先，游戏的输入来源通常包括键盘、鼠标、触摸屏、手柄等设备。输入系统是最早处理数据的系统</p><p><strong>数据流动：</strong></p><ul><li>用户输入：例如玩家按下了一个按键或移动了鼠标</li><li>输入系统：Unity中的<code>InputSystem</code>会处理这些事件，封装成可用的输入数据<ul><li>新的<code>Input System</code>通常会以事件驱动的方式处理输入（例如键盘事件、鼠标点击、触摸滑动等），而旧的<code>Input</code>系统则是轮询输入状态</li><li>这时的输入数据通常是基于设备状态（如是否按下、按下的时长、触摸的坐标等）</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 示例：新Input System获取按键输入</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (Keyboard.current.spaceKey.isPressed)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 做相应处理</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-脚本逻辑处理>2. 脚本逻辑处理</h3><p>在接收到输入数据后，游戏的脚本逻辑（通常是C#脚本中的<code>Update()</code>函数）会对这些输入做出反应，并根据输入更新游戏的状态</p><p><strong>数据流动：</strong></p><ul><li>输入系统将输入数据传递到脚本</li><li>脚本根据输入修改GameObject的属性、动画状态、物理状态等<ul><li>例如，当玩家按下键盘的某个键时，<code>Update()</code>函数会更新玩家角色的位置，改变它的速度或状态</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (Keyboard.current.spaceKey.wasPressedThisFrame)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 执行跳跃</span>
</span></span><span style=display:flex><span>      character.Jump();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=从脚本到物理引擎>从脚本到物理引擎</h2><h3 id=1-数据流脚本---物理系统>1. 数据流：脚本 -> 物理系统</h3><p>物理系统通常由刚体（Rigidbody）、碰撞器（Collider）等组成，这些对象会根据物理规则（如重力、力的作用等）更新其状态。Unity的物理系统在固定时间间隔内运行，以<code>FixedUpdate()</code>为周期执行，这与普通的<code>Update()</code>不同，<code>FixedUpdate()</code>的执行周期是固定的，而<code>Update()</code>是根据帧率变化的</p><p><strong>数据流动：</strong></p><ul><li>脚本修改：脚本逻辑通常会通过操作物体的刚体（如<code>Rigidbody.AddForce()</code>），或者通过直接修改Transform的位置和旋转来影响物理系统<ul><li>例如，玩家输入方向键时，角色的速度会更新，然后物理引擎就会基于这些速度值来计算角色的运动</li></ul></li><li>物理计算：物理系统接收到这些修改后，会在每一帧进行物理模拟，更新物体的位置、速度、角速度、加速度等物理状态</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> FixedUpdate()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 根据输入给刚体施加一个力</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (Keyboard.current.wKey.isPressed)
</span></span><span style=display:flex><span>    rigidbody.AddForce(Vector3.forward * moveSpeed)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-物理系统的输出>2. 物理系统的输出</h3><p>物理系统会基于这些输入，计算出每个物体的新状态，并将结果传递回到脚本层。脚本可以进一步读取这些物理计算的结果并进行决策</p><p><strong>数据流动：</strong></p><ul><li>物理系统更新位置、速度后，通过<code>Rigidbody</code>对象将这些物理状态暴露给脚本</li><li>脚本根据这些更新的状态来判断下一步逻辑，或者用来驱动其他系统（如动画、声音等）</li></ul><h2 id=从物理到渲染渲染数据流动>从物理到渲染：渲染数据流动</h2><h3 id=数据流物理与渲染>数据流：物理与渲染</h3><p>物理系统计算完成后，需要把物体的位置、旋转、缩放等变换传递给渲染系统，以便在屏幕上正确显示</p><p><strong>数据流动：</strong></p><ul><li>Transform组件：物理系统通过更新物体的<code>Transform</code>（如<code>Transform.position</code>和<code>Transform.rotation</code>）来传递世界坐标给渲染系统</li><li>渲染准备：渲染系统会在每一帧根据场景的<code>Transform</code>更新物体的显示位置。摄像机、光源等也会在此阶段计算，并将最终结果输出到屏幕</li></ul><h3 id=渲染过程>渲染过程</h3><ul><li>Culling：场景中的物体会被摄像机剔除（即决定那些物体在当前视野中是可见的）。</li><li>图形管线：根据物体的材质、光照、Shader等，图形管线会生成最终的图像。所有的数据（如模型、纹理、光照、Shader、变换矩阵等）都会被传递给GPU,GPU通过渲染管线生成屏幕图像</li></ul><h2 id=异步任务与job系统>异步任务与Job系统</h2><p>在Unity中，许多繁重的计算任务（如物理模拟、路径计算、光照计算等）会通过Job System来异步执行。数据流动不仅限于主线程，很多计算任务会被分配到后台线程去执行，计算的结果会在主线程进行合并</p><h3 id=job-system的数据流动>Job System的数据流动</h3><ul><li>主线程分配任务：脚本或引擎核心根据需要创建和调度任务，这些任务会分配给Job系统执行</li><li>数据传递与同步：任务执行的数据通常以JobHandle或NativeArray的形式传递。这些任务执行时会对共享数据进行读写操作</li><li>结果回馈：异步任务完成后，主线程会通过同步机制获取计算结果，更新游戏状态或渲染输出</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 使用Job系统计算物理位置</span>
</span></span><span style=display:flex><span>NativeArray&lt;Vector3&gt; positions = <span style=color:#66d9ef>new</span> NativeArray&lt;Vector3&gt;(numObjects, Allocator.TempJob);
</span></span><span style=display:flex><span>MyJob job = <span style=color:#66d9ef>new</span> MyJob 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  positions = positions
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>JobHandle handle = job.Schedule();
</span></span><span style=display:flex><span>handle.Complete(); <span style=color:#75715e>// 等待任务完成</span>
</span></span></code></pre></div><h3 id=数据流动的优化gc与内存管理>数据流动的优化：GC与内存管理</h3><p>Unity的内存管理和数据流动中的GC管理对于性能优化至关重要。游戏中创建和销毁大量对象会导致频繁的GC暂停，影响帧率</p><ul><li>托管内存：Unity使用C#的内存管理机制，这意味着Unity对象（如<code>GameObject</code>, <code>Component</code>等）由垃圾回收器（GC）进行管理</li><li>原生内存：对于高性能计算，Unity使用原生内存（C++层）来存储与物理、渲染等系统相关的原始数据</li></ul><p>通过NativeArray, Job System和Burst Compiler等工具，Unity使得原生内存管理更加高效，从而减少GC暂停，提高性能</p><blockquote><p>开发者通过掌握数据流的路径和优化点，可以在游戏开发中提升性能、增强稳定性、以及打造更加高效的游戏系统</p></blockquote><h1 id=设计哲学与扩展性>设计哲学与扩展性</h1><p>Unity作为一个游戏引擎，其设计哲学是追求灵活性、可扩展性和跨平台兼容性。它通过简化复杂性、提供清晰的API接口，以及在多种平台上提供一致的体验，使开发者能够专注于创造内容，而不是底层实现</p><h2 id=抽象与暴露最小接口>抽象与暴露最小接口</h2><p>Unity的设计哲学的核心之一就是抽象复杂性，同时暴露最小的接口给开发者。这一哲学体现在以下方面</p><h3 id=1-高层次抽象>1. 高层次抽象</h3><ul><li>对象与组件模型：Unity的核心是其组件化架构，通过将不同功能（如渲染、物理、输入、动画等）拆分为不同的组件（Component），让开发者能够自由组合这些组件来构建对象（GameObject）。这种设计使得Unity既简化了开发过程，也保持了灵活性</li><li>GameObject/Component模型：GameObject作为一个容器，没有业务逻辑，它依赖于附加的组件来提供行为。组件化架构让开发者可以根据需要为一个GameObject添加多个组件，这种设计简化了游戏开发中的许多常见问题</li></ul><h3 id=2-最小接口>2. 最小接口</h3><ul><li>Unity力求暴露最小接口，即只暴露开发者常用的功能，避免了复杂且不常用的API。它通过提供清晰的API和默认实现，减轻了开发者的负担，同时还提供了丰富的自定义能力，以满足开发者的多样化需求
例如：</li><li>输入系统（Input）：它隐藏了不同设备的差异，只暴露了一个统一的接口，开发者通过简单的API即可获得键盘、鼠标、触摸屏等设备的输入数据</li></ul><h3 id=3-跨平台支持>3. 跨平台支持</h3><p>Unity的另一个重要设计哲学是跨平台。开发者只需要编写一次代码，Unity就会自动处理跨平台的兼容问题，减少平台特有的差异。无论是PC、移动端、Web,还是VR/AR设备，Unity都提供了平台抽象层（PAL），让游戏的核心逻辑保持一致，开发者只需关注游戏的业务逻辑，而无需关心具体平台的底层细节</p><h2 id=模块化与解耦>模块化与解耦</h2><p>Unity的设计不仅追求易用性，同时注重模块化和解耦。这使得Unity在扩展性方面表现得尤为强大，尤其是对于大型项目的开发</p><h3 id=1-模块化架构>1. 模块化架构</h3><p>Unity引擎通过多个独立的子系统（渲染、物理、输入、音频、资源管理等）来实现功能的分离。这些模块化的设计允许开发者可以有选择地使用某些子系统，同时还能够在不同的模块之间进行定制化扩展\</p><h3 id=2-解耦的系统架构>2. 解耦的系统架构</h3><p>游戏的物理系统、动画系统、输入系统等都能独立运行，并且可以彼此解耦，每个系统都负责自身的逻辑，可以独立开发和优化</p><h2 id=数据驱动与可扩展性>数据驱动与可扩展性</h2><p>Unity的数据驱动设计和可扩展性让它能够轻松应对多样化的开发需求，同时支持丰富的第三方插件和系统的集成</p><h3 id=数据驱动设计>数据驱动设计</h3><ul><li>Unity引擎的核心架构是数据驱动的。引擎核心本身将数据与功能分离，将游戏中的所有内容（例如，场景、物体、动画、资源）作为数据处理，而将这些数据呈现出来的逻辑通过脚本、组件和行为来实现。这种设计使得开发者能够灵活地操作数据和资源，从而实现各种功能</li><li>ECS架构的引入进一步推动来数据驱动的方式，特别是在高性能场景中，ECS通过把游戏数据组织成结构体（如<code>Entity</code>, <code>Component</code>)来提升数据存取的效率</li></ul><h3 id=灵活的插件扩展机制>灵活的插件扩展机制</h3><ul><li>Unity的可扩展性体现在它的插件系统和自定义工具上。开发者可以利用Unity的Editor API,扩展Unity编辑器功能，创建自定义工作流、工具和资源管理</li></ul><h3 id=asset-pipeline与扩展性>Asset Pipeline与扩展性</h3><ul><li>Unity的资源管线（Asset Pipeline）可以非常方便地扩展。例如，开发者可以创建自定义的资源导入器（<code>ScriptedImporter</code>）来处理特定类型的资源格式，或者在资源加载过程中添加自己的处理逻辑（如数据压缩、纹理优化等）</li></ul><h2 id=简化开发过程与自定义>简化开发过程与自定义</h2><p>Unity的设计哲学强调开发者体验，力求简化游戏开发过程，同时允许开发者在需要时进行自定义和深度修改</p><h3 id=可视化编辑与脚本编程>可视化编辑与脚本编程</h3><ul><li>Unity支持可视化编辑，开发者可以通过拖拽、点击等方式直观地设计游戏中的对象、场景、动画等。大多数任务都可以通过图形化界面完成，这使得没有编程背景的开发者也能参与到游戏开发中</li><li>脚本编程：同时，Unity也提供了完整的编程支持，允许开发者在C#脚本中实现更复杂的逻辑。C#脚本与Unity编辑器紧密结合，开发者可以直接在代码中访问Unity的API进行深度自定义</li></ul><h3 id=扩展与自定义的自由度>扩展与自定义的自由度</h3><p>Unity提供大量的扩展点，开发者可以根据需求自定义引擎的各个部分，例如渲染、物理、输入、GUI系统的行为。它的开源性质（如SRP）使得开发者可以灵活定制和优化性能，满足特定的项目需求</p><h3 id=代码生成与反射>代码生成与反射</h3><p>Unity通过提供反射（Reflection）功能和代码生成，使得开发者可以动态地调整程序行为。例如，使用<code>[SerializeField]</code>等特性，开发者可以让私有字段在编辑器中可见，便于调整游戏数据，进一步增强了Unity的可定制性</p></div><nav class=post-nav><a href=/blog/ui-system/ class=hover:underline>pre: UI System</a>
<a href=/blog/unity-asynchronous-and-coroutine/ class=hover:underline>next: Unity Asynchronous and Coroutine</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><a href=#引擎整体架构>引擎整体架构</a><ul><li><a href=#unity-playerc引擎内核>Unity Player(C++引擎内核)</a><ul><li><a href=#定位与作用>定位与作用</a></li><li><a href=#核心模块>核心模块</a></li><li><a href=#与scripting-runtime的关系>与Scripting Runtime的关系</a></li></ul></li><li><a href=#scripting-runtimemonoil2cpp>Scripting Runtime(Mono/IL2CPP)</a><ul><li><a href=#角色与定位>角色与定位</a></li><li><a href=#monoil2cpp>Mono&amp;IL2CPP</a></li><li><a href=#托管内存与gc机制>托管内存与GC机制</a></li><li><a href=#脚本与c交互机制bindings>脚本与C++交互机制（Bindings）</a></li><li><a href=#c与c之间的调用成本interop-overhead>C#与C++之间的调用成本（Interop Overhead）</a></li></ul></li><li><a href=#平台抽象层platform-abstraction-layer-pal>平台抽象层（Platform Abstraction Layer, PAL）</a><ul><li><a href=#定位与作用-1>定位与作用</a></li><li><a href=#pal的主要模块>PAL的主要模块</a></li><li><a href=#平台特化platform-specific-layer>平台特化（Platform Specific Layer）</a></li><li><a href=#对游戏开发者的意义>对游戏开发者的意义</a></li></ul></li><li><a href=#渲染管线build-in--urp--hdrp>渲染管线（Build-in / URP / HDRP）</a><ul><li><a href=#渲染管线本质>渲染管线本质</a></li><li><a href=#三代渲染管线的变化>三代渲染管线的变化</a></li><li><a href=#build-in-pipeline传统内置管线>Build-in Pipeline（传统内置管线）</a></li><li><a href=#urpuniversal-render-pipeline>URP（Universal Render Pipeline）</a></li><li><a href=#hdrphigh-definition-render-pipeline>HDRP（High Definition Render Pipeline）</a></li><li><a href=#scriptalbe-render-pipelinesrp的统一思想>Scriptalbe Render Pipeline（SRP）的统一思想</a></li></ul></li><li><a href=#物理与动画子系统>物理与动画子系统</a><ul><li><a href=#物理子系统physics>物理子系统（Physics）</a><ul><li><a href=#核心组成>核心组成</a></li><li><a href=#脚本层交互>脚本层交互</a></li></ul></li><li><a href=#动画子系统animation>动画子系统（Animation）</a><ul><li><a href=#核心模块-1>核心模块</a></li><li><a href=#脚本层交互-1>脚本层交互</a></li></ul></li><li><a href=#物理与动画的协作>物理与动画的协作</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#editor扩展层>Editor扩展层</a><ul><li><a href=#定位与作用-2>定位与作用</a></li><li><a href=#核心模块-2>核心模块</a></li><li><a href=#脚本层交互-2>脚本层交互</a></li><li><a href=#editor扩展与工具链>Editor扩展与工具链</a></li><li><a href=#总结-1>总结</a></li></ul></li></ul></li><li><a href=#运行时结构>运行时结构</a><ul><li><a href=#gameobject--component系统>GameObject & Component系统</a></li><li><a href=#scene--asset管理>Scene & Asset管理</a></li><li><a href=#生命周期管理>生命周期管理</a></li><li><a href=#脚本绑定与执行机制>脚本绑定与执行机制</a></li><li><a href=#内存模型与gc管理>内存模型与GC管理</a></li><li><a href=#系统协作与调度system-collaboration--scheduling>系统协作与调度（System Collaboration & Scheduling）</a><ul><li><a href=#核心理念playerloop驱动的分层世界>核心理念：PlayerLoop驱动的分层世界</a></li><li><a href=#时间维度的分层协作monobehaviour生命周期>时间维度的分层协作(MonoBehaviour生命周期)</a></li><li><a href=#系统之间的协作链>系统之间的协作链</a></li><li><a href=#数据同步与job调度>数据同步与Job调度</a></li><li><a href=#渲染与主循环的协同>渲染与主循环的协同</a></li><li><a href=#playerloop的可扩展性>PlayerLoop的可扩展性</a></li></ul></li></ul></li><li><a href=#数据流动>数据流动</a><ul><li><a href=#输入到处理>输入到处理</a><ul><li><a href=#1-输入数据流>1. 输入数据流</a></li><li><a href=#2-脚本逻辑处理>2. 脚本逻辑处理</a></li></ul></li><li><a href=#从脚本到物理引擎>从脚本到物理引擎</a><ul><li><a href=#1-数据流脚本---物理系统>1. 数据流：脚本 -> 物理系统</a></li><li><a href=#2-物理系统的输出>2. 物理系统的输出</a></li></ul></li><li><a href=#从物理到渲染渲染数据流动>从物理到渲染：渲染数据流动</a><ul><li><a href=#数据流物理与渲染>数据流：物理与渲染</a></li><li><a href=#渲染过程>渲染过程</a></li></ul></li><li><a href=#异步任务与job系统>异步任务与Job系统</a><ul><li><a href=#job-system的数据流动>Job System的数据流动</a></li><li><a href=#数据流动的优化gc与内存管理>数据流动的优化：GC与内存管理</a></li></ul></li></ul></li><li><a href=#设计哲学与扩展性>设计哲学与扩展性</a><ul><li><a href=#抽象与暴露最小接口>抽象与暴露最小接口</a><ul><li><a href=#1-高层次抽象>1. 高层次抽象</a></li><li><a href=#2-最小接口>2. 最小接口</a></li><li><a href=#3-跨平台支持>3. 跨平台支持</a></li></ul></li><li><a href=#模块化与解耦>模块化与解耦</a><ul><li><a href=#1-模块化架构>1. 模块化架构</a></li><li><a href=#2-解耦的系统架构>2. 解耦的系统架构</a></li></ul></li><li><a href=#数据驱动与可扩展性>数据驱动与可扩展性</a><ul><li><a href=#数据驱动设计>数据驱动设计</a></li><li><a href=#灵活的插件扩展机制>灵活的插件扩展机制</a></li><li><a href=#asset-pipeline与扩展性>Asset Pipeline与扩展性</a></li></ul></li><li><a href=#简化开发过程与自定义>简化开发过程与自定义</a><ul><li><a href=#可视化编辑与脚本编程>可视化编辑与脚本编程</a></li><li><a href=#扩展与自定义的自由度>扩展与自定义的自由度</a></li><li><a href=#代码生成与反射>代码生成与反射</a></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>