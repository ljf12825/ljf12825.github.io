<!doctype html><html lang=en><head><meta charset=UTF-8><title>Unity Build-in Types</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Unity Build-in Types" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Unity Build-in Types<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>Unity内建类型</p><h2 id=1空间几何类型transform相关>1.空间/几何类型（Transform相关）</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></td><td>表示二维/三维/四维向量</td></tr><tr><td><code>Quaternion</code></td><td>四元数，表示旋转</td></tr><tr><td><code>Matrix4x4</code></td><td>4×4 矩阵，常用于转换</td></tr><tr><td><code>Bounds</code></td><td>包围盒（中心+尺寸）</td></tr><tr><td><code>Ray</code>, <code>RaycastHit</code></td><td>射线检测相关类型</td></tr><tr><td><code>Plane</code></td><td>表示一个无限平面</td></tr><tr><td><code>Rect</code></td><td>二维矩形区域</td></tr><tr><td><code>Color</code>, <code>Color32</code></td><td>表示颜色（线性空间和 sRGB）</td></tr></tbody></table><h3 id=vector>Vector</h3><p><code>Vector2</code>、<code>Vector3</code>、<code>Vector4</code></p><p>它们是Unity提供的三个核心向量类型，广泛用于位置、方向、速度、缩放、颜色等各种场景</p><table><thead><tr><th>向量类型</th><th>维度</th><th>作用</th></tr></thead><tbody><tr><td><code>Vector2</code></td><td>2D 向量，包含 <code>x</code>, <code>y</code></td><td>用于 2D 空间中的位置、速度等</td></tr><tr><td><code>Vector3</code></td><td>3D 向量，包含 <code>x</code>, <code>y</code>, <code>z</code></td><td>用于 3D 空间中的大多数情况</td></tr><tr><td><code>Vector4</code></td><td>4D 向量，包含 <code>x</code>, <code>y</code>, <code>z</code>, <code>w</code></td><td>用于更高级的计算，如齐次坐标、shader 编程</td></tr></tbody></table><h4 id=vector2二维向量>Vector2（二维向量）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Vector2 position = <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>1.5f</span>, <span style=color:#ae81ff>3.0f</span>);
</span></span></code></pre></div><p>常见用途：</p><ul><li>2D游戏中的对象位置、速度、加速度等</li><li>屏幕空间坐标（如UI坐标）</li><li>纹理坐标（UV mapping）</li></ul><h4 id=vector3三维向量>Vector3（三维向量）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Vector3 direction = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>1f</span>, <span style=color:#ae81ff>0f</span>); <span style=color:#75715e>//向上</span>
</span></span><span style=display:flex><span>transform.position += direction * Time.deltaTime;
</span></span></code></pre></div><p>常见用途：</p><ul><li>3D对象的位置、方向、缩放</li><li>物理运动（速度、加速度）</li><li>相机方向、光照方向</li></ul><h5 id=api>API</h5><p><strong>Static Properties</strong><br>这些属性是<code>Vector3</code>结构体的常用快捷方式，简化了常见的方向或特殊值的表示，使得代码更简洁易读</p><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody><tr><td><code>back</code></td><td>等价于 <code>Vector3(0, 0, -1)</code>。</td></tr><tr><td><code>down</code></td><td>等价于 <code>Vector3(0, -1, 0)</code>。</td></tr><tr><td><code>forward</code></td><td>等价于 <code>Vector3(0, 0, 1)</code>。</td></tr><tr><td><code>left</code></td><td>等价于 <code>Vector3(-1, 0, 0)</code>。</td></tr><tr><td><code>negativeInfinity</code></td><td>等价于 <code>Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity)</code>，表示<code>-∞</code></td></tr><tr><td><code>one</code></td><td>等价于 <code>Vector3(1, 1, 1)</code>。</td></tr><tr><td><code>positiveInfinity</code></td><td>等价于 <code>Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity)</code>，表示<code>+∞</code></td></tr><tr><td><code>right</code></td><td>等价于 <code>Vector3(1, 0, 0)</code>。</td></tr><tr><td><code>up</code></td><td>等价于 <code>Vector3(0, 1, 0)</code>。</td></tr><tr><td><code>zero</code></td><td>等价于 <code>Vector3(0, 0, 0)</code>。</td></tr></tbody></table><ul><li><p><code>negativeInfinity</code>（负无穷）</p><ul><li>定义：表示负无穷大的值</li><li>类型：<code>float.NegativeInfinity</code></li><li>常见用途<ul><li>初始化最小值：可以用<code>negativeInfinity</code>来初始化一个变量，使其值总是比任何数值都小。例如，在计算最小值时，可以用它来确保首次比较时能正确地更新最小值</li><li>比较：用于处理在算法中可能遇到的负无穷大值，比如图形计算中的不可达距离</li></ul></li></ul></li><li><p><code>positiveInfinity</code>（正无穷）</p><ul><li>定义：表示正无穷大的值</li><li>类型：<code>float.PositiveInfinity</code></li><li>常见用途：<ul><li>初始化最大值：用 <code>positiveInfinity</code> 来初始化一个变量，使其值总是比任何数值都大。例如，在计算最大值时，可以用它来确保首次比较时能正确地更新最大值。</li><li>比较：用于处理可能出现的正无穷大值，例如在图形学中表示无法到达的最大距离或算法中的最大值。</li></ul></li></ul></li></ul><p><strong>Properties</strong></p><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody><tr><td><code>magnitude</code></td><td>返回此向量的长度（只读）。</td></tr><tr><td><code>normalized</code></td><td>返回基于当前向量的标准化向量。标准化后的向量长度为 1，并与当前向量方向相同。如果当前向量太小，返回零向量。</td></tr><tr><td><code>sqrMagnitude</code></td><td>返回此向量的平方长度（只读）。</td></tr><tr><td><code>this[int]</code></td><td>通过 <code>[0]</code>、<code>[1]</code>、<code>[2]</code> 分别访问向量的 x、y、z 分量。</td></tr><tr><td><code>x</code></td><td>向量的 x 分量。</td></tr><tr><td><code>y</code></td><td>向量的 y 分量。</td></tr><tr><td><code>z</code></td><td>向量的 z 分量。</td></tr></tbody></table><p><strong>Constructors</strong></p><table><thead><tr><th>COnstructor</th><th>Description</th></tr></thead><tbody><tr><td><code>Vector3</code></td><td>创建一个三维向量或点</td></tr></tbody></table><p><strong>Public Methods</strong></p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>Equals</code></td><td>如果给定的向量与当前向量完全相等，返回 <code>true</code>。</td></tr><tr><td><code>Set</code></td><td>设置现有 <code>Vector3</code> 的 x、y 和 z 分量。</td></tr><tr><td><code>ToString</code></td><td>返回该向量的格式化字符串表示。"(x, y, z)"</td></tr></tbody></table><p><strong>Static Methods</strong></p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>Angle</code></td><td>计算两个向量之间的夹角。</td></tr><tr><td><code>ClampMagnitude</code></td><td>返回一个新的向量，最大长度被限制为 <code>maxLength</code>。</td></tr><tr><td><code>Cross</code></td><td>计算两个三维向量的叉积。</td></tr><tr><td><code>Distance</code></td><td>计算两个三维点之间的距离。</td></tr><tr><td><code>Dot</code></td><td>计算两个三维向量的点积，定义在相同坐标空间中。</td></tr><tr><td><code>Lerp</code></td><td>在两个点之间进行线性插值。</td></tr><tr><td><code>LerpUnclamped</code></td><td>在两个向量之间进行线性插值，不限制插值范围。</td></tr><tr><td><code>Max</code></td><td>返回一个由两个向量中最大分量组成的向量。</td></tr><tr><td><code>Min</code></td><td>返回一个由两个向量中最小分量组成的向量。</td></tr><tr><td><code>MoveTowards</code></td><td>计算一个位置，当前位置到目标位置的最大移动距离不超过 <code>maxDistanceDelta</code>。</td></tr><tr><td><code>Normalize</code></td><td>将向量标准化，使其长度为 1。</td></tr><tr><td><code>OrthoNormalize</code></td><td>使两个向量都标准化并且相互正交。</td></tr><tr><td><code>Project</code></td><td>将一个向量投影到另一个向量上。</td></tr><tr><td><code>ProjectOnPlane</code></td><td>将一个向量投影到一个平面上。</td></tr><tr><td><code>Reflect</code></td><td>将向量反射到由法线定义的平面上。</td></tr><tr><td><code>RotateTowards</code></td><td>将一个向量 <code>current</code> 旋转到目标向量 <code>target</code>，并计算旋转。</td></tr><tr><td><code>Scale</code></td><td>逐分量地将两个向量相乘。</td></tr><tr><td><code>SignedAngle</code></td><td>计算两个向量之间相对于某一轴的带符号夹角。</td></tr><tr><td><code>Slerp</code></td><td>在两个三维向量之间进行球面线性插值。</td></tr><tr><td><code>SlerpUnclamped</code></td><td>在两个向量之间进行球面线性插值，不限制插值范围。</td></tr><tr><td><code>SmoothDamp</code></td><td>逐渐地将向量朝着目标位置变化，随着时间变化。</td></tr></tbody></table><p><strong>Operators</strong></p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>operator -</code></td><td>将一个向量从另一个向量中减去。</td></tr><tr><td><code>operator !=</code></td><td>如果两个向量不同，则返回 <code>true</code>。</td></tr><tr><td><code>operator *</code></td><td>将一个向量与一个数值相乘（逐分量相乘）。</td></tr><tr><td><code>operator /</code></td><td>将一个向量与一个数值相除（逐分量相除）。</td></tr><tr><td><code>operator +</code></td><td>两个三维向量进行逐分量加法。</td></tr><tr><td><code>operator ==</code></td><td>如果两个向量大致相等，则返回 <code>true</code>。</td></tr></tbody></table><p><a href=https://docs.unity3d.com/ScriptReference/Vector3.html>Unity官方文档（Vector3）</a></p><h4 id=vector4四维向量>Vector4（四维向量）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Vector4 v = <span style=color:#66d9ef>new</span> Vector4(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>);
</span></span></code></pre></div><p>常见用途：</p><ul><li>齐次坐标（矩阵变换常用）</li><li>传递颜色（Color在底层可能是Vector4(r,g,b,a)）</li><li>shader开发中用于高级数学运算（如平面方程、切线空间等）</li></ul><h3 id=quaternion--euler-angles>Quaternion & Euler Angles</h3><p>在Unity中，Quaternion是用来表示旋转的核心数学结构，它避免了Euler Angles的万向节死锁问题，并且适用于平滑插值和复杂3D计算</p><h4 id=quaternion>Quaternion</h4><p>Quaternion表示绕某一条单位轴旋转一个角度的这个过程，简单来说：表示一个旋转</p><p><strong>数学本质</strong>
四元数是一种复数扩展：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#a6e22e>Q</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>w + xi + yj + zk</span>
</span></span></code></pre></div><p>在Unity中被表示为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Quaternion</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> z;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> w;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>x, y, z</code>表示旋转轴的向量部分（方向）<br><code>w</code>表示旋转的角度部分(cos(θ/2))</p><p>四元数不是角度 + 轴直接拼成的，是通过以下方式构造：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#a6e22e>x</span><span style=color:#f92672>=</span><span style=color:#e6db74>axis.x⋅sin(θ/2)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>y</span><span style=color:#f92672>=</span><span style=color:#e6db74>axis.y⋅sin(θ/2)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>z</span><span style=color:#f92672>=</span><span style=color:#e6db74>axis.z⋅sin(θ/2)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>w</span><span style=color:#f92672>=</span><span style=color:#e6db74>cos(θ/2)</span>
</span></span></code></pre></div><p>其中<code>axis</code>是归一化的旋转轴向量<br><code>θ</code>是旋转角度（弧度）</p><p>你可以把四元数想象成一个旋转操作，它编码了两个信息：</p><ul><li>1.绕哪个轴旋转</li><li>2.旋转多少角度</li></ul><p><strong>Quaternion用途</strong></p><table><thead><tr><th>用途场景</th><th>描述</th></tr></thead><tbody><tr><td>表示物体旋转</td><td>替代 <code>transform.rotation = new Vector3(...)</code>，更稳定</td></tr><tr><td>做平滑旋转（Slerp/Lerp）</td><td>保持插值平滑、不跳跃、不变形</td></tr><tr><td>实现摄像机跟随</td><td>平滑跟随目标的朝向</td></tr><tr><td>构建旋转动画</td><td>可结合 Timeline、Animator 使用</td></tr><tr><td>控制角色面向</td><td>看向目标、追踪方向等</td></tr></tbody></table><p><strong>Quaternion API</strong></p><table><thead><tr><th>方法/属性</th><th>说明</th></tr></thead><tbody><tr><td><code>Quaternion.identity</code></td><td>零旋转（即不旋转）</td></tr><tr><td><code>Quaternion.Euler(x, y, z)</code></td><td>从欧拉角创建旋转</td></tr><tr><td><code>Quaternion.LookRotation(dir)</code></td><td>让对象朝向某个方向</td></tr><tr><td><code>Quaternion.Angle(a, b)</code></td><td>计算两个旋转之间的角度</td></tr><tr><td><code>Quaternion.AngleAxis(float angle, Vector3 axis)</code></td><td>围绕axis旋转angle度</td></tr><tr><td><code>Quaternion.Slerp(a, b, t)</code></td><td>在两个旋转之间平滑插值（匀速）</td></tr><tr><td><code>Quaternion.Lerp(a, b, t)</code></td><td>线性插值旋转（不推荐用于大角度）</td></tr><tr><td><code>Quaternion.RotateTowards(a, b, maxDegreesDelta)</code></td><td>限制最大旋转角度的平滑旋转</td></tr><tr><td><code>* 运算符</code>（例如 <code>rot * vector</code>）</td><td>将旋转应用于向量，旋转该方向向量</td></tr></tbody></table><p><strong>构建方式</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Quaternion q = Quaternion.AngleAxis(<span style=color:#ae81ff>90</span>, Vector3.up); <span style=color:#75715e>//绕Y轴旋转90°</span>
</span></span></code></pre></div><p>使用欧拉角构建：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Quaternion q = Quaternion.Euler(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>//XYZ分别是绕X Y Z轴的角度</span>
</span></span></code></pre></div><h4 id=euler-angles>Euler Angles</h4><p><strong>欧拉角的定义</strong><br>欧拉角是用三个角度来描述3D空间中的一个旋转变换，每个角度表示围绕一个坐标轴的旋转量。<br>在Unity中，欧拉角就是一个<code>Vector3</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>transform.eulerAngles = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>45</span>, <span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><p>这表示：</p><ul><li>绕X轴旋转30°</li><li>然后绕Y轴旋转45°</li><li>然后绕Z轴旋转0°</li></ul><blockquote><p>欧拉角的本质是「分轴顺序旋转」，三个角度 + 一个旋转顺序（X -> Y -> Z），顺序不能出现问题，否则结果不同</p></blockquote><p><strong>欧拉角的特点</strong></p><table><thead><tr><th>特点</th><th>描述</th></tr></thead><tbody><tr><td>直观</td><td>直接写角度，容易理解和调试</td></tr><tr><td>顺序敏感</td><td>顺序不同，结果不同（ZYX ≠ XYZ）</td></tr><tr><td>有死锁</td><td>当某个轴旋转到特定位置时，另一个轴“失效”——<strong>万向节死锁（Gimbal Lock）</strong></td></tr><tr><td>插值难</td><td>在两个角度之间插值时可能会突然“跳动”或绕远路</td></tr></tbody></table><p><strong>欧拉角适用于：</strong></p><ul><li>手动设置角度</li><li>UI显示</li><li>编辑器中拖拽角度时</li><li>简单旋转动画、摄像机控制</li></ul><p><strong>实际旋转逻辑中，建议使用Quaternion</strong></p><p><strong>Euler Angels和Quaternion的关系</strong><br>Unity内部几乎不直接用欧拉角进行旋转运算，它会自动把你设置的欧拉角转换为四元数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>transform.eulerAngles = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 实际上自动转换为：</span>
</span></span><span style=display:flex><span>transform.rotation = Quaternion.Euler(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><p><strong>欧拉角插值出现的问题</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Vector3 <span style=color:#66d9ef>from</span> = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>Vector3 to = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>360</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Vector3 result = Vector3.Lerp(<span style=color:#66d9ef>from</span>, to, <span style=color:#ae81ff>0.5f</span>); <span style=color:#75715e>//会插值到180°</span>
</span></span></code></pre></div><p>实际上，从0°到360°最短路径时0°，这就是欧拉角插值跳变的问题<br>使用四元数可以避免</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Quaternion q1 = Quaternion.Euler(<span style=color:#66d9ef>from</span>);
</span></span><span style=display:flex><span>Quaternion q2 = Quaternion.Euler(to);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Quaternion qResult = Quaternion.Slerp(q1, q2, <span style=color:#ae81ff>0.5f</span>);
</span></span></code></pre></div><p><strong>Euler Angles和Quaternion的转换</strong><br>欧拉角 -> 四元数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Quaternion q = Quaternion.Euler(<span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>45</span>, <span style=color:#ae81ff>60</span>);
</span></span></code></pre></div><p>四元数 -> 欧拉角</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Vector3 euler = q.eulerAngles;
</span></span></code></pre></div><blockquote><p>四元数本身不会存储旋转顺序和原始角度，这个反转换可能会出现不寻常的角度，比如-180°、350°等</p></blockquote><p>欧拉角和四元数的关系：三次独立的XYZ轴旋转（Euler Angle）相当于对于某个特定轴旋转特定角度（Quaternion）<br><strong>深入原理</strong>
给定欧拉角 (𝛼, 𝛽, 𝛾)，表示绕 X、Y、Z 旋转，四元数变换公式如下（XYZ顺序）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Quaternion q = Quaternion.Euler(alpha, beta, gamma);
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Quaternion qx = Quaternion.AngleAxis(alpha, Vector3.right);
</span></span><span style=display:flex><span>Quaternion qy = Quaternion.AngleAxis(beta, Vector3.up);
</span></span><span style=display:flex><span>Quaternion qz = Quaternion.AngleAxis(gamma, Vector3.forward);
</span></span><span style=display:flex><span>Quaternion q = qy * qx * qz; <span style=color:#75715e>//组合旋转，顺序重要；Unity为左乘</span>
</span></span></code></pre></div><p><strong>万向节死锁（Gimbal Lock）</strong><br>Gimbal Lock是指使用欧拉角进行三维旋转时，当两个旋转轴重合，导致自由度从3变成2，某个方向的旋转无法表达的情况<br>产生Gimbal Lock的核心原因是欧拉角的特性:<br>一组欧拉角描述一个旋转过程：即，围绕每个轴的旋转角度和围绕每个轴旋转的顺序，顺序很重要，不同的顺序会带来不同的结果
Gimbal Lock产生的核心是：先执行旋转的轴会带动后执行旋转的轴转动，即产生新轴；但后执行旋转的轴不会带动先执行旋转的轴转动，即一个轴旋转过后就不会出现新轴了，这就会出现轴重合问题，即导致万向节死锁的产生<br><strong>数学本质是矩阵乘法的非交换性</strong><br>旋转在数学上是用矩阵表示的：</p><ul><li>旋转操作使用矩阵乘法实现的</li><li>矩阵乘法不满足交换律，也就是说：Rx × Ry != Ry × Rx</li></ul><p><strong>核心关键是为什么后旋转的轴不能带动先旋转的轴？</strong><br>这个问题涉及到旋转的执行顺序本质上是“嵌套变换”，而不是“同步协商”的。这就像流水线的工序，是不可逆和不可交错的<br>核心结论：<br>每一步旋转都是在“当前局部坐标系”下完成的，而不是回头修改前面坐标系的历史状态<br>后面的旋转只是在前面旋转结果基础上叠加，它并不会“回头影响”之前已经旋转过的坐标系<br>举个例子：
假设做一个蛋糕：<br>第一步：打鸡蛋<br>第二步：加牛奶<br>第三步：搅拌<br>现在你问：为什么我搅拌的时候不能回头改变我打鸡蛋这个过程？<br>因为：打鸡蛋已经做完了，是个不可逆的状态变换，你在搅拌的时候，只能处理“鸡蛋 + 牛奶”的混合物，不能改变已经打完的蛋</p><p><strong>数学视角：矩阵乘法是方向性的</strong>
旋转是通过矩阵来表示的，顺序matters： <code>FinalRotation = Rz · Ry · Rx</code><br>你先执行Rx，然后再执行Ry,再执行Rz<br>每个旋转操作都是将当前状态乘上一个旋转矩阵<br>一旦Rx被应用，坐标系就已经变了<br>之后的Ry是在这个变了的坐标系下进行的<br>Ry不会也无法回头修改Rx的效果<br>因为矩阵乘法不是可交换的，所以这个顺序是“单向嵌套”，不是“双向影响”</p><p><strong>欧拉角是旋转变换，每次旋转变换都是叠加了上次旋转的状态后再进行的，也就是说，虽然每次变换都是独立的，但都要经历从初始状态按顺序旋转，绕轴旋转角度达到目标状态这一系列流程，这就把时序包含在其中了</strong><br><strong>初始状态是（0，0，0）</strong></p><p><strong>为什么看到的变换是连续的</strong><br>欧拉角变换虽然顺序嵌套，但它们构成的是一个连续函数映射<br>欧拉角 → 四元数 → 变换矩阵 → 渲染出模型的姿态
整个链条中：</p><p>欧拉角：你手动输入的 (X, Y, Z) 是连续的（例如你拖动滑块）</p><p>四元数：Unity 把欧拉角转换成一个四元数，这是一个连续光滑的旋转表示</p><p>矩阵：四元数再转成 3×3 旋转矩阵，依然是平滑的</p><p>模型：在世界中展示的姿态是自然旋转、连贯变化的</p><p>所以你看到的旋转是连续的、平滑的。</p><p><strong>哪些地方是不连续的</strong><br>1.万向节死锁，当某个周旋转到90°，两个轴重合，自由度减少，Unity为了保持“姿态”，可能会自动调整其他轴的值，此时Rotation的值再Inspector中跳变，但物体并没有跳<br>2.四元数存在加减号不唯一（180°对称）问题，一个方向可以由两个四元数表示：q和-q，它们作用在物体上是一样的，Unity在背后自动选择最短路径，所以视觉上依旧是连续旋转路径上的最短旋转</p><h3 id=matrix44>Matrix4×4</h3><p>在 Unity 中，Matrix4x4 是一个 4x4 的矩阵，通常用于表示和处理 3D 图形变换（例如：平移、旋转、缩放）以及投影变换。它是 Unity 中进行图形学计算时不可或缺的工具之一，特别是在操作坐标系变换和投影时，矩阵起到了重要作用。</p><h4 id=结构和基本概念>结构和基本概念</h4><p>一个 4x4 的矩阵包含 16 个元素，用来存储 3D 空间中的变换信息。矩阵通常表示为：</p><p>$$
\begin{bmatrix}
m_00 & m_01 & m_02 & m_03\
m_10 & m_11 & m_12 & m_13\
m_20 & m_21 & m_22 & m_23\
m_30 & m_31 & m_32 & m_33
\end{bmatrix}
$$</p><ul><li>前三列（前三个3D向量）：表示选择、缩放和剪切变换</li><li>最后一列：通常表示平移</li><li>最后一行：在Unity中一般被设置为<code>[0, 0, 0, 1]</code>，它不参与位置和方向的变换，但在某些情况下（如透视投影）可能会发生变化</li></ul><h4 id=matrix44的常见用途>Matrix4×4的常见用途</h4><ol><li>变换（Transformations）
在3D图形中，变换通常包含平移（Translation）、旋转（Rotation）和缩放（Scaling），这些都可以通过矩阵来表示。矩阵变换是通过矩阵与向量的乘法实现的</li></ol><ul><li><p>平移矩阵：
通过矩阵中的第四列来实现物体的平移</p><p>$ Translation;Matrix = \begin{bmatrix} 1 & 0 & 0 & tx\ 0 & 1 & 0 & ty\ 0 & 0 & 1 & tz\ 0 & 0 & 0 & 1 \end{bmatrix} $</p><p>其中，<code>tx</code>,<code>ty</code>,<code>tz</code>是在X,Y,Z轴上的平移距离</p></li><li><p>旋转矩阵：
旋转矩阵用于旋转物体在不同轴上的旋转。旋转矩阵有不同的表示方式，常见的是绕X,Y,Z轴旋转的矩阵：</p><ul><li><p>绕X轴旋转：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Rotation\;Matrix(X)=\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; cos(θ) &amp; -sin(θ) &amp; 0\\ 0 &amp; sin(θ) &amp; cos(θ) &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}
</span></span></code></pre></div></li><li><p>绕Y轴旋转</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Rotation\;Matrix(Y)=\begin{bmatrix} cos(θ) &amp; 0 &amp; sin(θ) &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ -sin(θ) &amp; 0 &amp; cos(θ) &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} 
</span></span></code></pre></div><ul><li>绕Z轴旋转：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Rotation\;Matrix(Z)=\begin{bmatrix} cos(θ) &amp; 0 &amp; sin(θ) &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ -sin(θ) &amp; 0 &amp; cos(θ) &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} 
</span></span></code></pre></div></li></ul><p>其中<code>θ</code>代表旋转角度</p></li><li><p>缩放矩阵：
缩放矩阵控制物体在各个轴上的缩放：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Scale\;Matrix=\begin{bmatrix} sx &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; sy &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; sz &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} 
</span></span></code></pre></div><p>其中，<code>sx</code>,<code>sy</code>,<code>sz</code>代表X,Y,Z轴上的缩放因子</p></li></ul><ol start=2><li>矩阵乘法
多个变换（如平移、旋转、缩放）可以通过矩阵乘法结合起来。例如，将旋转和缩放变换合并到一个矩阵中，执行复合变换。</li></ol><ul><li>如果你有两个矩阵<code>M1</code>和<code>M2</code>，则复合变换矩阵是通过矩阵乘法得到的：<code>M = M1 * M2</code></li><li>在Unity中，矩阵乘法通过<code>Matrix4×4</code>的<code>*</code>操作符完成</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Matrix4x4 rotationMatrix = Matrix4x4.Rotate(Quaternion.Euler(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>45</span>, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>Matrix4x4 scaleMatrix = Matrix4x4.Scale(<span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>Matrix4x4 combinedMatrix = rotationMatrix * scaleMatrix; <span style=color:#75715e>// 复合变换</span>
</span></span></code></pre></div><ol start=3><li>投影矩阵
投影矩阵用于将 3D 场景投影到 2D 屏幕上。常见的投影有 正射投影 和 透视投影。</li></ol><ul><li>透视投影矩阵：
透视投影矩阵会产生“透视效果”，即远处的物体看起来更小。透视矩阵的公式通常比较复杂，Unity 提供了 <code>Matrix4x4.Perspective</code> 方法来生成透视投影矩阵。<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Matrix4x4 perspectiveMatrix = Matrix4x4.Perspective(<span style=color:#ae81ff>60f</span>, <span style=color:#ae81ff>16f</span>/<span style=color:#ae81ff>9f</span>, <span style=color:#ae81ff>0.1f</span>, <span style=color:#ae81ff>100f</span>);
</span></span></code></pre></div>其中，<code>60f</code>是垂直视野角度，<code>16/9f</code>是宽高比，<code>0.1f</code>和<code>100f</code>是近平面和远平面的距离</li><li>正射投影矩阵
正射投影没有透视效果，所有物体的大小都是相同的，不随远近变化。可以通过 Matrix4x4.Ortho 来创建<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Matrix4x4 orthoMatrix = Matrix4x4.Ortho(-<span style=color:#ae81ff>5f</span>, <span style=color:#ae81ff>5f</span>, -<span style=color:#ae81ff>5f</span>, <span style=color:#ae81ff>5f</span>, <span style=color:#ae81ff>0.1f</span>, <span style=color:#ae81ff>100f</span>);
</span></span></code></pre></div></li></ul><ol start=4><li>视图矩阵（View Matrix）
视图矩阵用于描述相机在场景中的位置和朝向。它把世界空间中的物体转换到相机的视图空间</li></ol><ul><li>Unity中可以通过<code>Camera.worldToCameraMatrix</code>获取视图矩阵</li></ul><h4 id=api-1>API</h4><p><strong>Static Properties</strong></p><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody><tr><td><code>identity</code></td><td>返回单位矩阵（只读）</td></tr><tr><td><code>zero</code></td><td>返回零矩阵（只读）</td></tr></tbody></table><p><strong>Properties</strong></p><table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody><tr><td><code>decomposeProjection</code></td><td>该属性接受一个投影矩阵并返回定义投影视锥体的六个平面坐标。</td></tr><tr><td><code>determinant</code></td><td>返回矩阵的行列式（只读）。</td></tr><tr><td><code>inverse</code></td><td>返回该矩阵的逆矩阵（只读）。</td></tr><tr><td><code>isIdentity</code></td><td>检查此矩阵是否为单位矩阵（只读）。</td></tr><tr><td><code>lossyScale</code></td><td>尝试从矩阵中获取一个缩放值（只读）。</td></tr><tr><td><code>rotation</code></td><td>尝试从矩阵中获取一个旋转四元数。</td></tr><tr><td><code>this[int, int]</code></td><td>访问矩阵中的元素，使用 <code>[row, column]</code> 索引。</td></tr><tr><td><code>transpose</code></td><td>返回矩阵的转置矩阵（只读）。</td></tr></tbody></table><p><strong>Public Methods</strong></p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>GetColumn</code></td><td>获取矩阵的某一列。</td></tr><tr><td><code>GetPosition</code></td><td>从矩阵中获取位置向量。</td></tr><tr><td><code>GetRow</code></td><td>返回矩阵的某一行。</td></tr><tr><td><code>MultiplyPoint</code></td><td>使用此矩阵对一个位置进行变换（通用）。</td></tr><tr><td><code>MultiplyPoint3x4</code></td><td>使用此矩阵对一个位置进行快速变换（适用于 3x4 矩阵）。</td></tr><tr><td><code>MultiplyVector</code></td><td>使用此矩阵对一个方向进行变换。</td></tr><tr><td><code>SetColumn</code></td><td>设置矩阵的某一列。</td></tr><tr><td><code>SetRow</code></td><td>设置矩阵的某一行。</td></tr><tr><td><code>SetTRS</code></td><td>将此矩阵设置为一个平移、旋转和缩放矩阵。</td></tr><tr><td><code>ToString</code></td><td>返回此矩阵的格式化字符串表示。</td></tr><tr><td><code>TransformPlane</code></td><td>返回一个在空间中经过变换的平面。</td></tr><tr><td><code>ValidTRS</code></td><td>检查此矩阵是否是一个有效的变换矩阵（平移、旋转、缩放组合矩阵）。</td></tr></tbody></table><p><strong>Static Methods</strong></p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>Frustum</code></td><td>返回一个具有视景体（viewing frustum）的投影矩阵，近平面由传入的坐标定义。</td></tr><tr><td><code>Inverse3DAffine</code></td><td>计算一个 3D 仿射矩阵的逆矩阵。</td></tr><tr><td><code>LookAt</code></td><td>创建一个“Look At”矩阵，使物体朝向指定的目标点。</td></tr><tr><td><code>Ortho</code></td><td>创建一个正交投影矩阵。</td></tr><tr><td><code>Perspective</code></td><td>创建一个透视投影矩阵。</td></tr><tr><td><code>Rotate</code></td><td>创建一个旋转矩阵。</td></tr><tr><td><code>Scale</code></td><td>创建一个缩放矩阵。</td></tr><tr><td><code>Translate</code></td><td>创建一个平移矩阵。</td></tr><tr><td><code>TRS</code></td><td>创建一个平移、旋转和缩放的组合矩阵。</td></tr></tbody></table><p><strong>Operators</strong></p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>operator*</code></td><td>两个矩阵相乘</td></tr></tbody></table><h2 id=application>Application</h2><p><code>Application</code>是Unity提供的一个全局静态类，用来获取或控制应用程序的整体运行状态，比如游戏生命周期、平台信息、版本号、退出应用、持久化路径、事件系统等<br>可以理解为：<code>Application</code> = 游戏运行时的全局控制台</p><h3 id=api-2>API</h3><p><strong>Static Properties</strong></p><table><thead><tr><th>分组</th><th>属性</th><th>用途简述</th></tr></thead><tbody><tr><td><strong>应用信息</strong></td><td><code>productName</code></td><td>应用产品名</td></tr><tr><td></td><td><code>companyName</code></td><td>公司名</td></tr><tr><td></td><td><code>version</code></td><td>应用版本号</td></tr><tr><td></td><td><code>unityVersion</code></td><td>Unity 运行时版本</td></tr><tr><td></td><td><code>buildGUID</code></td><td>构建唯一标识</td></tr><tr><td></td><td><code>cloudProjectId</code></td><td>云项目 ID</td></tr><tr><td></td><td><code>identifier</code></td><td>包名 / Bundle ID</td></tr><tr><td></td><td><code>installerName</code></td><td>安装来源（商店）</td></tr><tr><td></td><td><code>installMode</code></td><td>安装模式</td></tr><tr><td></td><td><code>sandboxType</code></td><td>沙盒环境类型</td></tr><tr><td><strong>平台与运行环境</strong></td><td><code>platform</code></td><td>当前运行平台</td></tr><tr><td></td><td><code>isMobilePlatform</code></td><td>是否移动平台</td></tr><tr><td></td><td><code>isConsolePlatform</code></td><td>是否主机平台</td></tr><tr><td></td><td><code>isEditor</code></td><td>是否在编辑器运行</td></tr><tr><td></td><td><code>isBatchMode</code></td><td>是否批处理模式</td></tr><tr><td></td><td><code>absoluteURL</code></td><td>当前 URL / 深度链接</td></tr><tr><td></td><td><code>systemLanguage</code></td><td>系统语言</td></tr><tr><td></td><td><code>internetReachability</code></td><td>网络可达性</td></tr><tr><td><strong>数据路径</strong></td><td><code>dataPath</code></td><td>游戏数据路径（只读）</td></tr><tr><td></td><td><code>persistentDataPath</code></td><td>持久化数据路径（可写）</td></tr><tr><td></td><td><code>streamingAssetsPath</code></td><td>StreamingAssets 路径</td></tr><tr><td></td><td><code>temporaryCachePath</code></td><td>临时缓存路径</td></tr><tr><td></td><td><code>consoleLogPath</code></td><td>日志文件路径</td></tr><tr><td><strong>运行状态</strong></td><td><code>isPlaying</code></td><td>是否正在运行</td></tr><tr><td></td><td><code>isFocused</code></td><td>是否获得焦点</td></tr><tr><td></td><td><code>runInBackground</code></td><td>后台运行开关</td></tr><tr><td></td><td><code>backgroundLoadingPriority</code></td><td>后台加载优先级</td></tr><tr><td></td><td><code>targetFrameRate</code></td><td>目标帧率</td></tr><tr><td></td><td><code>exitCancellationToken</code></td><td>退出时取消令牌</td></tr><tr><td><strong>安全与验证</strong></td><td><code>genuine</code></td><td>应用是否被篡改</td></tr><tr><td></td><td><code>genuineCheckAvailable</code></td><td>是否可用完整性检查</td></tr></tbody></table><p><strong>Static Methods</strong></p><table><thead><tr><th>分组</th><th>方法</th><th>描述</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>场景与运行控制</strong></td><td><code>CanStreamedLevelBeLoaded(string levelName)</code></td><td>检查指定场景是否可以加载（适用于流式加载）</td><td>场景预检测，避免加载不存在的场景</td></tr><tr><td></td><td><code>Unload()</code></td><td>卸载 Unity Player</td><td>WebGL、嵌入式 Unity 内容的卸载</td></tr><tr><td><strong>日志与调试</strong></td><td><code>GetStackTraceLogType(LogType logType)</code></td><td>获取指定日志类型的堆栈跟踪模式</td><td>日志调试策略</td></tr><tr><td></td><td><code>SetStackTraceLogType(LogType logType, StackTraceLogType stackTraceType)</code></td><td>设置指定日志类型的堆栈跟踪模式</td><td>减少无关堆栈信息，提高性能</td></tr><tr><td><strong>权限与授权</strong></td><td><code>HasUserAuthorization(UserAuthorization mode)</code></td><td>检查用户是否授权使用麦克风或摄像头（iOS/WebGL）</td><td>设备访问控制</td></tr><tr><td></td><td><code>RequestUserAuthorization(UserAuthorization mode)</code></td><td>请求用户授权麦克风/摄像头（iOS/WebGL）</td><td>首次访问硬件设备时使用</td></tr><tr><td><strong>许可证与广告</strong></td><td><code>HasProLicense()</code></td><td>检查当前 Unity 是否为 Pro 许可证</td><td>编辑器功能限制判断</td></tr><tr><td></td><td><code>RequestAdvertisingIdentifierAsync(Action&lt;string, bool, string> callback)</code></td><td>请求广告标识符（iOS/UWP）</td><td>广告分析、用户追踪（需遵守隐私法规）</td></tr><tr><td><strong>运行状态</strong></td><td><code>IsPlaying(Object obj)</code></td><td>检查对象是否在运行环境中（Play 模式或构建版本）</td><td>运行时逻辑分支判断</td></tr><tr><td><strong>系统交互</strong></td><td><code>OpenURL(string url)</code></td><td>打开外部链接或资源</td><td>跳转到网页、商店、帮助文档</td></tr><tr><td></td><td><code>Quit()</code></td><td>退出应用程序</td><td>游戏退出按钮</td></tr></tbody></table><p>注意事项</p><ol><li><code>Quit()</code>在编辑器中无效，只在构建版本中退出</li><li>权限方法仅在特定平台有效（iOS、WebGL），Android需要用原生接口</li><li>广告ID受隐私政策限制（iOS 14+ 必须先获得用户同意）</li><li><code>Unload()</code>主要用于WebGL等嵌入环境，不适用于独立应用</li><li>日志堆栈设置可以优化性能，但会影响调试信息完整性</li></ol><p><strong>Events</strong></p><table><thead><tr><th>事件名</th><th>触发时机</th><th>常见用途</th><th>注意事项</th></tr></thead><tbody><tr><td><strong>deepLinkActivated</strong></td><td>当 App 通过 <strong>Deep Link URL</strong> 被激活时（Android / iOS / UWP）</td><td>处理外部 URL 跳转，例如从浏览器点击链接直接打开游戏并跳转到特定场景</td><td>仅在移动端/UWP生效，需要在系统设置好 Deep Link</td></tr><tr><td><strong>focusChanged</strong></td><td>当应用程序获得或失去焦点时</td><td>暂停/恢复游戏逻辑、音乐播放、计时器等</td><td>与 <code>Application.runInBackground</code> 配合使用</td></tr><tr><td><strong>logMessageReceived</strong></td><td>在主线程收到 <code>Debug.Log</code>/<code>Debug.LogError</code>/<code>Debug.LogWarning</code> 时触发</td><td>收集运行时日志、保存到文件、上传服务器</td><td>仅主线程调用，性能安全</td></tr><tr><td><strong>logMessageReceivedThreaded</strong></td><td>在<strong>任意线程</strong>收到日志信息时触发</td><td>捕获多线程环境下的日志（Job System、线程池等）</td><td>回调不在主线程，访问 Unity API 会报错</td></tr><tr><td><strong>lowMemory</strong></td><td>当设备内存不足时触发</td><td>释放不必要的资源、清理缓存</td><td>常见于移动设备，尤其是低端机</td></tr><tr><td><strong>memoryUsageChanged</strong></td><td>当内存使用量显著变化时触发</td><td>做内存优化监控，比如动态调节贴图分辨率</td><td>Unity 2021.2+ 新增功能</td></tr><tr><td><strong>onBeforeRender</strong></td><td>在渲染前调用（尤其是 VR 输入更新）</td><td>VR/AR 场景中，在渲染前同步姿态数据</td><td>用途很小众，主要面向 XR</td></tr><tr><td><strong>quitting</strong></td><td>应用退出时触发</td><td>保存存档、上传数据、关闭网络连接</td><td>有时不一定能保证执行完，比如强杀进程</td></tr><tr><td><strong>unloading</strong></td><td>Player 卸载时触发</td><td>卸载前释放资源（场景卸载、资源清理）</td><td>常与 Addressables 资源卸载配合</td></tr><tr><td><strong>wantsToQuit</strong></td><td>应用<strong>想要</strong>退出时触发，可拦截</td><td>弹出“是否退出”确认框</td><td>通过返回 <code>false</code> 阻止退出</td></tr></tbody></table><p><strong>Delegates</strong></p><table><thead><tr><th>委托</th><th>作用</th><th>常用场景</th><th>签名</th></tr></thead><tbody><tr><td><strong>AdvertisingIdentifierCallback</strong></td><td>获取设备广告 ID（Ad ID / IDFA）</td><td>广告投放、用户追踪</td><td><code>void(string advertisingId, bool trackingEnabled, string error)</code></td></tr><tr><td><strong>LogCallback</strong></td><td>自定义日志处理</td><td>日志系统、异常上传</td><td><code>void(string condition, string stackTrace, LogType type)</code></td></tr><tr><td><strong>LowMemoryCallback</strong></td><td>低内存回调</td><td>清缓存、卸载贴图</td><td><code>void()</code></td></tr><tr><td><strong>MemoryUsageChangedCallback</strong></td><td>内存使用变化回调</td><td>实时内存监控、自适应性能</td><td><code>void(long memoryUsage)</code></td></tr></tbody></table><h2 id=color>Color</h2><p><code>Color</code>是UnityEngine命名空间下的一个非常核心的结构体，它的本质是RGBA颜色表示</p><h3 id=定义>定义</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Color</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> r; <span style=color:#75715e>// 红色分量</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> g; <span style=color:#75715e>// 绿色分量</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> b; <span style=color:#75715e>// 蓝色分量</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> a; <span style=color:#75715e>// 透明度</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>范围：每个分量的值通常在<code>[0.0f, 1.0f]</code>之间<ul><li>0表示没有该分量</li><li>1表示最大值</li></ul></li><li>如果超出范围，Unity仍然支持，但会根据材质/Shader的处理方式决定如何渲染（比如HDR时可以 > 1）</li><li>Unity内部用<code>float</code>存储颜色，而不是字节(<code>0~255</code>)，这样更方便在着色器和数学运算中直接处理</li></ul><h3 id=api-3>API</h3><ol><li>Constructor</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> Color(<span style=color:#66d9ef>float</span> r, <span style=color:#66d9ef>float</span> g, <span style=color:#66d9ef>float</span> b);
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Color(<span style=color:#66d9ef>float</span> r, <span style=color:#66d9ef>float</span> g, <span style=color:#66d9ef>float</span> b, <span style=color:#66d9ef>float</span> a);
</span></span></code></pre></div><ol start=2><li><p>Static Properties
各种颜色
<code>Color.aliceBlue.ToString()</code> RGBA(0.9411765f, 0.9725491f, 1f, 1f)</p></li><li><p>Properties</p></li></ol><p>| Property | Description |
| <code>a</code> | Alpha component of color(0 is transparent, 1 is opaque) |
| <code>b</code> | Blue component of color |
| <code>g</code> | Green component of color |
| <code>r</code> | Red component of color |
| <code>gamma</code> | 返回应用Gamma矫正的颜色 |
| <code>linear</code> | 返回从sRGB转换为Linear空间的颜色 |
| <code>grayscale</code> | 返回灰度值 |
| <code>maxColorComponent</code> | 返回<code>r, g, b</code>三个分量中的最大值 |
| <code>this[int index]</code> | 索引访问器，允许用数组的方式访问颜色分量， <code>0, 1, 2, 3</code>对应<code>r, g, b, a</code> |</p><p>// TODO: <code>gamma</code> and <code>linear</code> and <code>sRGB</code></p><ul><li><p><code>gamma</code>：显示器上的颜色通常不是线性的，而是sRGB（标准颜色空间）（gamma 2.2左右）</p><ul><li>在渲染时，一般在Linear空间计算光照，但最终显示时要转换为Gamma空间</li></ul></li><li><p><code>linear</code>：是<code>gamma</code>的相反操作</p></li><li><p><code>grayscale</code>：Unity内部使用平均加权（符合人眼对亮度的敏感度）$Gray = 0.299 × r + 0.587 × g + 0.144 × b$</p></li></ul><ol start=4><li>Public Methods</li></ol><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>Equals</code></td><td>rbga均相等</td></tr><tr><td><code>GetHashCode</code></td><td>返回该颜色的哈希值</td></tr><tr><td><code>ToString</code></td><td>返回颜色的标准字符串</td></tr></tbody></table><ol start=5><li>Static Methods</li></ol><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>HSVToRGB</code></td><td>HSV转RGB （HSV是色相、饱和度、明度颜色模型）</td></tr><tr><td><code>RGBToHSV</code></td><td>RGB转HSV</td></tr><tr><td><code>Lerp</code></td><td><code>public static Color Lerp(Color a, Color b, float t);</code> 从颜色a到颜色b的线差转换，速率为t</td></tr><tr><td><code>LerpUnclamped</code></td><td>非钳制插值，参数无范围限制</td></tr></tbody></table><h3 id=使用>使用</h3><ol><li>材质颜色</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>renderer.material.color = Color.red;
</span></span></code></pre></div><ol start=2><li>UI颜色</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>GetComponent&lt;Image&gt;().color = <span style=color:#66d9ef>new</span> Color(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0.5f</span>);
</span></span></code></pre></div><ol start=3><li>Gizmos绘制</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Gizmos.color = Color.yellow;
</span></span><span style=display:flex><span>Gizmos.DrawSphere(transform.position, <span style=color:#ae81ff>1f</span>);
</span></span></code></pre></div><h2 id=color32>Color32</h2><p>以32位格式表示RGBA颜色，每个颜色分量都是一个字节值，范围从0到255</p><p><code>Color</code>使用<code>float</code>，精度高，<code>Color32</code>使用<code>byte</code>，更适合和贴图、GPU数据交互</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Color c = <span style=color:#66d9ef>new</span> Color(<span style=color:#ae81ff>1f</span>, <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>1f</span>);
</span></span><span style=display:flex><span>Color32 c32 = <span style=color:#66d9ef>new</span> Color32(<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>);
</span></span></code></pre></div><p>二者可以隐式转换</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Color c = (Color) <span style=color:#66d9ef>new</span> Color32(<span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>);
</span></span><span style=display:flex><span>Color32 c32 = (Color32) Color.green;
</span></span></code></pre></div><p><code>Color</code>和<code>Color32</code>可以和<code>Vector4</code>进行转化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Vector4 newV4 = <span style=color:#66d9ef>new</span> Color(<span style=color:#ae81ff>0.3f</span>, <span style=color:#ae81ff>0.4f</span>, <span style=color:#ae81ff>0.6f</span>);
</span></span></code></pre></div></div><nav class=post-nav><a href=/blog/unity-architecture/ class=hover:underline>pre: Unity Componenet-Driven Architecture</a>
<a href=/blog/unity-behavior/ class=hover:underline>next: Unity Behavior</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#1空间几何类型transform相关>1.空间/几何类型（Transform相关）</a><ul><li><a href=#vector>Vector</a><ul><li><a href=#vector2二维向量>Vector2（二维向量）</a></li><li><a href=#vector3三维向量>Vector3（三维向量）</a><ul><li><a href=#api>API</a></li></ul></li><li><a href=#vector4四维向量>Vector4（四维向量）</a></li></ul></li><li><a href=#quaternion--euler-angles>Quaternion & Euler Angles</a><ul><li><a href=#quaternion>Quaternion</a></li><li><a href=#euler-angles>Euler Angles</a></li></ul></li><li><a href=#matrix44>Matrix4×4</a><ul><li><a href=#结构和基本概念>结构和基本概念</a></li><li><a href=#matrix44的常见用途>Matrix4×4的常见用途</a></li><li><a href=#api-1>API</a></li></ul></li></ul></li><li><a href=#application>Application</a><ul><li><a href=#api-2>API</a></li></ul></li><li><a href=#color>Color</a><ul><li><a href=#定义>定义</a></li><li><a href=#api-3>API</a></li><li><a href=#使用>使用</a></li></ul></li><li><a href=#color32>Color32</a></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved</p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>