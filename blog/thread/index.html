<!doctype html><html lang=en><head><meta charset=UTF-8><title>Thread</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=Thread class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Thread<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>Unity中的线程机制和使用方式，包括：</p><ul><li>Unity的线程模型概览</li><li>Unity API与线程限制</li><li>在Unity中使用线程的四种方式（Thread/Task/Job System/DOTS）</li><li>回到主线程的方法</li></ul><h2 id=unity线程模型概览>Unity线程模型概览</h2><p>Unity整个运行环境围绕主线程组织，它的执行流程大致如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scss data-lang=scss><span style=display:flex><span><span style=color:#f92672>主线程</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#f92672>Unity</span> <span style=color:#f92672>Loop</span><span style=color:#960050;background-color:#1e0010>）：</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> <span style=color:#f92672>Start</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> <span style=color:#f92672>Update</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> <span style=color:#f92672>渲染提交</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> <span style=color:#f92672>动画更新</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> <span style=color:#f92672>物理处理</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#f92672>同步</span> <span style=color:#f92672>PhysX</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>└─</span> <span style=color:#f92672>LateUpdate</span><span style=color:#f92672>()</span>
</span></span></code></pre></div><p><strong>主线程的作用：</strong></p><ul><li>唯一能安全访问大多数Unity API的线程</li><li>游戏逻辑、生命周期函数、事件处理等全部在主线程中执行</li></ul><h2 id=unity-api的线程限制>Unity API的线程限制</h2><blockquote><p>Unity引擎的绝大多数API不是线程安全的，只能在主线程中访问</p></blockquote><p>常见不可在子线程中调用的内容：</p><table><thead><tr><th>类型</th><th>示例</th></tr></thead><tbody><tr><td>场景对象</td><td><code>transform.position</code>、<code>gameObject.SetActive()</code></td></tr><tr><td>UI 操作</td><td><code>Text.text</code>、<code>Image.sprite</code>、<code>CanvasGroup.alpha</code></td></tr><tr><td>加载资源</td><td><code>Resources.Load</code>、<code>AssetBundle.LoadAsset</code></td></tr><tr><td>UnityEvent</td><td><code>Invoke()</code>、<code>AddListener()</code></td></tr><tr><td>摄像机/渲染设置</td><td><code>Camera.fieldOfView</code>、<code>RenderSettings.ambientLight</code></td></tr></tbody></table><h3 id=为什么大多数unity-api不是线程安全的>为什么大多数Unity API不是线程安全的</h3><blockquote><p>线程安全是指多个线程同时访问某个资源时，不会出现数据竞争、资源冲突或者状态不一致；
换句话说，线程安全的代码能保证即使多个线程同时调用，也不会导致程序崩溃或出现错误</p></blockquote><h4 id=1引擎设计的历史和架构>1.引擎设计的历史和架构</h4><ul><li>Unity是基于单线程渲染和游戏逻辑设计的引擎</li><li>主线程同时负责游戏逻辑更新、场景管理、物理模拟和渲染指令的提交</li><li>内部实现很多数据结构和资源管理是非并发安全的，没有加锁保护</li></ul><h4 id=2性能考虑>2.性能考虑</h4><ul><li>加锁和同步机制会引入性能开销，尤其在游戏高帧率需求下非常敏感</li><li>Unity为了最大化性能，避免在API层面使用大量锁机制，导致API不是线程安全</li><li>线程安全的实现往往会降低性能，而Unity选择了“主线程访问”策略，性能和复杂度间的平衡</li></ul><h4 id=3复杂的状态和资源管理>3.复杂的状态和资源管理</h4><ul><li>Unity API涉及大量复杂资源（场景、纹理、网格、动画、物理对象等）</li><li>这些资源的状态常常依赖于引擎内部复杂的生命周期管理和渲染管线</li><li>多线程访问同一资源可能导致状态不同步、竞争条件和崩溃</li></ul><h4 id=4引擎内部很多操作并非原子性>4.引擎内部很多操作并非原子性</h4><ul><li>例如<code>transform.position</code>实际是底层C++引擎中的一个复杂结构体操作</li><li>多线程同时读写可能破坏数据一致性，导致场景物体“错乱”或崩溃</li></ul><h2 id=unity中使用多线程的四种方式>Unity中使用多线程的四种方式</h2><h3 id=1thread类低级方案>1.<code>Thread</code>类（低级方案）</h3><p>适用场景：非常简单的子线程计算任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Thread t = <span style=color:#66d9ef>new</span> Thread(() =&gt;{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> result = HeavyCompute();
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;不能再这里操作 Unity API!&#34;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    t.Start();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>缺点：</p><ul><li>手动管理生命周期</li><li>无法直接“回主线程”</li><li>不支持返回值</li></ul><h3 id=2task--asyncawait推荐方式>2.<code>Task</code> + <code>async/await</code>（推荐方式）</h3><p>适合：异步加载、复杂逻辑封装</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result = <span style=color:#66d9ef>await</span> Task.Run(() =&gt; HeavyCompute());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 回到主线程，可以安全使用 Unity API</span>
</span></span><span style=display:flex><span>    Debug.Log(<span style=color:#e6db74>$&#34;计算结果：{result}&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>优点：</p><ul><li>语法简洁</li><li>自动线程切换</li><li>支持异常处理
注意：</li><li><code>await</code>后续代码回自动返回主线程（如果是Unity编译器）</li></ul><h3 id=3unity-job-system高性能并发>3.Unity Job System（高性能并发）</h3><p>适用场景：大量数据并发处理（如物理模拟、AI批量计算）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Burst;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Collections;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Jobs;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[BurstCompile]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyJob</span> : IJob
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> NativeArray&lt;<span style=color:#66d9ef>int</span>&gt; data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; data.Length; i++)
</span></span><span style=display:flex><span>            data[i] = data[i] * <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    NativeArray&lt;<span style=color:#66d9ef>int</span>&gt; arr = <span style=color:#66d9ef>new</span> NativeArray&lt;<span style=color:#66d9ef>int</span>&gt;(<span style=color:#ae81ff>100</span>, Allocator.TempJob);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; arr.Length ++i) arr[i] = i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> job = <span style=color:#66d9ef>new</span> MyJob { data = arr };
</span></span><span style=display:flex><span>    JobHandle handle = job.Schedule();
</span></span><span style=display:flex><span>    handle.Complete();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Debug.Log(arr[<span style=color:#ae81ff>10</span>]);
</span></span><span style=display:flex><span>    arr.Dispose();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>特点：</p><ul><li>Job数据结构需使用<code>NativeArray</code></li><li>不支持引用类型（string, class, GameObject）</li><li>高性能（支持Burst编译器）</li></ul><h3 id=4unity-dots-ecs--job--burst>4.Unity DOTS （ECS + Job + Burst）</h3><p>适用场景：高度并发的大型项目（如模拟类游戏、成千上万个实体）<br>ECS配合Job System形成完整的数据驱动架构<br>优点：</p><ul><li>极致性能</li><li>自动调度系统和Job</li><li>易于并行化和分布式
缺点：</li><li>和传统GameObject不兼容</li></ul><h2 id=回到主线程的方法>回到主线程的方法</h2><h3 id=场景你在子线程或task中获得数据想更新ui或gameobject>场景：你在子线程或Task中获得数据，想更新UI或GameObject</h3><h4 id=方法一使用asyncawait自动切换回主线程>方法一、使用<code>async/await</code>自动切换回主线程</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> LoadData()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> json = <span style=color:#66d9ef>await</span> Task.Run(() =&gt; File.ReadAllText(<span style=color:#e6db74>&#34;config.json&#34;</span>));
</span></span><span style=display:flex><span>    myText.text = json; <span style=color:#75715e>// 主线程</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=方法二自己封装一个主线程执行器>方法二、自己封装一个主线程执行器</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MainThreadDispatcher</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> Queue&lt;Action&gt; actions = <span style=color:#66d9ef>new</span> Queue&lt;Action&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Enqueue(Action action)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>lock</span> (actions)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            actions.Enqueue(action);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>lock</span> (actions)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (actions.Count &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                actions.Dequeue()?.Invoke();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>ThreadPool.QueueUserWorkItem(_ =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> data = HeavyLoad();
</span></span><span style=display:flex><span>    MainThreadDispatcher.Enqueue(() =&gt; myText.text = data);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=使用多线程的场景>使用多线程的场景</h2><ul><li>重计算任务（如路径寻路、AI、噪声生成）</li><li>网络请求、数据库访问</li><li>文件读写、图片压缩等I/O操作</li><li>海量数据处理（如ECS中的大量实体模型）</li></ul><blockquote><p>主线程外只用于非Unity API的计算，不允许访问Unity对象，执行完毕后记得退回主线程</p></blockquote><h3 id=unity引擎内部是多线程的>Unity引擎内部是多线程的</h3><p>虽热大多数逻辑跑在主线程，但Unity引擎内部会使用多线程来提升性能</p><table><thead><tr><th>功能</th><th>是否多线程</th><th>说明</th></tr></thead><tbody><tr><td>PhysX 物理引擎</td><td>多线程</td><td>Unity 会自动并行化处理</td></tr><tr><td>Audio 音频系统</td><td>多线程</td><td>音频解码、播放管理在后台</td></tr><tr><td>渲染管线（SRP）</td><td>多线程</td><td>在某些平台支持多线程提交渲染指令</td></tr><tr><td>Animation 系统</td><td>多线程（部分）</td><td>有些姿态计算在 Job 系统中进行</td></tr></tbody></table></div><nav class=post-nav><a href=/blog/texture/ class=hover:underline>pre: Texture</a>
<a href=/blog/tilemap/ class=hover:underline>next: Tilemap</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#unity线程模型概览>Unity线程模型概览</a></li><li><a href=#unity-api的线程限制>Unity API的线程限制</a><ul><li><a href=#为什么大多数unity-api不是线程安全的>为什么大多数Unity API不是线程安全的</a><ul><li><a href=#1引擎设计的历史和架构>1.引擎设计的历史和架构</a></li><li><a href=#2性能考虑>2.性能考虑</a></li><li><a href=#3复杂的状态和资源管理>3.复杂的状态和资源管理</a></li><li><a href=#4引擎内部很多操作并非原子性>4.引擎内部很多操作并非原子性</a></li></ul></li></ul></li><li><a href=#unity中使用多线程的四种方式>Unity中使用多线程的四种方式</a><ul><li><a href=#1thread类低级方案>1.<code>Thread</code>类（低级方案）</a></li><li><a href=#2task--asyncawait推荐方式>2.<code>Task</code> + <code>async/await</code>（推荐方式）</a></li><li><a href=#3unity-job-system高性能并发>3.Unity Job System（高性能并发）</a></li><li><a href=#4unity-dots-ecs--job--burst>4.Unity DOTS （ECS + Job + Burst）</a></li></ul></li><li><a href=#回到主线程的方法>回到主线程的方法</a><ul><li><a href=#场景你在子线程或task中获得数据想更新ui或gameobject>场景：你在子线程或Task中获得数据，想更新UI或GameObject</a><ul><li><a href=#方法一使用asyncawait自动切换回主线程>方法一、使用<code>async/await</code>自动切换回主线程</a></li><li><a href=#方法二自己封装一个主线程执行器>方法二、自己封装一个主线程执行器</a></li></ul></li></ul></li><li><a href=#使用多线程的场景>使用多线程的场景</a><ul><li><a href=#unity引擎内部是多线程的>Unity引擎内部是多线程的</a></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>