<!doctype html><html lang=en><head><meta charset=UTF-8><title>Rigidbody</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><div class=container><p>ljf12825.github.io@ljf12825.github.io:~</p></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Rigidbody<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>在Unity中，<code>Rigidbody</code>是一个用于实现物理行为的组件，它允许你的游戏对象受力、重力、碰撞等真实世界的物理规则影响</p><h2 id=rigidbody的基本功能>Rigidbody的基本功能</h2><p>当你给一个<code>GameObject</code>添加Rigibody后，它具备以下能力：</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>重力</td><td>会受到 Unity 世界的重力影响。</td></tr><tr><td>力作用</td><td>可通过 <code>AddForce()</code> 施加力。</td></tr><tr><td>碰撞</td><td>可与带有 <code>Collider</code> 的物体发生物理碰撞。</td></tr><tr><td>移动</td><td>可通过物理方式（而不是直接修改 transform）移动。</td></tr></tbody></table><h3 id=rigidbodypanel>RigidbodyPanel</h3><p><img src=/images/Blog/RigidbodyPanel.jpg alt=RigidbodyPanel></p><p><strong>基础物理参数</strong></p><table><thead><tr><th>参数名</th><th>作用</th><th>默认值</th><th>建议用法</th></tr></thead><tbody><tr><td><strong>Mass</strong>（质量）</td><td>控制惯性、碰撞反应</td><td><code>1</code></td><td>设为真实世界比例（如车 1000、人 70）</td></tr><tr><td><strong>Drag</strong>（线性阻力）</td><td>模拟空气/水的阻力（减速）</td><td><code>0</code></td><td>移动物体逐渐停止，可设为 <code>1~5</code></td></tr><tr><td><strong>Angular Drag</strong>（角阻力）</td><td>减缓旋转速度</td><td><code>0.05</code></td><td>防止物体无限旋转，常设为 <code>0.1~0.5</code></td></tr></tbody></table><ul><li><strong>Automatic Center Of Mass</strong>（自动质心，默认为true）<ul><li>Unity会根据物体的形状（Collider）和质量分布，自动计算Rigidbody的中心点</li><li>通常质心在物体的几何中心，但加多个Collider后可能偏移</li><li>这是大多数情况下推荐的方式，因为它物理上是合理的</li></ul></li></ul><p><strong>手动设置质心</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>rb.centerOfMass = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>0</span>, -<span style=color:#ae81ff>1f</span>, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>//手动设一个偏移量</span>
</span></span></code></pre></div><blockquote><p>设置后将覆盖自动计算值，适用于如车辆、飞船平衡优化、ragdoll调整等高级用途</p></blockquote><p>可视化质心方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>void</span> OnDrawGizmo()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (rb != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Gizmos.color = Color.red;
</span></span><span style=display:flex><span>        Gizmos.DrawSphere(rb.worldCenterOfMess, <span style=color:#ae81ff>0.1f</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>为什么质心重要</strong></p><table><thead><tr><th>应用场景</th><th>影响</th></tr></thead><tbody><tr><td>飞船 / 载具</td><td>若质心偏上，容易翻车或晃动</td></tr><tr><td>摆锤 / 吊挂物体</td><td>旋转效果中心点取决于质心</td></tr><tr><td>多 Collider 组合物体</td><td>自动质心可能不在视觉中心</td></tr><tr><td>被力击打（AddForce）</td><td>力不作用在质心会引起旋转（力矩）</td></tr></tbody></table><p><strong>Automatic Tensor</strong>（自动惯性张量，默认为true）</p><p><strong>什么是Tensor</strong></p><ul><li>在物理学中，惯性张量是描述刚体如何响应旋转力（力矩）的数学结构</li><li>它是质量分布的一个三维矩阵，决定了刚体绕每个轴的旋转惯性</li><li>简单理解：惯性张量 = “旋转版的质量”</li></ul><p><strong>默认自动计算惯性张量</strong></p><ul><li>Unity默认根据物体的<code>Collider</code>形状和<code>Mass</code>自动计算惯性张量</li><li>这就是<code>Rigidbody.inertiaTensor</code>和<code>inertiaTensorRotation</code>的来源</li><li>所以刚体自然会表现出“越大越难转”“形状影响旋转惯性”等真实行为</li></ul><p><strong>手动设置惯性张量（自动覆盖）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>rb.inertiaTensor = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>//自定义旋转惯性</span>
</span></span><span style=display:flex><span>rb.inertiaTensorRotation = Quaternion.identity; <span style=color:#75715e>//张量方向</span>
</span></span></code></pre></div><p>但这样做有前提条件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>rb.ResetInertiaTensor(); <span style=color:#75715e>//可重置为自动计算值</span>
</span></span></code></pre></div><blockquote><p>设置之前你要禁用自动张量</p></blockquote><p><strong>什么情况需要自定义惯性张量</strong></p><table><thead><tr><th>应用</th><th>目的</th></tr></thead><tbody><tr><td>物理模拟器 / 实验工具</td><td>精确控制旋转行为</td></tr><tr><td>异形刚体（如飞船、复杂机器人）</td><td>人为调整旋转惯性，防止旋转太快或不稳定</td></tr><tr><td>某些游戏设计</td><td>让角色或物体转得更“重”或更“灵活”</td></tr><tr><td>制作旋转玩具 / 陀螺仪</td><td>可控惯性带来物理可玩性</td></tr></tbody></table><p><strong>运动状态设置</strong></p><table><thead><tr><th>参数</th><th>作用</th><th>默认</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>Use Gravity</strong></td><td>是否受重力影响</td><td>true</td><td>用于自由下落、角色跳跃等</td></tr><tr><td><strong>Is Kinematic</strong></td><td>是否由代码控制，不参与物理</td><td>false</td><td>静态平台、动画控制角色等</td></tr></tbody></table><p><strong>Interpolate（插值）</strong></p><table><thead><tr><th>选项</th><th>说明</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>None</strong></td><td>不插值，可能抖动</td><td>一般默认</td></tr><tr><td><strong>Interpolate</strong></td><td>使用上一帧数据进行平滑</td><td>摄像机跟随刚体时防抖动</td></tr><tr><td><strong>Extrapolate</strong></td><td>使用下一帧数据预测位置</td><td>一般不推荐，容易导致位置错误</td></tr></tbody></table><blockquote><p>插值仅影响视觉表现，不影响物理逻辑，适合处理低帧率时的视觉平滑</p></blockquote><p><strong>Collision Detection（碰撞检测模式）</strong></p><table><thead><tr><th>模式</th><th>描述</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>Discrete</strong></td><td>默认，普通对象</td><td>慢速运动、低精度要求</td></tr><tr><td><strong>Continuous</strong></td><td>防穿透</td><td>快速移动物体（如子弹）</td></tr><tr><td><strong>Continuous Dynamic</strong></td><td>防止快速刚体穿过静态物体</td><td>用于导弹、飞行物</td></tr><tr><td><strong>Continuous Speculative</strong></td><td>预测未来路径是否碰撞</td><td>用于需要超高稳定性的对象</td></tr></tbody></table><blockquote><p>连续检测会增加计算量，不建议用于大量物体</p></blockquote><p><strong>Constraints（冻结轴向）</strong>
用于锁定物体的移动或旋转，防止不受控的漂移或翻滚</p><table><thead><tr><th>选项</th><th>说明</th><th>常用组合</th></tr></thead><tbody><tr><td>Freeze Position X/Y/Z</td><td>锁定对应轴上的移动</td><td>冻住平台等静态物体</td></tr><tr><td>Freeze Rotation X/Y/Z</td><td>锁定对应轴上的旋转</td><td>防止角色倒地、车轮翻转</td></tr><tr><td>Freeze All</td><td>锁定所有轴</td><td>彻底不动，用于静态物体</td></tr></tbody></table><p><strong>Layer Overrides（图层覆盖）</strong><br>允许刚体在物理世界中临时使用不同的Layer设置进行碰撞和检测计算，不会影响物体本身的Layer<br>影响范围：物理模拟（碰撞、Raycast、Force、Overlap等），不会影响渲染、标签识别、脚本逻辑</p><ul><li>Include Layers<ul><li>表示允许此刚体与哪些Layer的对象发生物理交互</li><li>这实质上是一个LayerMask</li></ul></li><li>Exclude Layers<ul><li>表示在物理交互中忽略的Layer</li></ul></li></ul><blockquote><p>Exclude Layers优先于Include Layers</p></blockquote><h2 id=rigidbody常见用法>Rigidbody常见用法：</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Rigidbody rb = GetComponent&lt;Rigidbody&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rb.AddForce(Vector3.forward * <span style=color:#ae81ff>10f</span>); <span style=color:#75715e>//施加一个向前的力</span>
</span></span><span style=display:flex><span>rb.AddTorque(Vector3.up * <span style=color:#ae81ff>5f</span>); <span style=color:#75715e>//添加一个旋转力</span>
</span></span><span style=display:flex><span>rb.MovePosition(newPos); <span style=color:#75715e>//平滑低移动Rigidbody</span>
</span></span><span style=display:flex><span>rb.velocity = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>//设置线速度</span>
</span></span></code></pre></div><h3 id=iskinematic-和-非-kinematic>isKinematic 和 非 Kinematic</h3><ul><li><code>isKinematic = false</code>（默认）：受物理引擎控制（例如重力、碰撞、AddForce）</li><li><code>isKinematic = true</code>：完全由你控制<code>transform</code>或<code>MovePosition()</code>，不会被物理引擎影响</li></ul><p>用途：</p><ul><li>Kinematic常用于移动平台、动画角色骨骼、摄像机跟随等</li></ul><h3 id=rigidbody-vs-transform控制>Rigidbody vs Transform控制</h3><p><strong>不要在有Rigidbody的物体上直接用<code>transform.position += ...</code>来移动，这会跳过物理系统，导致碰撞问题</strong></p><p>正确做法：</p><ul><li>用<code>Rigidbody.MovePosition()</code>移动</li><li>或使用<code>AddForce()</code>、<code>velocity</code>等物理方式</li></ul><p>问题本质：
在Unity中，Rigidbody是由物理系统控制的，一旦你给GameObject添加了Rigidbody，它的位置和旋转应该只通过物理系统来控制。</p><p>使用<code>transform.position += ...</code>会出现的问题</p><table><thead><tr><th>问题</th><th>说明</th></tr></thead><tbody><tr><td><strong>绕过物理引擎</strong></td><td><code>transform.position += ...</code> 是<strong>立即改变 Transform 的位置</strong>，Unity 物理系统（PhysX）对此毫不知情</td></tr><tr><td><strong>不会产生碰撞检测</strong></td><td>物体“穿越”其他碰撞体而不产生物理响应（穿模）</td></tr><tr><td><strong>不会产生力或速度变化</strong></td><td><code>Rigidbody.velocity</code> 不会更新，你也不能检测运动趋势</td></tr><tr><td><strong>打乱内部物理状态</strong></td><td>会破坏 Rigidbody 的睡眠状态、插值、运动预测等机制，造成 jitter（抖动）或奇怪弹跳</td></tr><tr><td><strong>失去重力/摩擦等作用</strong></td><td>物体移动但没有物理感，导致操作不自然</td></tr></tbody></table><p>只有在以下三种情况中可以使用<code>transform.position</code>:<br>1.没有<code>Rigidbody</code>的对象（纯UI/特效/场景物体）</p><p>2.临时调整位置，如传送、重置</p><p>3.<code>isKinematic = true</code></p><h3 id=示例角色控制器使用rigidbody>示例：角色控制器使用Rigidbody</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PlayerMovement</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> speed = <span style=color:#ae81ff>5f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Rigidbody rb;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Start() =&gt; rb = GetComponent&lt;Rigidbody&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> FixedUpdate()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> h = Input.GetAxis(<span style=color:#e6db74>&#34;Horizontal&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> v = Input.GetAxis(<span style=color:#e6db74>&#34;Vertical&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Vector3 move = <span style=color:#66d9ef>new</span> Vector3(h, <span style=color:#ae81ff>0</span>, v);
</span></span><span style=display:flex><span>        rb.MovePosition(rb.position + move * speed * Time.fixedDeltaTime);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=物理力应用的类型>物理力应用的类型</h2><p>Unity提供了多种物理力应用方式，你可以根据物理效果需求选择合适的模式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>rb.AddForce(Vector3.force, ForceMode.Force);
</span></span></code></pre></div><table><thead><tr><th>ForceMode</th><th>作用</th><th>适用场景</th></tr></thead><tbody><tr><td><code>Force</code></td><td>持续施加力（受质量影响）</td><td>模拟发动机、风力等持续力</td></tr><tr><td><code>Impulse</code></td><td>瞬时冲量（受质量影响）</td><td>子弹击中、跳跃、爆炸推动</td></tr><tr><td><code>VelocityChange</code></td><td>改变速度（忽略质量）</td><td>快速位移、瞬间反弹</td></tr><tr><td><code>Acceleration</code></td><td>施加加速度（不受质量影响）</td><td>飞行器推进、不考虑质量时</td></tr></tbody></table><h2 id=爆炸力addexplosionforce>爆炸力：<code>AddExplosionForce</code></h2><p>模拟爆炸冲击力，自动考虑距离衰减和力方向</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>rb.AddExplosionForce(force, explosionPosition, radius, upwardsModifier);
</span></span></code></pre></div><ul><li><code>force</code>:爆炸的最大力</li><li><code>explosionPosition</code>:爆炸中心</li><li><code>radius</code>:爆炸影响范围</li><li><code>upwardsModifier</code>:向上的推力（可增强爆炸效果）</li></ul><h2 id=rigidbody-constraints锁定轴向>Rigidbody Constraints（锁定轴向）</h2><p>锁定位置或旋转，常用于平台类游戏角色防止翻滚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>rb.constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ;
</span></span></code></pre></div><ul><li><code>FreezePositionX/Y/Z</code></li><li><code>FreezeRotationX/Y/Z</code></li><li><code>FreezeAll</code></li></ul><h2 id=rigidbody-interpolation插值>Rigidbody Interpolation（插值）</h2><p>用于缓解物体抖动或物理更新频率和渲染帧率不一致的问题<br>插值实在渲染帧之间平滑显示刚体位置或旋转，防止因物理更新滞后造成的抖动或卡顿</p><blockquote><p>渲染帧和物理帧
在Unity游戏循环中，渲染帧（Update）和物理帧（Fixed Update）是分开的
渲染帧率和物理帧率可能不同，这样一来，在两次物理更新之间可能要渲染一次或多次画面，此时刚体的位置还没更新，就会导致物体“跳跃”，摄像机跟随刚体时抖动</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>rb.interpolation = RigidbodyInterpolation.Interpolate;
</span></span></code></pre></div><table><thead><tr><th>插值类型</th><th>描述</th></tr></thead><tbody><tr><td>None</td><td>不插值，最性能优先</td></tr><tr><td>Interpolate</td><td>插值上一次位置</td></tr><tr><td>Extrapolate</td><td>预测下一帧位置</td></tr></tbody></table><p>适用于：摄像机跟随物体 + Rigidbody，平滑动画等</p><p><strong>插值不是同步手段</strong><br>插值只影响视觉显示，不影响实际物理行为或碰撞检测</p><h2 id=rigidbody连接joint系统>Rigidbody连接（Joint系统）</h2><p>Unity提供了多个<code>Joint</code>来连接两个Rigidbody，来实现机械、吊挂、弹簧等效果</p><p>常用Joint类型</p><table><thead><tr><th>Joint 类型</th><th>功能</th><th>应用</th></tr></thead><tbody><tr><td><code>FixedJoint</code></td><td>完全绑定两个刚体</td><td>构建刚性结构</td></tr><tr><td><code>HingeJoint</code></td><td>像门铰链一样旋转</td><td>车轮、门</td></tr><tr><td><code>SpringJoint</code></td><td>模拟弹簧连接</td><td>弹簧、绳索末端</td></tr><tr><td><code>ConfigurableJoint</code></td><td>自定义约束自由度</td><td>高级物理装置</td></tr><tr><td><code>CharacterJoint</code></td><td>模拟人体骨骼</td><td>人物 ragdoll</td></tr></tbody></table><p><strong>示例：固定一个物体</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> joint = gameObject.AddComponent&lt;FixedJoint&gt;();
</span></span><span style=display:flex><span>joint.connectedBody = otherRigidbody;
</span></span></code></pre></div><h2 id=刚体时间管理>刚体时间管理</h2><p>你可以临时控制刚体行为。例如冻结、暂停、缓动</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>rb.isKinematic = <span style=color:#66d9ef>true</span>; <span style=color:#75715e>// 暂停物理影响</span>
</span></span><span style=display:flex><span>rb.detectCollisions = <span style=color:#66d9ef>false</span>; <span style=color:#75715e>//禁用碰撞响应</span>
</span></span><span style=display:flex><span>rb.Sleep(); <span style=color:#75715e>//进入“休眠”状态，除非外力唤醒</span>
</span></span><span style=display:flex><span>rb.WakeUp(); <span style=color:#75715e>//强制唤醒</span>
</span></span></code></pre></div><h2 id=手动模拟物理少见但强大>手动模拟物理（少见但强大）</h2><p>Unity默认每帧自动调用<code>Physics.Simulate()</code>，你可以关闭自动模拟并手动调用它</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Physics.autoSimulation = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>Physics.Simulate(Time.fixedDeltaTime);
</span></span></code></pre></div><p>用于录制、回放、预测系统、AI训练等</p><h2 id=实践建议>实践建议</h2><h3 id=1性能优化>1.性能优化</h3><ul><li>尽量使用<code>MovePosition</code>和<code>MoveRotation</code>代替直接设置<code>transform</code></li><li>使用<code>Rigidbody.Sleep()</code>来节省性能，尤其是大量静态物体</li></ul><h3 id=2碰撞过滤>2.碰撞过滤</h3><ul><li>使用<code>Layer</code> + <code>Physics.IngoreCollision()</code>或<code>Physics.IgnoreLayerCollision()</code>控制碰撞逻辑</li></ul><h3 id=3组合joint>3.组合Joint</h3><ul><li>复杂角色物理（如ragdoll）可通过多个Joint配合约束自由度实现真实物理表现</li></ul><h3 id=4多刚体组合>4.多刚体组合</h3><ul><li>使用空物体为父物体挂多个子物体加不同Rigidbody，用<code>Joint</code>连接</li></ul><h2 id=刚体不能直接禁用>刚体不能直接禁用</h2><h3 id=1刚体不是一个标准行为组件>1.刚体不是一个标准行为组件</h3><ul><li>Unity中大多数组件都继承自<code>Behaviour</code>类，这类组件有一个通用的enable属性</li><li>但Rigidbody继承自<code>Component</code>，因此没有<code>enable</code>属性4</li></ul><h3 id=2rigidbody是物理系统的一部分关闭它的逻辑很复杂>2.Rigidbody是物理系统的一部分，关闭它的逻辑很复杂</h3><p>Unity的Rigidbody是底层物理引擎（NVIDIA PhysX）注册的一个刚体对象，它包含大量复杂的状态（如质量、速度、力、碰撞状态等），不能简单“关掉”</p><p>如果允许直接<code>enabled = false</code>，Unity就得把它从物理世界中注销，可能会导致：</p><ul><li>打乱碰撞检测状态</li><li>丢失动力学状态</li><li>导致其他与之交互的刚体行为出错</li></ul><p>替代方法：</p><table><thead><tr><th>方法</th><th>效果</th><th>场景</th></tr></thead><tbody><tr><td><code>rb.isKinematic = true</code></td><td>不再受物理引擎驱动</td><td>暂停物理交互，但可以通过 transform 控制</td></tr><tr><td><code>rb.detectCollisions = false</code></td><td>不再检测碰撞</td><td>让它“穿透”其他物体</td></tr><tr><td><code>rb.Sleep()</code></td><td>让刚体进入休眠</td><td>减少物理计算开销</td></tr><tr><td><code>Destroy(rb)</code></td><td>彻底移除刚体</td><td>完全不再参与物理</td></tr></tbody></table><h2 id=rigidbody-api><code>Rigidbody</code> API</h2><h3 id=常用字段属性>常用字段/属性</h3><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>mass</code></td><td><code>float</code></td><td>质量（默认 1）</td></tr><tr><td><code>drag</code></td><td><code>float</code></td><td>线性阻力</td></tr><tr><td><code>angularDrag</code></td><td><code>float</code></td><td>角阻力</td></tr><tr><td><code>useGravity</code></td><td><code>bool</code></td><td>是否启用重力</td></tr><tr><td><code>isKinematic</code></td><td><code>bool</code></td><td>是否受物理引擎影响</td></tr><tr><td><code>velocity</code></td><td><code>Vector3</code></td><td>当前线速度</td></tr><tr><td><code>angularVelocity</code></td><td><code>Vector3</code></td><td>当前角速度</td></tr><tr><td><code>position</code></td><td><code>Vector3</code></td><td>世界空间位置</td></tr><tr><td><code>rotation</code></td><td><code>Quaternion</code></td><td>世界旋转</td></tr><tr><td><code>centerOfMass</code></td><td><code>Vector3</code></td><td>质心位置</td></tr><tr><td><code>inertiaTensor</code></td><td><code>Vector3</code></td><td>惯性张量</td></tr><tr><td><code>constraints</code></td><td><code>RigidbodyConstraints</code></td><td>锁定移动或旋转轴</td></tr><tr><td><code>interpolation</code></td><td><code>RigidbodyInterpolation</code></td><td>插值方式</td></tr><tr><td><code>collisionDetectionMode</code></td><td><code>CollisionDetectionMode</code></td><td>碰撞检测模式</td></tr></tbody></table><h3 id=常用方法控制移动施加力>常用方法（控制移动、施加力）</h3><h4 id=施加力的方法力学模拟>施加力的方法（力学模拟）</h4><table><thead><tr><th>方法</th><th>描述</th><th>常用参数说明</th></tr></thead><tbody><tr><td><code>AddForce(Vector3 force, ForceMode mode = ForceMode.Force)</code></td><td>向刚体施加一个世界空间的力</td><td>- <code>ForceMode</code> 可选：<code>Force</code>, <code>Impulse</code>, <code>Acceleration</code>, <code>VelocityChange</code></td></tr><tr><td><code>AddRelativeForce(Vector3 force, ForceMode mode = ForceMode.Force)</code></td><td>向刚体施加一个<strong>相对于自身方向</strong>的力</td><td>用于局部方向推进，如飞船、角色局部移动</td></tr><tr><td><code>AddTorque(Vector3 torque, ForceMode mode = ForceMode.Force)</code></td><td>添加一个旋转力（转矩）</td><td>控制刚体的旋转，比如陀螺仪效果</td></tr><tr><td><code>AddRelativeTorque(Vector3 torque, ForceMode mode = ForceMode.Force)</code></td><td>添加一个<strong>相对坐标</strong>的转矩</td><td>以自身坐标轴方向旋转</td></tr><tr><td><code>AddExplosionForce(float force, Vector3 position, float radius, float upwardsModifier = 0.0f, ForceMode mode = ForceMode.Force)</code></td><td>模拟爆炸力</td><td>常用于爆炸、炸飞物体等效果</td></tr></tbody></table><h4 id=移动与旋转物理友好方式>移动与旋转（物理友好方式）</h4><p>这些方法在<code>FixedUpdate()</code>中调用，以物理方式平滑移动对象</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>MovePosition(Vector3 position)</code></td><td>让刚体以物理方式移动到某位置（会产生碰撞）</td></tr><tr><td><code>MoveRotation(Quaternion rot)</code></td><td>让刚体以物理方式旋转到目标旋转角度</td></tr></tbody></table><blockquote><p>不要使用transform.position = &mldr; 替代移动刚体，会破坏物理系统</p></blockquote><h4 id=状态控制>状态控制</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Sleep()</code></td><td>让刚体休眠（不再进行物理更新，除非唤醒）</td></tr><tr><td><code>WakeUp()</code></td><td>唤醒休眠的刚体</td></tr><tr><td><code>IsSleeping()</code></td><td>检查当前是否处于休眠状态</td></tr></tbody></table><h4 id=速度与点速度获取>速度与点速度获取</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>GetPointVelocity(Vector3 worldPoint)</code></td><td>获取世界空间中某一点的实际速度</td></tr><tr><td><code>GetRelativePointVelocity(Vector3 relativePoint)</code></td><td>获取某个相对位置的速度（少用）</td></tr></tbody></table><h3 id=状态检测与设置>状态检测与设置</h3><table><thead><tr><th>方法 / 属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>IsSleeping()</code></td><td><code>bool</code></td><td>当前是否休眠</td></tr><tr><td><code>detectCollisions</code></td><td><code>bool</code></td><td>是否响应碰撞</td></tr><tr><td><code>maxDepenetrationVelocity</code></td><td><code>float</code></td><td>最大穿透修正速度（用于防止卡住）</td></tr><tr><td><code>solverIterations</code></td><td><code>int</code></td><td>物理求解器迭代次数（越高越精准）</td></tr><tr><td><code>sleepThreshold</code></td><td><code>float</code></td><td>控制何时休眠</td></tr></tbody></table><h3 id=高级设置>高级设置</h3><table><thead><tr><th>属性 / 方法</th><th>说明</th></tr></thead><tbody><tr><td><code>inertiaTensorRotation</code></td><td>惯性张量旋转</td></tr><tr><td><code>maxAngularVelocity</code></td><td>最大角速度</td></tr><tr><td><code>centerOfMass</code></td><td>自定义质心位置</td></tr><tr><td><code>ResetCenterOfMass()</code></td><td>重置为默认质心</td></tr><tr><td><code>ResetInertiaTensor()</code></td><td>重置惯性张量</td></tr></tbody></table><h3 id=与collider配合相关>与Collider配合相关</h3><p>Rigidbody本身不处理碰撞细节，但需配合<code>Collider</code>组件才能参与物理交互</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>ClosestPointOnBounds(Vector3 position)</code></td><td>获取边界上最接近某点的位置</td></tr><tr><td><code>SweepTest(Vector3 direction, out RaycastHit hit, float maxDistance)</code></td><td>模拟刚体沿方向运动是否会撞到东西</td></tr><tr><td><code>SweepTestAll(...)</code></td><td>返回所有碰撞信息</td></tr><tr><td><code>GetRelativePointVelocity(Vector3 relativePoint)</code></td><td>获取某点相对速度</td></tr><tr><td><code>GetPointVelocity(Vector3 worldPoint)</code></td><td>获取世界空间下某点速度</td></tr></tbody></table><p><strong><a href=https://docs.unity3d.com/ScriptReference/Rigidbody.html>Unity官方文档（Rigidbody）</a></strong></p></div><nav class=post-nav><a href=/blog/probability-and-randomness-in-games/ class=hover:underline>pre: Probability and Randomness in Games</a>
<a href=/blog/scene-system/ class=hover:underline>next: Scene System</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#rigidbody的基本功能>Rigidbody的基本功能</a><ul><li><a href=#rigidbodypanel>RigidbodyPanel</a></li></ul></li><li><a href=#rigidbody常见用法>Rigidbody常见用法：</a><ul><li><a href=#iskinematic-和-非-kinematic>isKinematic 和 非 Kinematic</a></li><li><a href=#rigidbody-vs-transform控制>Rigidbody vs Transform控制</a></li><li><a href=#示例角色控制器使用rigidbody>示例：角色控制器使用Rigidbody</a></li></ul></li><li><a href=#物理力应用的类型>物理力应用的类型</a></li><li><a href=#爆炸力addexplosionforce>爆炸力：<code>AddExplosionForce</code></a></li><li><a href=#rigidbody-constraints锁定轴向>Rigidbody Constraints（锁定轴向）</a></li><li><a href=#rigidbody-interpolation插值>Rigidbody Interpolation（插值）</a></li><li><a href=#rigidbody连接joint系统>Rigidbody连接（Joint系统）</a></li><li><a href=#刚体时间管理>刚体时间管理</a></li><li><a href=#手动模拟物理少见但强大>手动模拟物理（少见但强大）</a></li><li><a href=#实践建议>实践建议</a><ul><li><a href=#1性能优化>1.性能优化</a></li><li><a href=#2碰撞过滤>2.碰撞过滤</a></li><li><a href=#3组合joint>3.组合Joint</a></li><li><a href=#4多刚体组合>4.多刚体组合</a></li></ul></li><li><a href=#刚体不能直接禁用>刚体不能直接禁用</a><ul><li><a href=#1刚体不是一个标准行为组件>1.刚体不是一个标准行为组件</a></li><li><a href=#2rigidbody是物理系统的一部分关闭它的逻辑很复杂>2.Rigidbody是物理系统的一部分，关闭它的逻辑很复杂</a></li></ul></li><li><a href=#rigidbody-api><code>Rigidbody</code> API</a><ul><li><a href=#常用字段属性>常用字段/属性</a></li><li><a href=#常用方法控制移动施加力>常用方法（控制移动、施加力）</a><ul><li><a href=#施加力的方法力学模拟>施加力的方法（力学模拟）</a></li><li><a href=#移动与旋转物理友好方式>移动与旋转（物理友好方式）</a></li><li><a href=#状态控制>状态控制</a></li><li><a href=#速度与点速度获取>速度与点速度获取</a></li></ul></li><li><a href=#状态检测与设置>状态检测与设置</a></li><li><a href=#高级设置>高级设置</a></li><li><a href=#与collider配合相关>与Collider配合相关</a></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>