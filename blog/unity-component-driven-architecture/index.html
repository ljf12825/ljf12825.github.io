<!doctype html><html lang=en><head><meta charset=UTF-8><title>Unity Component-Driven Architecture</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Unity Component-Driven Architecture" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Unity Component-Driven Architecture<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>Unity是如何驱动组件系统的</p><p>从<strong>运行架构</strong>、<strong>组件调度机制</strong>、<strong>底层实现</strong>三个方面来深度剖析</p><h3 id=unity的运行架构经典gameobject-component模型>Unity的运行架构（经典GameObject-Component模型）</h3><p>Unity引擎的架构是 <strong>“组合优于继承”</strong> 的典范：</p><ul><li><code>GameObject</code>：游戏世界中所有对象的容器</li><li><code>Component</code>：挂在GameObject上的功能模块</li><li><code>MonoBehaviour</code>：Unity脚本组件的基类，支持生命周期函数</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>//伪代码结构</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameObject</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    List&lt;Component&gt; components;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Component</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    GameObject gameObject;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=unity是如何调度组件的生命周期的>Unity是如何调度组件的生命周期的</h2><p>Unity在每一帧都会按以下顺序做一次组件调度遍历：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>For ever active GameObject:
</span></span><span style=display:flex><span>    For every enable Component:
</span></span><span style=display:flex><span>        If first frame:
</span></span><span style=display:flex><span>            Call Awake()
</span></span><span style=display:flex><span>            Call Start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Run physics:
</span></span><span style=display:flex><span>        Call FixedUpdate()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Handle rendering:
</span></span><span style=display:flex><span>        Transform -&gt; Camera -&gt; Renderer
</span></span></code></pre></div><ul><li>Unity引擎内部有个巨大的函数表（或反射表），知道哪些组件实现了哪些生命周期函数</li><li>每一帧自动去“调用你实现的函数”</li><li>C++内部利用RTTI或IL2CPP编译出的函数表映射进行调用</li></ul><h2 id=底层实现机制>底层实现机制</h2><h3 id=在mono引擎早期或il2cpp编译后>在Mono引擎（早期）或IL2CPP编译后</h3><ul><li>Unity会扫描所有<code>MonoBehaviour</code>脚本的继承结构和成员函数</li><li>使用反射或JIT（Mono）或AOT（IL2CPP）建立生命周期函数映射</li><li>每帧调用<code>Update()</code>时并不是逐个判断字符串，而是已建立了对应的“执行列表”</li></ul><blockquote><p>IL2CPP模式下，C#代码会被编译成C++，再编译成机器码，性能更好，但调试难</p></blockquote><h2 id=unity怎么知道你挂了什么组件>Unity怎么知道你挂了什么组件</h2><p>每个GameObject内部维护了一个组件列表（通常是数组或链表），每个组件记录自己类型，并且Unity会为常见组件使用缓存优化</p><ul><li><code>GetComponent&lt;T>()</code>实际上会进行：<ul><li>查缓存</li><li>缓存没有就遍历组件数组</li><li>找到就缓存下来，下次加速</li></ul></li></ul><h2 id=unity-gameobject--component的底层存储结构>Unity <code>GameObject</code> + <code>Component</code>的底层存储结构</h2><p>GameObject + Component架构时Unity的核心数据结构<br>大致如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Scene
</span></span><span style=display:flex><span> └── GameObjects (树状结构)
</span></span><span style=display:flex><span>      ├── GameObject A
</span></span><span style=display:flex><span>      │     ├── Transform (每个 GameObject 必有)
</span></span><span style=display:flex><span>      │     ├── MeshRenderer
</span></span><span style=display:flex><span>      │     ├── BoxCollider
</span></span><span style=display:flex><span>      │     └── MyScript (MonoBehaviour)
</span></span><span style=display:flex><span>      └── GameObject B
</span></span><span style=display:flex><span>            └── Transform
</span></span></code></pre></div><p>在内存中的布局</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>[GameObject]
</span></span><span style=display:flex><span> ├─ Name: &#34;Enemy&#34;
</span></span><span style=display:flex><span> ├─ Tag: &#34;Enemy&#34;
</span></span><span style=display:flex><span> ├─ Active: true
</span></span><span style=display:flex><span> ├─ Component[] --&gt; 指向一组组件
</span></span><span style=display:flex><span> │    ├─ [0] Transform*
</span></span><span style=display:flex><span> │    ├─ [1] MeshRenderer
</span></span><span style=display:flex><span> │    ├─ [2] MyScript : MonoBehaviour
</span></span><span style=display:flex><span> └─ SceneNode / Parent / Children 等关系信息
</span></span></code></pre></div><ul><li>所有组件都存储在一个 <strong>Component列表（数组/链表）</strong> 中</li><li><code>Transform</code>总是第一个组件（内置逻辑保证）</li><li>每个<code>Component</code>内部都有一个指向所属<code>GameObject</code>的反向引用</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameObject</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Component<span style=color:#f92672>*&gt;</span> components;
</span></span><span style=display:flex><span>    Transform<span style=color:#f92672>*</span> transform;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=gameobject-与-component>GameObject 与 Component</h2><blockquote><p>一个GameObject本身只是一个空壳，组件赋予它行为和外观</p></blockquote><p>每个GameObject都至少由这三个组件（不可移除）：</p><ul><li>Transform</li><li>Tag</li><li>Layer</li></ul><p>此外可以向GameObject添加任意数量的组件</p><p>每个组件就是一块插件，GameObject就像是空机壳，插上不同“模块”就有不同功能</p><p>Unity中组件影响GameObject的底层原理涉及到引擎的架构设计，主要是基于ECS的理念，虽然MonoBehaviour不是纯ECS，但是思想相近</p><p>在底层， Unity的架构可以简化成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#a6e22e>GameObject</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>实体（Entity）</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Component</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>数据 + 行为</span>
</span></span></code></pre></div><h3 id=gameobject本身>GameObject本身</h3><ul><li>是一个空容器，并不做事</li><li>只持有一个Transform</li><li>它维护一个组件列表（Component List）</li></ul><h3 id=当添加组件时>当添加组件时</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>gameObject.AddComponent&lt;Rigidbody&gt;();
</span></span></code></pre></div><p>Unity引擎底层会：
<strong>1.分配内存：在C++层面为<code>Rigidbody</code>组件实例分配空间</strong></p><p><strong>2.注册行为：将这个组件加入到<code>GameObject</code>的组件列表中</strong></p><p><strong>3.标记更新：将这个GameObject添加到物理系统更新队列中</strong></p><p><strong>4.启用生命周期函数</strong></p><h3 id=行为生效>行为生效</h3><p>Unity引擎每帧进行如下操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>for each GameObject:
</span></span><span style=display:flex><span>    for each Component in GameObject:
</span></span><span style=display:flex><span>        if Component.enabled:
</span></span><span style=display:flex><span>            Call Component.Update() / Render() / PhysicsStep()
</span></span></code></pre></div><p>具体到组件类型：</p><table><thead><tr><th>组件类型</th><th>引擎系统</th><th>调用方式</th></tr></thead><tbody><tr><td><code>MonoBehaviour</code></td><td>脚本系统</td><td><code>Update()</code>、<code>FixedUpdate()</code></td></tr><tr><td><code>Rigidbody</code></td><td>物理系统（PhysX）</td><td>每帧物理步计算</td></tr><tr><td><code>Renderer</code></td><td>渲染系统（Graphics）</td><td>每帧调用 GPU 绘制命令</td></tr><tr><td><code>Collider</code></td><td>碰撞系统</td><td>注册到空间分区中</td></tr><tr><td><code>AudioSource</code></td><td>音频系统</td><td>发出 PCM 数据到音频设备</td></tr></tbody></table><h3 id=unity引擎背后的底层结构简化>Unity引擎背后的底层结构（简化）</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scss data-lang=scss><span style=display:flex><span><span style=color:#f92672>GameObject</span> <span style=color:#f92672>(</span><span style=color:#f92672>C</span>#层 <span style=color:#f92672>wrapper</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>└─</span> <span style=color:#f92672>native</span> <span style=color:#f92672>GameObject</span> <span style=color:#f92672>(</span><span style=color:#f92672>C</span><span style=color:#f92672>++</span><span style=color:#f92672>层</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>       <span style=color:#960050;background-color:#1e0010>├──</span> <span style=color:#f92672>Transform</span>
</span></span><span style=display:flex><span>       <span style=color:#960050;background-color:#1e0010>├──</span> <span style=color:#f92672>Component</span><span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>       <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>├──</span> <span style=color:#f92672>MonoBehaviour</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#f92672>C</span>#脚本<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>       <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>├──</span> <span style=color:#f92672>Renderer</span>
</span></span><span style=display:flex><span>       <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>├──</span> <span style=color:#f92672>Rigidbody</span>
</span></span><span style=display:flex><span>       <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#960050;background-color:#1e0010>└──</span> <span style=color:#a6e22e>...</span>
</span></span></code></pre></div><p>Unity通过“托管桥接机制（Managed to Native Binding）”来让C#脚本和底层C++引擎通讯</p><h2 id=unity中生命周期函数的调度机制>Unity中生命周期函数的调度机制</h2><h3 id=per-frame>Per Frame</h3><p>Unity的C++引擎内部维护了一套复杂的调度系统，它在每帧中会依次完成：</p><ul><li>处理输入事件</li><li>调用<code>MonoBehaviour.Update()</code>等函数</li><li>执行物理模拟</li><li>渲染准备</li><li>真正渲染</li></ul><h3 id=调用过程以update为例>调用过程（以Update()为例）</h3><p>**关键逻辑：Unity会在引擎启动时反射出所有含有Update()的脚本，并构建函数调度表（Invocation List）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Startup:
</span></span><span style=display:flex><span>|___MonoScript Scanning（扫描所有脚本）
</span></span><span style=display:flex><span>       |___找出哪些脚本实现了Update()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Runtime 每帧：
</span></span><span style=display:flex><span>|___遍历Update列表
</span></span><span style=display:flex><span>        |___调用脚本.Update()
</span></span></code></pre></div><blockquote><p>这个调度是Unity内部用C++写的调度器来完成的，不是C#代码自己管自己的调用</p></blockquote><h3 id=il2cpp行为>IL2CPP行为</h3><p>当你开启IL2CPP编译</p><ul><li>所有C#代码都会被编译成IL</li><li>Unity的IL2CPP工具将IL转成CXX</li><li>然后统一编译为Native Binary</li></ul><p><strong>以Update()为例</strong>
最终会变成：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>PlayerMove_Update</span>(MonoBehaviour<span style=color:#f92672>*</span> <span style=color:#66d9ef>this</span>) {}
</span></span></code></pre></div><blockquote><p>Unity引擎内核就可以直接调用这个C++函数，避免了反射调用，提高性能</p></blockquote><h2 id=unity启动流程>Unity启动流程</h2><h3 id=0平台入口本地程序启动>0.平台入口：本地程序启动</h3><table><thead><tr><th>平台</th><th>实际入口函数</th></tr></thead><tbody><tr><td>Windows</td><td><code>main()</code> 或 <code>WinMain()</code>（由 <code>UnityPlayer.dll</code> 调用）</td></tr><tr><td>Android</td><td><code>android_main()</code>（JNI 进入 <code>libunity.so</code>）</td></tr><tr><td>iOS</td><td><code>UIApplicationMain()</code>（Objective-C）</td></tr><tr><td>WebGL</td><td><code>Module.main()</code>（JavaScript/wasm）</td></tr></tbody></table><p>这些都在C++写的引擎底层里，不可见且无法修改</p><h3 id=1引擎初始化阶段>1.引擎初始化阶段</h3><table><thead><tr><th>步骤</th><th>内容</th></tr></thead><tbody><tr><td>加载配置</td><td>读取 PlayerSettings、Graphics API、质量设置等</td></tr><tr><td>初始化子系统</td><td>渲染器、输入系统、物理引擎、音频系统等</td></tr><tr><td>初始化脚本引擎</td><td>启动 Mono 或 IL2CPP 虚拟机</td></tr><tr><td>加载资源管理系统</td><td>AssetBundle / Resources 等</td></tr><tr><td>加载启动场景</td><td>SceneManager 加载 Build Settings 中第一个 Scene</td></tr></tbody></table><h3 id=2场景加载后-创建gameobjectcomponent实例>2.场景加载后-创建GameObject/Component实例</h3><p>加载场景时：</p><ul><li>逐个读取GameObejct</li><li>为每个GameObject绑定组件</li><li>为挂载了<code>MonoBehaviour</code>的对象创建托管对象实例（C#）</li></ul><h3 id=3生命周期调用顺序首次>3.生命周期调用顺序（首次）</h3><p>Unity中的生命周期调度系统，每帧按照生命周期函数顺序依次调用</p><h3 id=4游戏循环开始每帧>4.游戏循环开始（每帧）</h3><p>Unity内部引擎每帧执行以下大致顺序：</p><table><thead><tr><th>顺序</th><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>Input Update</td><td>处理键鼠、触摸、手柄输入</td></tr><tr><td>2</td><td><code>Update()</code></td><td>调用所有激活脚本的 <code>Update()</code>（每帧）</td></tr><tr><td>3</td><td>动画更新</td><td>Animator 执行动画播放</td></tr><tr><td>4</td><td>物理模拟</td><td><code>FixedUpdate()</code> 调用 + Rigidbody 计算</td></tr><tr><td>5</td><td><code>LateUpdate()</code></td><td>通常用于摄像机跟随等逻辑</td></tr><tr><td>6</td><td>渲染准备</td><td>剔除、光照、材质、阴影计算等</td></tr><tr><td>7</td><td>渲染提交</td><td>图像渲染到屏幕，执行 UI、特效等</td></tr><tr><td>8</td><td><code>OnGUI()</code></td><td>Unity GUI 系统（少用）</td></tr><tr><td>9</td><td>PostProcessing</td><td>后期处理：Bloom、HDR、MotionBlur</td></tr></tbody></table><h3 id=5脚本执行机制mono-vs-il2cpp>5.脚本执行机制（Mono vs IL2CPP）</h3><h4 id=mono模式editor-或-dev-build>Mono模式（Editor 或 Dev Build）</h4><ul><li>每个脚本是托管C#类，由Mono VM动态加载与反射调用</li><li>优点：调试快，热重载方便</li><li>缺点：性能差，函数调度慢</li></ul><h4 id=il2cpp模式正式发布时>IL2CPP模式（正式发布时）</h4><ul><li>Unity构建时将C#脚本编译为C++源码 -> 原始代码</li><li>所有<code>Update()</code>、<code>Awake()</code>变成真正的C++函数</li><li>优点：性能极高、无法反编译</li><li>缺点：编译慢，不支持热重载</li></ul><h2 id=unity-ecs新架构entity-component-system>Unity ECS（新架构：Entity-Component-System）</h2><p>传统GameObject模式虽然灵活，但性能瓶颈明显（组件查找慢、缓存不友好）<br>Unity推出的ECS（DOTS）架构更接近底层系统编程</p><table><thead><tr><th>架构元素</th><th>作用</th></tr></thead><tbody><tr><td><code>Entity</code></td><td>轻量 ID，不是 GameObject，零开销。</td></tr><tr><td><code>Component</code></td><td>纯数据结构（无逻辑），类似 C struct。</td></tr><tr><td><code>System</code></td><td>控制逻辑，处理所有符合条件的 Entity+Component 数据。</td></tr></tbody></table><blockquote><p>ECS通过内存连续布局 + SIMD + JobSystem实现了超高性能</p></blockquote></div><nav class=post-nav><a href=/blog/unity-component-communication/ class=hover:underline>pre: Unity Component Communication</a>
<a href=/blog/unity-debug/ class=hover:underline>next: Unity Debug</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#unity的运行架构经典gameobject-component模型>Unity的运行架构（经典GameObject-Component模型）</a></li></ul></li><li><a href=#unity是如何调度组件的生命周期的>Unity是如何调度组件的生命周期的</a></li><li><a href=#底层实现机制>底层实现机制</a><ul><li><a href=#在mono引擎早期或il2cpp编译后>在Mono引擎（早期）或IL2CPP编译后</a></li></ul></li><li><a href=#unity怎么知道你挂了什么组件>Unity怎么知道你挂了什么组件</a></li><li><a href=#unity-gameobject--component的底层存储结构>Unity <code>GameObject</code> + <code>Component</code>的底层存储结构</a></li><li><a href=#gameobject-与-component>GameObject 与 Component</a><ul><li><a href=#gameobject本身>GameObject本身</a></li><li><a href=#当添加组件时>当添加组件时</a></li><li><a href=#行为生效>行为生效</a></li><li><a href=#unity引擎背后的底层结构简化>Unity引擎背后的底层结构（简化）</a></li></ul></li><li><a href=#unity中生命周期函数的调度机制>Unity中生命周期函数的调度机制</a><ul><li><a href=#per-frame>Per Frame</a></li><li><a href=#调用过程以update为例>调用过程（以Update()为例）</a></li><li><a href=#il2cpp行为>IL2CPP行为</a></li></ul></li><li><a href=#unity启动流程>Unity启动流程</a><ul><li><a href=#0平台入口本地程序启动>0.平台入口：本地程序启动</a></li><li><a href=#1引擎初始化阶段>1.引擎初始化阶段</a></li><li><a href=#2场景加载后-创建gameobjectcomponent实例>2.场景加载后-创建GameObject/Component实例</a></li><li><a href=#3生命周期调用顺序首次>3.生命周期调用顺序（首次）</a></li><li><a href=#4游戏循环开始每帧>4.游戏循环开始（每帧）</a></li><li><a href=#5脚本执行机制mono-vs-il2cpp>5.脚本执行机制（Mono vs IL2CPP）</a><ul><li><a href=#mono模式editor-或-dev-build>Mono模式（Editor 或 Dev Build）</a></li><li><a href=#il2cpp模式正式发布时>IL2CPP模式（正式发布时）</a></li></ul></li></ul></li><li><a href=#unity-ecs新架构entity-component-system>Unity ECS（新架构：Entity-Component-System）</a></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>