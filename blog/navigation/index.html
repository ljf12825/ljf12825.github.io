<!doctype html><html lang=en><head><meta charset=UTF-8><title>Navigation</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=Navigation class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Navigation<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>constructing</p><h1 id=navigation-in-3d>Navigation in 3D</h1><p>Unity的默认NavMesh系统是为3D场景涉及的</p><p>Unity中的Navigation主要涉及路径寻找（Pathfinding）和导航网格（NavMesh）两大核心内容，广泛应用于AI和角色移动的场景中，特别是用于控制NPC的行动</p><h2 id=navmesh导航网格>NavMesh（导航网格）</h2><p>NavMesh是一个为AI角色提供导航支持的系统。在一个3D场景中，NavMesh是通过对地面等可行走区域的“网格化”，让AI角色能在场景中找到通行路径</p><h3 id=navmesh的基本概念>NavMesh的基本概念</h3><ul><li>可行走区域：NavMesh会自动计算哪些地方是可供角色行走的，哪些地方是不可行走的。不可行走区域可以通过物理层（Layer）或直接标记为不可行走区域来实现</li><li>障碍物避让：NavMehs会避开障碍物，因此角色在移动时不会穿越墙壁、岩石等不可行走区域</li><li>NavMesh代理（NavMesh Agent）：用于控制角色在NavMesh上的运动，它会根据目标点、路径规划和障碍物自动调整角色的路径</li></ul><h3 id=navmesh生成>NavMesh生成</h3><p>在Unity中，我们通过以下几个步骤来创建NavMesh：</p><ol><li>导航面（NavMesh Surface）：这是Unity中生成NavMesh的工具。通过在地面上添加一个NavMeshSurface组件来定义NavMesh的生成区域。</li><li>烘焙NavMesh：一旦设置好NavMeshSurface，就可以通过点击“Bake”按钮来生成NavMesh，这时可行走的区域会被标记出来，Unity会在该区域内生成一个路径网格。</li><li>设置不可行走区域：可以通过NavMesh Obstacle组件来定义障碍物，标记出不可走的区域，生成的NavMesh会自动避开这些区域。</li></ol><h2 id=navmesh-surface>NavMesh Surface</h2><p><img src=/images/Blog/NavMeshSurfacePanel.jpg alt=NavMeshSurfacePanel></p><h2 id=navmesh-agent导航代理>NavMesh Agent（导航代理）</h2><p><code>NavMeshAgent</code> 是挂载在角色上的组件，负责根据计算出的路径自动引导角色移动。它依赖于NavMesh来判断路径和避开障碍物。NavMeshAgent 会计算从当前位置到目标点的路径，并使角色沿路径移动</p><p><img src=/images/Blog/NavMeshAgentPanel.jpg alt=NavMeshAgentPanel></p><p>属性</p><ul><li>Speed：设置角色的移动速度</li><li>Angular Speed：设置角色旋转的速度</li><li>Acceleration：角色的加速速度</li><li>Stopping Distance：目标点与角色之间的最小距离，当距离小于该值时，角色会停止移动</li><li>Auto-Breaking：是否在停止时自动刹车</li><li>Avoidance Priority：设置代理的优先级，用于多个角色避免碰撞</li></ul><p>移动方法<br>可以通过代码控制角色的移动</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>NavMeshAgent agent = GetComponent&lt;NavMeshAgent&gt;();
</span></span><span style=display:flex><span>agent.SetDestination(targetPosition);
</span></span></code></pre></div><p>这个方法会让角色自动计算到<code>targetPosition</code>的最短路径，并开始沿着路径移动</p><h2 id=navmesh-path导航路径>NavMesh Path（导航路径）</h2><p><code>NavMeshPath</code>是一个可以通过代码访问的类，它保存了计算出的路径的所有信息，包括路径的各个节点（Waypoints），可以使用它来获取更详细的路径信息</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>NavMeshPath path = <span style=color:#66d9ef>new</span> NavMeshPath();
</span></span><span style=display:flex><span>NavMesh.CalculatePath(startPosition, targetPosition, NavMesh.AllAreas, path);
</span></span></code></pre></div><p>这段代码会计算从<code>StartPosition</code>到<code>targetPostion</code>的路径，并返回路径中的所有节点</p><h2 id=路径寻找和动态障碍物>路径寻找和动态障碍物</h2><ul><li>动态障碍物：有时场景中的障碍物是动态变化的，比如敌人、移动的物体等。可以通过<code>NavMeshObstacle</code>组件来设置动态障碍物。该组件会实时更新NavMesh，自动调整路径</li><li>Recalculate Path：如果障碍物被移除或发生了变化，<code>NavMeshAgent</code>可以动态重新计算路径：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (agent.isOnNavMesh) agent.SetDestination(newDestination);
</span></span></code></pre></div><h2 id=navmesh-obstacle>NavMesh Obstacle</h2><h2 id=navmesh-link>NavMesh Link</h2><h2 id=navmesh-modifier>NavMesh Modifier</h2><h2 id=navmesh-modifier-volume>NavMesh Modifier Volume</h2><h2 id=navigation>Navigation</h2><ul><li>Agents</li><li>Areas</li></ul><h2 id=agent-avoidance代理避免>Agent Avoidance（代理避免）</h2><p>Unity的NavMesh系统支持代理避让功能。当多个<code>NavMeshAgent</code>对象在场景中一起移动时，系统会自动计算并避免它们相互碰撞，可以在<code>NavMeshAgent</code>的避让设置中调整优先级和半径，从而控制AI角色之间的避让行为</p><h2 id=高级应用>高级应用</h2><ul><li>多层NavMesh：可以为不同的地面或楼层设置不同的NavMesh；比如，可以设置两个不同的NavMesh，一个是地面上的，一个是楼顶上的。这样，角色可以跨楼层或避开楼层之间的障碍</li><li>自定义NavMesh：如果Unity的内置功能不满足需求，可以通过API自定义路径计算方式和避让算法。<code>NavMesh</code>类提供了API来获取网格数据，进行自定义的路径寻找计算</li></ul><h2 id=navmesh与ai结合>NavMesh与AI结合</h2><p>Unity的NavMesh不仅可以用于角色导航，还可以与AI逻辑结合，用于实现复杂的行为，比如：</p><ul><li>巡逻：AI可以在NavMesh上设置多个巡逻点，自动选择路径并执行巡逻</li><li>攻击行为：AI角色通过路径计算寻找到敌人并进行攻击</li><li>逃跑行为：AI根据当前状况（如角色被攻击时）可以自动计算逃跑路径</li></ul><h1 id=navigation-in-2d>Navigation in 2D</h1></div><nav class=post-nav><a href=/blog/monobehaviour/ class=hover:underline>pre: MonoBehaviour</a>
<a href=/blog/object/ class=hover:underline>next: Object</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><a href=#navigation-in-3d>Navigation in 3D</a><ul><li><a href=#navmesh导航网格>NavMesh（导航网格）</a><ul><li><a href=#navmesh的基本概念>NavMesh的基本概念</a></li><li><a href=#navmesh生成>NavMesh生成</a></li></ul></li><li><a href=#navmesh-surface>NavMesh Surface</a></li><li><a href=#navmesh-agent导航代理>NavMesh Agent（导航代理）</a></li><li><a href=#navmesh-path导航路径>NavMesh Path（导航路径）</a></li><li><a href=#路径寻找和动态障碍物>路径寻找和动态障碍物</a></li><li><a href=#navmesh-obstacle>NavMesh Obstacle</a></li><li><a href=#navmesh-link>NavMesh Link</a></li><li><a href=#navmesh-modifier>NavMesh Modifier</a></li><li><a href=#navmesh-modifier-volume>NavMesh Modifier Volume</a></li><li><a href=#navigation>Navigation</a></li><li><a href=#agent-avoidance代理避免>Agent Avoidance（代理避免）</a></li><li><a href=#高级应用>高级应用</a></li><li><a href=#navmesh与ai结合>NavMesh与AI结合</a></li></ul></li><li><a href=#navigation-in-2d>Navigation in 2D</a></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>