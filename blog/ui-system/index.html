<!doctype html><html lang=en><head><meta charset=UTF-8><title>UI System</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="UI System" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>UI System<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>Unity UI系统是Unity引擎内置的用于构建用户界面的工具集。它基于Canvas（画布）架构，支持制作按钮、文本、图片、滑动条、输入框等各种交互元素</p><h2 id=ugui和ngui>UGUI和NGUI</h2><table><thead><tr><th>特性</th><th>UGUI（Unity GUI）</th><th>NGUI（Next-Gen UI）</th></tr></thead><tbody><tr><td>开发方</td><td>Unity 官方</td><td>第三方（Tasharen Entertainment）</td></tr><tr><td>引入版本</td><td>Unity 4.6+ 内置</td><td>Unity 3.x 时期的主流 UI 插件</td></tr><tr><td>集成性</td><td>原生集成，支持 Canvas、EventSystem、Animation 等</td><td>插件形式，较早期版本需手动集成</td></tr><tr><td>渲染系统</td><td>使用 Unity 内部渲染系统（Canvas）</td><td>自定义渲染系统，Draw Call 优化依赖面板拆分</td></tr><tr><td>编辑器支持</td><td>所见即所得，Scene View 拖拽 UI</td><td>早期需要反复预览，后期版本改善较多</td></tr><tr><td>多分辨率适配</td><td>有自动布局系统、Anchor、RectTransform</td><td>依赖自定义 Anchor 系统</td></tr><tr><td>动画支持</td><td>支持 Unity Animation 和 Animator</td><td>原生支持有限，需自定义组件</td></tr><tr><td>事件系统</td><td>支持原生 EventSystem（点击、拖拽等）</td><td>使用自己的事件系统</td></tr><tr><td>社区和文档</td><td>官方支持，Unity 文档齐全</td><td>社区活跃度下降，文档依赖作者和社区</td></tr><tr><td>性能</td><td>对大型复杂 UI 会产生较多 Draw Call，需要合批优化</td><td>更早期对 Draw Call 优化做得较极致，但维护成本高</td></tr><tr><td>是否推荐使用</td><td>推荐（Unity 官方支持）</td><td>不推荐新项目使用（已过时）</td></tr></tbody></table><p>NGUI是在Unity官方UI系统还不成熟时的“事实标准”，很多Unity3.x和4.x的项目大量使用<br>UGUI时Unity官方退出的新UI系统，功能更强大，易于扩展，且原生支持多平台和工具链</p><p><img src=/images/Blog/CreateUI.jpg alt=CreateUI></p><p><a href=https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/index.html>UnityUI2.0.0</a></p><h2 id=canvas>Canvas</h2><p>Canvas是Unity中所有UI元素的容器，所有UI控件都必须是Canvas的子对象，否则它们不会被渲染成UI</p><p><img src=/images/Blog/CanvasInspector.jpg alt=CanvasInspector></p><h3 id=canvas的渲染模式>Canvas的渲染模式</h3><p>Canvas有三种渲染模式，不同模式影响UI的显示方式、渲染顺序以及与摄像机的关系</p><h4 id=1screen-space---overlay屏幕空间覆盖>1.Screen Space - Overlay（屏幕空间覆盖）</h4><ul><li>这是默认模式</li><li>UI直接渲染在屏幕上，始终覆盖在游戏视图的最上层</li><li>不受任何摄像机影响，不需要摄像机参与渲染</li><li>适合制作固定在屏幕上的HUD、血条、菜单等</li><li>优点：渲染简单，效率高</li><li>缺点：无法与3D世界产生深度关系，UI始终在前面</li></ul><h4 id=2screen-space---camera屏幕空间摄像机>2.Screen Space - Camera（屏幕空间摄像机）</h4><ul><li>UI挂载在指定的摄像机前面</li><li>通过摄像机来渲染UI，UI会与摄像机的视锥和深度产生关系</li><li>允许UI元素首摄像机影响（缩放、视角变化）</li><li>常用于需要与摄像机视角联动的UI，例如放大镜效果、视角内提示等</li><li>可以控制UI的排序顺序（Sorting Layer和Order in Layer）</li></ul><h4 id=3world-space世界空间>3.World Space（世界空间）</h4><ul><li>UI作为3D场景中的普通物体存在</li><li>有自己的位置、旋转、缩放，可以放在场景中任意位置</li><li>通过普通摄像机渲染，能与3D模型、光照等交互</li><li>适合制作3D菜单、游戏内面板、悬浮信息</li><li>需要调整Canvas的大小和UI元素的尺寸，比较复杂</li></ul><h3 id=canvas组件的重要属性>Canvas组件的重要属性</h3><h4 id=screen-space---overlay>Screen Space - Overlay</h4><p><img src=/images/Blog/Canvas-ScreenSpace-Overlay.jpg alt=CanvasScreenSpace-Overlay></p><p>默认模式</p><ul><li><p>Render Mode：渲染模式，见上文</p></li><li><p>Pixel Perfect：像素完美，开启后UI元素会对齐到像素点，减少模糊，适合2D像素风UI</p></li><li><p>Sort Order：控制UI元素渲染顺序，决定了多个Canvas之间的渲染优先级，数值越大，渲染层级越靠前，会覆盖数值较小的Canvas；数值相同，会根据它们在Hierarchy中的位置决定前后</p></li><li><p>Target Display：该Canvas渲染到哪一个物理显示器上，这个功能主要用在多显示器应用中，默认Unity只是用主显示器（Display1），有八个可选项，必须在代码中手动启动多个显示器 <code>if (Dispaly.display.Length > 1) Display.display[1].Activate();</code>（启用Display 2）</p></li><li><p>Additional Shader Channels：用于指定UI顶点需要传递给Shader的额外数据通道
当你使用自定义UI Shader（比如为按钮添加特效、动画、描边等）时，可能需要从UI元素的每个顶点传递一些额外数据（如颜色、UV1、法线、Tangent等）到Shader中。而默认Canvas并不会传递这些数据，只有你在<code>Additional Shader Channels</code>中显式勾选，Unity才会将这些数据从CPU传给GPU
可选项说明：</p><ul><li>TexCoord1：第二套UV坐标，一些Shader特效可能使用</li><li>TexCoord2：第三套UV坐标</li><li>TexCoord3：第四套UV坐标</li><li>Normal：法线信息（常用于光照Shader）</li><li>Tangent：切线信息（常与法线贴图配合）</li><li>Color：颜色通道（通常UI默认传递的是主颜色）</li></ul><p>Unity的UI是通过<code>CanvasRenderer</code>生成的顶点数据送入GPU，默认只传position、uv0、color；若Shader需要额外通道，必须通过<code>Additional Shader Channels</code>显式开启，让<code>Canvas</code>包装完整数据；但需要注意，勾选越多，传输数据越大，性能开销越大（尤其是在移动端）</p></li><li><p>Vertex Color Always In Gamma Color Space：控制UI顶点颜色是否始终使用Gamma空间进行处理，无论当前项目是否使用Linear或Gamma颜色空间</p></li></ul><h4 id=screen-space---camera>Screen Space - Camera</h4><p><img src=/images/Blog/Canvas-ScreenSpace-Camera.jpg alt=CanvasScreenSpace-Camera></p><ul><li>Render Camera：The Camera whitch will render the canvas. This is also the camera used to send events
A Screen Space Canvas with no specified camera acts like an Overlay Canvas</li></ul><h4 id=world-space>World Space</h4><p><img src=/images/Blog/Canvas-WorldSpace.jpg alt=CanvasWorldSpace></p><ul><li>Event Camera：用于处理射线点击UI的相机（通常是主摄像机），必须设置，否则点击无效</li></ul><h3 id=canvasscaler>CanvasScaler</h3><p>Canvas通常会搭配CanvasScaler使用，控制UI的缩放和适配，CanvasScaler用于根据不同分辨率、屏幕尺寸，动态调整UI大小，保证UI在不同设备上的一致性</p><h4 id=三种缩放模式>三种缩放模式</h4><p>1.Constant Pixel Size（固定像素大小）</p><p><img src=/images/Blog/CanvasScaler-ConstantPixelSize.jpg alt="Constant Pixel Size"></p><ul><li>UI元素大小固定为设计时的像素值，不会随屏幕尺寸变化缩放</li><li>适合UI对像素精度要求高，不想变形的场景</li><li>缺点：不同分辨率下UI大小不一致，低分辨率屏幕上UI显得很大，高分辨率上显得很小</li></ul><p>参数：</p><ul><li>Scale Factor：控制Canvas上所有UI元素的整体缩放倍数</li><li>Reference Pixels Per Unit：单位像素参考值，决定1个世界单位中包含多少个像素</li></ul><p>2.Scale With Screen Size（随屏幕尺寸缩放）</p><p><img src=/images/Blog/CanvasScaler-ScaleWithScreenSize.jpg alt="Scale With Screen Size"></p><ul><li>根据屏幕分辨率，按比例缩放UI，使得UI在不同分辨率下保持视觉一致</li><li>通过<code>Reference Resolution</code>设置参考设计分辨率</li><li>通过<code>Screen Match Mode</code>决定缩放如何适配宽高比<ul><li>Match Width Or Height：在宽和高之间插值，<code>Match</code>属性控制偏重那一边（0为宽，1为高）</li><li>Expand：适配屏幕，保证UI不会裁剪，但可能留空白</li><li>Shrink：保证UI填满屏幕，可能裁剪一部分</li></ul></li><li>这是最常用的模式，推荐用于大多数UI适配</li></ul><p>3.Constant Physical Size（固定物理大小）</p><p><img src=/images/Blog/CanvasScaler-ConstantPhysicalSize.jpg alt="Constant Physical Size"></p><ul><li>UI元素在物理尺寸上保持不变（以英寸、毫米为单位），无论屏幕分辨率如何变化</li><li>依赖设备DPI（屏幕像素密度），适用于对物理尺寸有要求的UI</li></ul><p>参数：</p><ul><li><p>Physical Unit：物理单位，告诉Unity希望使用哪种单位作为UI元素的尺寸基准
可选项：</p><ul><li>Points</li><li>Pixels</li><li>Millimeters</li><li>Centimeters</li><li>Inches</li></ul></li><li><p>Fallback Screen DPI：当Unity无法获取当前设备的DPI时，就会使用这个值来代替实际DPI</p></li><li><p>Default Sprite DPI：控制UI中Sprite贴图的物理尺寸缩放基准</p></li></ul><h3 id=graphic-raycaster>Graphic Raycaster</h3><p>在屏幕空间内把点击（Pointer）或触摸事件，转换成UI元素的响应事件</p><p>面板属性：</p><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td><strong>Ignore Reversed Graphics</strong></td><td>是否忽略背面 UI 图形（比如被旋转了 180° 的 UI 元素）</td></tr><tr><td><strong>Blocking Objects</strong></td><td>控制是否允许 3D/2D 物体阻挡 UI 点击（比如 3D 模型挡住了按钮）</td></tr><tr><td><strong>Blocking Mask</strong></td><td>用于限制哪些 Layer 的物体会阻挡 UI 射线</td></tr></tbody></table><h4 id=工作原理ui射线检测>工作原理：UI射线检测</h4><p>当你点击屏幕时，Unity的Event System会：</p><ul><li>发出一条射线（Ray）</li><li>交给<code>Grphic Raycaster</code></li><li><code>Graphic Raycaster</code>会检测这条射线是否与某些UI元素相交</li><li>若相交，就触发这些元素的<code>OnPointerClick()</code>、<code>OnPointerDown()</code>、<code>OnDrag()</code>等事件</li></ul><p>要让Graphic Paycaster正常工作，必须保证：</p><ul><li>Canvas上挂了<code>Graphic Raycaster</code></li><li>场景中有一个<code>Event System</code></li><li>UI元素上有<code>Graphic</code>组件（如<code>Image</code>、<code>Text</code>，才能被Raycaster检测到）</li><li>UI元素有<code>Raycast Target</code>为勾选状态</li><li>没有被<code>Canvas Group</code>阻挡（其<code>Blocks Raycasts</code>属性必须为true）</li></ul><h3 id=canvas-group>Canvas Group</h3><p><img src=/images/Blog/CanvasGroupPanel.jpg alt=CanvasGroupPanel></p><p>控制一组UI元素的整体透明度、交互性和射线响应<br>用它可以实现：</p><ul><li>一整个面板淡入淡出</li><li>临时禁用一组按钮</li><li>某些UI遮罩区域不响应点击</li></ul><h4 id=属性>属性</h4><table><thead><tr><th>属性名</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td><strong>Alpha</strong></td><td><code>float</code> (0 ~ 1)</td><td>控制透明度，0 = 全透明，1 = 不透明。会影响 <strong>UI 的视觉透明</strong> 和 <strong>交互性（如果 Block Raycasts = true）</strong></td></tr><tr><td><strong>Interactable</strong></td><td><code>bool</code></td><td>是否允许子元素响应交互事件（如点击 Button）</td></tr><tr><td><strong>Blocks Raycasts</strong></td><td><code>bool</code></td><td>是否拦截 UI 射线，决定子元素是否能被点击、拖动等</td></tr><tr><td><strong>Ignore Parent Groups</strong></td><td><code>bool</code></td><td>是否忽略父级 Canvas Group 的控制（<strong>重要属性</strong>）</td></tr></tbody></table><h3 id=canvas的层级关系>Canvas的层级关系</h3><p>Unity允许UI层级中存在多个Canvas组件，这时，Canvas本身就能作为字节点存在，形成嵌套结构</p><ul><li>子Canvas布置主Canvas的一部分，它是一个“独立渲染单元”</li><li>每个Canvas都是一个独立的渲染批次（Draw Call）</li><li>子Canvas不会因为父Canvas中其他UI元素变化而重绘，反之亦然</li></ul><h4 id=为什么要用子canvas>为什么要用子Canvas</h4><p>子Canvas主要用于优化性能和分离逻辑</p><h5 id=性能优化>性能优化</h5><blockquote><p>如果你有一个排行榜界面，只有当排行榜打开时才需要刷新内容，其他UI不变，这可以这样：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>Canvas</span><span style=color:#f92672>(</span><span style=color:#f92672>主UI</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span><span style=color:#960050;background-color:#1e0010>——</span><span style=color:#f92672>背景UI</span><span style=color:#f92672>(</span><span style=color:#f92672>静态</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span><span style=color:#960050;background-color:#1e0010>——</span><span style=color:#f92672>Canvas</span><span style=color:#f92672>(</span><span style=color:#f92672>排行榜</span><span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>-</span> <span style=color:#f92672>单独Canvas</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#f92672>打开时才激活和更新</span>
</span></span></code></pre></div><p>这样排行榜刷新不会引起整个主UI Canvas的重建批次</p><h5 id=ui分区逻辑清晰>UI分区逻辑清晰</h5><blockquote><p>把HUD、弹窗、系统提示各放到子Canvas中，方便管理和控制层级、显隐、动画等</p></blockquote><h4 id=父子canvas的排序--显示顺序>父子Canvas的排序 & 显示顺序</h4><h5 id=排序层控制sorting-layer--order-in-layer>排序层控制（Sorting Layer + Order in Layer）</h5><p>每个Canvas都有：</p><ul><li>Sorting Layer（图层）</li><li>Order in Layer（在该图层的顺序）
这两个参数决定Canvas之间的渲染先后顺序，数值越高越在前，越晚渲染</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>Canvas HUD(Sorting Layer: UI, Order</span>: <span style=color:#ae81ff>0</span><span style=color:#ae81ff>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>Canvas Popup(Sorting Layer: UI, Order</span>: <span style=color:#ae81ff>10</span><span style=color:#ae81ff>)</span>
</span></span></code></pre></div><p>Popup会在HUD上方显示，即使它是子物体也一样</p><h4 id=recttransform父子关系的影响>RectTransform父子关系的影响</h4><ul><li>子UI元素会继承父节点的位置、旋转、缩放等变换</li><li>子UI的位置是相对于父节点的（本地坐标）</li><li>适用于做面板嵌套、按钮列表、滑动区域等结构</li></ul><h3 id=canvas性能>Canvas性能</h3><ul><li>尽量减少Canvas数量，因为每个Canvas都是单独的渲染批次</li><li>将频繁变动的UI元素放到单独的Canvas，避免整个UI重绘</li><li>使用Canvas Group控制UI整体显示和透明度，可以减少重绘</li><li>关闭不需要显示的UI，避免额外渲染</li></ul><h3 id=canvas-api>Canvas API</h3><h4 id=properties>Properties</h4><table><thead><tr><th>属性名</th><th>类型</th><th>说明</th><th>常见用途</th></tr></thead><tbody><tr><td><code>renderMode</code></td><td><code>RenderMode</code></td><td>渲染模式（Overlay、ScreenSpaceCamera、WorldSpace）</td><td>决定Canvas如何渲染和视图方式</td></tr><tr><td><code>worldCamera</code></td><td><code>Camera</code></td><td>渲染用摄像机（适用于 Camera、World 模式）</td><td>控制UI投射方向、接收事件</td></tr><tr><td><code>pixelPerfect</code></td><td><code>bool</code></td><td>是否启用像素完美对齐（仅限Screen Space）</td><td>像素风格游戏的UI清晰对齐</td></tr><tr><td><code>planeDistance</code></td><td><code>float</code></td><td>距摄像机的距离（仅Screen Space - Camera）</td><td>控制Canvas深度层级</td></tr><tr><td><code>scaleFactor</code></td><td><code>float</code></td><td>缩放因子（通常由 CanvasScaler 控制）</td><td>适配不同分辨率</td></tr><tr><td><code>referencePixelsPerUnit</code></td><td><code>float</code></td><td>每单位像素数，决定图像缩放清晰度</td><td>确保 UI 图像缩放一致</td></tr><tr><td><code>sortingLayerID</code></td><td><code>int</code></td><td>渲染图层 ID</td><td>控制 Canvas 渲染层</td></tr><tr><td><code>sortingLayerName</code></td><td><code>string</code></td><td>渲染图层名称</td><td>可读性更强的层级控制</td></tr><tr><td><code>sortingOrder</code></td><td><code>int</code></td><td>同图层中的渲染顺序，越大越前面</td><td>控制 UI 显示前后关系</td></tr><tr><td><code>overrideSorting</code></td><td><code>bool</code></td><td>是否覆盖父 Canvas 的排序逻辑</td><td>弹窗、特效UI 的独立排序</td></tr><tr><td><code>targetDisplay</code></td><td><code>int</code></td><td>目标显示屏幕编号（用于多显示器）</td><td>多屏幕UI部署</td></tr><tr><td><code>isRootCanvas</code></td><td><code>bool</code> (只读)</td><td>是否为根 Canvas</td><td>判断是否主 Canvas（用于布局判断）</td></tr><tr><td><code>rootCanvas</code></td><td><code>Canvas</code> (只读)</td><td>所属的顶级 Canvas</td><td>获取当前 Canvas 的上级主容器</td></tr><tr><td><code>renderOrder</code></td><td><code>int</code> (只读)</td><td>实际渲染顺序（自动计算）</td><td>调试 Canvas 渲染先后</td></tr><tr><td><code>pixelRect</code></td><td><code>Rect</code> (只读)</td><td>当前 Canvas 实际的像素渲染区域</td><td>渲染区域调试</td></tr><tr><td><code>renderingDisplaySize</code></td><td><code>Vector2</code> (只读)</td><td>渲染显示区域的像素尺寸</td><td>获取目标显示区域尺寸</td></tr><tr><td><code>overridePixelPerfect</code></td><td><code>bool</code></td><td>是否允许覆盖父Canvas的像素对齐设置</td><td>子 Canvas 不启用像素对齐时用</td></tr><tr><td><code>additionalShaderChannels</code></td><td><code>AdditionalShaderChannels</code></td><td>指定额外的 shader 顶点数据传输通道</td><td>用于自定义UI Shader</td></tr><tr><td><code>cachedSortingLayerValue</code></td><td><code>int</code> (只读)</td><td>当前排序图层的底层缓存值，用于排序计算</td><td>系统内部优化（一般不手动使用）</td></tr><tr><td><code>normalizedSortingGridSize</code></td><td><code>float</code></td><td>Canvas 分割的排序网格单元大小</td><td>高阶排序控制，与 SRP 结合使用</td></tr><tr><td><code>updateRectTransformForStandalone</code></td><td><code>bool</code></td><td>在手动 <code>Camera.Render()</code> 时是否自动更新 RectTransform</td><td>手动渲染UI场景</td></tr><tr><td><code>vertexColorAlwaysGammaSpace</code></td><td><code>bool</code></td><td>在使用线性空间渲染时是否强制顶点颜色使用 Gamma 空间传递</td><td>确保 UI 颜色一致性（线性渲染）</td></tr></tbody></table><h4 id=static-method>Static Method</h4><table><thead><tr><th>方法名</th><th>返回类型</th><th>描述</th><th>常见用途</th></tr></thead><tbody><tr><td><code>Canvas.ForceUpdateCanvases()</code></td><td><code>void</code></td><td><strong>强制更新所有 Canvas</strong> 的布局和绘制内容</td><td>用于在下一帧前立即刷新 UI 状态（比如修改布局元素后）</td></tr><tr><td><code>Canvas.GetDefaultCanvasMaterial()</code></td><td><code>Material</code></td><td>返回一个<strong>默认 Canvas 材质</strong>，用于普通 UI 元素的渲染</td><td>如果需要自定义绘制或替换默认材质时使用</td></tr><tr><td><code>Canvas.GetETC1SupportedCanvasMaterial()</code></td><td><code>Material</code></td><td>获取或生成支持 <strong>ETC1 格式贴图的 UI 材质</strong>（主要用于 Android）</td><td>在使用 ETC1 压缩纹理时提供透明通道支持（Alpha 拆分）</td></tr></tbody></table><h4 id=events>Events</h4><table><thead><tr><th>事件名</th><th>调用时机</th><th>描述</th><th>常见用途</th></tr></thead><tbody><tr><td><code>preWillRenderCanvases</code></td><td><strong>Canvas 渲染前，最先调用</strong></td><td>在 Canvas 渲染流程开始前立即触发（早于布局和绘制）</td><td>在渲染前动态调整 UI 布局、刷新数据</td></tr><tr><td><code>willRenderCanvases</code></td><td><strong>Canvas 渲染前，紧接上一步</strong></td><td>在 Canvas 渲染流程开始前触发，但晚于 <code>preWillRenderCanvases</code></td><td>绑定动画播放、状态更新逻辑、依赖布局结果的修改操作</td></tr></tbody></table><h5 id=事件区别和调用顺序>事件区别和调用顺序</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Canvas.preWillRederCanvases -&gt; Canvas.willRenderCanvases -&gt; Canvas <span style=color:#960050;background-color:#1e0010>渲染</span>
</span></span></code></pre></div><ul><li><code>preWilldRenderCanvases</code>：在所有布局系统更新之前调用，用于准备UI状态、尺寸、数据等</li><li><code>willRenderCanvases</code>：在布局完成后、渲染开始前调用，适合根据最终布局做动画、视觉状态处理</li></ul><p><a href=https://docs.unity3d.com/ScriptReference/Canvas.html>UnityScripting Canvas</a></p><h2 id=ui-component>UI Component</h2><h3 id=通用组件>通用组件</h3><p><img src=/images/Blog/UI-CommonComponent.jpg alt=UICommonComponent></p><h4 id=rect-transform>Rect Transform</h4><p><code>RectTransform</code>继承自<code>Transform</code>，专门用于2D UI布局。<br>所有UI元素都依赖<code>RectTransform</code>来定位和缩放</p><h5 id=核心属性>核心属性</h5><table><thead><tr><th>属性名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>anchorMin</code></td><td>Vector2</td><td>锚点区域左下角（归一化坐标，0~1）</td></tr><tr><td><code>anchorMax</code></td><td>Vector2</td><td>锚点区域右上角</td></tr><tr><td><code>anchoredPosition</code></td><td>Vector2</td><td>相对于锚点区域中心的偏移量</td></tr><tr><td><code>pivot</code></td><td>Vector2</td><td>本地坐标的参考中心（范围 0~1）</td></tr><tr><td><code>sizeDelta</code></td><td>Vector2</td><td>元素宽高，或拉伸模式下的偏移</td></tr><tr><td><code>rect</code></td><td>Rect (只读)</td><td>实际的矩形框（位置、宽高）</td></tr><tr><td><code>localPosition</code></td><td>Vector3</td><td>相对于父节点的本地坐标（不推荐直接用于 UI）</td></tr></tbody></table><h5 id=anchor>Anchor</h5><p>Anchor（锚点）是<code>RectTransform</code>的关键组成部分，决定了UI元素相对于父物体的位置和尺寸的参考点</p><p>Anchor实际上是一对二维坐标：<code>anchorMin</code>和<code>anchorMax</code>，每个值都是<code>[0, 1]</code>范围内归一化坐标，表示在父元素矩形中的相对位置</p><ul><li><code>anchorMin = (0, 0)</code>表示父物体的左下角</li><li><code>anchorMax = (1, 1)</code>表示父物体的右上角</li></ul><p><strong>锚点的几种模式</strong>
1.固定位置（不拉伸）<br>当：<code>anchorMin</code> = <code>anchorMax</code></p><ul><li>元素位置相对于这个锚点点位</li><li>用<code>anchoredPosition</code>来控制偏移</li><li>常用于角落按钮、图标等</li></ul><p>2.拉伸尺寸（适应父物体）
当：<code>anchorMin</code> != <code>anchorMax</code></p><ul><li>元素会随着父容器的尺寸变化而拉伸</li><li><code>sizeDelta</code>不是绝对宽高，而是拉伸结果的偏移</li></ul><h5 id=pivot>Pivot</h5><p>pivot（枢轴点）定义的是UI元素自身的参考点（中心点），它决定了：</p><ul><li>元素的位置是以自身哪个位置为参考（锚点对齐）</li><li>元素在旋转时围绕哪里旋转</li><li>元素在缩放时以哪个点为中心缩放</li></ul><p>它的值是一个二维向量，范围在<code>[0, 1]</code>之间，表示相对于自身矩形的位置：</p><table><thead><tr><th><code>pivot</code> 值</th><th>位置说明</th></tr></thead><tbody><tr><td>(0, 0)</td><td>左下角</td></tr><tr><td>(0.5, 0.5)</td><td>中心（默认）</td></tr><tr><td>(1, 1)</td><td>右上角</td></tr><tr><td>(0, 1)</td><td>左上角</td></tr><tr><td>(1, 0)</td><td>右下角</td></tr></tbody></table><h4 id=布局>布局</h4><p><strong>布局演示</strong>
假设Canvas是1920*1080的全屏UI</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>RectTransform rt = GetComponent&lt;RectTransform&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rt.anchorMin = <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>0.5f</span>, <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>rt.anchorMax = <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>0.5f</span>, <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>rt.pivot = <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>0.5f</span>, <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>rt.anchoredPosition = <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>rt.sizeDelta = <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>100</span>);
</span></span></code></pre></div><p>这个UI元素将被放置在屏幕正中央，宽度为200，高度为100</p><h5 id=坐标系层级关系>坐标系层级关系</h5><p>1.<code>anchorMin</code> / <code>anchorMax</code>决定锚点区域</p><p>2.<code>anchoredPosition</code>是相对于锚点区域的中心</p><p>3.<code>pivot</code>是UI元素自身的中心点</p><p>4.最终位置由这些共同计算得到</p><p><strong>实际计算公式（简化版）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>最终位置 = 锚点区域中心 + anchoredPosition - pivot * sizeDelta
</span></span></code></pre></div><p>这个公式说明了设置的位置不是直接坐标，而是围绕锚点和pivot共同计算的结果</p><p><img src=/images/Blog/AnchorPresets.jpg alt=AnchorPreSets></p><ul><li>按住Alt + Shift拖动可以同时设置pivot和anchor</li><li>Unity提供Anchor Preset快速布局</li><li>蓝线表示Anchors，红点表示Pivot，灰框表示实际UI区域</li></ul><h5 id=recttransform-api>RectTransform API</h5><p><strong>Properties</strong></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>anchoredPosition</code></td><td>相对于锚点参考位置的<strong>二维坐标</strong>，表示此 <code>RectTransform</code> 的**pivot（枢轴点）**的位置。</td></tr><tr><td><code>anchoredPosition3D</code></td><td>相对于锚点参考位置的<strong>三维坐标</strong>，主要用于支持 Z 轴（例如 3D UI 或特殊布局需求）。</td></tr><tr><td><code>anchorMax</code></td><td>右上角锚点在父 <code>RectTransform</code> 中的<strong>归一化坐标</strong>（范围 0~1），例如 (1,1) 表示父物体的右上角。</td></tr><tr><td><code>anchorMin</code></td><td>左下角锚点在父 <code>RectTransform</code> 中的<strong>归一化坐标</strong>，例如 (0,0) 表示父物体的左下角。</td></tr><tr><td><code>drivenByObject</code></td><td>如果该 <code>RectTransform</code> 的属性被其他对象驱动（如 Layout 组件），会显示驱动它的对象；否则为 <code>null</code>。常用于调试自动布局。</td></tr><tr><td><code>offsetMax</code></td><td>当前矩形右上角相对于右上锚点的偏移值（本地坐标）。可以理解为 <code>Top</code> 和 <code>Right</code> 的偏移。</td></tr><tr><td><code>offsetMin</code></td><td>当前矩形左下角相对于左下锚点的偏移值。可以理解为 <code>Left</code> 和 <code>Bottom</code> 的偏移。</td></tr><tr><td><code>pivot</code></td><td>当前 <code>RectTransform</code> 的<strong>枢轴点</strong>，用归一化坐标表示 (0~1)，如 (0.5, 0.5) 表示中心点，(0, 0) 表示左下角。</td></tr><tr><td><code>rect</code></td><td>在本地坐标系下计算出的实际矩形区域，是一个 <code>Rect</code> 结构体（包含 x, y, width, height）。只读属性。</td></tr><tr><td><code>sizeDelta</code></td><td>表示当前矩形的宽高 <strong>相对于 anchor 之间距离的增量值</strong>。如果 anchorMin 和 anchorMax 相同，则这个值就是最终尺寸。</td></tr></tbody></table><p><strong>Public Method</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>ForceUpdateRectTransforms()</code></td><td>强制重新计算 <code>RectTransform</code> 的内部数据（通常在布局改变后使用，用来立即更新布局）。</td></tr><tr><td><code>GetLocalCorners(Vector3[] fourCornersArray)</code></td><td>获取该 <code>RectTransform</code> 在本地空间中的四个角的坐标，按顺序为：左下、左上、右上、右下。结果会填充到传入的 <code>Vector3[4]</code> 数组中。</td></tr><tr><td><code>GetWorldCorners(Vector3[] fourCornersArray)</code></td><td>获取该 <code>RectTransform</code> 在<strong>世界空间</strong>中的四个角的坐标（顺序同上）。</td></tr><tr><td><code>SetInsetAndSizeFromParentEdge(RectTransform.Edge edge, float inset, float size)</code></td><td>以父物体的某条边为参考，设置当前 <code>RectTransform</code> 距离该边的<strong>偏移值（inset）<strong>和自身的</strong>尺寸（size）</strong>。适用于锚点固定在某一边的场景。</td></tr><tr><td><code>SetSizeWithCurrentAnchors(RectTransform.Axis axis, float size)</code></td><td>在指定轴（水平或垂直）上，按照当前锚点设置矩形大小。它会考虑锚点之间的拉伸距离，<strong>相对于锚点调整 sizeDelta</strong>。</td></tr></tbody></table><p><strong>Event</strong></p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td><code>reapplyDrivenProperties</code></td><td>当一个 <code>RectTransform</code> 的某些属性（由外部系统如 Layout、Animation 或代码控制）需要被重新应用时触发的事件。开发者可以订阅这个事件来自定义处理逻辑。</td></tr></tbody></table><p><strong>Delegate</strong></p><table><thead><tr><th>委托</th><th>描述</th></tr></thead><tbody><tr><td><code>ReapplyDrivenProperties</code></td><td>用于 <code>RectTransform.reapplyDrivenProperties</code> 事件的委托类型，定义了事件回调的签名。</td></tr></tbody></table><p><a href=https://docs.unity3d.com/ScriptReference/RectTransform.html>UnityScripting RectTransform</a></p><h4 id=canvas-renderer>Canvas Renderer</h4><p><code>CanvasRenderer</code>是Unity UI系统中挂在每个可见UI上的一个底层组件，负责UI的绘制提交，它是Graphic类的渲染后台</p><blockquote><p><code>CanvasRenderer</code>是连接UI元素和底层渲染管线的桥梁</p></blockquote><h5 id=canvasrenderer的作用>CanvasRenderer的作用</h5><table><thead><tr><th>功能方向</th><th>说明</th></tr></thead><tbody><tr><td>渲染控制</td><td>负责把 UI 元素的顶点数据、颜色、材质提交给 Canvas 系统渲染</td></tr><tr><td>可见性控制</td><td>控制是否显示（通过 <code>cull</code>, <code>SetAlpha</code>, <code>SetColor</code> 等）</td></tr><tr><td>材质支持</td><td>支持单个或多个材质绘制（比如 <code>SetMaterial</code>, <code>SetPopMaterial</code>）</td></tr><tr><td>顶点缓存</td><td>维护每个 UI 元素的 Mesh 数据</td></tr><tr><td>Mask 支持</td><td>与 UI Mask 系统配合使用进行遮罩裁剪处理</td></tr></tbody></table><h5 id=canvasrenderer和ui的绘制流程>CanvasRenderer和UI的绘制流程</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>UI组件（Image/Text 等）
</span></span><span style=display:flex><span>    ↓
</span></span><span style=display:flex><span>生成顶点、UV、颜色等数据
</span></span><span style=display:flex><span>    ↓
</span></span><span style=display:flex><span>传给 CanvasRenderer
</span></span><span style=display:flex><span>    ↓
</span></span><span style=display:flex><span>CanvasRenderer 将数据提交给 Canvas 系统
</span></span><span style=display:flex><span>    ↓
</span></span><span style=display:flex><span>Canvas 系统统一批处理渲染
</span></span></code></pre></div><h5 id=canvasrenderer-api>CanvasRenderer API</h5><p><strong>Properties</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>含义</th><th>用途/说明</th></tr></thead><tbody><tr><td><code>absoluteDepth</code></td><td><code>int</code></td><td>相对于<strong>根 Canvas 的深度值</strong></td><td>用于判断当前 UI 元素在整个 UI 渲染中的层级。数值越大，越“靠上”渲染。</td></tr><tr><td><code>relativeDepth</code></td><td><code>int</code></td><td>相对于<strong>父 Canvas 的深度值</strong></td><td>可用于局部 Canvas 中排序。配合 <code>absoluteDepth</code> 理解 UI 层级渲染顺序。</td></tr><tr><td><code>materialCount</code></td><td><code>int</code></td><td>当前可用于渲染的<strong>材质数量</strong></td><td>用于分配和管理 UI 材质。你可以通过 <code>SetMaterial()</code> 为每个 index 设置材质。</td></tr><tr><td><code>popMaterialCount</code></td><td><code>int</code></td><td>内部用于 Mask（遮罩）的材质数量</td><td>这个通常配合 UI Masking 使用（如 <code>Image.maskable = true</code>）。设置 <code>PopMaterial</code> 用于控制遮罩剥离行为。</td></tr><tr><td><code>hasPopInstruction</code></td><td><code>bool</code></td><td>是否启用了 “渲染堆栈 pop draw call”</td><td>和 <code>PopMaterial</code> 有关。你可以开启它来显式控制何时 pop 遮罩渲染状态。</td></tr><tr><td><code>hasMoved</code></td><td><code>bool</code></td><td>如果 UI 位置发生变更，则为 <code>true</code></td><td>用于判断当前帧是否需要重新生成 UI 顶点几何。优化 UI 刷新频率用。</td></tr><tr><td><code>cull</code></td><td><code>bool</code></td><td>是否<strong>剔除</strong>当前元素</td><td>设置为 <code>true</code> 时，这个元素不再渲染（即使它可见）。用于节省性能。</td></tr><tr><td><code>cullTransparentMesh</code></td><td><code>bool</code></td><td>如果顶点颜色 alpha 接近 0，是否剔除渲染</td><td>用于透明 UI 元素的剔除优化。默认为 <code>true</code>，避免无意义绘制。</td></tr><tr><td><code>hasRectClipping</code></td><td><code>bool</code></td><td>是否启用了矩形剪裁区域</td><td>是否启用了 <code>EnableRectClipping(Rect)</code>。常用于 <code>ScrollRect</code> 中的裁剪效果。</td></tr><tr><td><code>clippingSoftness</code></td><td><code>Vector2</code></td><td>设置裁剪的“软边缘”范围</td><td>使裁剪边缘变得平滑渐变，不是硬切。单位像素值，适合美术优化。</td></tr></tbody></table><p><strong>Public Method</strong></p><table><thead><tr><th>方法</th><th>中文解释</th><th>常见用途</th></tr></thead><tbody><tr><td><strong><code>Clear()</code></strong></td><td>清除所有缓存的顶点数据</td><td>自定义 UI 元素重绘前清空数据</td></tr><tr><td><strong><code>DisableRectClipping()</code></strong></td><td>关闭矩形裁剪区域</td><td>让 UI 元素可以渲染到全屏（常见于浮动 UI）</td></tr><tr><td><strong><code>EnableRectClipping(Rect rect)</code></strong></td><td>启用矩形裁剪区域，只显示 <code>rect</code> 内内容</td><td>用于 <code>ScrollRect</code> 滚动列表裁剪或自定义遮罩逻辑</td></tr><tr><td><strong><code>GetAlpha()</code></strong></td><td>获取当前的透明度值</td><td>判断当前透明度状态，常用于动画/过渡控制</td></tr><tr><td><strong><code>GetColor()</code></strong></td><td>获取当前设置的颜色</td><td>一般配合 <code>SetColor</code> 使用，读取当前 UI 颜色</td></tr><tr><td><strong><code>GetInheritedAlpha()</code></strong></td><td>获取包括所有父级 CanvasGroup 的总 alpha 值</td><td>透明度层级继承计算，适合判断是否实际可见</td></tr><tr><td><strong><code>GetMaterial(int index)</code></strong></td><td>获取某个索引的材质</td><td>适合高级渲染管理，如多 Pass 材质</td></tr><tr><td><strong><code>GetPopMaterial(int index)</code></strong></td><td>获取 Pop 材质（用于 UI 遮罩的反向操作）</td><td>用于 UI Mask / Stencil Buffer 中的剪裁恢复逻辑</td></tr><tr><td><strong><code>GetMesh()</code></strong></td><td>获取当前用于渲染的 Mesh</td><td>常用于自定义绘制调试和顶点处理</td></tr><tr><td><strong><code>GetSecondaryTexture(int index)</code></strong></td><td>获取指定索引的第二纹理</td><td>用于多纹理 UI Shader，例如溶解图、遮罩图</td></tr><tr><td><strong><code>GetSecondaryTextureCount()</code></strong></td><td>获取当前可用第二纹理数量</td><td>用于管理复杂 Shader UI 结构</td></tr><tr><td><strong><code>GetSecondaryTextureName(int index)</code></strong></td><td>获取指定索引的 Shader 属性名</td><td>获取传入的纹理对应的 <code>_SomeTexName</code></td></tr><tr><td><strong><code>SetAlpha(float alpha)</code></strong></td><td>设置透明度，会与 <code>UIVertex alpha</code> 和 <code>Canvas alpha</code> 相乘</td><td>快速设置 UI 淡入淡出、不透明状态等</td></tr><tr><td><strong><code>SetAlphaTexture(Texture tex)</code></strong></td><td>将 <code>_AlphaTex</code> 指定为某个纹理，传给 Shader</td><td>适用于字体抗锯齿、自定义透明纹理渲染</td></tr><tr><td><strong><code>SetColor(Color color)</code></strong></td><td>设置颜色，会与 <code>UIVertex.color</code> 和 <code>Canvas.color</code> 混合</td><td>比如红色血条：<code>SetColor(Color.red)</code></td></tr><tr><td><strong><code>SetMaterial(Material mat, int index)</code></strong></td><td>为指定索引设置材质</td><td>UI Shader 控制，如多 pass 渲染、特效图层等</td></tr><tr><td><strong><code>SetPopMaterial(Material mat, int index)</code></strong></td><td>设置 Pop 材质（内部用于 Mask 反剪裁）</td><td>控制遮罩关闭后的恢复材质</td></tr><tr><td><strong><code>SetMesh(Mesh mesh)</code></strong></td><td>设置渲染用的 Mesh，Mesh 必须启用读写</td><td>你可以自定义顶点图形绘制复杂 UI</td></tr><tr><td><strong><code>SetSecondaryTextureCount(int count)</code></strong></td><td>设置可用第二纹理数量</td><td>Shader 中有多个纹理输入时要提前设置</td></tr><tr><td><strong><code>SetSecondaryTexture(int index, string shaderProp, Texture tex)</code></strong></td><td>设置指定索引的纹理及其 Shader 属性名</td><td>给 UI Shader 传多个纹理，如 <code>_MaskTex</code>, <code>_NoiseTex</code></td></tr><tr><td><strong><code>SetTexture(Texture tex)</code></strong></td><td>设置用于 UI 材质中的主纹理</td><td>相当于设定 Shader 的 <code>_MainTex</code>，适用于 <code>Image</code> 或 <code>RawImage</code> 渲染</td></tr></tbody></table><p><strong>Static Method</strong></p><table><thead><tr><th>方法名</th><th>作用</th><th>常见用途</th></tr></thead><tbody><tr><td><strong><code>SplitUIVertexStreams</code></strong></td><td>将 <code>UIVertex</code> 列表拆分成各个属性数组（位置、颜色、UV、法线、切线）</td><td>修改顶点颜色、UV、法线等时使用</td></tr><tr><td><strong><code>AddUIVertexStream</code></strong></td><td>将 <code>UIVertex</code> 中的数据<strong>添加</strong>到现有的顶点属性列表</td><td>组合多个顶点来源数据，叠加处理</td></tr><tr><td><strong><code>CreateUIVertexStream</code></strong></td><td>将单独的顶点属性数组（位置、颜色、UV等）<strong>合成为一个 <code>UIVertex</code> 流</strong></td><td>自定义 UI 图形顶点数据，如渐变、闪光、圆形 UI 等</td></tr></tbody></table><p>静态方法参数说明</p><table><thead><tr><th>参数名</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><code>verts</code></td><td><code>List&lt;UIVertex></code></td><td>完整顶点数据流</td></tr><tr><td><code>positions</code></td><td><code>List&lt;Vector3></code></td><td>每个顶点的位置</td></tr><tr><td><code>colors</code></td><td><code>List&lt;Color32></code></td><td>每个顶点的颜色</td></tr><tr><td><code>uv0S</code> / <code>uv1S</code></td><td><code>List&lt;Vector4></code></td><td>UV 坐标（第0、1通道）</td></tr><tr><td><code>normals</code></td><td><code>List&lt;Vector3></code></td><td>法线</td></tr><tr><td><code>tangents</code></td><td><code>List&lt;Vector4></code></td><td>切线，用于光照方向等</td></tr><tr><td><code>stream</code></td><td><code>List&lt;UIVertex></code></td><td>用于最终生成的合并数据</td></tr></tbody></table><p><strong>Event</strong></p><table><thead><tr><th>事件名</th><th>作用</th><th>使用场景</th></tr></thead><tbody><tr><td><strong><code>onRequestRebuild</code></strong></td><td>**（仅在 Editor 模式下）**当 CanvasRenderer 中的数据无效、需要重建时触发</td><td>编辑器下自定义 UI 编辑、自动刷新组件、响应布局更新等</td></tr></tbody></table><p><a href=https://docs.unity3d.com/ScriptReference/CanvasRenderer.html>CanvasRenderer</a></p><h4 id=image>Image</h4><p>Image用于在<code>Canvas</code>上渲染2D图像</p><h5 id=属性-1>属性</h5><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>Source Image</strong></td><td>要显示的图片（Sprite）</td></tr><tr><td><strong>Color</strong></td><td>渲染颜色，会乘上图片原色，可用于变色、淡入淡出</td></tr><tr><td><strong>Material</strong></td><td>自定义渲染材质（通常用于特殊效果，如描边、渐变）</td></tr><tr><td><strong>Raycast Target</strong></td><td>是否响应点击事件（勾选表示能被 <code>GraphicRaycaster</code> 检测）</td></tr><tr><td><strong>Maskable</strong></td><td>是否允许被遮罩裁剪（勾选表示允许）</td></tr></tbody></table><p><strong>Image Type</strong></p><table><thead><tr><th>类型</th><th>描述</th><th>用途示例</th></tr></thead><tbody><tr><td><strong>Simple</strong></td><td>直接绘制整张图片</td><td>图标、贴图、UI背景</td></tr><tr><td><strong>Sliced</strong></td><td>使用 9 宫格方式拉伸</td><td>按钮、对话框、面板背景</td></tr><tr><td><strong>Tiled</strong></td><td>将图像平铺（不拉伸）填满区域</td><td>网格背景、重复纹理</td></tr><tr><td><strong>Filled</strong></td><td>根据百分比填充图像</td><td>血条、技能冷却、进度圈</td></tr></tbody></table><h5 id=image-type-simple>Image Type: Simple</h5><ul><li><p>Use Sprite Mesh
是否使用Sprite导入时生成的精细网格来渲染这张图片</p><ul><li>勾选：使用Sprite的自定义网格（Polygon Mesh）</li><li>取消：使用默认的矩形网格（Quad）</li></ul></li><li><p>Preserve Aspect
图片在拉伸时是否保持原始宽高比</p></li></ul><h5 id=image-type-sliced>Image Type: Sliced</h5><ul><li><p>Fill Center
是否绘制九宫格中间的中心区域（中心填充）</p><ul><li>勾选：中间区域会被绘制，整个九宫格都会显示</li><li>取消：中间区域不会绘制，只绘制九宫格的四个边和四个角， 这样中心部分会变透明，常用于制作空心边框、框线效果</li></ul></li><li><p>Pixels Per Unit Multiplier
像素与Unity单位之间的转换比例，以调整图片显示的大小，从而不必修改RectTransform大小</p></li></ul><h5 id=image-type-tiled>Image Type: Tiled</h5><p>同上</p><h5 id=image-type-filled>Image Type: Filled</h5><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><strong>Fill Method</strong></td><td>填充方式（Horizontal、Vertical、Radial360、Radial180 等）</td></tr><tr><td><strong>Fill Origin</strong></td><td>填充起点（左/右/上/下/中心）</td></tr><tr><td><strong>Fill Amount</strong></td><td>填充比例（0 到 1）</td></tr><tr><td><strong>Clockwise</strong></td><td>是否顺时针填充</td></tr></tbody></table><h5 id=性能建议>性能建议</h5><table><thead><tr><th>建议</th><th>说明</th></tr></thead><tbody><tr><td>尽量合批</td><td>使用相同材质和图片可减少 draw call</td></tr><tr><td>禁用 <code>Raycast Target</code></td><td>如果不需要点击事件，记得取消勾选提高效率</td></tr><tr><td>使用 <code>Sliced</code></td><td>比 <code>Simple</code> 更适合可拉伸的 UI 元素，避免失真</td></tr><tr><td>用 <code>Mask</code> 做裁剪</td><td>可配合小地图/头像/UI 视窗裁剪区域</td></tr></tbody></table><h5 id=image-api>Image API</h5><p><strong>Static Properties</strong></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>ussClassName</code></td><td>该类型元素默认的 <strong>USS（Unity Style Sheets）类名</strong>。用于样式表（USS 文件）中选择和定义该类型元素的默认样式。</td></tr></tbody></table><p><strong>Properties</strong></p><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><code>image</code></td><td>要显示的贴图（<code>Texture</code> 或 <code>Texture2D</code>）。设置后，<code>Image</code> 会使用此纹理渲染，控件大小可能自动适应纹理尺寸。</td></tr><tr><td><code>scaleMode</code></td><td>图片的缩放模式，使用 <code>ScaleMode</code> 枚举值（如 <code>StretchToFill</code>, <code>ScaleAndCrop</code>, <code>ScaleToFit</code>）控制图片如何适应控件大小。</td></tr><tr><td><code>sourceRect</code></td><td>指定贴图中哪一部分作为源区域显示，使用左上角为参考点的坐标和尺寸（单位为像素）。</td></tr><tr><td><code>sprite</code></td><td>显示的精灵（<code>Sprite</code> 类型）。这是 UI Toolkit 中推荐的图像显示方式，比原始 <code>Texture</code> 更灵活。</td></tr><tr><td><code>tintColor</code></td><td>渲染图片时使用的着色颜色（默认为白色，设置为其他颜色可以改变图片颜色）。</td></tr><tr><td><code>uv</code></td><td>图片的 UV 坐标范围，基于左下角为原点（通常用于手动设置 UV 区域，控制显示纹理的哪一部分）。</td></tr><tr><td><code>vectorImage</code></td><td>用于显示的矢量图（<code>VectorImage</code> 类型，SVG 样式的图像）。适合需要分辨率无损缩放的图标或 UI 图案。</td></tr></tbody></table><p><a href=https://docs.unity3d.com/ScriptReference/UIElements.Image.html>UnityScrpting Image</a></p><h2 id=ui-element>UI Element</h2><h3 id=panel>Panel</h3><p>Panel是用来组织、分组、控制一组UI元素的容器，是UI架构中最基本的结构单位</p><p>本质上是一个普通的<code>GameObject</code></p><blockquote><p>Panel = GameObject + RectTransform + Other Optional Component</p></blockquote><h4 id=常见用途>常见用途</h4><table><thead><tr><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><strong>UI 分组容器</strong></td><td>将一组相关的 UI 元素包在一起（如背包、商店、设置等）</td></tr><tr><td><strong>背景视觉层</strong></td><td>给 UI 添加一个背景板（通常使用半透明黑色）</td></tr><tr><td><strong>控制显示/隐藏</strong></td><td>通过 <code>SetActive()</code> 控制整组 UI 显示与否</td></tr><tr><td><strong>蒙版裁剪</strong></td><td>配合 <code>Mask</code> 或 <code>RectMask2D</code> 使用，裁剪子内容</td></tr><tr><td><strong>动画过渡</strong></td><td>面板之间切换时做位移、渐变等 UI 动画</td></tr><tr><td><strong>局部布局控制</strong></td><td>配合 <code>LayoutGroup</code> 使用，控制子元素的自动排列</td></tr></tbody></table><h3 id=image-1>Image</h3><p>Image = RectTransform + Image<br>组件Image不能脱离RectTransform和CanvasRenderer<br>Image组件见上</p><h3 id=raw-image>Raw Image</h3><p>Raw Image = RectTransform + Canvas Renderer + Raw Image</p><p><img src=/images/Blog/RawImagePanel.jpg alt=RawImagePanel></p><p><code>Raw Image</code>是Unity UI中用于直接显示<code>Texture</code>的组件，区别于<code>Image</code>显示<code>Sprite</code>，<code>RawImage</code>更灵活，适合直接显示非Sprite类型的纹理</p><ul><li><code>RawImage</code>继承自<code>MaskableGraphic</code>，是一个UI可视化组件</li><li>它直接使用一个<code>Texture</code>对象进行绘制，而不需要把纹理先转换成<code>Sprite</code></li><li>适合展示视频帧、RenderTexture、摄像头画面或自定义生成的纹理</li></ul><h4 id=image-vs-rawimage>Image vs RawImage</h4><table><thead><tr><th>方面</th><th>RawImage</th><th>Image</th></tr></thead><tbody><tr><td>显示资源类型</td><td><code>Texture</code></td><td><code>Sprite</code></td></tr><tr><td>是否支持 9 切片</td><td>不支持</td><td>支持</td></tr><tr><td>适合用途</td><td>视频播放、动态纹理显示、非 Sprite 纹理</td><td>UI 图标、按钮、九宫格背景</td></tr><tr><td>是否自动处理边缘</td><td>不支持</td><td>支持切片自动拉伸</td></tr></tbody></table><h3 id=textlegacy>Text(Legacy)</h3><p>UGUI中最早期的文本显示方式之一，Legacy代表它已经被新的系统所取代，但它依然存在于Unity中，作为一种兼容性方案</p><p><img src=/images/Blog/TextPanel.jpg alt=TextPanel></p><p><code>Text</code>是Unity UGUI系统（UnityEngine.UI.Text）中的标准UI组件，用来在Canvas上显示简单的2D文本</p><h4 id=基本属性>基本属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td><strong>Text</strong></td><td>要显示的字符串</td></tr><tr><td><strong>Font</strong></td><td>使用的字体（<code>.ttf</code>）资源</td></tr><tr><td><strong>Font Style</strong></td><td>字体样式（Normal / Bold / Italic）</td></tr><tr><td><strong>Font Size</strong></td><td>字号大小（整数）</td></tr><tr><td><strong>Line Spacing</strong></td><td>行间距倍数</td></tr><tr><td><strong>Rich Text</strong></td><td>是否启用 <code>&lt;b></code>,<code>&lt;i></code> 等富文本语法</td></tr><tr><td><strong>Alignment</strong></td><td>对齐方式（左中右 / 上中下）</td></tr><tr><td><strong>Align By Geometry</strong></td><td>按几何对齐</td></tr><tr><td><strong>Horizontal Overflow</strong></td><td>超出边框时的处理方式（Wrap（换行）/Overflow（溢出）</td></tr><tr><td><strong>Vertical Overflow</strong></td><td>同上，垂直方向 (Truncate/Overflow)</td></tr><tr><td><strong>Best Fit</strong></td><td>是否自动缩放字体以适应文本框大小</td></tr><tr><td><strong>Color</strong></td><td>文本颜色</td></tr><tr><td><strong>Material</strong></td><td>可替换字体材质（如实现描边/阴影）</td></tr><tr><td><strong>Raycast Target</strong></td><td>是否参与事件响应（一般设为 false 提升性能）</td></tr><tr><td><strong>Raycast Padding</strong></td><td>用于扩大或缩小UI元素对射线检测（点击、触摸等交互）的响应区域</td></tr><tr><td><strong>Maskable</strong></td><td>可被遮罩剔除</td></tr></tbody></table><h4 id=工作流程>工作流程</h4><p>Text(Legacy)的渲染流程大致如下：</p><ul><li>将文本用指定字体转换为字符图形</li><li>用字体的字符图集（Font Atlas）作为纹理采样源</li><li>把这些字母绘制为UI顶点</li><li>通过Canvas Renderer渲染出来</li></ul><h4 id=textlegacy的缺点>Text(Legacy)的缺点</h4><table><thead><tr><th>问题</th><th>说明</th></tr></thead><tbody><tr><td>清晰度差</td><td>字体在不同分辨率下可能模糊（Bitmap-based）</td></tr><tr><td>无动态字形支持</td><td>不支持多语言自动扩展字体图集</td></tr><tr><td>没有高级排版功能</td><td>不支持富排版、嵌入图标、文本裁剪等高级功能</td></tr><tr><td>不支持富样式</td><td>难以实现多颜色、高级描边、背景等需求</td></tr><tr><td>性能低</td><td>每次修改文本都会重新生成 UI 顶点，占 GC 和 CPU</td></tr></tbody></table><h4 id=性能提升>性能提升</h4><ul><li>使用高质量<code>.tff</code>字体（防止边缘锯齿）</li><li>打开Best Fit或设置合理的Font Size</li><li>配合Shadow/Outline效果增强可读性</li><li>避免频繁更新文本，防止GC</li></ul><h4 id=textlegacy-api>Text(Legacy) API</h4><h5 id=properties-1>Properties</h5><table><thead><tr><th>属性名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><strong>alignByGeometry</strong></td><td>bool</td><td>是否根据字形几何范围对齐，而非字形度量（更精确的水平对齐）。</td></tr><tr><td><strong>alignment</strong></td><td>TextAnchor</td><td>文本相对于 RectTransform 的对齐方式（左中右，上中下等）。</td></tr><tr><td><strong>cachedTextGenerator</strong></td><td>TextGenerator</td><td>缓存的文本生成器，用于渲染当前可见文本。</td></tr><tr><td><strong>cachedTextGeneratorForLayout</strong></td><td>TextGenerator</td><td>缓存的文本生成器，用于布局计算。</td></tr><tr><td><strong>flexibleHeight</strong></td><td>float</td><td>布局系统调用，表示布局弹性高度。</td></tr><tr><td><strong>flexibleWidth</strong></td><td>float</td><td>布局系统调用，表示布局弹性宽度。</td></tr><tr><td><strong>font</strong></td><td>Font</td><td>使用的字体资源。</td></tr><tr><td><strong>fontSize</strong></td><td>int</td><td>字体渲染大小（像素）。</td></tr><tr><td><strong>fontStyle</strong></td><td>FontStyle</td><td>字体样式，如正常、斜体、粗体等。</td></tr><tr><td><strong>horizontalOverflow</strong></td><td>HorizontalWrapMode</td><td>水平溢出模式（Wrap 或 Overflow），控制文本是否换行。</td></tr><tr><td><strong>layoutPriority</strong></td><td>int</td><td>布局系统调用，布局优先级。</td></tr><tr><td><strong>lineSpacing</strong></td><td>float</td><td>行间距，相对于字体行高的比例，1为正常。</td></tr><tr><td><strong>mainTexture</strong></td><td>Texture</td><td>字体纹理，用于渲染字体。</td></tr><tr><td><strong>minHeight</strong></td><td>float</td><td>布局系统调用，最小高度。</td></tr><tr><td><strong>minWidth</strong></td><td>float</td><td>布局系统调用，最小宽度。</td></tr><tr><td><strong>pixelsPerUnit</strong></td><td>float (只读)</td><td>字体缩放的像素单位，描述字体渲染的像素密度。</td></tr><tr><td><strong>preferredHeight</strong></td><td>float</td><td>由文本生成器计算的理想高度。</td></tr><tr><td><strong>preferredWidth</strong></td><td>float</td><td>由文本生成器计算的理想宽度。</td></tr><tr><td><strong>resizeTextForBestFit</strong></td><td>bool</td><td>是否允许文本自动调整大小以适应容器。</td></tr><tr><td><strong>resizeTextMaxSize</strong></td><td>int</td><td>自动调整时允许的最大字体大小。</td></tr><tr><td><strong>resizeTextMinSize</strong></td><td>int</td><td>自动调整时允许的最小字体大小。</td></tr><tr><td><strong>supportRichText</strong></td><td>bool</td><td>是否支持富文本格式（例如 <code>&lt;b></code>, <code>&lt;i></code>, <code>&lt;color></code> 标签）。</td></tr><tr><td><strong>text</strong></td><td>string</td><td>当前显示的文本内容。</td></tr><tr><td><strong>verticalOverflow</strong></td><td>VerticalWrapMode</td><td>垂直溢出模式，控制文本超出垂直边界时的处理方式（裁剪或溢出）。</td></tr></tbody></table><h5 id=public-method>Public Method</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><strong>CalculateLayoutInputHorizontal</strong></td><td>由布局系统调用，用于计算水平布局输入（如宽度需求）。</td></tr><tr><td><strong>CalculateLayoutInputVertical</strong></td><td>由布局系统调用，用于计算垂直布局输入（如高度需求）。</td></tr><tr><td><strong>FontTextureChanged</strong></td><td>由 <code>FontUpdateTracker</code> 调用，当字体纹理更新时触发的回调。</td></tr><tr><td><strong>GetGenerationSettings</strong></td><td>便捷函数，用于生成并填充文本生成器（TextGenerator）的设置参数。</td></tr></tbody></table><h5 id=protected-method>Protected Method</h5><p><strong>OnDisable</strong></p><h5 id=static-method-1>Static Method</h5><p><strong>GetTextAnchorPivot</strong> 提供一个便捷方法计算锚点向量偏移量</p><p><a href=https://docs.unity3d.com/2019.1/Documentation/ScriptReference/UI.Text.html>UnityScrpting Text(2019.1)</a></p><h3 id=buttonlegacy>Button(Legacy)</h3><p>Unity早期标准控件（UnityEngine.UI.Button）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#a6e22e>Button(Legacy)</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`Rect Transform` + `Canvas Renderer` + `Image` + `Button`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  |__ Text(Legacy)</span>
</span></span></code></pre></div><p><img src=/images/Blog/ButtonCantAddTextComponent.jpg alt=ButtonCantAddTextComponent></p><p>Button组件只能绑定一个<code>Graphic</code>来做交互反馈，比如颜色变化、高亮、禁用状态<br>这个<code>Graphic</code>是通过<code>Button.targetGraphic</code>这个字段指定的，通常是绑定在同一个GameObject上的<code>Image</code>或<code>RawImage</code><br>Unity的默认交互逻辑只能作用于一个</p><p><img src=/images/Blog/Button(Legacy)Panel.jpg alt=Button(Legacy)Panel></p><h4 id=panel-properties>Panel Properties</h4><ul><li><p>Interactable
bool 是否允许按钮响应点击，取消勾选按钮将进入禁用状态（由Transition决定视觉反馈）</p></li><li><p>Transition（状态切换方式）
决定按钮在不同状态下的视觉反馈<br>可选项：</p><ul><li>None 没有任何状态变化</li><li>Color Tint（默认）<ul><li>改变<code>targetGraphic</code>的颜色</li><li>会出现以下设置：<ul><li>Target Graphic：颜色变化作用的目标</li><li>Normal Color：正常状态</li><li>Highlighted Color：鼠标悬停</li><li>Press Color：点击中</li><li>Selected Color：被选中状态（用于导航）</li><li>Disabled Color：禁用状态</li><li>Color Multiplier：颜色强度乘数，<code>最终颜色 = 原始颜色 * Color Multiplier</code></li><li>Fade Duration：颜色渐变持续时间（秒）</li></ul></li></ul></li><li>Sprite Swap<ul><li>会切换不同的图片</li><li>会出现以下设置：<ul><li>Target Graphic</li><li>Highlighted Sprite</li><li>Pressed Sprite</li><li>Disabled Sprite</li></ul></li></ul></li><li>Animation<ul><li>触发Animator控制器中的动画状态</li><li>要求你设置一个带有动画状态机的Animator Controller</li><li>字段：<ul><li>Normal Trigger</li><li>Highlighted Trigger</li><li>Pressed Trigger</li><li>Disabled Trigger</li></ul></li><li>配合Animator参数使用</li></ul></li></ul></li><li><p>Target Graphic</p><ul><li>设置受Transition控制的<code>Graphic</code>组件</li><li>通常是按钮本体上的<code>Image</code></li></ul></li><li><p>Navigation</p><ul><li>控制键盘或手柄方向键操作时，焦点如何移动</li><li>有四种模式：<ul><li>None：不使用导航</li><li>Horizontal / Vertical：自动查找上下左右按钮</li><li>Explicit：手动指定上下左右的按钮</li></ul></li></ul></li><li><p>OnClick()事件</p><ul><li>设置点击按钮时调用的函数</li><li>类型：UnityEvent（可以托脚本组件 + 指定公开方法）</li><li>多个函数可以同时绑定，按顺序依次调用</li></ul></li></ul><h4 id=button的继承结构>Button的继承结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>UIBehaviour
</span></span><span style=display:flex><span>|___ Selectable
</span></span><span style=display:flex><span>          |___Button
</span></span></code></pre></div><p><strong>Selectable</strong>提供了核心交互逻辑：</p><ul><li>状态切换</li><li>导航</li><li>是否可交互等逻辑</li></ul><p><strong>Button</strong>在此基础上扩展了：</p><ul><li><code>onClick</code>事件触发机制</li><li>响应鼠标点击和键盘操作</li></ul><h4 id=button的点击事件流程底层>Button的点击事件流程（底层）</h4><p>1.场景中有<code>EventSystem</code> + <code>GraphicRaycaster</code>
2.鼠标点击UI Canvas上的对象
3.<code>GraphicRaycaster</code>计算哪个UI元素被点击
4.被点到的UI触发<code>IPointerClickHandler</code>接口
5.Button继承这个接口，调用<code>.onClick.Invoke()</code></p><h4 id=button示例>Button示例</h4><h5 id=基础绑定--点击回调>基础绑定 + 点击回调</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.UI;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ButtonExample</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> Button myButton;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> Start() =&gt; myButton.onClick.AddListener(OnButtonClick);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> OnButtonClick() =&gt; Debug.Log(<span style=color:#e6db74>&#34;Click!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=动态创建按钮--设置点击事件>动态创建按钮 + 设置点击事件</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>GameObject buttonObj = <span style=color:#66d9ef>new</span> GameObject(<span style=color:#e6db74>&#34;MyButton&#34;</span>, <span style=color:#66d9ef>typeof</span>(RectTransform), <span style=color:#66d9ef>typeof</span>(CanvasRenderer), <span style=color:#66d9ef>typeof</span>(Image), <span style=color:#66d9ef>typeof</span>(Button));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Button btn = buttonObj.GetComponent&lt;Button&gt;();
</span></span><span style=display:flex><span>btn.onClick.AddListener(() =&gt; Debug.Log(<span style=color:#e6db74>&#34;动态按钮点击&#34;</span>));
</span></span></code></pre></div><h5 id=控制按钮状态变化>控制按钮状态变化</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>myButton.interactable = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>myButton.colors = <span style=color:#66d9ef>new</span> ColorBlock
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  normalColor = Color.white, 
</span></span><span style=display:flex><span>  highlightedColor = Color.yellow, 
</span></span><span style=display:flex><span>  pressedColor = Color,red, 
</span></span><span style=display:flex><span>  disabledColor = Color.gray, 
</span></span><span style=display:flex><span>  colorMultiplier = <span style=color:#ae81ff>1f</span>, 
</span></span><span style=display:flex><span>  fadeDuration = <span style=color:#ae81ff>0.1f</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=自定义扩展>自定义扩展</h4><p>可以通过接口实现更复杂的行为</p><table><thead><tr><th>接口</th><th>功能</th></tr></thead><tbody><tr><td><code>IPointerEnterHandler</code></td><td>鼠标进入时触发</td></tr><tr><td><code>IPointerExitHandler</code></td><td>鼠标离开时触发</td></tr><tr><td><code>IPointerClickHandler</code></td><td>鼠标点击时触发</td></tr><tr><td><code>ISubmitHandler</code></td><td>键盘回车时触发（按钮聚焦状态下）</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyButtonEx</span> : MonoBehaviour, IPointerEnterHandler
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnPointerEnter(PointerEventData eventData) =&gt; Debug.Log(<span style=color:#e6db74>&#34;鼠标进入按钮&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=高级交互>高级交互</h5><p>原始<code>Button</code>不支持长按、双击、右键等高级操作，可以通过扩展<code>EventTrigger</code>或实现接口自己处理，或自定义实现Button组件</p><h3 id=dropdownlegacy>Dropdown(Legacy)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mathematica data-lang=mathematica><span style=display:flex><span>Dropdown <span style=color:#f92672>=</span> RectTransform <span style=color:#f92672>+</span> Canvas Renderer <span style=color:#f92672>+</span> Image <span style=color:#f92672>+</span> Dropdown
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>___Label <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>当前选中项</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>___Arrow <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>小箭头实现</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>___Template <span style=color:#f92672>=</span> RectTransform <span style=color:#f92672>+</span> Canvas Renderer <span style=color:#f92672>+</span> Image <span style=color:#f92672>+</span> Scroll Rect <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>下拉菜单模板</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>___Viewport
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>      <span style=color:#f92672>|</span>___Content
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>             <span style=color:#f92672>|</span>___Item <span style=color:#f92672>=</span> RectTransform <span style=color:#f92672>+</span> Toggle
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>                   <span style=color:#f92672>|</span>___Item Background
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>                   <span style=color:#f92672>|</span>___Item Checkmark
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>                   <span style=color:#f92672>|</span>___Item Label
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>___Scrollbar <span style=color:#f92672>=</span> RectTransform <span style=color:#f92672>+</span> Canvas Renderer <span style=color:#f92672>+</span> Image <span style=color:#f92672>+</span> Scrollbar
</span></span><span style=display:flex><span>                <span style=color:#f92672>|</span>___Sliding Area
</span></span><span style=display:flex><span>                           <span style=color:#f92672>|</span>___Handle
</span></span></code></pre></div><h4 id=dropdown-panel>Dropdown Panel</h4><p><img src=/images/Blog/DropdownPanel.jpg alt=DropdownPanel></p><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td><strong>Template</strong></td><td>展开后的菜单列表的模板（Template）</td></tr><tr><td><strong>Caption Text</strong></td><td>当前选项显示的 Label 文本组件</td></tr><tr><td><strong>Caption Image</strong></td><td>当前选项显示的 Image（可选）</td></tr><tr><td><strong>Item Text</strong></td><td>下拉项显示用的 Text</td></tr><tr><td><strong>Item Image</strong></td><td>下拉项使用的图片（可选）</td></tr><tr><td><strong>Options</strong></td><td>所有的选项，<code>Dropdown.OptionData</code> 列表</td></tr><tr><td><strong>Value</strong></td><td>当前选中项的索引</td></tr><tr><td><strong>Alpha Fade Speed</strong></td><td>下拉列表打开或关闭时，列表的透明度变化速度</td></tr><tr><td><strong>OnValueChanged</strong></td><td>回调事件（当选项改变时触发）</td></tr></tbody></table><h4 id=scroll-rect-panel>Scroll Rect Panel</h4><p>Dropdown上的Scroll Rect是专用于Dropdown的，区别于通用的Scroll Rect</p><p><img src=/images/Blog/ScrollRectPanelofDropdown.jpg alt=ScrollRectPanelofDropdown></p><table><thead><tr><th>组件/属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>Content</strong></td><td>要滚动的内容（通常是一个RectTransform，里面包含所有需要滚动的元素）</td></tr><tr><td><strong>Viewport</strong></td><td>可视区域（显示区域），内容超出部分会被裁剪</td></tr><tr><td><strong>Horizontal/Vertical</strong></td><td>是否开启水平或垂直滚动</td></tr><tr><td><strong>Movement Type</strong></td><td>滚动行为类型：</td></tr><tr><td>    - Unrestricted</td><td>内容滚动无限制，超出视口可自由移动</td></tr><tr><td>    - Elastic</td><td>弹性滚动，拖拽到边界时会有弹回效果</td></tr><tr><td>    - Clamped</td><td>内容滚动被限制在边界内，无法拖出视口之外</td></tr><tr><td><strong>Elasticity</strong></td><td>弹性系数，决定弹性滚动的“软硬度”</td></tr><tr><td><strong>Inertia</strong></td><td>惯性开关，决定拖拽释放后内容是否继续滑动</td></tr><tr><td><strong>Deceleration Rate</strong></td><td>惯性减速度，惯性滚动速度衰减快慢</td></tr><tr><td><strong>Scroll Sensitivity</strong></td><td>鼠标滚轮或触控滑动的灵敏度</td></tr><tr><td><strong>OnValueChanged</strong></td><td>滚动事件</td></tr></tbody></table><h5 id=工作原理>工作原理</h5><ul><li>Scroll Rect监听用户的拖拽操作，根据拖动距离改变Content的位置</li><li>超出Viewport的区域的内容会被裁剪</li><li>支持惯性滚动，让滚动更自然流畅</li><li>可以通过代码控制滚动位置、滚动监听事件等</li></ul><h4 id=viewport>Viewport</h4><ul><li>Viewport是一个RectTransform，它定义了下拉列表展开时可视的区域大小和位置</li><li>Viewport通常带有一个<code>Mask</code>组件（或<code>RectMask2D</code>），用来裁剪内容， 确保超出范围的内容不显示</li><li>Viewport下挂载<code>Content</code>，Content里会动态生成每个选项 （Item）</li><li>Content是一个垂直排列的容器（通常有Vertical Layout Group和 Content Size Fitter），它控制所有选项的排列和尺寸</li></ul><h4 id=示例>示例</h4><p><strong>创建一个Dropdown并监听选择变化</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.UI;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DropdownExample</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> Dropdown myDropdown;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    myDropdown.onValueChanged.AddListener(OnDropdownValueChanged);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    myDropdown.options.Clear();
</span></span><span style=display:flex><span>    myDropdown.options.Add(<span style=color:#66d9ef>new</span> Dropdown.OptionData(<span style=color:#e6db74>&#34;选项 A&#34;</span>));
</span></span><span style=display:flex><span>    myDropdown.options.Add(<span style=color:#66d9ef>new</span> Dropdown.OptionData(<span style=color:#e6db74>&#34;选项 B&#34;</span>));
</span></span><span style=display:flex><span>    myDropdown.options.Add(<span style=color:#66d9ef>new</span> Dropdown.OptionData(<span style=color:#e6db74>&#34;选项 C&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    myDropdown.<span style=color:#66d9ef>value</span> = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> OnDropdownValueChanged(<span style=color:#66d9ef>int</span> index)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    Debug.Log(<span style=color:#e6db74>&#34;当前选择索引：&#34;</span> + index);
</span></span><span style=display:flex><span>    Dubug.Log(<span style=color:#e6db74>&#34;当前选择内容：&#34;</span> + myDropdown.options[index].text);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=扩展>扩展</h4><table><thead><tr><th>用法</th><th>说明</th></tr></thead><tbody><tr><td>动态加载选项</td><td>用代码控制 options 数据源，比如从配置文件读取</td></tr><tr><td>多级联动</td><td>比如：国家 -> 城市，选择国家后动态更新城市列表</td></tr><tr><td>自定义表现</td><td>替换 Item 的 Toggle 结构，实现自定义布局或图标</td></tr></tbody></table><h4 id=api>API</h4><p><strong>Properties</strong></p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>options</code></td><td><code>List&lt;Dropdown.OptionData></code></td><td>Dropdown 的所有选项列表</td></tr><tr><td><code>value</code></td><td><code>int</code></td><td>当前选中选项的索引（从 0 开始）</td></tr><tr><td><code>captionText</code></td><td><code>Text</code></td><td>用于显示当前选择文本的 UI Text 组件</td></tr><tr><td><code>captionImage</code></td><td><code>Image</code></td><td>显示当前选择图片的 Image 组件（可选）</td></tr><tr><td><code>itemText</code></td><td><code>Text</code></td><td>Dropdown 选项模板中 Item 的文本组件</td></tr><tr><td><code>itemImage</code></td><td><code>Image</code></td><td>Dropdown 选项模板中 Item 的图片组件</td></tr><tr><td><code>template</code></td><td><code>RectTransform</code></td><td>Dropdown 选项列表模板（包含 Viewport 等）</td></tr></tbody></table><p><strong>Event</strong></p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>onValueChanged</code></td><td><code>Dropdown.DropdownEvent</code></td><td>选中项改变时触发，带选中索引</td></tr></tbody></table><p><strong>Method</strong></p><table><thead><tr><th>名称</th><th>签名</th><th>说明</th></tr></thead><tbody><tr><td><code>ClearOptions()</code></td><td><code>void ClearOptions()</code></td><td>清空所有选项</td></tr><tr><td><code>AddOptions(List&lt;string>)</code></td><td><code>void AddOptions(List&lt;string> options)</code></td><td>添加字符串选项列表</td></tr><tr><td><code>AddOptions(List&lt;Sprite>)</code></td><td><code>void AddOptions(List&lt;Sprite> options)</code></td><td>添加图片选项列表</td></tr><tr><td><code>AddOptions(List&lt;Dropdown.OptionData>)</code></td><td><code>void AddOptions(List&lt;Dropdown.OptionData> options)</code></td><td>添加 OptionData 列表</td></tr><tr><td><code>RefreshShownValue()</code></td><td><code>void RefreshShownValue()</code></td><td>刷新当前显示的选项文本和图片</td></tr><tr><td><code>Show()</code></td><td><code>void Show()</code></td><td>展开下拉列表</td></tr><tr><td><code>Hide()</code></td><td><code>void Hide()</code></td><td>关闭下拉列表</td></tr></tbody></table><h3 id=input-fieldlegacy>Input Field(Legacy)</h3><p><code>Input Field</code>是Unity中用于接收用户输入的UI组件，主要用于文本输入（如用户名，密码，聊天框等）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>InputField
</span></span><span style=display:flex><span>|—— Palceholder(Text或TMP_Text)
</span></span><span style=display:flex><span>|__ Text
</span></span></code></pre></div><ul><li>InputField：主控件，管理交互逻辑</li><li>Placeholder：提示文字，内容为空时显示</li><li>Text：用户输入文本</li></ul><h4 id=input-field-panel>Input Field Panel</h4><p><img src=/images/Blog/InputFieldPanel.jpg alt=InputFieldPanel></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>Text Component</code></td><td>用户输入文字组件</td></tr><tr><td><code>text</code></td><td>当前输入的字符串</td></tr><tr><td><code>placeholder</code></td><td>占位文字组件（Text 或 TMP_Text）</td></tr><tr><td><code>characterLimit</code></td><td>输入字符数限制</td></tr><tr><td><code>contentType</code></td><td>内容类型（如密码、整数、电子邮件等）</td></tr><tr><td><code>lineType</code></td><td>单行或多行</td></tr><tr><td><code>inputType</code></td><td>是否隐藏输入字符（如密码）</td></tr><tr><td><code>keyboardType</code></td><td>移动端的虚拟键盘类型</td></tr><tr><td><code>readOnly</code></td><td>是否只读</td></tr><tr><td><code>caretBlinkRate</code></td><td>光标闪烁速度</td></tr><tr><td><code>Custom Caret Color</code></td><td>自定义光标颜色</td></tr><tr><td><code>Hide Mobile Input</code></td><td>隐藏移动设备键盘上方的原生输入框</td></tr><tr><td><code>selectionColor</code></td><td>选中文本的背景色</td></tr><tr><td><code>should Activate OnSelect</code></td><td>当InputField被选中时，是否自动激活并弹出键盘</td></tr><tr><td><code>On Value Changed</code></td><td>当用户每次修改输入内容时调用（每个字符变动都会触发）</td></tr><tr><td><code>On Submit</code></td><td>当用户提交输入时触发即按下回车键时</td></tr><tr><td><code>On End Edit</code></td><td>当输入框失去焦点或用户按下回车键时触发</td></tr></tbody></table><h4 id=api-1>API</h4><h5 id=properties-2>Properties</h5><table><thead><tr><th>属性名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>text</code></td><td><code>string</code></td><td>当前输入框中的文本内容</td></tr><tr><td><code>textComponent</code></td><td><code>Text</code></td><td>用于显示文本的 UI 组件</td></tr><tr><td><code>placeholder</code></td><td><code>Graphic</code></td><td>占位符（提示文本）组件</td></tr><tr><td><code>characterLimit</code></td><td><code>int</code></td><td>最大输入字符数，0 表示不限制</td></tr><tr><td><code>contentType</code></td><td><code>ContentType</code></td><td>输入内容类型（标准、密码、数字等）</td></tr><tr><td><code>inputType</code></td><td><code>InputType</code></td><td>输入显示方式（标准、密码隐藏等）</td></tr><tr><td><code>keyboardType</code></td><td><code>TouchScreenKeyboardType</code></td><td>移动端软键盘类型</td></tr><tr><td><code>characterValidation</code></td><td><code>CharacterValidation</code></td><td>字符校验规则</td></tr><tr><td><code>multiLine</code></td><td><code>bool</code></td><td>是否支持多行输入</td></tr><tr><td><code>lineType</code></td><td><code>LineType</code></td><td>输入框的换行方式</td></tr><tr><td><code>readOnly</code></td><td><code>bool</code></td><td>是否只读</td></tr><tr><td><code>onValidateInput</code></td><td><code>Func&lt;string, int, char></code></td><td>自定义输入字符验证回调</td></tr><tr><td><code>caretPosition</code></td><td><code>int</code></td><td>当前光标位置</td></tr><tr><td><code>caretWidth</code></td><td><code>int</code></td><td>光标宽度（像素）</td></tr><tr><td><code>caretBlinkRate</code></td><td><code>float</code></td><td>光标闪烁速度（次数/秒）</td></tr><tr><td><code>caretColor</code></td><td><code>Color</code></td><td>光标颜色</td></tr><tr><td><code>customCaretColor</code></td><td><code>bool</code></td><td>是否使用自定义光标颜色</td></tr><tr><td><code>selectionColor</code></td><td><code>Color</code></td><td>文本选中时的背景色</td></tr><tr><td><code>selectionAnchorPosition</code></td><td><code>int</code></td><td>选中起点</td></tr><tr><td><code>selectionFocusPosition</code></td><td><code>int</code></td><td>选中终点</td></tr><tr><td><code>shouldHideMobileInput</code></td><td><code>bool</code></td><td>是否隐藏移动端原生输入框</td></tr><tr><td><code>touchScreenKeyboard</code></td><td><code>TouchScreenKeyboard</code></td><td>当前软键盘实例</td></tr><tr><td><code>isFocused</code></td><td><code>bool</code></td><td>输入框当前是否获得焦点</td></tr><tr><td><code>wasCanceled</code></td><td><code>bool</code></td><td>输入是否被取消（如按返回键）</td></tr><tr><td><code>onValueChanged</code></td><td><code>UnityEvent&lt;string></code></td><td>输入内容改变时触发</td></tr><tr><td><code>onEndEdit</code></td><td><code>UnityEvent&lt;string></code></td><td>输入结束时触发（失焦或按回车）</td></tr><tr><td><code>asteriskChar</code></td><td><code>char</code></td><td>密码输入时显示的字符（默认是 <code>*</code>）</td></tr></tbody></table><h5 id=public-methods>Public Methods</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>ActivateInputField()</code></td><td>激活输入框，开始处理输入事件（获得焦点，弹出软键盘）</td></tr><tr><td><code>DeactivateInputField()</code></td><td>取消激活输入框，停止处理事件；如果输入未取消，会发送提交事件</td></tr><tr><td><code>ForceLabelUpdate()</code></td><td>强制立即刷新文本显示（重新计算光标位置和可见文本）</td></tr><tr><td><code>GraphicUpdateComplete()</code></td><td>（接口方法）通知画布图形更新完成</td></tr><tr><td><code>LayoutComplete()</code></td><td>（接口方法）通知布局更新完成</td></tr><tr><td><code>MoveTextEnd()</code></td><td>将光标移动到文本末尾</td></tr><tr><td><code>MoveTextStart()</code></td><td>将光标移动到文本开头</td></tr><tr><td><code>OnBeginDrag()</code></td><td>处理开始拖动事件，判断是否监听拖动</td></tr><tr><td><code>OnDeselect()</code></td><td>处理失去焦点事件</td></tr><tr><td><code>OnDrag()</code></td><td>处理拖动事件</td></tr><tr><td><code>OnEndDrag()</code></td><td>处理拖动结束事件，停止监听拖动</td></tr><tr><td><code>OnPointerClick()</code></td><td>处理指针点击事件</td></tr><tr><td><code>OnPointerDown()</code></td><td>处理指针按下事件</td></tr><tr><td><code>OnSubmit()</code></td><td>处理提交事件（通常是按回车或软键盘上的提交键）</td></tr><tr><td><code>OnUpdateSelected()</code></td><td>处理选中更新事件（持续输入、光标移动等）</td></tr><tr><td><code>ProcessEvent()</code></td><td>内部辅助函数，用于处理输入事件</td></tr><tr><td><code>Rebuild()</code></td><td>重建输入框几何体（光标、选中高亮等）</td></tr><tr><td><code>SetTextWithoutNotify()</code></td><td>设置输入框文本内容但不触发 <code>onValueChanged</code> 事件，常用于程序内部修改文本时避免事件递归触发</td></tr></tbody></table><h5 id=protected-methods>Protected Methods</h5><table><thead><tr><th>方法名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>Append(char c)</code></td><td>在输入框当前文本末尾追加一个字符。</td></tr><tr><td><code>ClampPos(ref int pos)</code></td><td>限制传入的光标或选择位置，保证不超过文本长度范围。</td></tr><tr><td><code>GetCharacterIndexFromPosition(Vector2 pos)</code></td><td>根据鼠标/指针位置计算对应文本中的字符索引。</td></tr><tr><td><code>KeyPressed(Event evt)</code></td><td>处理键盘事件，根据按键执行对应动作（输入、删除、光标移动等）。</td></tr><tr><td><code>OnDisable()</code></td><td>MonoBehaviour 生命周期函数，输入框禁用时调用（做清理等）。</td></tr><tr><td><code>OnFocus()</code></td><td>输入框获得焦点时初始化相关属性，准备输入。</td></tr><tr><td><code>SelectAll()</code></td><td>选中输入框内所有文本，通常用于快捷键 Ctrl+A 操作。</td></tr><tr><td><code>SendOnSubmit()</code></td><td>触发提交事件（相当于用户确认输入，如按回车）。</td></tr><tr><td><code>UpdateLabel()</code></td><td>刷新显示的文本内容，更新 UI 视图（光标和选区位置）。</td></tr><tr><td><code>Validate(string text, int charIndex, char addedChar)</code></td><td>对输入的字符进行校验（依据 <code>characterValidation</code> 设置）。</td></tr></tbody></table><h5 id=delegates>Delegates</h5><table><thead><tr><th>属性名</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td><code>onValidateInput</code></td><td><code>InputField.OnValidateInput</code></td><td>自定义每个输入字符的校验</td></tr></tbody></table><h3 id=textmeshprotmp>TextMeshPro(TMP)</h3><p>TextMeshPro是Unity提供的高级文本渲染系统，相比传统的<code>UI.Text</code>和<code>TextMesh</code>，它提供了：</p><ul><li>更清晰的字体渲染（支持SDF技术）</li><li>丰富的排版控制（文字间距、行距、边框、阴影等）</li><li>更强的富文本支持（颜色、图标、动画）</li><li>更高的性能（批量合并、材质复用）</li></ul><h4 id=tmp组件类型>TMP组件类型</h4><table><thead><tr><th>组件名称</th><th>用途说明</th></tr></thead><tbody><tr><td><strong>TextMeshPro (3D)</strong></td><td>用于3D世界的文本渲染（替代 <code>TextMesh</code>）</td></tr><tr><td><strong>TextMeshProUGUI (UI)</strong></td><td>用于UI Canvas的文本渲染（替代 <code>UI.Text</code>）</td></tr></tbody></table><h4 id=tmp-importer>TMP Importer</h4><p><img src=/images/Blog/TMPImporter.jpg alt="TMP Importer"></p><p>TMP Importer是Unity第一次导入TextMeshPro包时自动弹出的一个向导窗口，也可以手动从菜单中打开<br>它的作用是：</p><ul><li>导入TMP的资源（默认字体、材质、示例场景等）</li><li>升级旧的UI元素（可选，把现有的<code>Text</code>升级为<code>TextMeshProUGUI</code>）</li><li>帮助初始化TMP设置</li></ul><h5 id=何时会看到tmp-importer>何时会看到TMP Importer</h5><ul><li>第一次使用TMP功能时</li><li>第一次安装TMP包时</li><li>手动打开 <code>Window -> TextMeshPro -> Import TMP Essential Resources</code></li></ul><h5 id=tmp-importer提供的资源内容>TMP Importer提供的资源内容</h5><table><thead><tr><th>内容</th><th>说明</th></tr></thead><tbody><tr><td><strong>Default Font Asset</strong></td><td>默认使用的字体（LiberationSans SDF）</td></tr><tr><td><strong>Default Material Presets</strong></td><td>支持描边、阴影的材质</td></tr><tr><td><strong>TMP Settings.asset</strong></td><td>全局设置配置</td></tr><tr><td><strong>Shaders</strong></td><td>TMP 的渲染器使用的 SDF Shader</td></tr><tr><td><strong>Examples & Extras（可选）</strong></td><td>示例场景、脚本、UI 风格演示等</td></tr></tbody></table><h4 id=tmp-vs-textlegacy>TMP vs Text(Legacy)</h4><table><thead><tr><th>功能/特性</th><th>Unity UI.Text</th><th>TextMeshPro</th></tr></thead><tbody><tr><td>清晰度</td><td>低</td><td>高（SDF）</td></tr><tr><td>富文本支持</td><td>有限</td><td>强大</td></tr><tr><td>图文混排</td><td>无</td><td>有</td></tr><tr><td>字体控制</td><td>基本</td><td>精细</td></tr><tr><td>性能（大批量）</td><td>低</td><td>高</td></tr><tr><td>动态字体加载</td><td>有</td><td>支持</td></tr></tbody></table><p><strong>SDF字体</strong>
TMP使用SDF来实现高质量的文本缩放和效果（描边、投影）</p><ul><li>在导入字体时会生成一个<code>.asset</code>文件（字体图集 + 字形信息）</li><li>SDF渲染不依赖分辨率，UI可以任意缩放不失真</li></ul><h4 id=texttmp>Text（TMP）</h4><p><img src=/images/Blog/TMPTextPanel_1.jpg alt=TMPTextPanel_1>
<img src=/images/Blog/TMPTextPanel_2.jpg alt=TMPTextPanel_2></p><h5 id=基础设置区>基础设置区</h5><ul><li>Text Input：文字内容输入框（直接修改会改变显示内容）</li><li>Enable RTL Editor：启用从右到左语言支持（如阿拉伯语、希伯来语）</li><li>Text Style：选择预设的文字样式（一般用不到，除非用Style Sheet）</li></ul><h5 id=main-settings>Main Settings</h5><ul><li>Font Asset：当前使用的字体资源</li><li>Material Preset：当前字体使用的材质（会影响颜色、描边等）</li><li>Font Style：B（粗体）、I（斜体）、U（下划线）、S（删除线）、AB（全部大写）、SC（小型大写）</li><li>Font Size / Auto Size：字号和是否自动缩放</li><li>Vertex Color：文字的顶点色（可用于动态变色）</li><li>Spacing Options：控制字符、单词、段落、行的间距</li><li>Mapping：水平/垂直映射方式，一般设为Character即可</li></ul><h5 id=extra-settings>Extra Settings</h5><ul><li>Margins：文字四边内边距</li><li>Geometry Sorting：渲染顺序（用于粒子、透明叠加等高级场景）</li><li>Is Scale Static：是否标记为静态缩放（用于性能优化）</li><li>Rich Text：是否允许富文本标签（如 <color>）</li><li>Raycast Target：是否能被点击或射线检测命中</li><li>Maskable：是否允许被 UI Mask 遮罩裁剪</li><li>Parse Escape Characters：是否解析转义符 \n、\t</li><li>Visible Descender：显示下沉字符（如 g, y）的空间</li><li>Sprite Asset：图文混排用的精灵图集</li><li>Style Sheet Asset：文字样式预设集合</li><li>Kerning：特定字符对之间的间距微调，用于让文本在视觉上更加美观、易读</li><li>Extra Padding：给字符添加额外的像素充填区域，以避免某些视觉效果被裁剪或显示不完整</li></ul><h5 id=material-inspector>Material Inspector</h5><ul><li><p>Shader</p></li><li><p>Face（主体文字）</p><ul><li>Color：字体本体颜色</li><li>Softness：模糊程度（文字边缘越柔和）</li><li>Dilate：扩张/收缩字体（负值让文字细一点）</li></ul></li><li><p>Outline（描边）</p><ul><li>Color：描边颜色</li><li>Thickness：描边厚度（默认是0，没有描边）</li></ul></li><li><p>Underlay（阴影）</p></li><li><p>Debug Settings（Shader调试）</p></li></ul><h3 id=toggle>Toggle</h3><h4 id=结构>结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mathematica data-lang=mathematica><span style=display:flex><span>Toggle <span style=color:#f92672>=</span> Rect Transform <span style=color:#f92672>+</span> Toggle
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___Background(Image)<span style=color:#960050;background-color:#1e0010>:勾选框的背景</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>        <span style=color:#f92672>|</span>___Checkmark<span style=color:#960050;background-color:#1e0010>（</span>Image<span style=color:#960050;background-color:#1e0010>）：√</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___Label(Text)<span style=color:#960050;background-color:#1e0010>：名称</span>
</span></span></code></pre></div><h4 id=toggle-panel>Toggle Panel</h4><p><img src=/images/Blog/TogglePanel.jpg alt=TogglePanel></p><table><thead><tr><th>属性名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>isOn</code></td><td><code>bool</code></td><td>当前是否勾选，<code>true</code> 表示已选中</td></tr><tr><td><code>onValueChanged</code></td><td><code>UnityEvent&lt;bool></code></td><td>状态切换时的回调，传入参数为新的状态</td></tr><tr><td><code>interactable</code></td><td><code>bool</code></td><td>是否可以被点击</td></tr><tr><td><code>graphic</code></td><td><code>Graphic</code></td><td>勾选图像（Checkmark）</td></tr><tr><td><code>group</code></td><td><code>ToggleGroup</code></td><td>所属的 ToggleGroup（用于单选）</td></tr><tr><td><code>Toggle Transition</code></td><td><code>Toggle Transition</code></td><td>状态切换时的视觉过渡效果</td></tr></tbody></table><h4 id=示例-1>示例</h4><h5 id=获取并监听toggle状态>获取并监听Toggle状态</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.UI;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ToggleExample</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> Toggle myToggle;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    myToggle.onValueChanged.AddListener(OnToggleChanged);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> OnToggleChanged(<span style=color:#66d9ef>bool</span> isOn) =&gt; Debug.Log(<span style=color:#e6db74>&#34;当前 Toggle 状态&#34;</span> + isOn);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=toggle-group单选组>Toggle Group(单选组)</h4><p><code>ToggleGroup</code>组件用于实现多个Toggle的单选功能，类似于网页中的<code>radio button</code></p><p>设置方法：<br>1.创建一个空物体并挂载<code>ToggleGroup</code><br>2.将多个Toggle拖入该物体并在Inspector中的Toggle组件上设置<code>Group</code>为这个ToggleGroup<br>3.每次只能勾选一个Toggle</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> ToggleGroup toggleGroup;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> GetSelectedToggle()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  Toggle selected = toggleGroup.ActiveToggles().FirstOrDefault();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (selected != <span style=color:#66d9ef>null</span>) Debug.Log(<span style=color:#e6db74>&#34;当前选中项： &#34;</span> + selected.name);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=api-2>API</h4><h5 id=properties-3>Properties</h5><table><thead><tr><th>属性名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>graphic</code></td><td><code>Graphic</code></td><td>受状态影响的图像，通常是用于显示勾选标记的 <code>Checkmark</code>（<code>Image</code> 或其他 <code>Graphic</code>）。</td></tr><tr><td><code>group</code></td><td><code>ToggleGroup</code></td><td>当前 Toggle 所属于的 ToggleGroup，用于实现“单选”逻辑。</td></tr><tr><td><code>isOn</code></td><td><code>bool</code></td><td>当前 Toggle 是否被选中，<code>true</code> 表示“开”；也可用于代码设置状态。</td></tr><tr><td><code>onValueChanged</code></td><td><code>UnityEvent&lt;bool></code></td><td>当 Toggle 状态发生改变时触发的事件回调，参数是新的状态（true/false）。</td></tr><tr><td><code>toggleTransition</code></td><td><code>Toggle.ToggleTransition</code></td><td>状态切换的视觉过渡方式，枚举类型：<code>None</code> 或 <code>Fade</code>（淡入淡出）。</td></tr></tbody></table><h5 id=public-methods-1>Public Methods</h5><table><thead><tr><th>方法 / 接口</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>GraphicUpdateComplete()</code></td><td><code>ICanvasElement</code> 接口方法</td><td>图形更新完成时被调用（Canvas 渲染流程的一部分）。通常无需手动调用。</td></tr><tr><td><code>LayoutComplete()</code></td><td><code>ICanvasElement</code> 接口方法</td><td>布局更新完成时调用，确保组件根据布局正确显示。</td></tr><tr><td><code>Rebuild(CanvasUpdate update)</code></td><td><code>ICanvasElement</code> 接口方法</td><td>当 UI Canvas 需要重建时被调用，用于更新 Toggle 的布局或图形状态。</td></tr><tr><td><code>OnPointerClick(PointerEventData eventData)</code></td><td><code>IPointerClickHandler</code> 接口方法</td><td>当 Toggle 被鼠标点击或触控点击时触发。会自动切换 <code>isOn</code> 状态并触发 <code>onValueChanged</code>。</td></tr><tr><td><code>OnSubmit(BaseEventData eventData)</code></td><td><code>ISubmitHandler</code> 接口方法</td><td>当用户按下“提交键”（如 Enter）时触发（用于键盘/手柄操作 UI）。</td></tr><tr><td><code>SetIsOnWithoutNotify(bool value)</code></td><td>自定义方法</td><td><strong>设置 Toggle 状态但不触发 <code>onValueChanged</code> 回调</strong>，适合你在代码中手动切换状态但不希望触发监听器时使用。</td></tr></tbody></table><h5 id=protected-mehtods>Protected Mehtods</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>OnDisable</code></td><td>参照MonoBehaviour.OnDisable</td></tr></tbody></table><h3 id=slider>Slider</h3><h4 id=结构-1>结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mathematica data-lang=mathematica><span style=display:flex><span>Slider <span style=color:#f92672>=</span> Rect Transform <span style=color:#f92672>+</span> Slider
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___Background(Image)<span style=color:#960050;background-color:#1e0010>：滑动条颜色（不可变部分）</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___Fill Area<span style=color:#960050;background-color:#1e0010>：包裹</span>Fill<span style=color:#960050;background-color:#1e0010>区域</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>       <span style=color:#f92672>|</span>___Fill(image)<span style=color:#960050;background-color:#1e0010>：实际充填区域，随着值的改变而拉伸</span><span style=color:#f92672>/</span><span style=color:#960050;background-color:#1e0010>缩放</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___Handle Slide Area<span style=color:#960050;background-color:#1e0010>：可滑动范围的区域容器</span>
</span></span><span style=display:flex><span>             <span style=color:#f92672>|</span>___Handle(image)<span style=color:#960050;background-color:#1e0010>：可拖动的滑块，通常是个图标或者圆点</span>
</span></span></code></pre></div><h4 id=slider-panel>Slider Panel</h4><p><img src=/images/Blog/SliderPanel.jpg alt=SliderPanel></p><ul><li>Whole Numbers：是否只允许整数</li></ul><h4 id=api-3>API</h4><h5 id=properties-4>Properties</h5><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>direction</code></strong></td><td><code>Slider.Direction</code></td><td>滑动条的方向，从最小值到最大值的滑动方向。<br>可选：<br>• <code>LeftToRight</code><br>• <code>RightToLeft</code><br>• <code>BottomToTop</code><br>• <code>TopToBottom</code></td></tr><tr><td><strong><code>fillRect</code></strong></td><td><code>RectTransform</code></td><td>指定一个 <code>RectTransform</code>，作为滑动条的填充区域。滑动值变化时会调整此区域的大小。</td></tr><tr><td><strong><code>handleRect</code></strong></td><td><code>RectTransform</code></td><td>指定滑块的 <code>RectTransform</code>，用于显示可拖动的手柄。</td></tr><tr><td><strong><code>maxValue</code></strong></td><td><code>float</code></td><td>滑动条允许的最大值。</td></tr><tr><td><strong><code>minValue</code></strong></td><td><code>float</code></td><td>滑动条允许的最小值。</td></tr><tr><td><strong><code>value</code></strong></td><td><code>float</code></td><td>当前的滑动值。可以手动设置，会同步更新滑块位置和填充。</td></tr><tr><td><strong><code>normalizedValue</code></strong></td><td><code>float</code> (只读/可设)</td><td>当前值归一化后（范围 0 到 1）的表示。设置它可以等价于设置 <code>value</code>。</td></tr><tr><td><strong><code>onValueChanged</code></strong></td><td><code>UnityEvent&lt;float></code></td><td>当 <code>value</code> 改变时触发的回调事件。可以在 Inspector 中指定函数响应变化。</td></tr><tr><td><strong><code>wholeNumbers</code></strong></td><td><code>bool</code></td><td>是否只允许整数值。勾选后即使你滑动到小数位置，也会自动取整。</td></tr></tbody></table><p><strong>示例：设置Slider参数</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> Slider mySlider;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  mySlider.minValue = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  mySlider.maxValue = <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>  mySlider.<span style=color:#66d9ef>value</span> = <span style=color:#ae81ff>50</span>;;
</span></span><span style=display:flex><span>  mySlider.wholeNumbers = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  mySlider.onValueChanged.AddListener(OnSliderValueChanged);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> OnSliderValueChanged(<span style=color:#66d9ef>float</span> val) =&gt; Debug.Log(<span style=color:#e6db74>&#34;当前值&#34;</span> + val);
</span></span></code></pre></div><h5 id=public-methods-2>Public Methods</h5><table><thead><tr><th>方法名</th><th>来源接口 / 基类</th><th>说明</th></tr></thead><tbody><tr><td><strong>FindSelectableOnDown()</strong></td><td><code>Selectable</code></td><td>返回下方的可选 UI 元素（用于键盘/手柄导航）。</td></tr><tr><td><strong>FindSelectableOnUp()</strong></td><td><code>Selectable</code></td><td>返回上方的可选 UI 元素。</td></tr><tr><td><strong>FindSelectableOnLeft()</strong></td><td><code>Selectable</code></td><td>返回左侧的可选 UI 元素。</td></tr><tr><td><strong>FindSelectableOnRight()</strong></td><td><code>Selectable</code></td><td>返回右侧的可选 UI 元素。</td></tr><tr><td><strong>GraphicUpdateComplete()</strong></td><td><code>ICanvasElement</code></td><td>在 UI 图形重绘完成时调用。</td></tr><tr><td><strong>LayoutComplete()</strong></td><td><code>ICanvasElement</code></td><td>在 UI 布局更新完成时调用。</td></tr><tr><td><strong>Rebuild(CanvasUpdate update)</strong></td><td><code>ICanvasElement</code></td><td>当 Canvas 需要重建 UI 时调用（刷新布局和图形）。</td></tr><tr><td><strong>OnInitializePotentialDrag(PointerEventData)</strong></td><td><code>IInitializePotentialDragHandler</code></td><td>初始化拖拽状态，设置拖拽方向或行为。</td></tr><tr><td><strong>OnDrag(PointerEventData)</strong></td><td><code>IDragHandler</code></td><td>当用户拖动 Handle 时调用，更新滑动值。</td></tr><tr><td><strong>OnMove(AxisEventData)</strong></td><td><code>IMoveHandler</code></td><td>当使用键盘或手柄操作滑块时调用（如方向键）。</td></tr><tr><td><strong>SetDirection(Direction, bool)</strong></td><td><code>Slider</code> 自身</td><td>设置滑动方向，并决定是否调整 Fill 和 Handle 的布局。</td></tr><tr><td><strong>SetValueWithoutNotify(float)</strong></td><td><code>Slider</code> 自身</td><td>设置数值但不触发 <code>onValueChanged</code> 回调事件。</td></tr></tbody></table><h5 id=protected-methods-1>Protected Methods</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>OnDisable</code></td><td>参照MonoBehaviour.OnDisable</td></tr><tr><td><code>Set</code></td><td>设置Slider的值</td></tr></tbody></table><h3 id=scrollbar>Scrollbar</h3><p><code>Scrollbar</code>是一个用于滚动控制的UI组件，常与<code>ScrollRect</code>搭配使用，控制列表、文本区域、图片等内容的滚动</p><h4 id=结构-2>结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mathematica data-lang=mathematica><span style=display:flex><span>Scrollbar <span style=color:#f92672>=</span> Rect Transform <span style=color:#f92672>+</span> Canvas Renderer <span style=color:#f92672>+</span> Image <span style=color:#f92672>+</span> Scrollbar
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___Sliding Area<span style=color:#960050;background-color:#1e0010>（滑动轨道范围）</span>
</span></span><span style=display:flex><span>           <span style=color:#f92672>|</span>___Handle<span style=color:#960050;background-color:#1e0010>（滑块）</span> <span style=color:#f92672>=</span> Rect Transform <span style=color:#f92672>+</span> Canvas Renderer <span style=color:#f92672>+</span> Image
</span></span></code></pre></div><h4 id=scrollbar-panel>Scrollbar Panel</h4><p><img src=/images/Blog/ScrollbarPanel.jpg alt=ScrollbarPanel></p><ul><li>Size：滑块所占比率，值越小，滑块越短，内容和视口的比例的反映，由ScrollRect进行调节</li><li>numberOfSteps：可选值个数，如果设置 > 1，滑块将分段跳动</li></ul><h4 id=scrollbar-vs-slider>Scrollbar vs Slider</h4><table><thead><tr><th>比较项</th><th><code>Scrollbar</code></th><th><code>Slider</code></th></tr></thead><tbody><tr><td>用途</td><td>滚动内容控制</td><td>数值选择器</td></tr><tr><td>是否可设置 <code>size</code></td><td>是</td><td>否</td></tr><tr><td>与 <code>ScrollRect</code> 结合</td><td>常用</td><td>较少</td></tr><tr><td>滑动方式</td><td>滚轮、拖拽、点击轨道</td><td>拖拽或编程控制</td></tr></tbody></table><h4 id=api-4>API</h4><h5 id=properties-5>Properties</h5><table><thead><tr><th>成员</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><strong>handleRect</strong></td><td><code>RectTransform</code></td><td>滑块（Handle）的 RectTransform。</td></tr><tr><td><strong>direction</strong></td><td><code>Scrollbar.Direction</code></td><td>滑动方向（枚举）。</td></tr><tr><td><strong>value</strong></td><td><code>float</code></td><td>当前滚动值，范围 [0, 1]。</td></tr><tr><td><strong>size</strong></td><td><code>float</code></td><td>滑块在轨道中所占比例 [0, 1]。值越小，滑块越短。</td></tr><tr><td><strong>numberOfSteps</strong></td><td><code>int</code></td><td>分段数量。>1 时启用分段滚动。</td></tr><tr><td><strong>onValueChanged</strong></td><td><code>UnityEvent&lt;float></code></td><td>滚动值变化时调用。</td></tr></tbody></table><h6 id=public-methods-3>Public Methods</h6><table><thead><tr><th>方法名</th><th>类型 / 接口</th><th>说明</th></tr></thead><tbody><tr><td><strong>FindSelectableOnDown()</strong></td><td><code>Selectable</code>（基类）</td><td>返回下方可选的 UI 控件（用于键盘/手柄方向导航）。</td></tr><tr><td><strong>FindSelectableOnLeft()</strong></td><td><code>Selectable</code>（基类）</td><td>返回左侧可选的 UI 控件。</td></tr><tr><td><strong>FindSelectableOnRight()</strong></td><td><code>Selectable</code>（基类）</td><td>返回右侧可选的 UI 控件。</td></tr><tr><td><strong>FindSelectableOnUp()</strong></td><td><code>Selectable</code>（基类）</td><td>返回上方可选的 UI 控件。</td></tr><tr><td><strong>GraphicUpdateComplete()</strong></td><td><code>ICanvasElement</code></td><td>在图形系统更新完成后调用，用于重绘完 UI 后的清理/处理。</td></tr><tr><td><strong>LayoutComplete()</strong></td><td><code>ICanvasElement</code></td><td>布局系统更新完成时调用，通常用于收尾处理。</td></tr><tr><td><strong>OnBeginDrag(PointerEventData)</strong></td><td><code>IBeginDragHandler</code></td><td>当开始拖动滑块时触发（鼠标按下并准备拖动）。</td></tr><tr><td><strong>OnDrag(PointerEventData)</strong></td><td><code>IDragHandler</code></td><td>拖动过程中持续触发，更新 <code>value</code>。</td></tr><tr><td><strong>OnInitializePotentialDrag(PointerEventData)</strong></td><td><code>IInitializePotentialDragHandler</code></td><td>拖拽开始前初始化拖拽设置（如拖拽方向等）。</td></tr><tr><td><strong>OnMove(AxisEventData)</strong></td><td><code>IMoveHandler</code></td><td>响应键盘/手柄的移动事件（如方向键、左摇杆）。</td></tr><tr><td><strong>OnPointerDown(PointerEventData)</strong></td><td><code>IPointerDownHandler</code></td><td>当鼠标或触控按下滑条时触发。</td></tr><tr><td><strong>OnPointerUp(PointerEventData)</strong></td><td><code>IPointerUpHandler</code></td><td>当鼠标或触控释放时触发。</td></tr><tr><td><strong>Rebuild(CanvasUpdate)</strong></td><td><code>ICanvasElement</code></td><td>在 Canvas 需要重新构建 UI 时调用，如尺寸或内容更新。</td></tr><tr><td><strong>SetDirection(Direction, bool)</strong></td><td><code>Scrollbar</code> 本身</td><td>设置滑动方向，并决定是否重新布置滑块布局。</td></tr><tr><td><strong>SetValueWithoutNotify(float)</strong></td><td><code>Scrollbar</code> 本身</td><td>设置 <code>value</code> 但不触发 <code>onValueChanged</code> 回调，用于静默初始化。</td></tr></tbody></table><h5 id=protected-methods-2>Protected Methods</h5><table><thead><tr><th>方法名</th><th>所属</th><th>说明</th></tr></thead><tbody><tr><td><strong>ClickRepeat(PointerEventData)</strong></td><td>协程函数（Coroutine）</td><td>当按住滑条空白区域（非 Handle）时启动，用于模拟持续点击（滚动），直到释放。通常由 <code>OnPointerDown</code> 启动，用于实现“点住滚动”的行为。</td></tr><tr><td><strong>OnDisable()</strong></td><td><code>MonoBehaviour</code> 生命周期方法</td><td>当组件或 GameObject 被禁用时调用。用于清理状态，比如停止滑动协程、取消事件等。</td></tr></tbody></table><p><strong>ClickRepeat工作原理</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>用户点击 Scrollbar 空白区域（非 Handle）
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>OnPointerDown 被触发
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>启动协程 ClickRepeat
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>每隔一段时间不断调整value，模拟“持续按压”
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>OnPointerUp 或 OnDisable 停止协程
</span></span></code></pre></div><blockquote><p><code>ClickRepeat</code>不会在拖动Handle时触发，仅当点击轨道空白部分时才会执行通常用于快速向上/向下滚动</p></blockquote><h3 id=scroll-view>Scroll View</h3><h4 id=结构-3>结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mathematica data-lang=mathematica><span style=display:flex><span>Scroll View <span style=color:#f92672>=</span> Rect Transform <span style=color:#f92672>+</span> Canvas Renderer <span style=color:#f92672>+</span> Image <span style=color:#f92672>+</span> Scroll Rect
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___Viewport <span style=color:#f92672>=</span> Rect Transform <span style=color:#f92672>+</span> Canvas Renderer <span style=color:#f92672>+</span> Image <span style=color:#f92672>+</span> Mask
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>       <span style=color:#f92672>|</span>___Content
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___Scrollbar Horizontal
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>       <span style=color:#f92672>|</span>___Sliding Area
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>       <span style=color:#f92672>|</span>___Handle
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>___Scrollbar Vertical
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>___Sliding Area
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>___Handle
</span></span></code></pre></div><h4 id=scroll-rect-panel-1>Scroll Rect Panel</h4><p><img src=/images/Blog/ScrollRectPanel.jpg alt=ScrollRectPanel></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>Content</strong></td><td>滚动的内容区域（Transform）。必须设置。</td></tr><tr><td><strong>Horizontal / Vertical</strong></td><td>是否允许横向 / 纵向滚动。</td></tr><tr><td><strong>Movement Type</strong></td><td>滚动行为的类型：<br>• <code>Unrestricted</code>（无限滚动）<br>• <code>Elastic</code>（弹性回弹）<br>• <code>Clamped</code>（限制在边界）</td></tr><tr><td><strong>Elasticity</strong></td><td>弹性程度，适用于 Elastic 模式。</td></tr><tr><td><strong>Inertia</strong></td><td>是否使用惯性滚动（拖动停止后缓慢减速）。</td></tr><tr><td><strong>Deceleration Rate</strong></td><td>惯性减速速率（值越接近 0 减速越快）。</td></tr><tr><td><strong>Scroll Sensitivity</strong></td><td>鼠标滚轮或拖动的灵敏度。</td></tr><tr><td><strong>Viewport</strong></td><td>可视窗口（一般是带有 <code>Mask</code> 或 <code>RectMask2D</code> 的 UI 元素）。</td></tr><tr><td><strong>Horizontal/Vertical Scrollbar</strong></td><td>滚动条（可选）。</td></tr><tr><td><strong>OnValueChanged</strong></td><td>滚动时触发的事件（<code>Vector2</code>，x 为横向偏移，y 为纵向偏移，范围 0~1）。</td></tr></tbody></table><h4 id=使用要点>使用要点</h4><p>1.Content必须配合Layout Group使用<br>常见组合：</p><ul><li>Vertical Layout Group + Content Size Fitter (Preferred Height)</li><li>或者使用Grid Layout Group实现网格布局</li></ul><p>2.可视区域需要加Mask<br>否则滚动时会“溢出显示”</p><p>3.Content的Pivot通常设为(0, 1)<br>也就是左上角，这样滚动方向更符合视觉直觉（从上往下滚）</p><h4 id=api-5>API</h4><h5 id=properties-6>Properties</h5><p><strong>内容控制</strong></p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>content</code></td><td><strong>被滚动的内容区域</strong>，必须是 ScrollRect 的子节点，一般挂 Layout Group 和元素。</td></tr><tr><td><code>viewport</code></td><td><strong>可视区域</strong>，通常是带有 <code>Mask</code> 或 <code>RectMask2D</code> 的 RectTransform，用于裁剪 content。</td></tr></tbody></table><p><strong>滚动方向控制</strong></p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>horizontal</code></td><td>是否启用 <strong>水平滚动</strong>。</td></tr><tr><td><code>vertical</code></td><td>是否启用 <strong>垂直滚动</strong>。</td></tr><tr><td><code>horizontalNormalizedPosition</code></td><td>当前水平滚动位置，<strong>0 = 左侧，1 = 右侧</strong>。</td></tr><tr><td><code>verticalNormalizedPosition</code></td><td>当前垂直滚动位置，<strong>0 = 底部，1 = 顶部</strong>。</td></tr><tr><td><code>normalizedPosition</code></td><td>一个 <code>(x, y)</code> 的向量，表示水平和垂直的标准化位置。</td></tr></tbody></table><p><strong>滚动行为与物理效果</strong></p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>movementType</code></td><td>滚动边界行为：<br>• <code>Unrestricted</code>: 不限制内容滚动出界<br>• <code>Clamped</code>: 限制内容不超出边界<br>• <code>Elastic</code>: 允许超出边界但有弹性回弹</td></tr><tr><td><code>elasticity</code></td><td>内容超出边界时的回弹强度（只适用于 <code>Elastic</code> 模式）。</td></tr><tr><td><code>inertia</code></td><td>是否启用 <strong>惯性滚动</strong>（用户松手后内容继续滑动）。</td></tr><tr><td><code>decelerationRate</code></td><td>惯性滚动时的减速率，越小减速越快，0~1。</td></tr><tr><td><code>velocity</code></td><td>当前内容的滚动速度（仅运行时可读写）。</td></tr></tbody></table><p><strong>滚动灵敏度</strong></p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>scrollSensitivity</code></td><td>鼠标滚轮或触摸板的滚动灵敏度，值越大越灵敏。</td></tr></tbody></table><p><strong>滚动条相关</strong></p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>horizontalScrollbar</code></td><td>水平滚动条组件引用（可选）。</td></tr><tr><td><code>horizontalScrollbarSpacing</code></td><td>水平滚动条与 viewport 之间的间距。</td></tr><tr><td><code>horizontalScrollbarVisibility</code></td><td>滚动条的显示策略（自动、永久等）。</td></tr><tr><td><code>verticalScrollbar</code></td><td>垂直滚动条组件引用（可选）。</td></tr><tr><td><code>verticalScrollbarSpacing</code></td><td>垂直滚动条与 viewport 之间的间距。</td></tr><tr><td><code>verticalScrollbarVisibility</code></td><td>垂直滚动条的显示策略。</td></tr></tbody></table><p><strong>事件</strong></p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>onValueChanged</code></td><td>滚动位置变化时的事件回调，参数是 <code>Vector2(normalizedPosition)</code>。<br>可以用来联动其他 UI，或动态加载内容等。</td></tr></tbody></table><p><strong>与布局系统集成</strong></p><p>这些属性主要是用于ScrollRect本身作为UI元素时的布局信息（一般不常改）</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>minWidth</code> / <code>minHeight</code></td><td>布局系统要求的最小宽高。</td></tr><tr><td><code>preferredWidth</code> / <code>preferredHeight</code></td><td>建议的宽高，通常用于自动布局计算。</td></tr><tr><td><code>flexibleWidth</code> / <code>flexibleHeight</code></td><td>是否可以在布局中灵活伸缩。</td></tr><tr><td><code>layoutPriority</code></td><td>控制多布局系统下优先级（数字越高越优先）。</td></tr></tbody></table><h5 id=public-methods-4>Public Methods</h5><p><strong>与布局系统有关的方法</strong></p><p>这些方法一般由Unity的UI Layout系统自动调用，开发者很少直接使用，了解它们可以帮助搞清楚<code>ScrollRect</code>和布局系统的协作过程</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>CalculateLayoutInputHorizontal()</code></td><td>告诉布局系统如何计算内容的宽度需求。</td></tr><tr><td><code>CalculateLayoutInputVertical()</code></td><td>告诉布局系统如何计算内容的高度需求。</td></tr><tr><td><code>SetLayoutHorizontal()</code></td><td>设置子元素的水平布局（内部执行，如 Content 的定位）。</td></tr><tr><td><code>SetLayoutVertical()</code></td><td>设置子元素的垂直布局。</td></tr><tr><td><code>LayoutComplete()</code></td><td>布局系统完成后调用，通常用于布局结束时的清理。</td></tr><tr><td><code>Rebuild(CanvasUpdate update)</code></td><td>在不同的 Canvas 更新阶段重建 UI（布局、绘制、交互等）。</td></tr></tbody></table><p><strong>拖拽相关方法（响应用户手势）</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>OnBeginDrag(PointerEventData eventData)</code></td><td>当用户开始拖动 ScrollRect 时触发（鼠标或触摸开始拖动）。初始化拖动参数。</td></tr><tr><td><code>OnDrag(PointerEventData eventData)</code></td><td>拖动过程中持续触发，<strong>主要移动 Content</strong>。</td></tr><tr><td><code>OnEndDrag(PointerEventData eventData)</code></td><td>拖动结束时触发，决定是否开始 <strong>惯性滚动</strong>。</td></tr><tr><td><code>OnInitializePotentialDrag(PointerEventData eventData)</code></td><td>在系统检测到可能要开始拖拽时调用。设置拖拽相关参数，如 <code>useDragThreshold</code>。</td></tr><tr><td><code>StopMovement()</code></td><td>手动停止滚动（将 <code>velocity</code> 设为零），可用于外部中断滚动行为。</td></tr></tbody></table><p><strong>鼠标滚轮事件</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>OnScroll(PointerEventData eventData)</code></td><td>响应鼠标滚轮事件，常用于鼠标滑动滚动内容。ScrollRect 内部会根据 <code>scrollSensitivity</code> 来改变 <code>content</code> 的位置。</td></tr></tbody></table><p><strong>Canvas系统更新周期</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>GraphicUpdateComplete()</code></td><td>图形更新阶段完成后调用，通常用于清理绘制状态。</td></tr><tr><td><code>IsActive()</code></td><td>ScrollRect 当前是否激活（继承自 <code>UIBehaviour</code>），用于判断是否参与渲染和交互。</td></tr></tbody></table><h5 id=示例-2>示例</h5><p><strong>自定义拖动方向（只允许竖直）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VerticalOnlyScrollRect</span> : ScrollRect
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnDrag(PointerEventData eventData)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (!vertical) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> delta = <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>0</span>, eventData.delta.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>base</span>.OnDrag(<span style=color:#66d9ef>new</span> PointerEventData(eventData.eventSystem)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      position = eventData.position,
</span></span><span style=display:flex><span>      delta = delta
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ui更新>UI更新</h2><p>Unity的UI系统在每一帧里，都按照一定顺序对所有UI元素做布局计算、绘制更新、交互处理，这个顺序被划分成了几个阶段</p><h3 id=ui更新流程的3个阶段canvasupdate>UI更新流程的3个阶段（CanvasUpdate）</h3><p>Unity会调用实现了<code>ICanvasElement</code>接口的UI组件（如<code>Text</code>，<code>Image</code>，<code>ScrollRect</code>等），按顺序执行：</p><table><thead><tr><th>阶段</th><th>意义</th><th>常见调用的方法</th></tr></thead><tbody><tr><td>1.<code>Layout</code> 阶段</td><td>计算大小、位置</td><td><code>CalculateLayoutInputHorizontal/Vertical</code>, <code>SetLayoutHorizontal/Vertical</code></td></tr><tr><td>2.<code>Graphic</code> 阶段</td><td>更新可视内容，比如文字、图片、颜色等</td><td><code>GraphicUpdateComplete</code></td></tr><tr><td>3.<code>LatePreRender</code> 阶段</td><td>最后准备渲染前的调整</td><td>比如强制设置滚动位置等</td></tr></tbody></table><h3 id=timelineper-frame>TimeLine(Per Frame)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span>Update()
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>Layout阶段：
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>-</span> ScrollRect：计算内容区域位置
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>-</span> Text：计算文字排版
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>Graphic阶段：
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>-</span> Image：更新贴图
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>-</span> Text：更新文字网格
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>LatePreRender阶段：
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>-</span> ScrollRect：修正 normalizedPosition
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>渲染 → 显示画面
</span></span></code></pre></div><p>某些UI行为必须等到布局计算完成后才能准确执行，比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>scrollRect.verticalNormalizedPosition = <span style=color:#ae81ff>0f</span>;
</span></span></code></pre></div><p>如果放在<code>Start()</code>里，它可能在布局阶段之前就执行了，所以不会生效</p><p>正确的方式是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Canvas.ForceUpdateCanvases(); <span style=color:#75715e>// 强制执行Layout阶段</span>
</span></span><span style=display:flex><span>scrollRect.verticalNormalizedPosition = <span style=color:#ae81ff>0f</span>;
</span></span></code></pre></div><h2 id=ui-event-system>UI Event System</h2><p><a href=blog/UI-Event-System/>UI Event System</a></p><h2 id=effects>Effects</h2><p><img src=/images/Blog/UIEffectsPanel.jpg alt=UIEffectsPanel></p><h3 id=outline>Outline</h3><p><code>Outline</code>是UI元素（特别是Text或Image）边缘的描边效果，常用于：</p><ul><li>让文字在复杂背景上更清晰</li><li>做出“激活态、高亮态、按钮描边”等视觉反馈</li></ul><p>可以使用Unity内置组件或者自定义Shader</p><table><thead><tr><th>方法</th><th>原理</th></tr></thead><tbody><tr><td>Unity 内置效果</td><td>给文字/图片添加一个 UI 组件 <code>Outline</code>，复制顶点并偏移渲染多次</td></tr><tr><td>Shader 实现</td><td>将 UI 元素边缘偏移若干方向采样贴图，合成边缘</td></tr></tbody></table><p>内置Outline的原理：</p><ul><li>一个文字变成多个（通常4~8）方向偏移的副本，每个副本绘制为描边颜色</li><li>性能相对差一些，特别是在大量UI上使用</li></ul><h3 id=position-as-uv1>Position As UV1</h3><p>这是一个技术手段：将某个偏移后的顶点坐标值（如描边方向的位移）写入UV1通道，让Shader在片元阶段使用它来做偏移采样</p><p>用途：</p><ul><li>把需要的特效位移、数据提前写入UV1（节省顶点数据或避免增加新通道）</li><li>Shader在Fragment阶段用UV1执行各种偏移采样，如做模糊、描边、阴影</li></ul><h3 id=shadow>Shadow</h3><p><code>Shadow</code>是给UI文本或图形加上的下投影阴影，常用于：</p><ul><li>提高层次感</li><li>模拟立体感</li><li>UI Hover时的强调效果</li></ul><p>实现方式和Outline类似，也常用顶点偏移 + 颜色叠加实现；通常只需1此偏移绘制，不像Outline要多个方向</p><h2 id=layout-system>Layout System</h2><p>详见<a href=blog/Layout/>Layout</a></p><h2 id=mask>Mask</h2><p>详见<a href=blog/Mask/>Mask</a></p><h2 id=ugui渲染流程>UGUI渲染流程</h2><p>UGUI的渲染是基于Canvas来驱动和管理的，Canvas是UGUI的核心渲染单元</p><h3 id=ugui组成核心>UGUI组成核心</h3><ul><li>Canvas：UI的根节点，管理批处理和渲染</li><li>RectTransform：UI元素的定位组件</li><li>Graphic（Image、Text等）：UI的可绘制元素，负责生成顶点数据</li><li>CanvasRenderer：负责将顶点数据提交给GPU绘制</li></ul><h3 id=ugui渲染总体流程>UGUI渲染总体流程</h3><p>1.UI元素状态改变触发重建（Dirty）</p><ul><li>位置、大小、颜色、材质、文本内容等变化，都会标记对应Graphic为Dirty</li><li>Dirty的Graphic会触发它所属的Canvas的重建流程</li></ul><p>2.Canvas重建</p><ul><li>Unity会重新收集所有需要渲染的Graphic，生成顶点缓冲（Vertex Buffer）</li><li>会合并材质和纹理相同的Graphic，尽量批处理减少Draw Call</li></ul><p>3.Canvas批处理</p><ul><li>批处理把相同材质的Graphic合并成一个Draw Call</li><li>Unity会更具是否启用Canvas分割（拆分Canvas）、动态批处理、GPU Instancing决定合批方案</li></ul><p>4.顶点提交</p><ul><li>CanvasRenderer组件负责把生成的顶点数据传给GPU</li><li>通过Unity内置的UI Shader渲染UI元素</li></ul><p>5.GPU渲染</p><ul><li>GPU执行顶点着色、像素着色，最终把UI绘制到屏幕</li></ul><p>示意图：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>UI元素变化</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#f92672>Dirty</span><span style=color:#960050;background-color:#1e0010>）</span> 
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>Canvas重建</span>
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>顶点缓冲区重新生成</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#f92672>OnPopulateMesh</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>批处理合并</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#f92672>Batching</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>CanvasRenderer提交顶点</span>
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>GPU渲染绘制</span>
</span></span></code></pre></div><h3 id=重要细节>重要细节</h3><ul><li>Canvas重建代价大<ul><li>UI元素变化会触发Canvas重建，代价主要在CPU端的顶点生成和批处理</li></ul></li><li>Canvas的划分影响渲染效率<ul><li>单一大Canvas变动小部分时，整个Canvas都需要重建</li><li>拆分多个Canvas能减少重建范围，提高性能</li></ul></li><li>使用Mask、ScrollRect会增加Draw Call<ul><li>Mask会强制拆分批处理，影响性能</li></ul></li><li>TextMeshPro相比原生Text性能更优<ul><li>生成的顶点少，渲染更高效</li></ul></li></ul><h2 id=ui性能优化>UI性能优化</h2><h3 id=ui性能瓶颈来源>UI性能瓶颈来源</h3><ul><li>Canvas重绘（Canvas Batching）<ul><li>Unity UI的核心瓶颈，任何UI元素的改变都会触发Canvas重绘</li><li>重绘会导致大量Draw Call和CPU消耗</li></ul></li><li>过多Draw Call<ul><li>UI元素数量多，切换材质、纹理时会产生更多Draw Call</li></ul></li><li>过度的布局计算<ul><li>Layout Group、ContentSizeFitter频繁更新会触发布局计算，消耗CPU</li></ul></li><li>频繁的UI更新<ul><li>文本、图片频繁更改，尤其是动态更新时</li></ul></li></ul><h3 id=重点优化方向和方法>重点优化方向和方法</h3><p>减少Canvas重绘范围</p><ul><li>拆分Canvas<ul><li>把经常变动的UI元素放在单独的Canvas，避免整屏重绘</li></ul></li><li>避免频繁更改UI属性<ul><li>避免频繁修改RectTransform、颜色、图片等触发Canvas重绘的操作</li></ul></li><li>使用Canvas的分区刷新<ul><li>Unity在2020+版本有更好的Canvas局部刷新</li></ul></li></ul><p>控制Draw Call数量</p><ul><li>使用UI图集（Sprite Atlas）<ul><li>减少纹理切换，批量合并Draw Call</li></ul></li><li>合理使用Image Type<ul><li>对于简单图形使用Simple，避免复杂的Sliced或Tiled导致额外计算</li></ul></li><li>减少Mask数量<ul><li>Mask会导致额外Draw Call，尽量复用或用RectMask2D替代</li></ul></li></ul><p>优化布局系统</p><ul><li>避免使用过多Layout Group和ContentSizeFitter<ul><li>这两个组件会频繁触发布局刷新，影响性能</li></ul></li><li>尽量在UI静态阶段完成布局计算<ul><li>动态添加、删除时手动刷新布局</li></ul></li></ul><p>文本优化</p><ul><li>避免频繁修改Text内容<ul><li>文本更新会重建顶点，代价大</li></ul></li><li>使用TextMeshPro<ul><li>性能更好，支持更灵活的排版和渲染</li></ul></li><li>启用文本的“字体缓存”功能<ul><li>减少文本绘制成本</li></ul></li></ul><p>使用Pool技术复用UI元素</p><ul><li>对动态生成的大量UI（如列表、格子），用对象池复用而非反复创建销毁</li></ul><h2 id=unity-ui-tookit>Unity UI Tookit</h2><p>Unity UI Tookit是Unity推出的新一代UI框架，用于狗i按Editor UI（编译器工具）以及运行时UI（Runtime UI），逐渐称为UGUI的继任者。<br>它借鉴了Web的开发理念，使用类似HTML + CSS的语法（UXML + USS），结合C#逻辑代码</p><h3 id=ui-toolkit组成>UI Toolkit组成</h3><p>1.UXML（Unity XML）</p><ul><li>类似HTML，定义UI结构</li><li>示例：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;engine:VisualElement</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;container&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;engine:Label</span> <span style=color:#a6e22e>text=</span><span style=color:#e6db74>&#34;Hello UI Toolkit&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;title-label&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/engine:VisualElement&gt;</span>
</span></span></code></pre></div><p>2.USS（Unity Style Sheets）</p><ul><li>类似CSS，用于样式设置</li><li>示例：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>flex-direction</span>: <span style=color:#66d9ef>column</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>padding</span>: <span style=color:#ae81ff>10</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>title-label</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>white</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>3.C#脚本</p><ul><li>控制逻辑，加载UI，注册事件</li><li>示例：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> root = GetComponent&lt;UIDocument&gt;().rootVisualElement;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> button = root.Q&lt;Button&gt;(<span style=color:#e6db74>&#34;myButton&#34;</span>);
</span></span><span style=display:flex><span>button.clicked += () =&gt; Debug.Log(<span style=color:#e6db74>&#34;Button clicked&#34;</span>);
</span></span></code></pre></div><h3 id=ui-tookit的优势>UI Tookit的优势</h3><table><thead><tr><th>优点</th><th>描述</th></tr></thead><tbody><tr><td>数据驱动</td><td>更好地支持 MVC/MVVM 等架构。</td></tr><tr><td>样式分离</td><td>USS 类似 CSS，使样式和逻辑分离，维护性强。</td></tr><tr><td>高度自定义</td><td>支持自定义控件、继承组件等。</td></tr><tr><td>原生支持编辑器工具</td><td>创建自定义 Inspector、工具面板更加方便。</td></tr><tr><td>性能更好（Runtime UI）</td><td>尤其在静态 UI 上比 UGUI 更高效。</td></tr></tbody></table><p><strong>UI Tookit vs UGUI</strong></p><table><thead><tr><th>特性</th><th>UI Toolkit</th><th>UGUI</th></tr></thead><tbody><tr><td>样式机制</td><td>USS（类似 CSS）</td><td>内联属性</td></tr><tr><td>布局方式</td><td>Flexbox</td><td>Anchors + RectTransform</td></tr><tr><td>可编程性</td><td>更接近 Web 构建方式</td><td>Unity 特有组件方式</td></tr><tr><td>编辑器支持</td><td>完善，Inspector、EditorWindow</td><td>需要自写代码</td></tr><tr><td>动态创建元素</td><td>支持（动态加载 UXML）</td><td>支持，但较繁琐</td></tr><tr><td>性能（静态 UI）</td><td>更优</td><td>中等</td></tr><tr><td>学习曲线</td><td>偏陡峭（对 Web 不熟悉的人）</td><td>更直观</td></tr></tbody></table><h3 id=使用场景>使用场景</h3><ul><li>自定义编辑器（如Inspector、EditorWindow）</li><li>数据面板、工具插件等</li><li>复杂动态UI游戏界面</li><li>动画复杂、过渡多的UI</li></ul><h2 id=ui动画>UI动画</h2><p>Unity中做UI动画，有以下几种常见方式</p><h3 id=unity-animator-controller做ui动画>Unity Animator Controller做UI动画</h3><ul><li>可以用<code>Animator</code>组件对UI元素做复杂动画，类似角色动画</li><li>配合<code>Animation</code>窗口，制作位置、缩放、旋转、颜色、透明度等属性动画</li><li>适合状态切换、复杂动画序列，比如按钮按下弹跳、菜单打开过渡等</li></ul><h3 id=tween动画库>Tween动画库</h3><ul><li>比较常用且高效的方式，很多第三方Tween库都支持UI动画：<ul><li>DOTween（Dimigiant）</li><li>LeanTween</li><li>iTween</li></ul></li></ul><h3 id=利用ui-canvasgroup做渐隐渐显动画>利用UI CanvasGroup做渐隐渐显动画</h3><ul><li><code>CanvasGroup</code>组件可以控制整体UI透明度、交互和射线阻挡</li><li>搭配Tween库做淡入淡出效果</li></ul><h3 id=使用代码插值做自定义动画>使用代码插值做自定义动画</h3><ul><li>使用<code>Update()</code>里的插值控制位置、颜色等</li><li>灵活，但代码复杂度高，不推荐做复杂UI动画</li></ul><h3 id=ui粒子动画和shader动画>UI粒子动画和Shader动画</h3><ul><li>结合粒子系统、Shader特效提升UI表现</li><li>适合特殊需求，比如炫酷按钮发光、粒子飞散等</li></ul><h3 id=timeline与ui动画>Timeline与UI动画</h3><ul><li>Unity Timeline也支持控制UI动画，适合需要同步多动画的场景</li></ul></div><nav class=post-nav><a href=/blog/ui-event-system/ class=hover:underline>pre: UI Event System</a>
<a href=/blog/unity-asynchronous-and-coroutine/ class=hover:underline>next: Unity Asynchronous and Coroutine</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#ugui和ngui>UGUI和NGUI</a></li><li><a href=#canvas>Canvas</a><ul><li><a href=#canvas的渲染模式>Canvas的渲染模式</a><ul><li><a href=#1screen-space---overlay屏幕空间覆盖>1.Screen Space - Overlay（屏幕空间覆盖）</a></li><li><a href=#2screen-space---camera屏幕空间摄像机>2.Screen Space - Camera（屏幕空间摄像机）</a></li><li><a href=#3world-space世界空间>3.World Space（世界空间）</a></li></ul></li><li><a href=#canvas组件的重要属性>Canvas组件的重要属性</a><ul><li><a href=#screen-space---overlay>Screen Space - Overlay</a></li><li><a href=#screen-space---camera>Screen Space - Camera</a></li><li><a href=#world-space>World Space</a></li></ul></li><li><a href=#canvasscaler>CanvasScaler</a><ul><li><a href=#三种缩放模式>三种缩放模式</a></li></ul></li><li><a href=#graphic-raycaster>Graphic Raycaster</a><ul><li><a href=#工作原理ui射线检测>工作原理：UI射线检测</a></li></ul></li><li><a href=#canvas-group>Canvas Group</a><ul><li><a href=#属性>属性</a></li></ul></li><li><a href=#canvas的层级关系>Canvas的层级关系</a><ul><li><a href=#为什么要用子canvas>为什么要用子Canvas</a><ul><li><a href=#性能优化>性能优化</a></li><li><a href=#ui分区逻辑清晰>UI分区逻辑清晰</a></li></ul></li><li><a href=#父子canvas的排序--显示顺序>父子Canvas的排序 & 显示顺序</a><ul><li><a href=#排序层控制sorting-layer--order-in-layer>排序层控制（Sorting Layer + Order in Layer）</a></li></ul></li><li><a href=#recttransform父子关系的影响>RectTransform父子关系的影响</a></li></ul></li><li><a href=#canvas性能>Canvas性能</a></li><li><a href=#canvas-api>Canvas API</a><ul><li><a href=#properties>Properties</a></li><li><a href=#static-method>Static Method</a></li><li><a href=#events>Events</a><ul><li><a href=#事件区别和调用顺序>事件区别和调用顺序</a></li></ul></li></ul></li></ul></li><li><a href=#ui-component>UI Component</a><ul><li><a href=#通用组件>通用组件</a><ul><li><a href=#rect-transform>Rect Transform</a><ul><li><a href=#核心属性>核心属性</a></li><li><a href=#anchor>Anchor</a></li><li><a href=#pivot>Pivot</a></li></ul></li><li><a href=#布局>布局</a><ul><li><a href=#坐标系层级关系>坐标系层级关系</a></li><li><a href=#recttransform-api>RectTransform API</a></li></ul></li><li><a href=#canvas-renderer>Canvas Renderer</a><ul><li><a href=#canvasrenderer的作用>CanvasRenderer的作用</a></li><li><a href=#canvasrenderer和ui的绘制流程>CanvasRenderer和UI的绘制流程</a></li><li><a href=#canvasrenderer-api>CanvasRenderer API</a></li></ul></li><li><a href=#image>Image</a><ul><li><a href=#属性-1>属性</a></li><li><a href=#image-type-simple>Image Type: Simple</a></li><li><a href=#image-type-sliced>Image Type: Sliced</a></li><li><a href=#image-type-tiled>Image Type: Tiled</a></li><li><a href=#image-type-filled>Image Type: Filled</a></li><li><a href=#性能建议>性能建议</a></li><li><a href=#image-api>Image API</a></li></ul></li></ul></li></ul></li><li><a href=#ui-element>UI Element</a><ul><li><a href=#panel>Panel</a><ul><li><a href=#常见用途>常见用途</a></li></ul></li><li><a href=#image-1>Image</a></li><li><a href=#raw-image>Raw Image</a><ul><li><a href=#image-vs-rawimage>Image vs RawImage</a></li></ul></li><li><a href=#textlegacy>Text(Legacy)</a><ul><li><a href=#基本属性>基本属性</a></li><li><a href=#工作流程>工作流程</a></li><li><a href=#textlegacy的缺点>Text(Legacy)的缺点</a></li><li><a href=#性能提升>性能提升</a></li><li><a href=#textlegacy-api>Text(Legacy) API</a><ul><li><a href=#properties-1>Properties</a></li><li><a href=#public-method>Public Method</a></li><li><a href=#protected-method>Protected Method</a></li><li><a href=#static-method-1>Static Method</a></li></ul></li></ul></li><li><a href=#buttonlegacy>Button(Legacy)</a><ul><li><a href=#panel-properties>Panel Properties</a></li><li><a href=#button的继承结构>Button的继承结构</a></li><li><a href=#button的点击事件流程底层>Button的点击事件流程（底层）</a></li><li><a href=#button示例>Button示例</a><ul><li><a href=#基础绑定--点击回调>基础绑定 + 点击回调</a></li><li><a href=#动态创建按钮--设置点击事件>动态创建按钮 + 设置点击事件</a></li><li><a href=#控制按钮状态变化>控制按钮状态变化</a></li></ul></li><li><a href=#自定义扩展>自定义扩展</a><ul><li><a href=#高级交互>高级交互</a></li></ul></li></ul></li><li><a href=#dropdownlegacy>Dropdown(Legacy)</a><ul><li><a href=#dropdown-panel>Dropdown Panel</a></li><li><a href=#scroll-rect-panel>Scroll Rect Panel</a><ul><li><a href=#工作原理>工作原理</a></li></ul></li><li><a href=#viewport>Viewport</a></li><li><a href=#示例>示例</a></li><li><a href=#扩展>扩展</a></li><li><a href=#api>API</a></li></ul></li><li><a href=#input-fieldlegacy>Input Field(Legacy)</a><ul><li><a href=#input-field-panel>Input Field Panel</a></li><li><a href=#api-1>API</a><ul><li><a href=#properties-2>Properties</a></li><li><a href=#public-methods>Public Methods</a></li><li><a href=#protected-methods>Protected Methods</a></li><li><a href=#delegates>Delegates</a></li></ul></li></ul></li><li><a href=#textmeshprotmp>TextMeshPro(TMP)</a><ul><li><a href=#tmp组件类型>TMP组件类型</a></li><li><a href=#tmp-importer>TMP Importer</a><ul><li><a href=#何时会看到tmp-importer>何时会看到TMP Importer</a></li><li><a href=#tmp-importer提供的资源内容>TMP Importer提供的资源内容</a></li></ul></li><li><a href=#tmp-vs-textlegacy>TMP vs Text(Legacy)</a></li><li><a href=#texttmp>Text（TMP）</a><ul><li><a href=#基础设置区>基础设置区</a></li><li><a href=#main-settings>Main Settings</a></li><li><a href=#extra-settings>Extra Settings</a></li><li><a href=#material-inspector>Material Inspector</a></li></ul></li></ul></li><li><a href=#toggle>Toggle</a><ul><li><a href=#结构>结构</a></li><li><a href=#toggle-panel>Toggle Panel</a></li><li><a href=#示例-1>示例</a><ul><li><a href=#获取并监听toggle状态>获取并监听Toggle状态</a></li></ul></li><li><a href=#toggle-group单选组>Toggle Group(单选组)</a></li><li><a href=#api-2>API</a><ul><li><a href=#properties-3>Properties</a></li><li><a href=#public-methods-1>Public Methods</a></li><li><a href=#protected-mehtods>Protected Mehtods</a></li></ul></li></ul></li><li><a href=#slider>Slider</a><ul><li><a href=#结构-1>结构</a></li><li><a href=#slider-panel>Slider Panel</a></li><li><a href=#api-3>API</a><ul><li><a href=#properties-4>Properties</a></li><li><a href=#public-methods-2>Public Methods</a></li><li><a href=#protected-methods-1>Protected Methods</a></li></ul></li></ul></li><li><a href=#scrollbar>Scrollbar</a><ul><li><a href=#结构-2>结构</a></li><li><a href=#scrollbar-panel>Scrollbar Panel</a></li><li><a href=#scrollbar-vs-slider>Scrollbar vs Slider</a></li><li><a href=#api-4>API</a><ul><li><a href=#properties-5>Properties</a><ul><li><a href=#public-methods-3>Public Methods</a></li></ul></li><li><a href=#protected-methods-2>Protected Methods</a></li></ul></li></ul></li><li><a href=#scroll-view>Scroll View</a><ul><li><a href=#结构-3>结构</a></li><li><a href=#scroll-rect-panel-1>Scroll Rect Panel</a></li><li><a href=#使用要点>使用要点</a></li><li><a href=#api-5>API</a><ul><li><a href=#properties-6>Properties</a></li><li><a href=#public-methods-4>Public Methods</a></li><li><a href=#示例-2>示例</a></li></ul></li></ul></li></ul></li><li><a href=#ui更新>UI更新</a><ul><li><a href=#ui更新流程的3个阶段canvasupdate>UI更新流程的3个阶段（CanvasUpdate）</a></li><li><a href=#timelineper-frame>TimeLine(Per Frame)</a></li></ul></li><li><a href=#ui-event-system>UI Event System</a></li><li><a href=#effects>Effects</a><ul><li><a href=#outline>Outline</a></li><li><a href=#position-as-uv1>Position As UV1</a></li><li><a href=#shadow>Shadow</a></li></ul></li><li><a href=#layout-system>Layout System</a></li><li><a href=#mask>Mask</a></li><li><a href=#ugui渲染流程>UGUI渲染流程</a><ul><li><a href=#ugui组成核心>UGUI组成核心</a></li><li><a href=#ugui渲染总体流程>UGUI渲染总体流程</a></li><li><a href=#重要细节>重要细节</a></li></ul></li><li><a href=#ui性能优化>UI性能优化</a><ul><li><a href=#ui性能瓶颈来源>UI性能瓶颈来源</a></li><li><a href=#重点优化方向和方法>重点优化方向和方法</a></li></ul></li><li><a href=#unity-ui-tookit>Unity UI Tookit</a><ul><li><a href=#ui-toolkit组成>UI Toolkit组成</a></li><li><a href=#ui-tookit的优势>UI Tookit的优势</a></li><li><a href=#使用场景>使用场景</a></li></ul></li><li><a href=#ui动画>UI动画</a><ul><li><a href=#unity-animator-controller做ui动画>Unity Animator Controller做UI动画</a></li><li><a href=#tween动画库>Tween动画库</a></li><li><a href=#利用ui-canvasgroup做渐隐渐显动画>利用UI CanvasGroup做渐隐渐显动画</a></li><li><a href=#使用代码插值做自定义动画>使用代码插值做自定义动画</a></li><li><a href=#ui粒子动画和shader动画>UI粒子动画和Shader动画</a></li><li><a href=#timeline与ui动画>Timeline与UI动画</a></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>