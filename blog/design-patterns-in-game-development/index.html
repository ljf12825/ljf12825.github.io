<!doctype html><html lang=en><head><meta charset=UTF-8><title>Design Patterns in Game Development</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Design Patterns in Game Development" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Design Patterns in Game Development<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>游戏开发中，设计模式是组织代码、提升可维护性、扩展性和复用性的基础工具。尤其是大型游戏项目或使用Unity、Unreal等引擎开发时，恰当使用设计模式能显著提高架构质量</p><p>基于Gof23种设计模式，常用于游戏开发的设计模式有以下几种：</p><table><thead><tr><th>分类</th><th>模式</th><th>用途</th></tr></thead><tbody><tr><td><strong>创建型</strong></td><td>Singleton（单例）</td><td>管理全局状态（如 GameManager、AudioManager）</td></tr><tr><td></td><td>Factory Method（工厂方法）</td><td>创建敌人、道具、技能等实例</td></tr><tr><td></td><td>Prototype（原型）</td><td>克隆预制体、生成技能副本等</td></tr><tr><td></td><td>Object Pool（对象池）</td><td>管理大量频繁生成/销毁的对象（子弹、特效）</td></tr><tr><td><strong>结构型</strong></td><td>Component（组件）</td><td>Unity核心模式（基于组合而非继承）</td></tr><tr><td></td><td>Decorator（装饰器）</td><td>给技能、Buff添加额外效果</td></tr><tr><td></td><td>Flyweight（享元）</td><td>减少内存（如重复使用同一 Mesh、材质）</td></tr><tr><td><strong>行为型</strong></td><td>State（状态机）</td><td>角色状态切换（Idle、Run、Jump、Attack）</td></tr><tr><td></td><td>Observer（观察者）</td><td>UI监听角色属性变化、事件派发系统</td></tr><tr><td></td><td>Command（命令）</td><td>实现撤销/重做、输入缓存、动作序列</td></tr><tr><td></td><td>Strategy（策略）</td><td>多种AI行为切换，技能释放策略等</td></tr><tr><td></td><td>EventBus（事件总线）</td><td>解耦不同系统的事件通信（如成就、音效）</td></tr><tr><td></td><td>Mediator（中介者）</td><td>管理复杂交互系统（UI面板交互）</td></tr><tr><td></td><td>Visitor（访问者）</td><td>用于遍历不同 GameObject 执行操作（如保存、统计）</td></tr></tbody></table><h2 id=unity中常用的设计模式>Unity中常用的设计模式</h2><h3 id=singleton-单例模式>Singleton 单例模式</h3><p>单例模式用于确保一个类只有一个实例，并提供一个全局访问点</p><p>用途：管理全局对象，如AudioManager、UIManager、GameManager</p><p>单例模式的核心思想：确保一个类仅有一个实例，并提供一个访问它的全局方式\</p><h4 id=典型结构>典型结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameManager</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> GameManager _instance;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> GameManager Instance
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (_instance == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                _instance = <span style=color:#66d9ef>new</span> GameManager();
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> _instance;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> GameManager() {} <span style=color:#75715e>// 私有构造</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> StartGame()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 游戏启动逻辑</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=典型用途>典型用途</h4><ol><li>游戏管理器（GameManager）
控制游戏状态（开始、暂停、结束、重启等）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>GameManager.Instance.StartGame();
</span></span></code></pre></div><ol start=2><li>音效管理器（AudioManager）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>AudioManager.Instance.PlaySound(<span style=color:#e6db74>&#34;Explosion&#34;</span>);
</span></span></code></pre></div><ol start=3><li>资源管理器（ResourceManager）
加载资源（Prefab、音效、贴图等），避免重复加载</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> bullet = ResourceManager.Instance.LoadPrefab(<span style=color:#e6db74>&#34;Bullet&#34;</span>);
</span></span></code></pre></div><ol start=4><li>UI管理器（UIManager）
打开、关闭UI界面，维护UI栈</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>UIManager.Instance.ShowPanel(<span style=color:#e6db74>&#34;MainMenu&#34;</span>);
</span></span></code></pre></div><ol start=5><li><p>输入管理器（InputManager）
统一收集和管理玩家输入，避免在多个地方监听</p></li><li><p>配置表管理器（ConfigManager）
统一读取CSV/JSON配置数据</p></li></ol><h4 id=unity中的单例实现>Unity中的单例实现</h4><p>在Unity中，单例类一般继承自<code>MonoBehaviour</code>，并用<code>DontDestroyOnLoad</code>保持在多个场景中持久存在</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameManager</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> GameManager Instance { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Awake()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Instance != <span style=color:#66d9ef>null</span> &amp;&amp; Instance != <span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Destroy(gameObject);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Instance = <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        DontDestroyOnLoad(gameObject);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> StartGame() { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>将其拖到场景中的一个空物体上就可以使用了</p><p>如果不想拖脚本，可以实现自动创建</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameManager</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> GameManager _instance;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> GameManager Instance;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (_instance == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 查找场景中是否存在</span>
</span></span><span style=display:flex><span>                _instance = FindObjectOfType&lt;GameManager&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果没有，创建一个新的GameObject挂上它</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (_instance == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    GameObject obj = <span style=color:#66d9ef>new</span> GameObject(<span style=color:#e6db74>&#34;GameManager&#34;</span>);
</span></span><span style=display:flex><span>                    _instance = obj.AddComponent&lt;GameManager&gt;();
</span></span><span style=display:flex><span>                    DontDestroyOnLoad(obj);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> _instance;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Awake()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 防止重复</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_instance == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            _instance = <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>            DontDestroyOnLoad(gameObject);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (_instance != <span style=color:#66d9ef>this</span>) Destroy(gameObject);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=单例模式的特点>单例模式的特点</h4><p><strong>优点</strong></p><ol><li>全局访问：任何脚本都能方便地访问</li><li>数据共享：多个系统共享同一份数据，如游戏状态、资源</li><li>节省资源：避免多次实例化相同管理器</li><li>逻辑集中：将一类功能集中处理，方便维护</li></ol><p><strong>缺点</strong></p><ol><li>隐藏依赖：使用单例模式可能让类间依赖不明显，降低可读性</li><li>生命周期管理难：尤其在Unity中，切换场景可能出现多实例、空引用等问题</li><li>难以测试：单例可能使单元测试变得困难（不可隔离、难模拟）</li><li>违背面向对象原则：单例是全局状态，本质上是一种全局变量。过度依赖会让程序耦合严重</li></ol><p><strong>改进建议</strong></p><ol><li>使用懒汉式 vs 饿汉式</li></ol><ul><li>懒汉式（Lazy）：只有第一次访问时才创建实例</li><li>饿汉式（Eager）：程序启动时立即创建</li></ul><ol start=2><li>使用接口隔离
将单例隐藏在接口后面，便于替换和测试</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IAudioManager</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> PlaySound(<span style=color:#66d9ef>string</span> name);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>使用依赖注入容器
如Zenject、Extenject等</li></ol><h3 id=objectpool-对象池>ObjectPool 对象池</h3><p>用途：频繁生成/销毁对象如子弹、粒子效果，减少GC
<a href=%7B%7Bsite.baseurl%7D%7D/posts/2025-06-06-Object-Pooling/>ObjectPooling</a></p><h3 id=state-状态机模式>State 状态机模式</h3><p>用途：角色状态管理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IState</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Ender();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Execute();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Exit();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IdleState</span> : IState { ... }
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RunState</span> : IState { ... }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StateMechine</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> IState currentState;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ChangeState(IState newState)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        currentState?.Exit();
</span></span><span style=display:flex><span>        currentState = newState;
</span></span><span style=display:flex><span>        currentState.Enter();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Update() =&gt; currentState?.Execute();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=observer-观察者模式>Observer 观察者模式</h3><p>用途：事件通知系统、属性变化通知UI</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Health</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Action&lt;<span style=color:#66d9ef>int</span>&gt; OnHealtChanged;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> hp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> SetHP(<span style=color:#66d9ef>int</span> <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        hp = <span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>        OnHealthChanged?.Invoke(hp);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=strategy-策略模式>Strategy 策略模式</h3><p>用途：定义不同行为策略（如攻击方式、AI逻辑）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IAttackStrategy</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Attack();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MeleeAttack</span> : IAttackStrategy { ... }
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RangedAttack</span> : IAttackStrategy { ... }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Character</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> IAttackStrategy attackStrategy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> PerformAttack() =&gt; attackStrategy.Attack();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=command-命令模式>Command 命令模式</h3><p>用途：实现撤销、按键映射、行为记录</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ICommand</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Execute();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Undo();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MoveCommand</span> : ICommand { ... }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InputHandler</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Stack&lt;ICommand&gt; history = <span style=color:#66d9ef>new</span> Stack&lt;ICommand&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> HandleInput()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ICommand cmd = <span style=color:#66d9ef>new</span> MoveCommand();
</span></span><span style=display:flex><span>        cmd.Execute();
</span></span><span style=display:flex><span>        history.Push(cmd);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Undo() =&gt; history.Pop().Undo();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=eventbus-事件总线>EventBus 事件总线</h3><p>用途：各个系统之间通信解耦</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EventBus</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>event</span> Action OnLevelComplete;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> LevelComplete() =&gt; OnLevelComplete?.Invoke();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=unity自带的设计模式>Unity自带的设计模式</h2><table><thead><tr><th>系统</th><th>使用的设计模式</th></tr></thead><tbody><tr><td>GameObject + Component</td><td>Component 模式</td></tr><tr><td>ScriptableObject</td><td>数据驱动、配置注入</td></tr><tr><td>Coroutine</td><td>类似状态机/命令模式</td></tr><tr><td>Animator Controller</td><td>状态机（FSM）</td></tr><tr><td>Input System</td><td>命令模式、策略模式</td></tr><tr><td>UI System（事件系统）</td><td>观察者模式、命令模式</td></tr></tbody></table><p>推荐书籍：《游戏编程模式》 Game Programming Patterns</p></div><nav class=post-nav><a href=/blog/dependency-injection/ class=hover:underline>pre: Dependency Injection(DI)</a>
<a href=/blog/dots/ class=hover:underline>next: DOTS</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#unity中常用的设计模式>Unity中常用的设计模式</a><ul><li><a href=#singleton-单例模式>Singleton 单例模式</a><ul><li><a href=#典型结构>典型结构</a></li><li><a href=#典型用途>典型用途</a></li><li><a href=#unity中的单例实现>Unity中的单例实现</a></li><li><a href=#单例模式的特点>单例模式的特点</a></li></ul></li><li><a href=#objectpool-对象池>ObjectPool 对象池</a></li><li><a href=#state-状态机模式>State 状态机模式</a></li><li><a href=#observer-观察者模式>Observer 观察者模式</a></li><li><a href=#strategy-策略模式>Strategy 策略模式</a></li><li><a href=#command-命令模式>Command 命令模式</a></li><li><a href=#eventbus-事件总线>EventBus 事件总线</a></li></ul></li><li><a href=#unity自带的设计模式>Unity自带的设计模式</a></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>