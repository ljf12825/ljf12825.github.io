<!doctype html><html lang=en><head><meta charset=UTF-8><title>Prefab System</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Prefab System" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Prefab System<div class=meta>PublishDate: 2025-05-31 |
CreateDate: 2025-05-31 |
LastModify: 2025-05-31
| Creator：ljf12825</div></div><div class=content><p>Unity提供Prefab这种非常强大的机制，用来复用游戏对象，让开发更高效、项目更模块化<br>Prefab就是一个可以重复使用的GameObject模板</p><h2 id=什么是prefab>什么是Prefab</h2><p>Prefab是你在场景里创建好的GameObject（可以包含模型、脚本、组件、子物体等），然后把它拖到项目窗口中生成的资源文件。<br>之后就可以随时从Project中把这个模板拖入场景，生成和原始一样的对象</p><h2 id=prefab特点>Prefab特点</h2><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>模板复用</td><td>一次创建，多次使用</td></tr><tr><td>改动同步</td><td>修改 Prefab，会自动同步所有实例</td></tr><tr><td>支持嵌套</td><td>Prefab 可以包含另一个 Prefab</td></tr><tr><td>可分离</td><td>Prefab 实例可以局部修改，不影响原始 Prefab</td></tr></tbody></table><h2 id=prefab实例与原型的关系>Prefab实例与原型的关系</h2><p>当你把Prefab拖入场景，它会成为Prefab实例，你可以</p><ul><li>完全跟随原始Prefab</li><li>局部Override某些属性</li><li>解除连接（Unpack）</li></ul><table><thead><tr><th>图标颜色</th><th>状态</th></tr></thead><tbody><tr><td>蓝色立方体</td><td>与原 Prefab 保持连接</td></tr><tr><td>灰色立方体</td><td>已经解除连接（Unpacked）</td></tr></tbody></table><h2 id=prefab编辑方式>Prefab编辑方式</h2><p>1.Open Prefab：双击或点击小蓝箭头进入Prefab编辑模式<br>2.Override面板：查看并应用或还原你对实例的修改
3.Apply to Prefab：将实例的更改写入原始Prefab</p><h2 id=prefab的创建和使用>Prefab的创建和使用</h2><p><strong>创建</strong>
1.在<code>Hierarchy</code>中创建好一个GameObject及其组件和子对象<br>2.拖拽到<code>Project</code>视图中，Unity自动保存为<code>.prefab</code>
3.你可以删除场景中的对象，只保留Project中的预制体</p><p><strong>使用</strong></p><ul><li>直接拖到场景中</li><li><code>Instantiate()</code>动态生成</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>void</span> Shoot() =&gt; Instantiate(bulletPrefab, transform.position, transform.rotation);
</span></span></code></pre></div><h2 id=apply--revert操作>Apply / Revert操作</h2><h3 id=apply>Apply</h3><p>把场景中的某个Prefab示例上做的修改，应用回Prefab Asset，让所有示例都得到这个更新<br>在 Hierarchy 选中一个修改过的 Prefab 实例 →
在 Inspector 顶部看到蓝色小条（表示有修改）→
点击右上角小菜单 ≡ → 选择：<br>Apply All：把所有改动应用回 Prefab。<br>Apply to Prefab Name：只应用当前对象。<br>Apply to Root：应用根 Prefab（对于嵌套 Prefab 情况）。</p><h3 id=revert>Revert</h3><p>同样的位置点击：<br>Revert All:撤销所有更改<br>Revert Component：仅撤销某个组件的改动</p><h2 id=实例化prefab>实例化Prefab</h2><p>在运行时通过代码动态创建一个GameObject的副本</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>GameObject obj = Instantiate(prefab)
</span></span></code></pre></div><p><strong>完整示例</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Spawner</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> GameObject prefab;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Instantiate(prefab, transform.position, transform.rotation);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Instantiate几种重载</strong></p><table><thead><tr><th>用法</th><th>说明</th></tr></thead><tbody><tr><td><code>Instantiate(prefab)</code></td><td>在默认位置 <code>(0,0,0)</code> 实例化，没旋转</td></tr><tr><td><code>Instantiate(prefab, position, rotation)</code></td><td>指定位置和旋转</td></tr><tr><td><code>Instantiate(prefab, parent)</code></td><td>设置父物体</td></tr><tr><td><code>Instantiate(prefab, position, rotation, parent)</code></td><td>完整版本，常用</td></tr></tbody></table><p><strong>管理多个实例：比如使用List存储</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;GameObject&gt; enemies = <span style=color:#66d9ef>new</span> List&lt;GameObject&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> SpawnEnemy()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    GameObject enemy = Instantiate(enemyPrefab, RandomPos(), Quaternion.identity);
</span></span><span style=display:flex><span>    enemies.Add(enemy);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>实例化后销毁</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Destroy(gameObject); <span style=color:#75715e>//下一帧销毁</span>
</span></span><span style=display:flex><span>Destroy(gameObject, <span style=color:#ae81ff>2f</span>); <span style=color:#75715e>//2秒后销毁</span>
</span></span></code></pre></div><h2 id=嵌套prefab>嵌套Prefab</h2><p>Nested Prefab是指：一个Prefab内部再包含其他Prefab实例，这样可以构建更加复杂、模块化、易维护的结构</p><h3 id=嵌套prefab的优点>嵌套Prefab的优点</h3><ul><li>结构清晰
拆分功能模块（如武器、UI、特效）</li><li>复用性强
一个组件，可以被多个角色共用</li><li>易于维护
只需要更新嵌套Prefab，所有用到它的地方都会同步</li><li>可组合性高
像搭积木一样组合出复杂对象</li></ul><h2 id=prefab-variant>Prefab Variant</h2><p>Prefab Variant（预制体变体）是一种现有Prefab派生出来的子类Prefab，它继承原始Prefab的结构和属性，但又可以进行自定义修改而不影响原始Prefab</p><p>在Project面板中选中一个Prefab，右键-Create-Prefabvariant</p><p>在Variant中，可以添加新组建，修改属性；但是不可以删除原有组件，并且最好不要修改结构（层级、命名），容易破坏继承结构</p><h2 id=动态加载prefabresources--addressables>动态加载Prefab（Resources / Addressables）</h2><p>在运行时从资源中加载一个Prefab并实例化它，常用于：</p><ul><li>场景中初始不包含目标物体</li><li>按需加载节省内存</li><li>动态UI/子弹/特效等</li></ul><h3 id=resourcesload>Resources.Load</h3><p>基本语法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>GameObject prefab = Resource.Loda&lt;GameObject&gt;(<span style=color:#e6db74>&#34;/path&#34;</span>)
</span></span><span style=display:flex><span>Instantiate(prefab, pos, roa);
</span></span></code></pre></div><h4 id=使用流程>使用流程</h4><p>1.将Prefab放入<code>Assets/Resources</code>文件夹<br>2.加载并实例化</p><p><strong>动态加载常用于需要灵活性、不是频繁生成的物体，运行时加载不如静态引用快</strong><br><strong>动态加载无法自动释放内存，建议手动<code>Resources.UnloadUnusedAssets()</code></strong></p><h3 id=addressables>Addressables</h3><p>如果项目大，Prefab多，建议使用Unity的<a href=%7B%7Bsite.baseurl%7D%7D/posts/2025-06-05-Addressables-System/>Addressables System</a>，支持：</p><ul><li>异步加载</li><li>更灵活的资源管理</li><li>内存更易控制</li></ul><h2 id=prefab和对象池的结合使用>Prefab和对象池的结合使用</h2><p>将Prefab与Object Pooling结合使用，是Unity中非常高效的优化手段，特别适合用于：</p><ul><li>大量反复生成/销毁的物体（如子弹、特效、敌人）</li><li>需要高性能的游戏场景（如射击、塔防、弹幕）</li></ul><h3 id=prefab--object-pooling的基本原理>Prefab + Object Pooling的基本原理</h3><p>1.提前加载Prefab<br>2.批量生成一定数量的实例<br>3.禁用它们，加入池中<br>4.每次需要物体时，从池中取出并启用<br>5.用完后，返回池中而不是销毁</p><p>详见：<a href=%7B%7Bsite.baseurl%7D%7D/posts/2025-06-06-Object-Pooling/>Object Pooling</a></p><h2 id=prefab实战用法>Prefab实战用法</h2><table><thead><tr><th>场景</th><th>Prefab 应用</th></tr></thead><tbody><tr><td>UI 系统</td><td>每个按钮、弹窗都是一个 Prefab</td></tr><tr><td>关卡组件</td><td>场景中的房子、门、陷阱都可以做成 Prefab</td></tr><tr><td>敌人生成</td><td>动态从代码中 <code>Instantiate(enemyPrefab)</code></td></tr><tr><td>粒子特效</td><td>爆炸、烟雾、光环 Prefab 可复用</td></tr></tbody></table></div><nav class=post-nav><a href=/blog/material/ class=hover:underline>pre: Material</a>
<a href=/blog/light/ class=hover:underline>next: Light</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#什么是prefab>什么是Prefab</a></li><li><a href=#prefab特点>Prefab特点</a></li><li><a href=#prefab实例与原型的关系>Prefab实例与原型的关系</a></li><li><a href=#prefab编辑方式>Prefab编辑方式</a></li><li><a href=#prefab的创建和使用>Prefab的创建和使用</a></li><li><a href=#apply--revert操作>Apply / Revert操作</a><ul><li><a href=#apply>Apply</a></li><li><a href=#revert>Revert</a></li></ul></li><li><a href=#实例化prefab>实例化Prefab</a></li><li><a href=#嵌套prefab>嵌套Prefab</a><ul><li><a href=#嵌套prefab的优点>嵌套Prefab的优点</a></li></ul></li><li><a href=#prefab-variant>Prefab Variant</a></li><li><a href=#动态加载prefabresources--addressables>动态加载Prefab（Resources / Addressables）</a><ul><li><a href=#resourcesload>Resources.Load</a><ul><li><a href=#使用流程>使用流程</a></li></ul></li><li><a href=#addressables>Addressables</a></li></ul></li><li><a href=#prefab和对象池的结合使用>Prefab和对象池的结合使用</a><ul><li><a href=#prefab--object-pooling的基本原理>Prefab + Object Pooling的基本原理</a></li></ul></li><li><a href=#prefab实战用法>Prefab实战用法</a></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>