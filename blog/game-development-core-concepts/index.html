<!doctype html><html lang=en><head><meta charset=UTF-8><title>Game Development Core Concepts</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Game Development Core Concepts" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Game Development Core Concepts<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>数学的核心是形式化，工程的核心是权衡，计算机科学的核心就是抽象<br>从底层到顶层，从电路到软件，抽象以各种形式存在于各个过程</p><h2 id=为什么说抽象是核心>为什么说抽象是核心</h2><ul><li>体系层面：计算机世界是人为构建的，没有自然规律必须规定“这样做”。一切系统都是分层设计的产物；真实的硬件指令、晶体管电路过于庞杂，人类无法直接操作这些细节；抽象层帮助屏蔽掉底层复杂性，让开发者用更高层的“模型”去思考问题</li><li>概念层面：在计算机科学中，抽象不仅是对实现细节的屏蔽，更是对问题的本质建模；人为划分的学科是对某个领域的抽象，某个领域是一系列相关概念的集合，而概念本身就是一种抽象，例如：<ul><li>数据结构是对存储方式和操作的抽象</li><li>算法是对解决步骤的抽象</li><li>进程是对程序运行的抽象</li><li>类是对现实事物和行为的抽象</li></ul></li></ul><p>开发者不是直接跟“机器”打交道，而是用“概念”去思考和操作。而抽象是把“具体细节”提炼成“普遍概念”。而编程能力 = 使用抽象的能力 + 构建抽象的能力</p><h2 id=游戏开发>游戏开发</h2><p>游戏开发是技术性、艺术性和商业性的融合，它包括：</p><ul><li>计算机科学的抽象：算法、数据结构、图形学、网络、AI</li><li>工程抽象：引擎架构、模块化、组件系统、工具链</li><li>艺术抽象：视觉（美术、动画、特效）、听觉（音乐、音效）</li><li>人类学抽象：交互设计、玩家心理学、叙事学</li></ul><p>游戏开发的特点在于以下几个方面</p><ul><li>架构与主循环<ul><li>传统软件<ul><li>多是事件驱动：用户点击按钮 -> 程序响应 -> 完成一次逻辑</li><li>没有严格的全局循环，更多依赖操作系统的消息机制</li></ul></li><li>游戏开发<ul><li>Game Loop是核心</li><li>每一帧都要处理输入、物理、AI、渲染 -> 保证实时性</li></ul></li></ul></li><li>数据与状态管理<ul><li>大量瞬时数据（角色坐标、速度、动画状态、AI决策等）</li><li>状态每帧都在更新，生命周期可能只有几毫秒</li><li>引擎常用ECS架构或对象池优化性能</li></ul></li><li>图形与界面<ul><li>实时渲染管线：3D模型、材质、光照、阴影、后处理</li><li>UI也是游戏世界的一部分（血条、HUD、动态菜单）</li><li>需要GPU编程（Shader、OpenGL/DirectX/Vulkan/Metal）</li></ul></li><li>输入处理<ul><li>输入是连续流：键盘、鼠标、手柄、触摸、VR控制器</li><li>必须处理高频输入事件，并和游戏循环绑定（如角色移动、镜头旋转）</li><li>需要支持多平台输入抽象（PC、主机、移动）</li></ul></li><li>性能与优化<ul><li>性能优化是日常工作<ul><li>CPU -> AI/物理/逻辑优化</li><li>GPU -> Draw Call减少、LOD、光照烘焙</li><li>内存 -> 对象池、资源管理</li></ul></li></ul></li><li>多人与网络<ul><li>多人游戏需要实时同步（50~60次/秒）</li><li>处理网络延迟与抖动：预测（Client Prediction）、插值、回滚（Rollback Netcode）</li><li>技术难度远高于传统C/S架构</li></ul></li><li>调试与测试<ul><li>自动化测试覆盖有限（尤其是“手感”“平衡性”）</li><li>调试常依赖游戏内调试工具（DebugUI、可视化碰撞框、日志叠加）</li><li>QA需要人工长时间试玩，找“试玩bug”</li></ul></li><li>团队协作<ul><li>多工种融合：程序 + 美术 + 设计师 + 音效 + 策划</li><li>美术资源和程序逻辑高度耦合（模型、贴图、动画都要引擎支持）</li><li>迭代过程常常是“美术换素材 -> 程序适配 -> 调整玩法”</li></ul></li></ul><h3 id=技术层面的抽象概念>技术层面的抽象概念</h3><p>抛开引擎，语言，工具链，游戏开发的核心本质可以抽象为以下层面</p><h4 id=最底层的抽象状态与变换>最底层的抽象：状态与变换</h4><ul><li>游戏本质上是：在时间维度上不断更新状态</li><li>状态：数据</li><li>变换规则：物理公式、输入逻辑、AI决策、脚本事件&mldr;</li><li>抽象公式：$State_{t+1} = f(State_t, Input_t, \Delta t)$</li></ul><blockquote><p>单机游戏是确定性状态机（输入决定下一步）；网络游戏是部分不确定状态机（网络延迟、同步问题让同一状态在不同客户端不一致，需要预测/回滚）</p></blockquote><p>所有游戏逻辑，都可以抽象为“状态机 + 时间推进”</p><h4 id=核心抽象循环game-loop>核心抽象：循环（Game Loop）</h4><p>Game Loop是游戏引擎的心脏，所有游戏逻辑、渲染、输入处理、物理更新都围绕它转<br><strong>核心思想：循环 + 时间驱动</strong><br>每一帧游戏世界都要经历一套固定流程\</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>while</span> (game_is_running) {
</span></span><span style=display:flex><span>    process_input();   <span style=color:#75715e>// 处理输入：键盘、鼠标、手柄、触屏
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    update(deltaTime); <span style=color:#75715e>// 更新游戏逻辑：AI、动画、物理、状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    render();          <span style=color:#75715e>// 渲染：把当前世界画出来
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>输入：把玩家和外部事件（键盘、鼠标、网络消息）收集进来</li><li>更新：基于输入和时间推进游戏世界状态。这会涉及物理计算、角色移动、碰撞检测、AI逻辑等</li><li>渲染：把结果绘制到屏幕，交给GPU显示</li></ul><p>游戏引擎的核心就是封装了这个主循环</p><h5 id=时间控制deltatime>时间控制：<code>deltaTime</code></h5><p>CPU/GPU性能和环境不同，循环速度会变化。为了保证游戏逻辑的一致性，需要引入帧间隔时间：</p><ul><li><code>deltaTime</code> = 当前帧时间 - 上一帧时间</li><li>所有物体移动、动画更新都基于<code>deltaTime</code>来计算，而不是“每帧加1”</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>position <span style=color:#f92672>+=</span> velocity <span style=color:#f92672>*</span> deltaTime;
</span></span></code></pre></div><h5 id=固定更新-vs-可变更新>固定更新 vs 可变更新</h5><p>很多引擎（比如Unity、Unreal）会区分</p><ul><li>Fixed Update：逻辑、物理更新用固定时间步长（比如0.02秒一次）。保证物理模拟稳定、确定</li><li>Variable Update：渲染和输入随帧率变化，每次循环一次</li></ul><p>这就是为什么Unity里有<code>Update()</code>和<code>FixedUpdate()</code>两个钩子</p><h4 id=结构抽象实体与组件>结构抽象：实体与组件</h4><ul><li>游戏事件由许多对象组成</li><li>最常见的抽象是ECS（Entity-Component-System）或Node/Scene</li><li>公式化：<ul><li>实体（Entity）：唯一ID，对象存在本身</li><li>组件（Component）：数据（位置、生命、动画&mldr;）</li><li>系统（System）：处理逻辑（移动系统、渲染系统&mldr;）</li></ul></li></ul><p>这就是现代引擎常见的设计模式</p><h4 id=行为抽象事件与消息>行为抽象：事件与消息</h4><ul><li>游戏逻辑不是线性流程，而是大量事件驱动<ul><li>玩家按下键 -> 发射子弹</li><li>怪物死亡 -> 掉落物品</li></ul></li><li>所以技术抽象是：事件系统 / 信号系统</li><li>这让不同模块解耦，支持扩展</li></ul><h4 id=表现抽象渲染管线>表现抽象：渲染管线</h4><ul><li>游戏最终要呈现给玩家</li><li>渲染管线抽象：<ul><li>世界数据（模型、灯光、材质）</li><li>变换（矩阵：世界 -> 摄像机 -> 投影）</li><li>光照/Shader计算</li><li>输出像素到屏幕</li></ul></li></ul><p>渲染其实就是：数学变换 + 并行计算</p><h4 id=系统抽象资源与时间>系统抽象：资源与时间</h4><ul><li>游戏是大规模资源的组织：纹理、音效、脚本、AI</li><li>技术抽象上，需要资源管理（加载、缓存、卸载）</li><li>同时要保证实时性：60fps/120fps的节奏约束</li></ul><p>游戏开发技术层面的抽象概念是“实时状态机 + 事件驱动的交互循环”，引擎则是帮助把这些抽象组织好</p></div><nav class=post-nav><a href=/blog/gizmos/ class=hover:underline>pre: Gizmos</a>
<a href=/blog/game-architecture/ class=hover:underline>next: Game Architecture</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#为什么说抽象是核心>为什么说抽象是核心</a></li><li><a href=#游戏开发>游戏开发</a><ul><li><a href=#技术层面的抽象概念>技术层面的抽象概念</a><ul><li><a href=#最底层的抽象状态与变换>最底层的抽象：状态与变换</a></li><li><a href=#核心抽象循环game-loop>核心抽象：循环（Game Loop）</a><ul><li><a href=#时间控制deltatime>时间控制：<code>deltaTime</code></a></li><li><a href=#固定更新-vs-可变更新>固定更新 vs 可变更新</a></li></ul></li><li><a href=#结构抽象实体与组件>结构抽象：实体与组件</a></li><li><a href=#行为抽象事件与消息>行为抽象：事件与消息</a></li><li><a href=#表现抽象渲染管线>表现抽象：渲染管线</a></li><li><a href=#系统抽象资源与时间>系统抽象：资源与时间</a></li></ul></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved</p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>