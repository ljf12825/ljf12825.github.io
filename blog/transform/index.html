<!doctype html><html lang=en><head><meta charset=UTF-8><title>Transform</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=Transform class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Transform<div class=meta>PublishDate: 2025-05-28 |
CreateDate: 2025-05-28 |
LastModify: 2025-05-28
| Creator：ljf12825</div></div><div class=content><p>Transform是Unity中控制物体位置、旋转、缩放和父子层级关系的核心组件</p><h2 id=一什么是transform>一、什么是Transform</h2><p><code>Transfrom</code>是每个<code>GameObject</code>都自带的核心组件，主要负责：</p><ul><li>位置（Position）</li><li>旋转（Rotation）</li><li>缩放（Scale）</li><li>父子关系（Hierarchy）</li></ul><p>可以理解为每个物体在三维世界中的“坐标轴和局部空间信息”。</p><h2 id=二transform的重要属性和区别>二、Transform的重要属性和区别</h2><p>**1.<code>position</code>和<code>localPosition</code></p><table><thead><tr><th>属性名</th><th>含义</th><th>示例用途</th></tr></thead><tbody><tr><td><code>position</code></td><td>世界坐标（绝对位置）</td><td>物体在整个场景中的位置</td></tr><tr><td><code>localPosition</code></td><td>本地坐标（相对于父物体的位置）</td><td>子物体相对于父物体的偏移</td></tr></tbody></table><p>**2.<code>rotation</code>和<code>localRotation</code></p><table><thead><tr><th>属性名</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td><code>rotation</code></td><td>世界旋转</td><td>Quaternion</td></tr><tr><td><code>localRotation</code></td><td>相对父物体的旋转</td><td>Quaternion</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>transform.rotation = Quaternion.Euler(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>//世界旋转</span>
</span></span><span style=display:flex><span>transform.localRotation = Quaternion.idetity; <span style=color:#75715e>//本地旋转重置</span>
</span></span></code></pre></div><p><strong>3.localScale</strong></p><ul><li>表示对象自身的缩放</li><li>注意：缩放不会自动传递到<code>position</code>，但会影响渲染尺寸和碰撞盒</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>transform.localScale = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>); <span style=color:#75715e>//放大两倍</span>
</span></span></code></pre></div><h2 id=三父子层级结构>三、父子层级结构*</h2><p><strong>设置父物体</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>child.transform.parent = parent.transform;
</span></span><span style=display:flex><span><span style=color:#75715e>//或</span>
</span></span><span style=display:flex><span>child.transform.SetParent(parent.transform);
</span></span></code></pre></div><p><strong>常见操作</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Transform parent = transform.parent; <span style=color:#75715e>//获取父对象</span>
</span></span><span style=display:flex><span>Transform child = transform.GetChild(<span style=color:#ae81ff>0</span>); <span style=color:#75715e>//获取第一个子对象</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> childCount = transform.childCount; <span style=color:#75715e>//获取子对象数量</span>
</span></span></code></pre></div><p><strong>使用本地坐标的原因</strong>
当物体成为子对象时，使用<code>localPosition</code>更容易控制其相对于父对象的偏移，比如角色头部、武器挂点等</p><p><strong>为什么<code>Transform</code>可以决定父子结构？</strong>
1.Unity中父子结构的本质
在Unity中，一个GameObject能成为另一个GameObject的子对象，本质上是通过Transform组件的嵌套结构来实现的
2.为什么<code>Transform</code>决定父子关系
因为GameObject的位置、旋转、缩放、层级关系都是由<code>Transform</code>控制的，而Unity场景树（Hierarchy）实际上就是一个<code>Transform</code>树</p><p><strong>举个例子</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>GameObject parent = <span style=color:#66d9ef>new</span> GameObject(<span style=color:#e6db74>&#34;Parent&#34;</span>);
</span></span><span style=display:flex><span>GameObject child = <span style=color:#66d9ef>new</span> GameObject(<span style=color:#e6db74>&#34;Child&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>child.transform.parent = parent.transform;
</span></span></code></pre></div><p>这段代码不会修改该GameObject的本体，它只是把<code>Child</code>的<code>Transform</code>挂到了<code>Parent</code>的<code>Transform</code>上</p><ul><li>GameObject本身不存储层级结构，它只是一个容器</li><li>Transform组件内部有：<ul><li><code>parent</code>：父级Transform</li><li><code>childCount</code>：子级数量</li><li><code>.GetChild(i)</code>：获取第i个子Transform</li></ul></li><li>场景中任何层级结构，其实就是多个Transform组件互相引用的结果</li></ul><h2 id=四transform的重要方法>四、Transform的重要方法</h2><p><strong>移动（不考虑物理系统）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>transform.Translate(Vector3.forward * Time.deltaTIme);
</span></span></code></pre></div><p><strong>旋转</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>tansform.Rotate(Vector3.up, <span style=color:#ae81ff>45</span>);
</span></span></code></pre></div><p><strong>查找</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Transform arm = transform.Find(<span style=color:#e6db74>&#34;Body/LeftArm&#34;</span>);
</span></span></code></pre></div><p><strong>向某点转向（LookAt）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>transform.LookAt(target.transform);
</span></span></code></pre></div><h2 id=五使用技巧与注意事项>五、使用技巧与注意事项</h2><p><strong>坐标转换</strong></p><ul><li>世界坐标转本地坐标</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Vector3 local = transform.InverseTransformPoint(worldPos);
</span></span></code></pre></div><ul><li>本地坐标转世界坐标</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Vector3 world = transform.TransformPoint(localPos);
</span></span></code></pre></div><p><strong>Transform的Property</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>position</code></td><td><code>Vector3</code></td><td>游戏对象在世界空间中的位置</td></tr><tr><td><code>localPosition</code></td><td><code>Vector3</code></td><td>相对于父对象的本地位置</td></tr><tr><td><code>rotation</code></td><td><code>Quaternion</code></td><td>世界空间的旋转（四元数）</td></tr><tr><td><code>localRotation</code></td><td><code>Quaternion</code></td><td>相对于父对象的旋转</td></tr><tr><td><code>eulerAngles</code></td><td><code>Vector3</code></td><td>世界空间的欧拉角（角度制）</td></tr><tr><td><code>localEulerAngles</code></td><td><code>Vector3</code></td><td>本地空间的欧拉角</td></tr><tr><td><code>right</code></td><td><code>Vector3</code></td><td>对象的右方向（本地 X 轴）</td></tr><tr><td><code>up</code></td><td><code>Vector3</code></td><td>对象的上方向（本地 Y 轴）</td></tr><tr><td><code>forward</code></td><td><code>Vector3</code></td><td>对象的前方向（本地 Z 轴）</td></tr><tr><td><code>localScale</code></td><td><code>Vector3</code></td><td>本地空间的缩放比例</td></tr><tr><td><code>parent</code></td><td><code>Transform</code></td><td>父对象的 Transform</td></tr><tr><td><code>childCount</code></td><td><code>int</code></td><td>子对象数量</td></tr><tr><td><code>lossyScale</code></td><td><code>Vector3</code></td><td>世界空间中的实际缩放（包含父缩放影响）</td></tr><tr><td><code>hasChanged</code></td><td><code>bool</code></td><td>表示 Transform 是否自上次检查后发生了变化（可以手动重置为 false）</td></tr><tr><td><code>root</code></td><td><code>Transform</code></td><td>当前 Transform 层级中的最上层对（根）</td></tr></tbody></table><p><strong>Transform的Methods</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Translate(Vector3 translation, Space space = Space.Self)</code></td><td>沿给定方向移动对象（默认本地坐标）</td></tr><tr><td><code>Rotate(Vector3 eulerAngles, Space space = Space.Self)</code></td><td>沿给定方向旋转对象</td></tr><tr><td><code>LookAt(Transform target)</code> 或 <code>LookAt(Vector3 worldPosition)</code></td><td>使对象面向目标</td></tr><tr><td><code>RotateAround(Vector3 point, Vector3 axis, float angle)</code></td><td>绕某个点和轴旋转</td></tr><tr><td><code>TransformDirection(Vector3 localDirection)</code></td><td>将本地方向转换为世界方向</td></tr><tr><td><code>InverseTransformDirection(Vector3 worldDirection)</code></td><td>将世界方向转换为本地方向</td></tr><tr><td><code>TransformPoint(Vector3 localPosition)</code></td><td>本地坐标转世界坐标</td></tr><tr><td><code>InverseTransformPoint(Vector3 worldPosition)</code></td><td>世界坐标转本地坐标</td></tr><tr><td><code>DetachChildren()</code></td><td>解除所有子对象的父子关系</td></tr></tbody></table><p><strong>层级操作与结构</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>SetParent(Transform parent)</code></td><td>设置父对象</td></tr><tr><td><code>SetParent(Transform parent, bool worldPositionStays)</code></td><td>设置父对象，同时控制是否保持世界坐标不变</td></tr><tr><td><code>GetChild(int index)</code></td><td>获取指定索引的子 Transform</td></tr><tr><td><code>Find(string name)</code></td><td>查找名字为 name 的子物体（递归）</td></tr><tr><td><code>IsChildOf(Transform parent)</code></td><td>判断当前 Transform 是否是某父 Transform 的子级</td></tr><tr><td><code>SetAsFirstSibling()</code></td><td>将当前对象设置为父对象的第一个子对象</td></tr><tr><td><code>SetAsLastSibling()</code></td><td>设置为最后一个子对象</td></tr><tr><td><code>SetSiblingIndex(int index)</code></td><td>设置在父 Transform 下的子对象索引</td></tr><tr><td><code>GetSiblingIndex()</code></td><td>获取在父 Transform 下的索引位置</td></tr></tbody></table><p><strong>详见<a href=https://docs.unity3d.com/ScriptReference/Transform.html>Unity官方文档(Transform)</a></strong></p><h2 id=常见组合用法示例>常见组合用法示例</h2><p><strong>1.移动并保持世界坐标</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>child.SetParent(parent, <span style=color:#66d9ef>false</span>);
</span></span></code></pre></div><p><strong>2.朝向某一点</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>transform.LookAt(<span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>));
</span></span></code></pre></div><p><strong>3.自转与公转</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>//公转</span>
</span></span><span style=display:flex><span>transform.RotateAround(center.position, Vector3.up, <span style=color:#ae81ff>20</span> * Time.deltaTIme);
</span></span><span style=display:flex><span><span style=color:#75715e>//自转</span>
</span></span><span style=display:flex><span>transform.Rotate(Vector3.up * <span style=color:#ae81ff>45</span> * Time.deltaTime);
</span></span></code></pre></div><p><strong>4.查找指定子物体并设置缩放</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Transform gun = transform.Find(<span style=color:#e6db74>&#34;Body/Hand/Gun&#34;</span>);
</span></span><span style=display:flex><span>gun.localScale = Vector3.one * <span style=color:#ae81ff>2f</span>;
</span></span></code></pre></div><h2 id=容易混淆的几个方法说明>容易混淆的几个方法说明</h2><table><thead><tr><th>方法/属性</th><th>注意点</th></tr></thead><tbody><tr><td><code>rotation.eulerAngles = ...</code></td><td>实际无效，应该用 <code>rotation = Quaternion.Euler(...)</code></td></tr><tr><td><code>position += ...</code></td><td>本质上是设置绝对世界位置</td></tr><tr><td><code>Translate(...)</code></td><td>默认是相对于自身坐标系移动</td></tr><tr><td><code>LookAt()</code></td><td>会修改 rotation，旋转 Z 轴正方向指向目标</td></tr><tr><td><code>TransformDirection()</code></td><td>是方向转换，不是位置转换！比如方向向量 <code>(0, 0, 1)</code> 表示前方</td></tr></tbody></table></div><nav class=post-nav><a href=/blog/gameobject/ class=hover:underline>pre: GameObject</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#一什么是transform>一、什么是Transform</a></li><li><a href=#二transform的重要属性和区别>二、Transform的重要属性和区别</a></li><li><a href=#三父子层级结构>三、父子层级结构*</a></li><li><a href=#四transform的重要方法>四、Transform的重要方法</a></li><li><a href=#五使用技巧与注意事项>五、使用技巧与注意事项</a></li><li><a href=#常见组合用法示例>常见组合用法示例</a></li><li><a href=#容易混淆的几个方法说明>容易混淆的几个方法说明</a></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved</p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>