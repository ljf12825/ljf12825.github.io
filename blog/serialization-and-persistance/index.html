<!doctype html><html lang=en><head><meta charset=UTF-8><title>Serialization and Persistence</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><div class=container><div class=terminal-overlay><span class=prompt>ljf12825@ljf12825.github.io</span>:<span class=path>~</span>$
<span id=typed-command></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Serialization and Persistence<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>在Unity中，序列化和持久化在游戏数据存储中起到重要的作用</p><h2 id=序列化serialization>序列化（Serialization）</h2><p>序列化就是把内存中的对象转换成可以存储或传输的格式的过程，比如转换成二进制、JSON、XML、或者Unity自己的资产格式\<br>反过来，反序列化（Deserialization）就是把存储或传输的格式转换回程序内存分钟的对象<br>序列化的意义</p><ol><li>保存数据<br>游戏存档就是把游戏状态保存到磁盘上的过程，这个过程就是序列化</li><li>编辑器显示与修改数据<br>Unity Inspector面板显示脚本里字段的值，需要序列化这些字段才能让编辑器读写它们</li><li>网络传输<br>多人游戏中，玩家状态需要网络传输，也要序列化成网络能传输的格式</li></ol><h3 id=unity的序列化系统>Unity的序列化系统</h3><p>Unity有自己的一套序列化规则，决定哪些数据会被序列化（保存、显示在Inspector），核心要点如下：</p><ul><li>字段必须是公有的或标记为<code>[SeriializeField]</code>
只有公有字段或被<code>[SerializeField]</code>标记的私有字段才能被Unity序列化和显示在Inspector中</li><li>支持的类型
Unity支持大部分基础类型的序列化：<code>int</code>,<code>float</code>,<code>string</code>,<code>bool</code>,<code>Vector3</code>,<code>Color</code>等，自定义类型也能被序列化但是要加上<code>[System.Serializable]</code>属性，以及<code>UnityEngine.Object</code>类型（如<code>GameObject</code>,<code>Transform</code>,<code>ScriptableObject</code>等）</li><li>不支持的类型
一些类型无法被序列化，比如<code>Dictionary</code>,<code>delegate</code>,<code>event</code>等</li><li>Unity的序列化是深度序列化
Unity会自动处理类的成员变量，递归序列化引用类型（如类的实例）</li></ul><h3 id=如何序列化>如何序列化</h3><ul><li>基本类型
默认情况下，Unity会序列化所有公有字段和标记为<code>[SerializeField]</code>的私有字段</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyComponent</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> score;
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [SerializeField]</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> playerName;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述代码中<code>score</code>和<code>playerName</code>会被Unity序列化，可以在Inspector中看到并修改</p><ul><li>类的序列化
自定义类（结构体、对象等）也可以被序列化，前提是它们符合序列化条件</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[System.Serializable]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Player</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> health;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameController</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Player player;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这种情况下，<code>Player</code>类被标记为<code>[System.Serializable]</code>，Unity会序列化<code>GameController</code>中的<code>player</code>字段</p><p>在Unity自带的序列化系统中，不能被Unity序列化的字段无法自动保存到Unity的资源文件或场景文件里，在场景保存、Prefab保存、ScriptableObject保存时会被直接忽略，也就是说，下次重新打开场景时，这些字段的值会丢失，但是可以自己保存和传输</p><ol><li>手动转换为可序列化格式</li></ol><ul><li>可以自己把Dictionary、复杂对象转成JSON、XML、二进制等可保存的格式</li><li>常用工具<ul><li><code>JsonUtility</code>（Unity内置，速度快，但功能简单）</li><li><code>Newtonsoft.Json</code>（功能强大，支持Dictionary等）</li><li>二进制序列化（<code>BinaryFormatter</code>/<code>System.IO</code>）</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> Newtonsoft.Json;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collection.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SaveDataExample</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>int</span>&gt; score = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>int</span>&gt;();
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        { <span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#ae81ff>100</span> },
</span></span><span style=display:flex><span>        { <span style=color:#e6db74>&#34;Bob&#34;</span>, <span style=color:#ae81ff>80</span> }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Save()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> json = JsonConvert.SerializeObject(scores);
</span></span><span style=display:flex><span>        System.IO.File.WriteAllText(Application.persistentDataPath + <span style=color:#e6db74>&#34;/scores.json&#34;</span>, json);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Load()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> json = System.IO.File.ReadAllText(Application.persistentDataPath + <span style=color:#e6db74>&#34;/scores.json&#34;</span>);
</span></span><span style=display:flex><span>        scores = JsonConvert.DeserializeObject&lt;Dictionary&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>int</span>&gt;&gt;(json);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样，即使Dictionary在Unity内置序列化中不支持，也能保存和恢复</p><ol start=2><li>用可序列化的中间结构代替
比如把<code>Dictionary&lt;string, int></code>转成两个List</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[System.Serializable]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SerializableDict</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List&lt;<span style=color:#66d9ef>string</span>&gt; keys;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List&lt;<span style=color:#66d9ef>int</span>&gt; values;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> SerializableDict(Dictionary&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>int</span>&gt; dict)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        keys = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>string</span>&gt;(dict.Keys);
</span></span><span style=display:flex><span>        values = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt;(dict.Values);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>int</span>&gt; ToDictionary()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> dict = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>int</span>&gt;();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; keys.Count; ++i)
</span></span><span style=display:flex><span>            dict[keys[i]] = values[i];
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dict;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样Unity就能正常序列化这个<code>SerializableDict</code>，保存到场景或Prefab中</p><ol start=3><li>网络传输</li></ol><ul><li>如果是网络同步（如多人游戏），完全可以跳过Unity序列化系统，直接把数据用JSON、Protobuf、MessagePack等格式打包，发到另一台机器</li><li>这些方式不依赖Unity的序列化规则，因此能传几乎所有C#对象</li></ul><h3 id=序列化到文件>序列化到文件</h3><p><a href=blog/Data-Driven-Design/>Data Driven Design</a></p><h3 id=常见问题和注意事项>常见问题和注意事项</h3><ul><li>引用类型的序列化
如果将一个引用类型（如类实例）赋值给一个字段，Unity会序列化这个引用，而不是值本身。这意味着可以在多个对象中看到相同的实例。如果希望每个实例独立，需要确保它们不共享同一个引用；就是说指针指向同一块内存，要主要意外联动和数据共享</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> MyComponent : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> GameObject prefab; <span style=color:#75715e>// 引用类型</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>[NonSerialized]</code>属性
有时可能不想让某个字段被序列化，这时可以使用<code>[NonSerialized]</code>属性。这会阻止字段在Inspector中显示并被序列化</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[System.NonSerialized]</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> runtimeOnlyValue;
</span></span></code></pre></div><ul><li><code>[HidenInInspector]</code>属性
如果字段被序列化但不希望再Inspector中显示，可以使用<code>[HideInInspector]</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[HideInInspector]</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> hiddenValue;
</span></span></code></pre></div><h3 id=自定义序列化>自定义序列化</h3><ul><li><code>ISerializationCallbackReceiver</code>接口
Unity提供了<code>ISerializationCallbackReceiver</code>接口，允许再对象序列化和反序列化时进行自定义操作。这个接口有两个方法：<code>OnBeforeSerialize()</code>和<code>OnAfterDeserialize()</code>，可以在这些方法中编写序列化之前和之后的逻辑</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MySerializableClass</span> : ISerializationCallbackReceiver
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> valueString;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnBeforeSerialize() { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnAfterDeserialize() =&gt; valueString = <span style=color:#66d9ef>value</span>.ToString();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>自定义PropertyDrawer
如果希望为自定义类创建一个定制化的Inspector界面，可以使用<code>PropertyDrawer</code>类来自定义序列化数据的显示</li></ul><h3 id=序列化与性能>序列化与性能</h3><p>Unity的序列化系统在加载和保存数据时会比较高效，但是有时深度序列化和复杂的数据结构（尤其是包含大量嵌套的引用类型的结构）可能会影响性能。最好限制序列化的数据量，并在必要时进行优化</p><p>能被序列化只是代表Unity知道如何保存/恢复它的格式，是否自动保存取决于它是否在场景、Prefab、ScriptableObject这类持久资源里，运行时数据不会自动保存，而需要手动做持久化</p><h2 id=持久化persistence>持久化（Persistence）</h2><p>持久化是指将游戏或应用中的数据保存在外部存储设备（如硬盘、云存档中），以便在应用关闭或重新启动时恢复。持久化的目标是使数据在不同的会话之间持久存在</p><p><strong>持久化的目的</strong></p><ul><li>保存游戏进度：允许玩家保存当前游戏状态在以后恢复</li><li>配置存储：保存玩家设置、游戏配置等数据</li><li>数据共享：在不同设备间共享和恢复游戏数据</li></ul><h3 id=持久化常见方法>持久化常见方法</h3><h4 id=playerprefs>PlayerPrefs</h4><p><code>PlayerPrefs</code>是Unity内置的一个简单持久化存储工具，主要用于保存玩家的偏好设置、游戏进度等轻量级数据（如音量、分数、关卡解锁状态等）。它的特点是键值对存储，数据会保存到磁盘中，即使退出游戏也会保留</p><h5 id=基本原理>基本原理</h5><p><code>PlayerPrefs</code>本质上是Unity封装的一个跨平台存储接口</p><ul><li>Windows：数据存储在注册表<code>HKEY_CURRENT_USER\Software\[CompanyName]\[ProductName]</code></li><li>macOS：使用<code>~/Library/Preferences/[CompanyName].[ProductName].plist</code></li><li>Android/iOS：使用设备平台提供的<code>SharedPreferences</code>/<code>NSUserDefaults</code></li></ul><blockquote><p>注意：它不是加密存储，任何人都能轻松修改数据，所以不能用来保存敏感信息（例如账号密码、付费信息等）</p></blockquote><h5 id=api>API</h5><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>SetInt(string key, int value)</code></td><td>保存一个整数</td></tr><tr><td><code>SetFloat(string key, float value)</code></td><td>保存一个浮点数</td></tr><tr><td><code>SetString(string key, string value)</code></td><td>保存一个字符串</td></tr><tr><td><code>GetInt(string key, int defaultValue = 0)</code></td><td>获取整数，支持默认值</td></tr><tr><td><code>GetFloat(string key, float defaultValue = 0f)</code></td><td>获取浮点数，支持默认值</td></tr><tr><td><code>GetString(string key, string defaultValue = "")</code></td><td>获取字符串，支持默认值</td></tr><tr><td><code>HasKey(string key)</code></td><td>检查是否存在指定键</td></tr><tr><td><code>DeleteKey(string key)</code></td><td>删除指定键值</td></tr><tr><td><code>DeleteAll()</code></td><td>删除所有存储数据</td></tr><tr><td><code>Save()</code></td><td>手动保存数据到磁盘（通常 Unity 会自动保存，但在退出前调用更安全）</td></tr></tbody></table><h5 id=示例>示例</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PlayerPrefsExample</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 存储数据</span>
</span></span><span style=display:flex><span>        PlayerPrefs.SetInt(<span style=color:#e6db74>&#34;HighScore&#34;</span>, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>        PlayerPrefs.SetFloat(<span style=color:#e6db74>&#34;Volume&#34;</span>, <span style=color:#ae81ff>0.8f</span>);
</span></span><span style=display:flex><span>        PlayerPrefs.SetString(<span style=color:#e6db74>&#34;PlayerName&#34;</span>, <span style=color:#e6db74>&#34;Jeff&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 手动保存（建议重要数据存储后调用一次）</span>
</span></span><span style=display:flex><span>        PlayerPrefs.Save();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 读取数据</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> score = PlayerPrefs.GetInt(<span style=color:#e6db74>&#34;HighSocre&#34;</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> volume = PlayerPrefs.GetFloat(<span style=color:#e6db74>&#34;Volume&#34;</span>, <span style=color:#ae81ff>1f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> name = PlayerPrefs.GetString(<span style=color:#e6db74>&#34;PlayerName&#34;</span>, <span style=color:#e6db74>&#34;Unknown&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>$&#34;Score: {score}, Volume: {volume}, Name: {name}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 检查和删除</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (PlayerPrefs.HasKey(<span style=color:#e6db74>&#34;HighScore&#34;</span>))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            PlayerPrefs.DeleteKey(<span style=color:#e6db74>&#34;HighScore&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=使用建议>使用建议</h5><p>适用场景</p><ul><li>玩家设置（音量、分辨率、按键映射等）</li><li>简单进度数据（关卡解锁、最高分）</li><li>启动次数、首次运行标记</li></ul><p>不适用场景</p><ul><li>大量数据（效率低）</li><li>复杂结构数据（只支持<code>int</code>/<code>float</code>/<code>string</code>）</li><li>敏感信息（无加密，易被修改）</li><li>实时高频写入（可能影响性能）</li></ul><h5 id=存储结构拓展>存储结构拓展</h5><p>如果想用<code>PlayerPrefs</code>存储更复杂的数据（如数组、对象），可以先序列化成JSON</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[System.Serializable]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PlayerData</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> level;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> health;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PlayerPrefsJsonExample</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> SaveData()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        PlayerData data = <span style=color:#66d9ef>new</span> PlayerData
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            name = <span style=color:#e6db74>&#34;Jeff&#34;</span>,
</span></span><span style=display:flex><span>            level = <span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span>            health = <span style=color:#ae81ff>75.5f</span>
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> json = JsonUtility.ToJson(data);
</span></span><span style=display:flex><span>        PlayerPrefs.SetString(<span style=color:#e6db74>&#34;PlayerData&#34;</span>, json);
</span></span><span style=display:flex><span>        PlayerPrefs.Save();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> LoadData()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (PlayerPrefs.HasKey(<span style=color:#e6db74>&#34;PlayerData&#34;</span>))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>string</span> json = PlayerPrefs.GetString(<span style=color:#e6db74>&#34;PlayerData&#34;</span>);
</span></span><span style=display:flex><span>            PlayerData data = JsonUtility.FromJson&lt;PlayerData&gt;(json);
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>$&#34;Name: {data.name}, Level: {data.level}, HP: {data.health}&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=注意事项>注意事项</h5><ol><li>自动保存：Unity在退出游戏时会自动保存，但关键点手动调用<code>Save()</code>更安全（尤其是移动平台可能被强制杀进程）</li><li>数据修改：因为存储在本地，玩家可以通过修改注册表或文件来作弊</li><li>性能问题：频繁调用<code>Save()</code>会导致性能下降，应当批量保存</li></ol><h4 id=文件持久化>文件持久化</h4><p>可以使用<code>System.IO</code>命名空间通过序列化对象的方式将数据保存为文件，常用的格式有JSON、XML和二进制，<a href=#%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%B0%E6%96%87%E4%BB%B6>见上文</a></p><h4 id=scriptableobject><a href=blog/ScriptableObject/>ScriptableObject</a></h4><p><code>ScriptableObject</code>是Unity的一种数据容器，特别适合用于保存游戏配置、关卡数据等。它本质上是一个Unity对象，因此可以被序列化，并且可以保存在项目文件夹中，便于管理</p><h4 id=云存储>云存储</h4><p>对于多人在线游戏或跨设备的存档系统，可以使用云存储。Unity提供了多种方式与云存储服务进行集成，如通过Unity的Cloud Save系统、Firebase等</p><h3 id=文件存储和性能>文件存储和性能</h3><p>持久化数据时，如果存储的数据量很大，或者文件结构很复杂，可能会对性能产生影响。因此：</p><ul><li>使用二进制格式存储数据，比JSON或XML等文本格式效率更高</li><li>如果数据量较小，使用PlayerPrefs或ScriptableObject也是一个较为简单且高效的方案</li></ul><p>在Unity中，序列化和持久化通常是相互结合的，可以使用序列化技术将对象的数据保存到文件中，然后使用文件持久化技术（如JSON、XML、二进制）来存储这些数据，可以实现游戏存档、玩家设置保存等功能</p></div><nav class=post-nav><a href=/blog/scripts/ class=hover:underline>pre: Scripts</a>
<a href=/blog/service-locator/ class=hover:underline>next: Service Locator</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#序列化serialization>序列化（Serialization）</a><ul><li><a href=#unity的序列化系统>Unity的序列化系统</a></li><li><a href=#如何序列化>如何序列化</a></li><li><a href=#序列化到文件>序列化到文件</a></li><li><a href=#常见问题和注意事项>常见问题和注意事项</a></li><li><a href=#自定义序列化>自定义序列化</a></li><li><a href=#序列化与性能>序列化与性能</a></li></ul></li><li><a href=#持久化persistence>持久化（Persistence）</a><ul><li><a href=#持久化常见方法>持久化常见方法</a><ul><li><a href=#playerprefs>PlayerPrefs</a><ul><li><a href=#基本原理>基本原理</a></li><li><a href=#api>API</a></li><li><a href=#示例>示例</a></li><li><a href=#使用建议>使用建议</a></li><li><a href=#存储结构拓展>存储结构拓展</a></li><li><a href=#注意事项>注意事项</a></li></ul></li><li><a href=#文件持久化>文件持久化</a></li><li><a href=#scriptableobject>ScriptableObject</a></li><li><a href=#云存储>云存储</a></li></ul></li><li><a href=#文件存储和性能>文件存储和性能</a></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
		import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
		mermaid.initialize({startOnLoad: true});
	</script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script><script>const text="ls | xargs cat";let i=0;const el=document.getElementById("typed-command");function type(){i<text.length&&(el.textContent+=text[i++],setTimeout(type,80))}type()</script></body></html>