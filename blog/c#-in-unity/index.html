<!doctype html><html lang=en><head><meta charset=UTF-8><title>C# in Unity</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="C# in Unity" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>C# in Unity<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>C#作为Unity开发的首选脚本语言，熟练掌握C#和C.NET Framework对项目架构，可维护性和性能优化的理解能够更加深入<br>C#不同于C++，它的核心是它庞大的框架和生态系统<br>它的设计哲学是底层一致，上层多个分支<br>底层是指：</p><ul><li>同统一的语言（C#）：语法、核心特性（OOP、泛型、委托、LINQ、async/await）在所有领域都是完全一致的</li><li>统一的运行时（CLR -> .NET）：无论是ASP.NET Core、MAUI还是Unity（基于Mono/.NET），最终代码都在一个托管运行时上执行，共享同样的GC、JIT（或AOT）和内存模型</li><li>统一的基础类库（BCL）：<code>System.*</code>命名空间下的核心库（如集合、文件IO、网络、加密、并发）被所有应用类型共享</li></ul><p>学C#核心知识永远不会浪费，切换领域只是在不同的上下文中应用它们</p><p>上层是指：<br>为了针对不同的应用场景和平台，.NET在统一的基础之上，构建了众多高度专业化的应用程序框架\</p><ul><li>Web开发：ASP.NET Core(MVC, Razor Pages, Blazor, Web API)</li><li>跨平台桌面/移动：.NET MAUI</li><li>Windows原生卓铭：WPF, WinForms, WinUI</li><li>游戏开发：Unity（使用C#作为脚本语言）</li><li>云原生/微服务：基于ASP.NET Core，但有一套特定的架构模式和库（如Dapr、Orleans）</li><li>机器学习：ML.NET</li><li>物联网：loT Core</li></ul><p>每个分支都是一个庞大的、自称体系的生态，有自己独有的概念、API、设计模式和最佳实践<br>因此，放弃完全掌握的想法，加固底层（C#核心），和专精某一分支（比如Unity）</p><p>作为一名Unity开发者，学习C#的路径和侧重点是为能够高效解决游戏开发问题，大致可以分为以下几个层级</p><h3 id=层次一核心基础>层次一：核心基础</h3><p>这是写任何脚本的基石，必须达到条件反射般的熟练程度</p><ol><li>OOP</li></ol><ul><li>类和对象</li><li>封装（Encapsulation）</li><li>继承（Inheritance）</li><li>多态（Polymorphism）</li></ul><ol start=2><li>基本语法和类型</li></ol><ul><li>变量、方法、循环、条件判断</li><li>值类型和引用类型</li></ul><ol start=3><li>集合（Collections）</li></ol><ul><li>数组、列表、字典</li></ul><h3 id=层次二unity开发中的特色核心>层次二：Unity开发中的特色核心</h3><p>这些是C#在Unity环境下的特色应用，直接关系到游戏性能和架构</p><ol><li>委托（<code>delegate</code>）和事件（<code>event</code>）</li></ol><ul><li>这是实现脚本间通信最优雅、最解耦的方式</li><li>Unity事件：<code>UnityEvent</code>和<code>UnityAction</code>，用于Inspector中的可视化事件绑定</li></ul><ol start=2><li>协程（<code>Coroutine</code>）</li></ol><ul><li>用于处理随时间序列执行的操作，是<code>Update</code>的替代方案，更高效</li></ul><ol start=3><li>属性（<code>Properties</code>）</li></ol><ul><li>不仅是语法糖。可以用它们创建在Inspector中只读的变量，或者在get/set时加入逻辑</li></ul><ol start=4><li>接口（<code>Interface</code>）</li></ol><ul><li>定义契约行为</li></ul><h3 id=层级三中级概念>层级三：中级概念</h3><p>这些知识能让你写出更优秀、更专业、性能更好的代码</p><ol><li>泛型（<code>Generics</code>）</li></ol><ul><li>编写可重用、类型安全的代码</li></ul><ol start=2><li>LINQ</li></ol><ul><li>查询集合</li></ul><ol start=3><li>异步编程（<code>async</code>/<code>await</code>）</li></ol><ul><li>在Unity中作为协程的另一种选择，在某些场景（如加载资源、网络请求）写法更优雅</li></ul><h3 id=层级四进阶概念>层级四：进阶概念</h3><p>这些是C#的高级特性或在Unity中较少使用的部分</p><ul><li>反射（Reflection）：Unity本身大量使用，但不建议在业务中使用，除非用于基础设施开发</li><li>复杂的表达式树（Expression Trees）</li><li>完整的委托进阶（协变、逆变）</li><li>大部分关于多线程（<code>Thread</code>）的内容：Unity的API大部分必须在主线程调用。如果要使用多线程处理密集计算（如寻路、生成地形），需使用<code>Thread</code>但要将结果通过主线程更新。更常用的是<code>Job System</code>和<code>Burst</code>编译器</li></ul><h3 id=unity开发中的c知识体系>Unity开发中的C#知识体系</h3><p>这是专家级的知识体系，超越了特定领域，涵盖了语言本身、底层原理、生态系统和软技能的全方位深度知识</p><table><thead><tr><th>类别</th><th>具体内容</th><th>说明与深度要求</th></tr></thead><tbody><tr><td>一、语言核心与CLR底层</td><td></td><td>理解“为什么”而不仅仅是“怎么用”</td></tr><tr><td></td><td>CLR（公共语言运行时）内部机制</td><td>深刻理解程序集加载、JIT编译、GC generations（分代垃圾回收）、Large Object Heap（大对象堆）、Just-In-Time vs AOT（如Native AOT）</td></tr><tr><td></td><td>内存管理高级专题</td><td>精通<code>IDisposable</code>模式、<code>finalizer</code>、<code>SafeHandle</code>。理解内存泄露的成因（如事件注册、静态引用）并使用工具（如dotMemory）诊断</td></tr><tr><td></td><td>值类型和引用类型深度探索</td><td><code>struct</code>布局（<code>LayoutKind</code>）、<code>ref</code>返回和局部变量、<code>in</code>/<code>out</code>参数修饰符、<code>Span&lt;T></code>/<code>Memory&lt;T></code>用于高性能无分配操作</td></tr><tr><td></td><td>异常处理最佳实践</td><td>那些异常是可恢复的，哪些不是。会使用<code>ThrowHelper</code>模式避免性能损耗。理解第一次机会异常（First-chance exception）</td></tr><tr><td>二、类型系统与高级特性</td><td></td><td>将语言特性运用至极致的艺术</td></tr><tr><td></td><td>泛型系统内部原理</td><td>理解运行时泛型实例化、类型擦除、约束（<code>where</code>）的编译时影响</td></tr><tr><td></td><td>委托与事件的本质</td><td>理解委托是MulticastDelegate, <code>+=</code>/<code>-=</code>的线程安全问题。会使用<code>Delegate.CreateDelegate</code>进行反射高级操作</td></tr><tr><td></td><td>反射与元数据高级操作</td><td>精通<code>System.Reflection.Emit</code>在运行时动态生成IL代码。理解Attribute的检索性能及其应用场景</td></tr><tr><td></td><td>动态编程</td><td>精通<code>dynamic</code>关键字与DLR（动态语言运行时）的交互，并能说明其与反射的优劣对比</td></tr><tr><td>三、并发与异步编程</td><td></td><td>构建高性能、高响应应用的基石</td></tr><tr><td></td><td>内存模型与volatile</td><td>理解C#内存模型（ECMA CLI规范）、<code>volatile</code>关键字、<code>Volatile.Read</code>/<code>Write</code>、内存屏障（<code>MemoryBarrier</code>）</td></tr><tr><td></td><td>TPL（任务并行库）高级用法</td><td>精通<code>Task</code>状态机内部原理、<code>TaskScheduler</code>自定义、<code>TaskCreationOptions</code>、<code>TaskContinuationOptions</code></td></tr><tr><td></td><td>异步流（Async Streams）</td><td>熟练使用<code>IAsyncEnumerable&lt;T></code>处理异步数据流（如分页拉取所有数据库记录）</td></tr><tr><td></td><td>并行与数据并行</td><td>精通<code>Parallel.For/ForEach</code>及其分区策略（Partitioner）、<code>PLINQ</code>与LINQ的性能权衡与调优</td></tr><tr><td></td><td>高级同步原语</td><td>超越<code>lock</code>，精通<code>SemaphoreSlim</code>、<code>ReaderWriterLockSlim</code>、<code>ManualResetEventSlim</code>、<code>SpinLock</code>、<code>Barrier</code>等的使用场景与性能特性</td></tr><tr><td>四、性能优化与诊断</td><td></td><td>从能跑到飞驰的转变</td></tr><tr><td></td><td>基准测试</td><td>精通使用BenchmarkDotNet进行科学、准确的微基准测试，避免常见的性能测试误区</td></tr><tr><td></td><td>诊断工具链</td><td>熟练使用PerfView、dotnet trace、dotnet counters、Visual Studio Diagnositic Tool 分析性能瓶颈、GC压力、线程竞争等</td></tr><tr><td></td><td>不分配（Zero Allocation）技巧</td><td>熟练使用<code>ArrayPool&lt;T></code>、<code>String.Create</code>、<code>stackalloc</code>（在安全上下文中）来避免托管分配</td></tr><tr><td></td><td>内在函数（Intrinsics）与SIMD</td><td>了解<code>System.Runtime.Intrinsics</code>命名空间，能使用硬件指令集（如SSE,AVX2）进行超高性能计算</td></tr><tr><td>五、生态系统与工程化</td><td></td><td>从代码到可交付的全局视野</td></tr><tr><td></td><td>Roslyn编译器平台</td><td>能编写分析器（Analyzer）和代码修正（Code Fix）来实施团队规范，实现“编译器即平台”</td></tr><tr><td></td><td>依赖注入高级模式</td><td>超越基本用法，精通工厂模式、命名服务、装饰器模式与DI容器（如Microsoft.Extensions.DI）的集成、生命周期管理陷阱</td></tr><tr><td></td><td>源代码生成器（Source Generators）</td><td>能使用SG在编译时生成代码，用于AOT友好、高性能序列化、API绑定等场景</td></tr><tr><td></td><td>跨平台与运行时</td><td>深刻理解<code>.NET</code>与<code>.NET Framework</code>的差异，熟悉<code>RID</code>（运行时标识符），并能处理跨平台兼容性问题</td></tr><tr><td>六、架构与设计</td><td></td><td>构建可维护、可扩展系统的思维</td></tr><tr><td></td><td>领域驱动设计（DDD）</td><td>精通限界上下文、实体、值对象、聚合根、领域事件等概念，并能落地实现</td></tr><tr><td></td><td>高级设计模式</td><td>精通并灵活使用装饰器、适配器、策略、观察者、代理等模式，并理解其现代实现（如基于DI的代理）</td></tr><tr><td></td><td>原则与规范</td><td>不仅遵循SOLID，更能深刻理解其背后的哲学，并能批判性地应用。精通CQS/CQRS、Event Sourcing等架构模式</td></tr><tr><td></td><td>代码度量与质量</td><td>使用工具（如SonarQube, NDepend）维护代码质量，关注圈复杂度、继承深度、耦合度等指标</td></tr><tr><td>七、软技能</td><td></td><td>专家区别于高级工程师的关键</td></tr><tr><td></td><td>技术选型与决策</td><td>能评估不同技术方案（如gRPC vs REST， SQL vs NoSQL）的利弊，并做出符合业务目标的合理决策</td></tr><tr><td></td><td>mentorship（指导）</td><td>能有效地指导和提升团队其他成员的水平，进行有效的代码评审</td></tr><tr><td></td><td>技术债务管理</td><td>能识别并规划偿还技术债务，平衡业务需求与技术卓越</td></tr><tr><td></td><td>持续学习与社区参与</td><td>持续关注语言和生态发展（如.NET Conf），阅读核心团队博客，甚至为开源项目（如.NET Runtime, Roslyn）贡献代码</td></tr></tbody></table></div><nav class=post-nav><a href=/blog/burst-complier/ class=hover:underline>pre: Burst Complier</a>
<a href=/blog/character-controller/ class=hover:underline>next: Character Controller</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#层次一核心基础>层次一：核心基础</a></li><li><a href=#层次二unity开发中的特色核心>层次二：Unity开发中的特色核心</a></li><li><a href=#层级三中级概念>层级三：中级概念</a></li><li><a href=#层级四进阶概念>层级四：进阶概念</a></li><li><a href=#unity开发中的c知识体系>Unity开发中的C#知识体系</a></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>