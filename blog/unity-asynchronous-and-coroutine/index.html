<!doctype html><html lang=en><head><meta charset=UTF-8><title>Unity Asynchronous and Coroutine</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt="Unity Asynchronous and Coroutine" class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Unity Asynchronous and Coroutine<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>在Unity中，异步编程主要应用于长时间运行的操作或I/O操作，例如加载场景、资源（如纹理、音频文件）、进行网络请求或其他非阻塞操作。Unity提供了几种常见的方式来实现异步操作，通常通过协程和异步编程API（如<code>async/await</code>）来实现</p><h2 id=asynchronous>Asynchronous</h2><p>Unity 从 2017 版本开始支持 <code>async/await</code> 异步编程方式，它是 C# 的一部分，适用于处理 耗时的异步操作，如网络请求、文件操作等。通过 <code>async</code> 标记方法，并在需要等待的地方使用 <code>await</code>，可以简化代码并使其更加可读</p><p><strong>示例：异步加载资源（UnityWebRequest）</strong><br>假设你要从网络上下载文件，可以使用<code>async/await</code>来实现非阻塞的异步操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.Networking;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading.Task;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AsyncExample</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> url = <span style=color:#e6db74>&#34;https://example.com/resource&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> result = <span style=color:#66d9ef>await</span> DownloadDataAsync(url);
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;下载完成：&#34;</span> + result);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 异步下载数据</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>string</span>&gt; DownloadDataAsync(<span style=color:#66d9ef>string</span> url)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>using</span> (UnityWebRequest webRequest = UnityWebRequest.Get(url))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 发送请求并等待结果</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>await</span> webRequest.SendWebRequest();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (webRequest.result == UnityWebRequest.Result.Success)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> webRequest.downloadHandler.text; <span style=color:#75715e>// 返回下载的文本内容</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;错误：&#34;</span> + webRequest.error;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中，<code>DownloadDataAsync</code>使用<code>async/await</code>来处理异步操作。<code>awatiwebRequest.SendWebRequest()</code>会等待请求完成，避免阻塞主线程</p><p>异步操作的常见用途：</p><ul><li>网络请求：例如从服务器获取数据或上传数据</li><li>文件操作：读取/写入大文件时避免主线程阻塞</li><li>资源加载：异步加载资源（比如大型的纹理、音频文件等）</li></ul><p>异步编程优缺点：</p><ul><li><p>优点：</p><ul><li>代码更简洁、易于理解</li><li>支持现代C#异步模式，错误处理更加方便</li><li>完全非阻塞主线程，不会影响UI和游戏的流畅性</li></ul></li><li><p>缺点：</p><ul><li>对于资源加载（如场景加载）等操作，仍然需要通过Unity自带的API来实现</li><li>不适用于每一类异步操作，尤其是涉及到Unity特有的对象和接口时</li></ul></li></ul><h2 id=coroutine>Coroutine</h2><p>Unity Coroutine是一种允许在多帧中分布执行代码的机制，它通常用于处理一些需要在多个帧之间等待的任务，比如延时操作、动画播放、资源加载等<br>协程本质上是通过一种特殊的方式执行代码，它可以在执行过程中“暂停”并在后续的帧继续执行</p><p>协程是通过<code>StartCoroutine()</code>来启动的。协程通常返回一个<code>IEnumerator</code>类型的方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CoroutineExample</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Start() =&gt; StartCoroutine(MyCoroutine());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    IEnumerator MyCoroutine()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//在这里执行某些操作</span>
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;协程开始&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Wait 2 seconds</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WaitForSeconds(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 等待结束后继续执行</span>
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;2秒后继续执行&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 继续执行其他操作</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// 等待下一帧</span>
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;协程执行完毕&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中，<code>MyCoroutine</code>协程将在开始时打印“协程开始”，然后等待2秒后打印“2秒后继续执行”，最后在下一帧打印“协程执行完毕”</p><p>协程可以通过<code>yield return</code>暂停执行，直到某个条件满足。常见的暂停类型有：</p><ul><li><code>WaitForSeconds</code>：等待指定的时间</li><li><code>WaitForEndOfFrame</code>：等待当前帧渲染结束后继续执行</li><li><code>WaitForFixedUpdate</code>：等待下一次物理更新</li><li><code>null</code>：等到下一帧执行</li></ul><p>协程并不是自动停止的，你需要显示地停止它<br>使用<code>StopCoroutine()</code>方法可以停止某个协程，或者通过<code>StopAllCoroutine()</code>停止当前对象的所有协程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>StartCoroutine(MyCoroutine());
</span></span><span style=display:flex><span>StopCoroutine(MyCoroutine());
</span></span></code></pre></div><p>协程通常返回一个<code>IEnumerator</code>，但也可以有不同的返回类型，比如<code>WaitForSeconds</code>或其他等待条件类型</p><h3 id=协程的优缺点>协程的优缺点</h3><p>优点：</p><ul><li>简洁性：相比于传统的<code>Update</code>或者使用定时器的方式，协程让代码更简洁、更易于理解</li><li>灵活性：可以处理复杂的等待逻辑，比如按帧延迟、动态等待、分步执行等</li><li>性能优化：协程可以有效避免不必要的多次计算或事件处理，提升游戏性能</li></ul><p>缺点：</p><ul><li>容易受到Unity引擎主线程调度的影响</li><li>错误处理不如<code>async/await</code>简单</li></ul><h3 id=注意>注意</h3><ul><li>协程是在主线程中执行的，所以它们会被游戏的主循环驱动，而不能跨线程操作数据</li><li>协程一旦启动，默认会在对象生命周期内有效，如果对象被销毁，协程会自动停止</li><li>如果需要频繁控制协程的暂停或停止，可能需要考虑使用更复杂的状态机或事件系统来更好的管理它们</li></ul><h3 id=进阶应用>进阶应用</h3><p>协程不仅仅仅限于等待固定时间，也可以与其他逻辑结合实现复杂的功能</p><p><strong>等待某个条件满足后继续执行</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerator WaitForCondition()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (!someCondition) <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Debug.Log(<span style=color:#e6db74>&#34;条件满足，继续执行&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=动态修改等待时间>动态修改等待时间</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerator DynamicWait(<span style=color:#66d9ef>float</span> time)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WaitForSeconds(time);
</span></span><span style=display:flex><span>    Debug.Log(<span style=color:#e6db74>&#34;等待结束&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>实现动画或缓动</strong>
可以用协程来实现逐个改变的某个值，例如实现一个平滑的动画过渡</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerator LerpPosition(Vector3 targetPosition, <span style=color:#66d9ef>float</span> duration)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Vector3 startPosition = transform.position;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> timeElapsed = <span style=color:#ae81ff>0f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (timeElapsed &lt; duration)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        transform.position = Vector3.Lerp(startPosition, targetPosition, timeElapsed / duration);
</span></span><span style=display:flex><span>        timeElapsed += Time.deltaTime;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transform.position = targetPosition;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=协程的底层机制>协程的底层机制</h3><p>在Unity中，协程的执行是通过<code>IEnumerator</code>类型的函数来定义的，协程的调用、暂停、恢复都与Unity的主线程紧密结合<br>协程不是传统意义上的线程，而是通过Unity引擎内部的协程调度系统来管理的</p><p>通过<code>StartCoroutine()</code>方法启动，这个方法接收一个<code>IEnumerator</code>类型的函数，或者是一个字符串（表示方法名）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>StartCoroutine(MyCoroutine());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>StartCoroutine(<span style=color:#e6db74>&#34;MyCoroutine&#34;</span>);
</span></span></code></pre></div><p>当调用<code>StartCoroutine()</code>时，Unity会为该协程分配一个任务，并把它加入到协程调度队列中<br>之后Unity的主循环会负责在每一帧执行协程的代码</p><p>协程本质上时被Unity的引擎框架所调度的，协程代码并不会一次性执行完，而是会按需执行<br><strong>调度流程</strong><br>1.挂起状态：当协程执行到<code>yield return</code>语句时，Unity会暂停协程的执行，并把协程的执行状态保存下来（即当前的执行位置和上下文）<br>2.等待状态：协程会等待指定的时间、条件、或事件。在等待期间，协程的执行被挂起<br>3.恢复执行：当协程等待的条件满足，Unity会再次将协程的执行任务加入到下一帧的调度队列中，并从挂起点继续执行</p><h4 id=协程调度的底层实现机制>协程调度的底层实现机制</h4><p>大致底层实现：</p><ul><li>每个协程有一个状态机，包含当前的执行位置、等待的条件等信息</li><li>Unity会管理所有的协程的队列，在每帧中，根据协程的状态和等待条件，决定哪些协程应该继续执行，哪些需要暂停或恢复</li><li>Unity引擎通过<code>MonoBehaviour</code>类的<code>Update()</code>函数来调度协程，保证协程的状态更新和执行是与游戏主线程同步的</li><li>每次协程的恢复操作本质上是在下一帧的<code>Update()</code>或<code>LateUpdate()</code>中继续执行。协程的执行是由Unity内部的协程管理系统控制的</li></ul><h4 id=协程的性能与限制>协程的性能与限制</h4><ul><li>协程过多会影响性能：如果你创建了大量的协程，并且每个协程的执行时间都比较长，可能会导致性能下降。建议根据时间需求合理使用协程</li><li>协程不能跨线程：协程只能在主线程上允许，它们并不会生成新的线程，因此不能在协程中执行线程相关的任务</li><li>协程与对象生命周期：协程与对象的生命周期紧密关联，当独享被销毁时，所有挂载该对象上的协程都会自动停止</li></ul><h4 id=unity中协程的状态是如何被保存的>Unity中协程的状态是如何被保存的</h4><ol><li><p>Coroutine对象
协程的状态是通过<code>Coroutine</code>对象来管理的，每个协程在运行时都会创建一个<code>Coroutine</code>对象，Unity会使用这个对象来跟踪协程执行状态</p></li><li><p>IEnumerator状态机
协程通常返回一个<code>IEnumerator</code>对象，这实际上就是一个状态机的实现。在协程函数中，你可以通过<code>yield return</code>语句控制协程的执行。当协程遇到<code>yield</code>语句时，Unity会保存当前的执行上下文（如执行位置、局部变量等），并在下一帧继续从这个位置开始执行</p></li><li><p>内存和堆栈
在协程执行过程中，Unity会使用内存中的堆栈来保存函数调用的上下文，每次协程被挂起时，它的局部变量、执行位置等信息会被保存在堆栈中，当协程恢复时，这些信息会被取出，协程继续执行</p></li><li><p>协程调度器
Unity会管理一个协程调度器，它负责跟踪所有活动的协程，并在每一帧更新它们。协程调度器会检查每个协程的状态，如果协程已经完成，它就会被销毁</p></li><li><p>状态保存与恢复
Unity通过以下方式来保存和恢复协程状态：</p></li></ol><ul><li>yield条件：<code>yield return</code>语句时协程的暂停点，Unity会记录当前的暂停点（如等待的时间、是否等待某个事件等）</li><li>协程生命周期：协程的生命周期和GameObject、MonoBehaviour的生命周期有关，只有当对象被销毁或协程被停止时，协程才会完全退出</li><li>暂停/恢复机制：Unity的协程机制基于状态机模型，每次<code>yield</code>返回后，Unity会根据当前的<code>yield</code>值来决定合适恢复协程的执行</li></ul><h4 id=结束和清理>结束和清理</h4><p>当协程结束时，Unity会清理相关的资源并移除协程。若协程被手动停止，Unity会在下一帧停止协程的执行，并释放相关资源</p><h3 id=ienumerator接口><code>IEnumerator</code>接口</h3><p><code>IEnumerator</code>是C#中的一个接口，它广泛用于实现迭代器模式，通过<code>IEnumerator</code>，我们可以控制集合的遍历、生成懒加载的数据、以及其他的一些需要“暂停”和“恢复”的操作，比如Unity中的协程</p><h4 id=ienumerator接口概述><code>IEnumerator</code>接口概述</h4><p><code>IEnumerator</code>是C#中用来实现迭代器模式的接口，它定义了两种方法和一个属性：</p><ul><li><code>MoveNext()</code>：移动到集合中的下一个元素，返回<code>true</code>或<code>false</code>表示是否还有更多元素可供迭代</li><li><code>Current</code>：返回当前元素</li><li><code>Reset()</code>：将迭代器重置到初始状态（不常用，部分实现会抛出异常）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IEnumerator</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> MoveNect();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>object</span> Current { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Reset();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=ienumerator在迭代器中的使用><code>IEnumerator</code>在迭代器中的使用</h4><p><code>IEnumerator</code>主要用于构建“迭代器”，用于按顺序遍历集合中的元素。一个典型的实现例子是一个自定义集合类，它提供了一个迭代器来遍历集合中的元素：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyCollection</span> : IEnumerable
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span>[] numbers = {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> IEnumerator GetEnumerator() =&gt; <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> MyEnumerator(numbers);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyEnumerator</span> : IEnumerator
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span>[] _numbers;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _index = -<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> MyEnumerator(<span style=color:#66d9ef>int</span>[] numbers) =&gt; _numbers = numbers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> MoveNext()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            _index++;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> _index &lt; _numbers.Length;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>object</span> Current =&gt; _numbers[_index];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Reset() =&gt; _index = -<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中，<code>MyCollection</code>实现了<code>IEnumerable</code>接口，这样它就可以被<code>foreach</code>遍历<br><code>GetEnumerator</code>方法返回一个<code>IEnumerator</code>实例，负责控制迭代过程</p><h4 id=yield-return和ienumerator><code>yield return</code>和<code>IEnumerator</code></h4><p>在C#中，<code>yield return</code>是实现<code>IEnumerator</code>接口的一种简化方式，当你使用<code>yield return</code>时，编译器会自动生成一个迭代器类，并且每次<code>yield</code>作为一个暂停点来保存当前的状态<br><strong>示例：使用<code>yield return</code>返回值</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyCollection</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> IEnumerable&lt;<span style=color:#66d9ef>int</span>&gt; GetNumbers()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>GetNumbers</code>返回了一个<code>IEnumerable&lt;int></code>类型的对象，这意味着可以通过<code>foreach</code>来遍历这个集合。<br>每次迭代时，<code>yield return</code>会暂停方法的执行，并将当前值返回给调用者，这个过程在每次调用<code>MoveNext</code>时自动恢复</p><h4 id=ienumerator与unity协程><code>IEnumerator</code>与Unity协程</h4><p>Unity中的协程是基于<code>IEnumerator</code>实现的，它是延迟执行的核心。协程的执行通过<code>yield return</code>来暂停，Unity引擎管理协程的调度和恢复</p><h4 id=yield-return与状态机><code>yield return</code>与状态机</h4><p>在使用<code>yield return</code>时，C#编译器会将方法转化为状态机，每次遇到<code>yield return</code>时，编译器会保存当前方法的执行状态（局部变量、执行信息等），并返回一个<code>IEnumerator</code>迭代器，这个迭代器控制着何时继续执行代码，何时返回控制权</p><p><strong>状态机生成示例</strong>
假设有协程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerator ExampleCoroutine()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Debug.Log(<span style=color:#e6db74>&#34;Step 1&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WairForSeconds(<span style=color:#ae81ff>1f</span>);
</span></span><span style=display:flex><span>    Debug.Log(<span style=color:#e6db74>&#34;Step 2&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译器会将这个代码转化成类似以下的状态机：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ExampleCoroutineStateMachine</span> : IEnumerator
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _state = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> _isPaused = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> MoveNext()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> (_state)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                Debug.Log(<span style=color:#e6db74>&#34;Step 1&#34;</span>);
</span></span><span style=display:flex><span>                _state = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>; <span style=color:#75715e>// 暂停，等待外部恢复</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (_isPaused)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    _isPaused = <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// 模拟等待1秒</span>
</span></span><span style=display:flex><span>                    Debug.Log(<span style=color:#e6db74>&#34;Step 2&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// 完成</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>; <span style=color:#75715e>// 继续执行</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// 协程结束</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>object</span> Current =&gt; <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>每次协程执行时，状态机会检查当前状态，并决定是否继续执行或暂停</p><h4 id=状态保存与恢复ienumerator和unity协程>状态保存与恢复：<code>IEnumerator</code>和Unity协程</h4><p>当Unity执行协程时，每次遇到<code>yield return</code>，它会将协程的执行状态（包括局部变量、执行栈、当前指令位置等）保存到内存中。<br>Unity引擎管理一个协程调度器，这个调度器负责在每一帧检查协程的状态，并恢复或继续执行这些协程<br><code>yield</code>表达式在背后通过<code>IEnumerator</code>实现，并通过Unity的调度器继续执行</p><h4 id=自定义ieumerator>自定义<code>IEumerator</code></h4><p>可以自定义自己的<code>IEnumerator</code>来控制更复杂的行为</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WaitForCondition</span> : CustomYieldInstruction
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Func&lt;<span style=color:#66d9ef>bool</span>&gt; _condition;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> WaitForCondition(Func&lt;<span style=color:#66d9ef>bool</span>&gt; condition) =&gt; _condition = condition;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>bool</span> keepWaiting =&gt; !_condition(); <span style=color:#75715e>// 直到条件满足才结束</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><nav class=post-nav><a href=/blog/ui-system/ class=hover:underline>pre: UI System</a>
<a href=/blog/unity-behavior/ class=hover:underline>next: Unity Behavior</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#asynchronous>Asynchronous</a></li><li><a href=#coroutine>Coroutine</a><ul><li><a href=#协程的优缺点>协程的优缺点</a></li><li><a href=#注意>注意</a></li><li><a href=#进阶应用>进阶应用</a></li><li><a href=#动态修改等待时间>动态修改等待时间</a></li><li><a href=#协程的底层机制>协程的底层机制</a><ul><li><a href=#协程调度的底层实现机制>协程调度的底层实现机制</a></li><li><a href=#协程的性能与限制>协程的性能与限制</a></li><li><a href=#unity中协程的状态是如何被保存的>Unity中协程的状态是如何被保存的</a></li><li><a href=#结束和清理>结束和清理</a></li></ul></li><li><a href=#ienumerator接口><code>IEnumerator</code>接口</a><ul><li><a href=#ienumerator接口概述><code>IEnumerator</code>接口概述</a></li><li><a href=#ienumerator在迭代器中的使用><code>IEnumerator</code>在迭代器中的使用</a></li><li><a href=#yield-return和ienumerator><code>yield return</code>和<code>IEnumerator</code></a></li><li><a href=#ienumerator与unity协程><code>IEnumerator</code>与Unity协程</a></li><li><a href=#yield-return与状态机><code>yield return</code>与状态机</a></li><li><a href=#状态保存与恢复ienumerator和unity协程>状态保存与恢复：<code>IEnumerator</code>和Unity协程</a></li><li><a href=#自定义ieumerator>自定义<code>IEumerator</code></a></li></ul></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>