<!doctype html><html lang=en><head><meta charset=UTF-8><title>Camera</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=Camera class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Camera<div class=meta>PublishDate: 2025-05-28 |
CreateDate: 2025-05-28 |
LastModify: 2025-05-28
| Creator：ljf12825</div></div><div class=content><p>在Unity中，<code>Camera</code>是游戏中视角呈现的核心组件，它决定了玩家从哪里、以什么方式看到游戏世界。</p><p>可以将它理解为游戏世界的“观察者”，通过相机的视角来渲染和展示游戏世界的内容</p><h2 id=camera的核心概念>Camera的核心概念</h2><ol><li>视野（Field of View, FOV）</li></ol><ul><li>视野决定了相机的可见范围，单位通常是角度。FOV越大，显示的范围越广；FOV越小，显示的范围越窄。常见的游戏视角有第一人称（FOV通常较小）和第三人称（FOV较大）</li><li>对于透视相机，FOV越大，物体看起来就越远，越小则物体看起来越近</li><li>对于正交相机，FOV不影响物体的大小，物体的大小保持不变</li></ul><ol start=2><li>摄像机类型</li></ol><ul><li><p>透视摄像机（Perspective）：像人眼一样</p><ul><li>透视摄像机FOV = 60
<img src="/assets/images/PerspectiveCameraFOV=60.jpg" alt="透视摄像机FOV=60"></li><li>透视摄像机FOV = 20
<img src="/assets/images/PerspectiveCameraFOV=20.jpg" alt="透视摄像机FOV=20"></li><li>透视摄像机FOV = 80
<img src="/assets/images/PerspectiveCameraFOV=80.jpg" alt="透视摄像机FOV=80"></li></ul></li><li><p>正交摄像机（Orthographic）：精确而非真实</p><ul><li><p>正交摄像机
<img src=/assets/images/OrthographicCamera.jpg alt=正交摄像机></p></li><li><p>消除透视畸变</p><ul><li>正交摄像机的最大特点是不考虑透视，即：<ul><li>远处的物体不会变小</li><li>近处的物体不会变大</li></ul></li><li>这在某些场景下非常有用，比如：<ul><li>工程图、建筑图、UI界面、2D游戏等</li></ul></li></ul></li><li><p>便于精确计算与对齐</p><ul><li>因为所有对象的投影都是平行的，没有缩放失真，所以：<ul><li>对象之间的相对位置更容易计算</li><li>适合用于网格对齐（Grid Snap）和像素精确的渲染</li></ul></li></ul></li><li><p>适用于2D游戏开发</p><ul><li>大多数2D游戏使用正交摄像机，这样才能保持像素美术不被拉伸或缩放失真</li><li>例如：平台跳跃、塔防、策略类游戏</li></ul></li><li><p>用于UI和HUD绘制</p><ul><li>UI元素通常使用正交摄像机绘制，以确保在不同屏幕分辨率下保持相同的外观</li></ul></li><li><p>技术与设计简化</p><ul><li>对于一些需要标准比例的场景（如棋盘游戏、等距地图编辑器），正交摄像机可以让开发者更轻松地布局和设计</li></ul></li></ul></li></ul><ol start=3><li>裁剪平面（Clipping Planes）</li></ol><ul><li>每个相机有一个近裁剪面和远裁剪面，这些平面决定了相机能够渲染的场景区域。任何在近裁剪面之前或远裁剪面之后的物体都会被剔除，无法渲染</li><li>这两个值非常重要，过小的近裁剪面可能导致深度精度问题，过大的远裁剪面可能会降低性能</li></ul><ol start=4><li>深度（Depth）</li></ol><ul><li>深度是多个相机渲染顺序的控制参数。较大的深度值表示该相机会在渲染顺序中排在较后，优先渲染的相机会覆盖深度较小的相机。可以使用深度来控制不同相机的渲染顺序</li><li>例如，第一人称相机的深度应该大于第三人称相机的深度，这样在同一场景中，第一人称相机的渲染会覆盖第三人称相机</li></ul><ol start=5><li>渲染目标（Render Target）</li></ol><ul><li>默认情况下，相机会将渲染的图像显示在屏幕上。但是也可以将渲染结果输出到一个纹理中（称为Render Texture），从而创建镜头效果或UI显示</li></ul><ol start=6><li>视锥体（View Frustum）</li></ol><ul><li>它定义了摄像机能够看到的空间区域</li><li>是一个截掉顶部的四棱锥体，表示摄像机的“视野”或“观察体积”</li><li>近裁剪面和远裁剪面构成了锥体的前后边界</li><li>左右上下边界则由视角和屏幕宽高比决定</li><li>Unity会自动裁剪视锥体之外的物体，不进行渲染</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>RenderTexture rt = <span style=color:#66d9ef>new</span> RenderTexture(<span style=color:#ae81ff>1920</span>, <span style=color:#ae81ff>1080</span>, <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>camera.targetTexture = rt;
</span></span></code></pre></div><p>用途：</p><ul><li>监控摄像头</li><li>多人游戏中的小窗口视角</li><li>后处理特效（Blur, EdgeDetect）</li></ul><h2 id=camera常用属性>Camera常用属性</h2><p><strong>Clear Flag（清除模式）</strong></p><table><thead><tr><th>ClearFlag 模式</th><th>描述</th></tr></thead><tbody><tr><td><strong>Skybox</strong></td><td>使用当前 Skybox 作为背景</td></tr><tr><td><strong>Solid Color</strong></td><td>使用指定背景颜色</td></tr><tr><td><strong>Depth Only</strong></td><td>仅清除深度缓冲区（常用于叠加 UI）</td></tr><tr><td><strong>Nothing</strong></td><td>什么都不清除（很少用）</td></tr></tbody></table><p><strong>Viewport Rect视口渲染（rect）</strong></p><ul><li>Viewport Rect定义了相机在屏幕上的显示区域。它使用一个四元组来定义，格式为<code>(x, y, width, height)</code>，用于控制相机渲染的区域，可以通过Viewport Rect来在同一屏幕上显示多个相机视图</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>camera.rec = <span style=color:#66d9ef>new</span> Rect(x, y, w, h);
</span></span></code></pre></div><ul><li><code>(x, y)</code>是起点（左下角0,0）</li><li><code>(w, h)</code>是宽度、高度 (0~1)</li></ul><p><strong>示例：左下角显示一个小窗口（小地图）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>miniMapCamera.rect = <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>0.75f</span>, <span style=color:#ae81ff>0.75f</span>, <span style=color:#ae81ff>0.25f</span>, <span style=color:#ae81ff>0.25f</span>);
</span></span></code></pre></div><h2 id=相机控制和效果>相机控制和效果</h2><ol><li>相机跟随</li></ol><ul><li>游戏中的常见需求之一是让相机跟随玩家或物体运动。可以通过简单的脚本，让相机的<code>Transform.position</code>跟随目标物体</li><li>平滑跟随：可以利用<code>Vector3.Lerp</code>或<code>Vector3.SmoothDamp</code>来平滑相机的移动，避免突兀的运动</li></ul><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Vector3 targetPosition = <span style=color:#66d9ef>new</span> Vector3(player.transform.position.x, player.transform.position.y, player.transform.position.z);
</span></span><span style=display:flex><span>    transform.position = Vector3.SmoothDamp(transform.position, targetPosition, <span style=color:#66d9ef>ref</span> velocity, <span style=color:#ae81ff>0.3f</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>第一人称与第三人称视角：</li></ol><ul><li>第一人称视角：相机直接附加到玩家的头部位置，视角跟随玩家的头部运动</li><li>第三人称视角：相机位于玩家背后或上方，保持一定距离并跟随玩家的移动旋转</li></ul><ol start=3><li>后处理效果（Post-Processing）</li></ol><ul><li>Unity的后处理效果可以在渲染之后应用各种视觉效果，比如Bloom、Motion Blur、Depth of Field等。这些效果能够极大地增强游戏的视觉表现</li><li>通常使用PostProcessing Stack来处理这些效果，后处理效果会在相机渲染完之后加入，因此对原始场景的渲染不会产生影响</li></ul><ol start=4><li>摄像机遮挡与碰撞</li></ol><ul><li>在某些情况下，玩家的角色或物体可能会挡住视线，造成相机无法清晰地看到目标。为了避免这种问题，可以在摄像机的脚本中加入简单的碰撞检测，确保相机不会穿透物体</li></ul><h2 id=常见技巧>常见技巧</h2><ol><li>相机拉远/拉近（Zoom）</li></ol><ul><li>通过调整相机的FOV或者直接调整相机的<code>Transform.position.z</code>，可以模拟相机的拉近或拉远效果</li></ul><ol start=2><li>自定义相机动画</li></ol><ul><li>通过对相机的Transform进行插值动画，可以实现平滑的过渡效果，例如在场景中切换不同视角或执行特定的镜头动作</li></ul><h2 id=常见使用案例>常见使用案例</h2><p><strong>1.世界坐标转UI坐标（UI跟随物体）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Vector3 screenPos = Camera.main.WorldToScreenPoint(worldTarget.Position);
</span></span><span style=display:flex><span>uiObject.position = screenPos;
</span></span></code></pre></div><p><strong>2.鼠标点击获取世界坐标（射线）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (Physics.Raycast(ray, <span style=color:#66d9ef>out</span> RaycastHit hit)) Debug.Log(<span style=color:#e6db74>&#34;点击位置是：&#34;</span> + hit.point);
</span></span></code></pre></div><p><strong>3.多相机渲染UI与3D</strong></p><ul><li>主相机渲染3D（depth = 0）</li><li>UI相机渲染UI， clearFlags = DepthOnly, depth = 1</li></ul><h2 id=优化建议>优化建议</h2><ul><li>不要同时启用多个全屏相机</li><li>尽量合并摄像机输出（避免depth重叠）</li><li>用Layer + cullingMask控制渲染内容</li><li>使用Object Pool避免动态创建摄像机</li></ul><h2 id=摄像机插件推荐>摄像机插件推荐</h2><p><strong>Cinemachine（Unity官方）</strong></p><ul><li>更专业的摄像机管理系统</li><li>支持跟随、过渡、轨迹、抖动等</li><li>强烈推荐用来代替自定义相机控制脚本</li></ul><h2 id=api>API</h2><h3 id=properties>Properties</h3><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>clearFlags</code></td><td><code>CameraClearFlags</code></td><td>清除模式（背景如何处理）</td></tr><tr><td><code>backgroundColor</code></td><td><code>Color</code></td><td>背景颜色（Clear Flags 为 Color 时有效）</td></tr><tr><td><code>cullingMask</code></td><td><code>LayerMask</code></td><td>渲染哪些层的物体（通过 Layer 过滤）</td></tr><tr><td><code>orthographic</code></td><td><code>bool</code></td><td>是否为正交摄像机（2D 用）</td></tr><tr><td><code>orthographicSize</code></td><td><code>float</code></td><td>正交相机的可视区域高度一半</td></tr><tr><td><code>fieldOfView</code></td><td><code>float</code></td><td>视野角度（仅透视模式下有效）</td></tr><tr><td><code>nearClipPlane</code></td><td><code>float</code></td><td>最近可见距离</td></tr><tr><td><code>farClipPlane</code></td><td><code>float</code></td><td>最远可见距离</td></tr><tr><td><code>depth</code></td><td><code>float</code></td><td>相机渲染优先级（数字大者后绘制）</td></tr><tr><td><code>targetTexture</code></td><td><code>RenderTexture</code></td><td>渲染输出目标（用于后处理、UI）</td></tr><tr><td><code>aspect</code></td><td><code>float</code></td><td>宽高比，默认由屏幕决定</td></tr><tr><td><code>rect</code></td><td><code>Rect</code></td><td>相机视口（屏幕中的显示区域）</td></tr><tr><td><code>pixelRect</code></td><td><code>Rect</code></td><td>实际像素区域</td></tr><tr><td><code>cameraType</code></td><td><code>CameraType</code></td><td>摄像机类型（Game、Scene、Preview）</td></tr><tr><td><code>enabled</code></td><td><code>bool</code></td><td>是否启用此相机</td></tr></tbody></table><h3 id=methods>Methods</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>ScreenToWorldPoint(Vector3)</code></td><td>将屏幕坐标转为世界坐标（Z 轴代表深度）</td></tr><tr><td><code>WorldToScreenPoint(Vector3)</code></td><td>将世界坐标转为屏幕坐标</td></tr><tr><td><code>ScreenToViewportPoint(Vector3)</code></td><td>屏幕坐标转视口坐标（0~1）</td></tr><tr><td><code>ViewportToWorldPoint(Vector3)</code></td><td>视口转世界坐标</td></tr><tr><td><code>Render()</code></td><td>手动触发相机渲染（常用于离屏渲染）</td></tr><tr><td><code>ResetAspect()</code></td><td>重置相机宽高比为屏幕比例</td></tr><tr><td><code>ResetProjectionMatrix()</code></td><td>重置投影矩阵</td></tr></tbody></table><p><strong><a href=https://docs.unity3d.com/ScriptReference/Camera.html>Unity官方文档（Camera）</a></strong></p></div><nav class=post-nav><a href=/blog/light/ class=hover:underline>pre: Light</a>
<a href=/blog/gameobject/ class=hover:underline>next: GameObject</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#camera的核心概念>Camera的核心概念</a></li><li><a href=#camera常用属性>Camera常用属性</a></li><li><a href=#相机控制和效果>相机控制和效果</a></li><li><a href=#常见技巧>常见技巧</a></li><li><a href=#常见使用案例>常见使用案例</a></li><li><a href=#优化建议>优化建议</a></li><li><a href=#摄像机插件推荐>摄像机插件推荐</a></li><li><a href=#api>API</a><ul><li><a href=#properties>Properties</a></li><li><a href=#methods>Methods</a></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved</p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>