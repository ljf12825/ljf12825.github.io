<!doctype html><html lang=en><head><meta charset=UTF-8><title>Object</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=Object class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Object<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>Object是Unity中所有内建物体的基类，实现在UnityEngine.CoreModule中，不同于C#中的<code>System.Object</code>，它是托管层（C#）和原生引擎层（C++）之间的桥梁，背后绑定着Unity C++引擎层的资源句柄</p><h2 id=object的特点unity的特有行为>Object的特点（Unity的特有行为）</h2><p><strong>引擎资源的绑定</strong></p><p>每个<code>UnityEngine.Object</code>对象都对应一个C++层对象，它们通过一个<code>instance 2D</code>来关联，且资源的生命周期不由GC管理</p><p>比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>GameObject go = <span style=color:#66d9ef>new</span> GameObject();
</span></span><span style=display:flex><span>Object.Destroy(go);
</span></span><span style=display:flex><span>Debug.Log(go == <span style=color:#66d9ef>null</span>);  <span style=color:#75715e>// true</span>
</span></span></code></pre></div><p>这就是Object的“鬼行为”，此处的<code>go == null</code>并非等价于<code>object is null</code></p><p><strong>Unity的“fake null”机制</strong>
<code>fake null</code>是Unity中一个特有的概念，通常用来描述已经销毁的对象或者已经不再有效的对象的引用。尽管对象被销毁了，但它仍然存在一个“假”引用，这个引用就像是一个假的<code>null</code>，它指向的对象实际上已经不再有效，但在代码层面看起来却任然是一个对象。具体来说，<code>fake null</code>让你能够获得一个对象引用，但该对象的属性和方法无法被正常访问，或者会返回默认值，或者不会产生期望的结果</p><p>Unity重写了<code>==</code>操作符</p><p>如果一个<code>Object</code>对象在引擎层已经被销毁（Destroy过），但C#还保有托管引用，这时候：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Debug.Log(go == <span style=color:#66d9ef>null</span>); <span style=color:#75715e>// true</span>
</span></span><span style=display:flex><span>Debug.Log(go.Equals(<span style=color:#66d9ef>null</span>)); <span style=color:#75715e>// false</span>
</span></span><span style=display:flex><span>Debug.Log(ReferenceEquals(go, <span style=color:#66d9ef>null</span>)); <span style=color:#75715e>// false</span>
</span></span></code></pre></div><p>为什么需要fake null</p><ol><li><p>避免NullReferenceException
在传统的编程中，如果一个对象被销毁或设为<code>null</code>，而你还试图访问它的属性或方法，就会引发<code>NullReferenceException</code>错误。在Unity中，许多对象的销毁并不立即释放内存，尤其是当销毁了一个游戏对象或组件时。为了避免频繁的<code>null</code>检查和避免程序崩溃，Unity引入了<code>fake null</code></p></li><li><p>内存管理的优化
Unity并不是立即销毁对象，而是将其“标记”为无效，保持它的引用存在，但无法访问。这使得Unity可以更高效地管理内存。内存的实际释放通常依赖于垃圾回收器，而不是对象销毁后立即释放内存，从而避免频繁的内存分配和释放造成的性能瓶颈</p></li></ol><p><code>fake null</code>行为总结</p><ol><li>引用存在，但对象无效</li><li>不抛出异常</li><li>确保内存管理不会立即释放内存</li></ol><h3 id=底层原理>底层原理</h3><p>Unity的<code>Object</code>在C#层其实只是一个代理，它对应的C++引擎层对象通过C#层的<code>IntPtr m_CachedPtr</code>与C++对象通信（该字段可以在反编译时看到）</p><p>资源对象（比如一个贴图）在编译器导入时会被转换为native object，保存在场景或资源文件中，加载时通过Unity自己的反序列化系统生成C#代理对象，并挂接<code>m_CachedPtr</code></p><p>Unity会使用C++引擎进行资源生命周期的管理，而不是C#的GC，所以Destroy调的是C++的释放接口</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Sometimes an instance of Object can be in detached state, where there is no underlying native object. T
</span></span><span style=display:flex><span>his can happen if the instance references an native object that has been destroyed, or a missing Asset or missing type. 
</span></span><span style=display:flex><span>Detached objects retain their InstanceID, but the object cannot be used to call methods or access properties. 
</span></span><span style=display:flex><span>An object in this state will appear to be null, because of special implementations of operator==, operator!= and Ojbect.bool.
</span></span><span style=display:flex><span>Because the object is not truly null, a call to Object.ReferenceEquals(myobject, null) will return false.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The null-comditional operator(?.)and the null-coalescing operator(??)are not supported with Unity Object because they cannot be overridden to treat detached objects the same as null.
</span></span><span style=display:flex><span>It is only safe to use those operators in your scripts if there is certainty that the objects being checked are never in a detached state.
</span></span></code></pre></div><h2 id=object-api>Object API</h2><p><strong>Properties</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>name</code></td><td><code>string</code></td><td>对象名称（可读写）</td></tr><tr><td><code>hideFlags</code></td><td><code>HideFlags</code></td><td>控制对象是否可隐藏/可编辑/保存</td></tr></tbody></table><p><strong><code>hideFlags</code></strong><br>常见用途：</p><ul><li>隐藏对象</li><li>防止误删或编辑</li><li>不让对象随着场景保存（通常用于运行时生成的对象）</li></ul><p>常用枚举值</p><table><thead><tr><th>枚举值</th><th>含义</th></tr></thead><tbody><tr><td><code>HideFlags.None</code></td><td>默认行为，无隐藏</td></tr><tr><td><code>HideFlags.HideInHierarchy</code></td><td>在 Hierarchy 视图中隐藏</td></tr><tr><td><code>HideFlags.HideInInspector</code></td><td>在 Inspector 中隐藏</td></tr><tr><td><code>HideFlags.NotEditable</code></td><td>不允许用户编辑（灰掉）</td></tr><tr><td><code>HideFlags.DontSave</code></td><td>场景保存时不保存该对象</td></tr><tr><td><code>HideFlags.DontSaveInBuild</code></td><td>打包时不保存该对象</td></tr><tr><td><code>HideFlags.DontSaveInEditor</code></td><td>编辑器中不保存该对象</td></tr><tr><td><code>HideFlags.HideAndDontSave</code></td><td>隐藏并不保存（临时对象）</td></tr></tbody></table><p><strong>Public Methods</strong></p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>GetInstanceID</code></td><td>获得object的实例ID</td></tr><tr><td><code>ToString</code></td><td>返回<code>object.name</code></td></tr></tbody></table><p><strong>Static Methods</strong></p><table><thead><tr><th>方法</th><th>描述</th><th>示例/说明</th></tr></thead><tbody><tr><td><code>Destroy(Object obj)</code></td><td>销毁一个对象，在当前帧结束时生效</td><td><code>Destroy(gameObject);</code></td></tr><tr><td><code>Destroy(Object obj, float t)</code></td><td>延迟 t 秒销毁对象</td><td><code>Destroy(gameObject, 2.0f);</code></td></tr><tr><td><code>DestroyImmediate(Object obj)</code></td><td>立刻销毁对象，<strong>只推荐在编辑器中使用</strong></td><td><code>DestroyImmediate(gameObject);</code></td></tr><tr><td><code>DontDestroyOnLoad(Object target)</code></td><td>场景切换时不销毁该对象</td><td>常用于单例或管理器类</td></tr><tr><td><code>FindAnyObjectByType&lt;T>()</code></td><td>获取任何已加载的指定类型对象（不保证顺序）</td><td>替代旧版 <code>FindObjectOfType</code></td></tr><tr><td><code>FindFirstObjectByType&lt;T>()</code></td><td>获取第一个找到的指定类型对象（可能更快）</td><td>常用于初始化查找</td></tr><tr><td><code>FindObjectsByType&lt;T>()</code></td><td>获取所有已加载的指定类型对象</td><td><code>var allEnemies = FindObjectsByType&lt;Enemy>();</code></td></tr><tr><td><code>Instantiate(Object original)</code></td><td>克隆一个对象（创建副本）</td><td><code>Instantiate(prefab);</code></td></tr><tr><td><code>Instantiate(Object original, Vector3 position, Quaternion rotation)</code></td><td>在指定位置和旋转创建克隆</td><td><code>Instantiate(prefab, pos, rot);</code></td></tr><tr><td><code>InstantiateAsync(Object original)</code></td><td>异步克隆对象，返回 <code>AsyncInstantiateOperation</code></td><td>用于 Addressables 或大型对象，节省主线程开销</td></tr></tbody></table><p><strong>Operators</strong></p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>bool</code></td><td>是否存在</td></tr><tr><td><code>operator!=</code></td><td>比较两个object是否引用不同的物体</td></tr><tr><td><code>operator==</code></td><td>是否引用相同</td></tr></tbody></table><h2 id=object与资源的关系>Object与资源的关系</h2><p>几乎所有资源类型（包括预制体、贴图、材质、音频、动画等）都继承自<code>Object</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Texture tex = Resources.Load&lt;Texture&gt;(<span style=color:#e6db74>&#34;MyTexture&#34;</span>);
</span></span></code></pre></div><p><code>Resources.Load&lt;T>()</code>返回的其实就是一个<code>Object</code>的子类（这里是Texture）</p><h2 id=继承关系>继承关系</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Object
</span></span><span style=display:flex><span>  ├── GameObject
</span></span><span style=display:flex><span>  └── Component
</span></span><span style=display:flex><span>        ├── MonoBehaviour
</span></span><span style=display:flex><span>        └── Transform / Collider / Renderer / ...
</span></span></code></pre></div><p>所以可以有：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>GameObject go = <span style=color:#66d9ef>new</span> GameObject();
</span></span><span style=display:flex><span>Object obj = go; <span style=color:#75715e>// legal</span>
</span></span><span style=display:flex><span>Component comp = go.GetComponent&lt;Transform&gt;();
</span></span><span style=display:flex><span>Object o2 = comp; <span style=color:#75715e>// legal</span>
</span></span></code></pre></div><p><code>new</code>出来的<code>GameObject</code>是合法的，但不能<code>new</code> <code>Transform</code>或<code>Renderer</code>，必须用<code>AddComponent</code>等引擎API创建</p></div><nav class=post-nav><a href=/blog/navigation/ class=hover:underline>pre: Navigation</a>
<a href=/blog/object-pooling/ class=hover:underline>next: Object Pooling</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#object的特点unity的特有行为>Object的特点（Unity的特有行为）</a><ul><li><a href=#底层原理>底层原理</a></li></ul></li><li><a href=#object-api>Object API</a></li><li><a href=#object与资源的关系>Object与资源的关系</a></li><li><a href=#继承关系>继承关系</a></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved</p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>