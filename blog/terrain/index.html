<!doctype html><html lang=en><head><meta charset=UTF-8><title>Terrain</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/>~</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Lib</a></li><li><a href=/repository/>Repos</a></li><li><a href=/files/>Files</a></li><li><a href=/resource/>Resource</a></li><li><a href=/reference/>Ref</a></li><li><a href=/about/>About</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Winodws</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/ href=/>Home</a> ————————————— <a class=nav-item data-path=/system/ href=/system/>System</a>          |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |                                |
|                        /    |                                |
|                       /     |                                |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |                <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |                <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                          <a class=nav-item data-path=/csbasic/ href=/csbasic/>CSBasic</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script src=/js/star-nav.js></script><script src=/js/site.js defer></script><script src=/js/star-active.js></script><article class=single_article><div class=title>Terrain<div class=meta>Update: 2025-06-01
>> Creator：ljf12825</div></div><div class=content><p>在Unity中，Terrain是一个专门用于制作大规模、自然风格场景的强大工具</p><h2 id=什么是terrain>什么是Terrain</h2><p>Terrain是Unity提供的一个内置组件，用于在场景中创建可编辑的地形<br>它由多个部分组成：</p><ul><li>地形本体（高度图控制的网格）</li><li>纹理涂层（地表材质贴图）</li><li>植被/树木/草</li><li>光照支持（光照贴图、探针）</li><li>LOD和剔除</li></ul><h2 id=terrain的核心结构>Terrain的核心结构</h2><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td><strong>高度图（Heightmap）</strong></td><td>决定地形的高低起伏</td></tr><tr><td><strong>绘制材质（Layers）</strong></td><td>地面纹理（如草地、岩石、雪）混合涂刷</td></tr><tr><td><strong>细节对象（Details）</strong></td><td>草、石头、花等低多边形细节（大量渲染优化）</td></tr><tr><td><strong>树木系统（Trees）</strong></td><td>批量放置支持 LOD 的树</td></tr><tr><td><strong>碰撞体</strong></td><td>自动生成地形碰撞</td></tr><tr><td><strong>光照支持</strong></td><td>支持烘焙光照图、Light Probe、反射探针</td></tr></tbody></table><h2 id=terrain-data>Terrain Data</h2><p><code>Terrain Data</code>是地形的“后端数据容器”，和<code>Terrain</code>组件一起工作，一个<code>Terrain</code>组件绑定一个<code>TerrainData</code>资源</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Terrain terrain = GetComponent&lt;Terrain&gt;();
</span></span><span style=display:flex><span>TerrainData data = terrain.terrainData;
</span></span></code></pre></div><h3 id=terraindata保存的内容><code>TerrainData</code>保存的内容</h3><h4 id=高度图heightmap>高度图（Heightmap）</h4><ul><li>用灰度图(float[,])描述地形的高度</li><li>控制地形表面的形状</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>float</span>[,] heights = terrainData.GetHeights(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, width, height);
</span></span></code></pre></div><h4 id=纹理图层splatmaps>纹理图层（Splatmaps）</h4><ul><li>每层纹理混合信息</li><li>用来混合多个地形材质（如泥土、草地、雪）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>float</span>[,,] alphamaps = terrainData.GetAlphamaps(x, y, w, h);
</span></span></code></pre></div><h4 id=细节对象detailsgrass>细节对象（Details/Grass）</h4><ul><li>如草地、灌木，用细节地图存储</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span>[,] detailMap = terrainData.GetDetailLayer(x, y, w, h, detailLayerIndex);
</span></span></code></pre></div><h4 id=树对象trees>树对象（Trees）</h4><ul><li>存储每棵树的位置、缩放、原型类型</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>TreeInstance[] trees = terrainData.treeInstances;
</span></span></code></pre></div><h4 id=分辨率信息>分辨率信息</h4><ul><li>高度图分辨率：决定地形精细度</li><li>控制图分辨率：纹理混合图精度</li><li>细节图分辨率：草木布置精度</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>terrainData.heightmapResolution
</span></span><span style=display:flex><span>terrainData.alphamapResolution
</span></span><span style=display:flex><span>terrainData.detailResolution
</span></span></code></pre></div><p><strong>示例：运行时生成地形</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> GenerateTerrain()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  TerrainData terrainData = <span style=color:#66d9ef>new</span> TerrainData();
</span></span><span style=display:flex><span>  terrainData.heightmapResolution = <span style=color:#ae81ff>513</span>;
</span></span><span style=display:flex><span>  terrainData.size = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>1000</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span>[,] heights = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>float</span>[<span style=color:#ae81ff>513</span>, <span style=color:#ae81ff>513</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> x = <span style=color:#ae81ff>0</span>; x &lt; <span style=color:#ae81ff>513</span>; ++x)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> y = <span style=color:#ae81ff>0</span>; y &lt; <span style=color:#ae81ff>513</span>; ++y)
</span></span><span style=display:flex><span>    heights[x, y] = Mathf.PerlinNoise(x * <span style=color:#ae81ff>0.01f</span>, y * <span style=color:#ae81ff>0.01f</span>) * <span style=color:#ae81ff>0.2f</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  terrainData.SetHeights(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, heights);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  GameObject terrainGO = Terrain.CreateTerrainGameObject(terrainData);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=注意事项>注意事项</h3><table><thead><tr><th>限制</th><th>说明</th></tr></thead><tbody><tr><td>只能在主线程读写</td><td>不支持多线程访问（除非用 <code>NativeArray</code> Hack）</td></tr><tr><td>修改后需刷新</td><td>修改 <code>terrainData</code> 后需设置给 <code>Terrain</code> 才生效</td></tr><tr><td>不可跨 Terrain 共享贴图索引</td><td>每个地形的 <code>TerrainLayer[]</code> 不能乱用，需要独立处理</td></tr></tbody></table><h2 id=terrain-in-inspector>Terrain in Inspector</h2><p>场景中的Terrain对象一般会包含以下模块</p><ul><li>Terrain（主组件）</li><li>Terrain Collider（自动附加）</li><li>Terrain Tools（各种绘制工具）</li><li>Terrain Settings（参数设置）</li></ul><h3 id=create-neighbor-terrains>Create Neighbor Terrains</h3><p><img src=/images/Blog/CreateNeighborTerrains.jpg alt=CreateNeighborTerrains></p><h4 id=这是什么>这是什么</h4><p>Unity的每一个Terrain是一个地形快（chunk），当你需要构建更大的世界地图时：</p><blockquote><p>你可以将多个地形快拼接在一起，形成一个无缝连接的大地图
<code>Create Neighbor Terrains</code>就是一个快捷工具，让你快速在上下左右形成新的Terrain，并自动设置它们之间的连接关系（Neighbor）</p></blockquote><h4 id=unity会做什么>Unity会做什么</h4><ul><li>自动创建一个或多个相邻的Terrain GameObject</li><li>与当前的Terrain无缝拼接（边界贴合）</li><li>自动设置每个地形的Neighbor引用（主要用于LOD过渡等）</li></ul><p><img src=/images/Blog/TerrainNeighbor.jpg alt=TerrainsNeighbor></p><h4 id=创建后的terrain有哪些特征>创建后的Terrain有哪些特征</h4><ul><li>分辨率与当前Terrain一致</li><li>初始高度图为空白</li><li>材质/Detail Layer/树/Layer并不会自动继承，需要手动复制</li><li>已经自动设置了<code>SetNeighbor</code>（Unity会在内部管理连接信息）</li></ul><h4 id=为什么需要neighbor信息>为什么需要Neighbor信息</h4><p>Unity Terrain在运行时做：</p><ul><li>LOD边界融合（避免接缝）</li><li>光照探针插值正确性</li><li>寻路/NavMesh分布</li></ul><p>也就是说，如果你手动创建了多个Terrain，没有设置Neighbor，会出现：</p><ul><li>LOD切换时断裂</li><li>光照贴图不连续</li><li>草树渲染突然中断</li></ul><h4 id=tips>Tips</h4><p>多Terrain的场景通常配合：</p><ul><li><code>Streaming</code>（按需加载块）</li><li><code>Runtime Stitching</code>（连接边界）
可以使用插件如MicroSplat/Gaia等进行多地形管理</li></ul><h3 id=paintterrain>PaintTerrain</h3><p><img src=/images/Blog/PaintTerrain.jpg alt=PaintTerrain></p><p>这是Unity Terrain系统用于手动“绘制”地形的工具，类似PS中的笔刷，但是用于三维地形，可以用它来：</p><ul><li>提升/降低地形</li><li>涂抹纹理（比如：草、图、雪）</li><li>铺设草和石头（Detail）</li><li>放置树木（Tree）</li><li>设置材质混合</li><li>创建地形孔洞（如山洞入口）</li></ul><h4 id=sub-tools>Sub Tools</h4><h5 id=1raise-or-lower-terrain>1.Raise or Lower Terrain</h5><blockquote><p>用笔刷将地形向上或向下推动</p></blockquote><ul><li>Bursh Size：笔刷大小（影响范围）</li><li>Opacity：强度（提升速度）</li><li>Target Strength：单次推拉的力量</li><li>可用于画山、丘陵、平原</li></ul><p>配合<code>Shift</code>反向操作</p><h5 id=2set-height>2.Set Height</h5><blockquote><p>把地形调整到某个统一的高度（例如建平台）</p></blockquote><ul><li>设置<code>Target Height</code>，然后绘制地形</li><li>适合制作建筑平台、河面、平地道路</li></ul><p>可以使用<code>Flatten</code>一键铺平当前Terrain</p><h5 id=3smooth-height平滑地形>3.Smooth Height（平滑地形）</h5><blockquote><p>平滑地形的高低差，让地形更自然</p></blockquote><ul><li>常用于锐利山峰边缘平滑处理</li><li>减少单位移动时的突兀感</li></ul><h5 id=4paint-texture涂地表材质>4.Paint Texture（涂地表材质）</h5><blockquote><p>把不同纹理“画”到地形上，实现草地、雪地、沙漠的混合过渡</p></blockquote><ul><li>每个纹理时一个Terrain Layer</li><li>Unity支持多图混合（最多8张）</li><li>使用笔刷方式混合地表纹理</li></ul><p>示例层：</p><ul><li>Layer1：Grass</li><li>Layer2：Dirt</li><li>Layer3：Rock</li></ul><p>支持自定义笔刷、混合过渡控制（Opacity）<br><code>Add Layer</code>添加纹理层，选用PBR材质（支持BaseMap、NormalMap）</p><h5 id=5terrain-holes>5.Terrain Holes</h5><blockquote><p>画出洞，让地形有缺口（可用于洞穴、地道入口）</p></blockquote><ul><li>类似“橡皮擦”，直接擦掉地形面片</li><li>可用于：<ul><li>做地下世界入口</li><li>配合Portal、Volume、Trigger使用
默认不可通过地形下看见，需要你手动铺地板或连接其他网格模型</li></ul></li></ul><h3 id=paint-trees>Paint Trees</h3><p><img src=/images/Blog/PaintTrees.jpg alt=PaintTrees></p><p><code>Paint Trees</code>是Unity Terrain中用于批量种植树木的工具，它支持使用不同树模型的自动随机分布、缩放、选择、LOD显示等，是创建森林、山地植被的关键工具</p><h4 id=添加树模型>添加树模型</h4><p>点击 “Edit Trees” → “Add Tree…”：</p><ul><li>在弹出的窗口中选择一个 树的 Prefab</li><li>Unity 支持：<ul><li>Tree Creator 制作的树（.tree 文件）</li><li>SpeedTree 模型（.spm 文件）</li><li>自己导入的 FBX/Prefab 模型（需带有 LOD/Collider）</li></ul></li></ul><p>要求：</p><ul><li>树不能有刚体或Animator</li><li>树Prefab中必须包含Mesh Renderer（或SpeedTree）</li></ul><h4 id=种树参数设置>种树参数设置</h4><p>添加好树之后，就可以开始“画树”了，主要参数如下：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><strong>Brush Size</strong></td><td>控制笔刷直径（影响范围）</td></tr><tr><td><strong>Tree Density</strong></td><td>控制单位面积内种植的数量</td></tr><tr><td><strong>Tree Height/Width</strong></td><td>控制树的缩放范围（有最小和最大）</td></tr><tr><td><strong>Color Variation</strong></td><td>控制颜色的随机扰动（偏红、偏绿、偏亮等）</td></tr><tr><td><strong>Random Rotation</strong></td><td>勾选后自动随机 Y 轴旋转树（防止重复感）</td></tr></tbody></table><p>每画一次，就会在当前区域根据密度、大小、颜色等参数生成多个树</p><h4 id=树木渲染和性能优化>树木渲染和性能优化</h4><p>Unity的Terrain树有专门的渲染优化方案</p><h5 id=billboard看板树>Billboard（看板树）</h5><ul><li>当树距离相机较远时，自动变成平面图片</li><li>极大减少了远距离渲染负担</li></ul><h5 id=lod支持>LOD支持</h5><ul><li>使用SpeedTree模型或LOD Group的树可自动切换模型精度</li><li>可自定义LOD阶段</li></ul><h5 id=gpu-instancing>GPU Instancing</h5><ul><li>大量相同的树会使用GPU Instancing批处理渲染</li><li>极大提高性能，适合森林、大面积自然场景</li></ul><h4 id=树的碰撞>树的碰撞</h4><p>默认树时没有碰撞器的，但你可以启用碰撞</p><ul><li>勾选<code>Tree Collider</code>（取决于添加的树的prefab）</li><li>或者在Runtime中为某些特殊树添加<code>Capsule Collider</code>等</li></ul><p>适用于：</p><ul><li>玩家可以撞到树</li><li>砍树系统</li><li>遮挡判断</li></ul><h4 id=几种树的比较>几种树的比较</h4><table><thead><tr><th>工具</th><th>特点</th></tr></thead><tbody><tr><td><strong>Tree Creator</strong></td><td>Unity 内置的老式树编辑器，支持风、LOD，效率不高，（2022版本已弃用）</td></tr><tr><td><strong>SpeedTree</strong></td><td>高级树木生成工具，效果好，适合中大型项目（但是商业插件）</td></tr><tr><td><strong>普通 Prefab 树</strong></td><td>自己做的 FBX + LOD，灵活但需优化得当</td></tr><tr><td><strong>Terrain 树</strong></td><td>专为大量地形种树优化，性能最佳但不支持动画/刚体</td></tr></tbody></table><h3 id=paint-details>Paint Details</h3><p><img src=/images/Blog/PaintDetails.jpg alt=PaintDetails></p><p><code>Paint Details</code>是Unity Terrain系统中用于在地形上批量绘制“小型自然细节”的工具，它与<code>Paint Trees</code>类似，但用于体积更小、密度更高的细节对象，是构建自然场景的关键补充</p><h4 id=如何添加细节类型>如何添加细节类型</h4><p>点击面板中的：Edit Details → Add Detail Mesh / Add Grass Texture</p><p>Unity提供两种添加方式</p><table><thead><tr><th>类型</th><th>描述</th><th>适用</th></tr></thead><tbody><tr><td><strong>Detail Mesh</strong></td><td>3D Mesh 物体</td><td>小石头、蘑菇、落叶、低模草</td></tr><tr><td><strong>Grass Texture</strong></td><td>Billboard（摄像机对面）草贴图</td><td>草地、麦田、灌木等</td></tr></tbody></table><h5 id=add-grass-texture>Add Grass Texture</h5><p>用于画贴图式草，性能最高</p><ul><li>你只需指定一个灰度图草纹理（通常带透明背景）</li><li>Unity会使用Billboard模式渲染草</li><li>草会随风飘动（可在Terrain Setting设置Wind参数）</li><li>可调颜色混合范围、尺寸、透明度</li></ul><h5 id=add-detail-mesh>Add Detail Mesh</h5><ul><li>可选一个Prefab（如石头、蘑菇、底模模型）</li><li>用于3D小物件渲染</li><li>可以勾选GPU Instancing以提升性能</li></ul><p>注意：</p><ul><li>太复杂的Mesh会降低性能</li><li>太密集的放置会导致Draw Call飙升</li></ul><h4 id=paint参数>Paint参数</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><strong>Brush Size</strong></td><td>笔刷范围（单位为世界坐标）</td></tr><tr><td><strong>Opacity</strong></td><td>笔刷强度（一次能刷多少）</td></tr><tr><td><strong>Target Strength</strong></td><td>总体密度（越高越密）</td></tr><tr><td><strong>Random Color / Size</strong></td><td>自动扰动草的颜色、尺寸，提升自然感</td></tr><tr><td><strong>Noise Spread</strong></td><td>控制颜色/透明度变化分布程度（更逼真）</td></tr></tbody></table><h4 id=渲染与性能优化>渲染与性能优化</h4><h5 id=优化特性>优化特性</h5><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td><strong>Billboard 渲染</strong></td><td>仅用平面草贴图，看起来像 3D 实际是贴图</td></tr><tr><td><strong>GPU Instancing</strong></td><td>Detail Mesh 会批处理，显著降低 Draw Call</td></tr><tr><td><strong>LOD 剔除</strong></td><td>距离过远会剔除渲染，节省性能</td></tr></tbody></table><p>注意：</p><ul><li>草的渲染非常依赖显卡带宽，大量草可能拖慢帧率</li><li>Detail Mesh应尽量简化为低面数模型</li><li>尽量不要混用太多不同Detail类型</li></ul><h5 id=风动效果设置>风动效果设置</h5><ul><li>草地的“飘动”来自于<code>Terrain Setting</code>中的Wind Settings for Grass</li><li>可调：<ul><li>Speed（速度）</li><li>Size（波动幅度）</li><li>Bending（弯曲度）</li><li>Grass Tint（颜色偏移）</li></ul></li></ul><p>默认Terrain草是静态烘焙的，运行时不支持动态添加
但可以：</p><ul><li>使用脚本控制<code>DetailPrototype</code>动态添加/刷新</li><li>使用<code>GPU Instancing + Compute Shader</code>自制草系统</li></ul><h3 id=terrain-settings>Terrain Settings</h3><p><img src=/images/Blog/TerrainSetting_1.jpg alt=TerrainSetting_1>
<img src=/images/Blog/TerrainSetting_2.jpg alt=TerrainSetting_2></p><h4 id=basic-terrain>Basic Terrain</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>Grouping ID</strong></td><td>地形自动拼接的组编号。多个地形设置相同 ID，可自动连接边界。</td></tr><tr><td><strong>Auto Connect</strong></td><td>自动连接相邻地形边缘（启用后根据 Grouping ID）。</td></tr><tr><td><strong>Draw</strong></td><td>控制地形是否可见。取消勾选可临时隐藏地形。</td></tr><tr><td><strong>Draw Instanced</strong></td><td>使用 GPU Instancing 渲染瓦片，节省 draw call，推荐开启。</td></tr><tr><td><strong>Enable Ray Tracing Support</strong></td><td>支持光线追踪（HDRP下使用）。</td></tr><tr><td><strong>Pixel Error</strong></td><td>地形 LOD 精度。数值越低越精细，越高越省性能（建议 PC: 1<del>5，移动端：5</del>15）。</td></tr><tr><td><strong>Minimum/Maximum Detail Limit</strong></td><td>限制 LOD 变化范围（较少使用，可保持默认）。</td></tr><tr><td><strong>Base Map Dist.</strong></td><td>多远使用低分辨率贴图（节省远处渲染消耗）。</td></tr><tr><td><strong>Cast Shadows</strong></td><td>地形是否投射阴影。</td></tr><tr><td><strong>Reflection Probes</strong></td><td>是否使用反射探针，推荐使用 <code>Blend Probes</code>。</td></tr><tr><td><strong>Material</strong></td><td>使用的地形材质，默认是 <code>TerrainLit</code> 或 <code>Default-Terrain-Standard</code>。</td></tr></tbody></table><h4 id=tree--detail-objects>Tree & Detail Objects</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>Draw</strong></td><td>控制是否渲染树木和草丛等细节。</td></tr><tr><td><strong>Bake Light Probes For Trees</strong></td><td>树木是否参与光照探针烘焙。</td></tr><tr><td><strong>Remove Light Probe Ringing</strong></td><td>防止光照探针边界产生光晕伪影。</td></tr><tr><td><strong>Preserve Tree Prototype</strong></td><td>保持原始树模型设置。</td></tr><tr><td><strong>Tree Motion Vectors</strong></td><td>设置树木是否支持运动矢量（用于动效或后期处理）。</td></tr><tr><td><strong>Detail Distance</strong></td><td>草/细节渲染距离（推荐 60~100，性能关键）。</td></tr><tr><td><strong>Detail Density Scale</strong></td><td>草的密度百分比（1 = 全密度，调小省性能）。</td></tr><tr><td><strong>Tree Distance</strong></td><td>树木的最大渲染距离（推荐 PC: 500~1000）。</td></tr><tr><td><strong>Billboard Start</strong></td><td>多远开始使用看板树（节省性能）。</td></tr><tr><td><strong>Fade Length</strong></td><td>Billboard 淡入淡出的距离，提升视觉平滑度。</td></tr><tr><td><strong>Max Mesh Trees</strong></td><td>同屏最多渲染多少真实 Mesh 树，超过则不渲染。</td></tr><tr><td><strong>Detail Scatter Mode</strong></td><td>控制草丛分布策略（Coverage 更均匀，推荐）。</td></tr></tbody></table><h4 id=wind-settings-for-grass>Wind Settings for Grass</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>Speed / Size / Bending</strong></td><td>控制风的速度、大小、弯曲程度。</td></tr><tr><td><strong>Grass Tint</strong></td><td>草的全局色调调整（可以统一偏绿、偏黄）。</td></tr></tbody></table><h4 id=mesh-resolution>Mesh Resolution</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>Terrain Width / Length / Height</strong></td><td>地形尺寸（单位：米）</td></tr><tr><td><strong>Detail Resolution Per Patch</strong></td><td>每块 Detail Patch 中草的分布密度。</td></tr><tr><td><strong>Detail Resolution</strong></td><td>整体地形上草丛/细节的划分格子数。越高越细腻但越耗。</td></tr></tbody></table><h4 id=holes-settings>Holes Settings</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>Compress Holes Texture</strong></td><td>对地形挖洞贴图进行压缩，节省内存。</td></tr></tbody></table><h4 id=texture-resolutions>Texture Resolutions</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>Heightmap Resolution</strong></td><td>地形高度图精度，建议：513 或 1025（越高越细腻）</td></tr><tr><td><strong>Control Texture Resolution</strong></td><td>混合贴图精度，控制多种材质混合（如草+土+雪）</td></tr><tr><td><strong>Base Texture Resolution</strong></td><td>远距离使用的 Base Map 分辨率（节省远处性能）</td></tr></tbody></table><h4 id=lighting>Lighting</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>Contribute Global Illumination</strong></td><td>地形是否参与全局光照（用于 Lightmap/GI）</td></tr><tr><td><strong>Receive Global Illumination</strong></td><td>接收 GI 的方式：<code>Lightmaps</code> 或 <code>Light Probes</code></td></tr></tbody></table><h4 id=lightmapping>Lightmapping</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>Scale In Lightmap</strong></td><td>地形占 Lightmap 的比例。越高越清晰（但更占用空间）</td></tr><tr><td><strong>Lightmap Parameters</strong></td><td>控制烘焙时的精度、抗锯齿、间距等，可选低中高 preset。</td></tr></tbody></table><h4 id=quality-settings>Quality Settings</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>Ignore Quality Settings</strong></td><td>是否忽略当前全局 Quality 设置的控制，强制使用当前面板设定。</td></tr></tbody></table><h2 id=主要地形制作方式>主要地形制作方式</h2><h3 id=1手动笔刷绘制适用于小项目快速原型>1.手动笔刷绘制（适用于小项目、快速原型）</h3><ul><li>Unity自带Terrain工具，支持高度、纹理、树、草等绘制</li><li>优点：操作直观，上手快</li><li>缺点：效率低、不易保持美术风格一致，细节靠人工修</li><li>使用场景：教学演示、小型独立游戏、快速原型</li></ul><h3 id=2外部dcc工具制作---导入高度图专业项目常用>2.外部DCC工具制作 -> 导入高度图（专业项目常用）</h3><ul><li>使用专业地形软件或美术工具生成高质量地形，再导入Unity：</li></ul><table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td><strong>World Machine</strong></td><td>高级噪声算法，真实山脉地貌生成</td></tr><tr><td><strong>Gaea</strong></td><td>节点式地形设计工具，艺术控制更强</td></tr><tr><td><strong>Blender / Houdini</strong></td><td>使用建模 + 程序化节点生成复杂地形</td></tr><tr><td><strong>Photoshop</strong></td><td>手绘/合成灰度高度图</td></tr><tr><td><strong>Substance Designer</strong></td><td>高度图 + Splatmap生成</td></tr></tbody></table><ul><li>Unity支持将这些高度图作为<code>Raw</code>导入，并通过<code>TerrainData</code>生成地形</li></ul><h3 id=3程序生成地形runtime或编译器内>3.程序生成地形（Runtime或编译器内）</h3><ul><li>常用于开放世界、沙盒、随机地图类型游戏</li><li>通过代码控制<code>TerrainData</code>的高度图、纹理图、细节对象等</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>float</span>[,] heights = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>float</span>[width, height];
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> x = <span style=color:#ae81ff>0</span>; x &lt; width; ++x)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> y = <span style=color:#ae81ff>0</span>; y &lt; height; ++y)
</span></span><span style=display:flex><span>    heights[x, y] = Mathf.PerlinNoise(x * <span style=color:#ae81ff>0.05f</span>, y * <span style=color:#ae81ff>0.05f</span>);
</span></span><span style=display:flex><span>terrainData.SetHeights(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, heights);
</span></span></code></pre></div><ul><li>可加入：<ul><li>噪声函数（Perlin、Simplex）</li><li>河流生成</li><li>村庄、道路布置</li></ul></li></ul><h3 id=插件生成最强大的方式>插件生成（最强大的方式）</h3><p>Unity商城中有许多强大的地形插件：</p><table><thead><tr><th>插件</th><th>功能特色</th></tr></thead><tbody><tr><td><strong>Gaia Pro</strong></td><td>一站式地形生成、生态系统、海洋、天气</td></tr><tr><td><strong>MapMagic 2</strong></td><td>节点图式、程序化地形、支持多地形拼接</td></tr><tr><td><strong>Terrain Composer 2</strong></td><td>高自由度、数据驱动生成</td></tr><tr><td><strong>MicroSplat / MegaSplat</strong></td><td>高级地形贴图混合、溶解、湿度等效果</td></tr><tr><td><strong>Vegetation Studio Pro</strong></td><td>大规模草木渲染优化</td></tr></tbody></table><h2 id=terrain-lod-编写调优>Terrain LOD 编写/调优</h2><p>在Unity中，Terrain的LOD是通过高度图分辨率、<code>Pixel Error</code>、以及细节分布分辨率来自动控制网格细分级别。</p><p>但Unity也允许通过Shader或代码进一步控制、调优甚至自定义LOD系统</p><h3 id=unity-terrain的lod原理>Unity Terrain的LOD原理</h3><p>Unity的内置Terrain使用以下机制实现LOD：</p><table><thead><tr><th>控制项</th><th>功能</th></tr></thead><tbody><tr><td><code>Pixel Error</code></td><td>控制地形 LOD 变化的灵敏度（越高越糙但更快）。</td></tr><tr><td><code>Base Map Distance</code></td><td>多远开始只用 base map 贴图（低分辨率预览）</td></tr><tr><td><code>Detail Resolution Per Patch</code></td><td>每块 patch 的细节分辨率，影响草和细节的 LOD。</td></tr><tr><td><code>Detail Distance / Tree Distance</code></td><td>控制草木显示距离。</td></tr></tbody></table><p>Unity Terrain会自动把地形划分为多个Patch（块），并对每块Patch做LOD</p><h3 id=自定义地形lod-shader>自定义地形LOD Shader</h3><p>如果想完全控制地形LOD，特别是在自写Mesh Terrain时，可以通过<code>Shader + C#</code>实现</p><p><strong>示例：通过高度图动态LOD网格</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-hlsl data-lang=hlsl><span style=display:flex><span><span style=color:#75715e>// 顶点 shader 中使用 distance 控制 mesh LOD 精度</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> distanceToCamera <span style=color:#f92672>=</span> distance(_WorldSpaceCameraPos.xyz, v.vertex.xyz);
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> lodLevel <span style=color:#f92672>=</span> saturate(distanceToCamera <span style=color:#f92672>/</span> _LodRange); <span style=color:#75715e>// 0~1</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 然后根据lodLevel选择不同精度的高度图采样</span>
</span></span></code></pre></div><p>也可以用 Tessellation Shader 来实现更智能的细分控制</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-hlsl data-lang=hlsl><span style=display:flex><span>[<span style=color:#a6e22e>domain</span>(<span style=color:#e6db74>&#34;tri&#34;</span>)]
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>partitioning</span>(<span style=color:#e6db74>&#34;fractional_even&#34;</span>)]
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>outputtopology</span>(<span style=color:#e6db74>&#34;triangle_cw&#34;</span>)]
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>patchconstantfunc</span>(<span style=color:#e6db74>&#34;PatchConstantFunction&#34;</span>)]
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>outputcontrolpoints</span>(<span style=color:#ae81ff>3</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> TessellationHullFunction(...)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 自定义 LOD 控制 tessellationFactor</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=lod调优策略>LOD调优策略</h3><table><thead><tr><th>调优目标</th><th>技术手段</th></tr></thead><tbody><tr><td>提高性能</td><td>增大 Pixel Error、减小 Patch 分辨率、加大 base map 距离</td></tr><tr><td>增加视觉质量</td><td>减少 Pixel Error、开启实时阴影、使用高精度高度图</td></tr><tr><td>跨平台支持</td><td>低端设备禁用草地、禁用阴影、减少树距离</td></tr><tr><td>编程控制</td><td>使用 <code>terrain.detailObjectDistance = x</code>、<code>terrain.heightmapPixelError = x</code> 动态调节</td></tr></tbody></table><h2 id=terrain-gpu-instancing草树渲染优化>Terrain GPU Instancing（草、树渲染优化）</h2><p><code>Terrain GPU Instancing</code>是Unity用于优化草和树渲染性能的关键技术，它能显著减少Draw Call数量，加速大量重复物体的渲染，非常适合用于大场景、开放世界、森林等</p><h3 id=什么是gpu-instancing>什么是GPU Instancing</h3><p>GPU Instancing(GPU 实例化)是指：</p><blockquote><p>一次提交，多次绘制相同物体，减少CPU->GPU的调用次数</p></blockquote><ul><li>普通方式：每棵草都一次Draw Call（开销爆炸）</li><li>Instancing：同一模型、不同位置->1次Draw Call，绘制所有实例</li></ul><h3 id=在unity-terrain中的应用>在Unity Terrain中的应用</h3><h4 id=details-gpu-instancing>Details GPU Instancing</h4><p>Unity 2018+起支持：</p><ul><li>使用材质类型：Instanced Mesh 或 Grass Mesh</li><li>并开启“Enable GPU Instancing”选项</li></ul><p>操作方法：<br>1.打开Terrain面板-><code>Paint Details</code>工具</p><p>2.点击<code>Edit Details</code> -> <code>Add Detail Mesh</code></p><p>3.在弹窗中：</p><ul><li>选择一个小草模型（Mesh）</li><li>勾选Use GPU Instancing</li><li>设置距离、颜色、密度等参数</li></ul><p>4.Unity自动启用GPU实例渲染</p><blockquote><p>注意：草贴图（billboard类型）默认不支持GPU Instancing，需改为Mesh类型或自定义Shader</p></blockquote><h4 id=trees-gpu-instancing>Trees GPU Instancing</h4><p>树的GPU Instancing 需要满足两个条件：</p><ul><li>模型为Mesh（非SpeedTree）</li><li>树的材质启用GPU Instancing</li></ul><p>操作：<br>1.打开<code>Paint Trees</code>工具</p><p>2.添加树种时选择普通Mesh树（非SpeedTree）</p><p>3.确保其材质上开启GPU Instancing</p><h3 id=注意事项-1>注意事项</h3><table><thead><tr><th>限制 / 要点</th><th>说明</th></tr></thead><tbody><tr><td>草的材质必须使用 <strong>支持 Instancing 的 Shader</strong>（如 URP Lit 或自写）</td><td></td></tr><tr><td>Instancing 不等于合批，它是“并行绘制”，但仍然占用 GPU VRAM</td><td></td></tr><tr><td>不支持完全随机模型或颜色（需通过 Shader 控制实例差异）</td><td></td></tr><tr><td>若草量极大，结合 <strong>LOD、Culling、地形剔除工具</strong> 更有效</td><td></td></tr></tbody></table><h3 id=高阶优化>高阶优化</h3><table><thead><tr><th>技术</th><th>功能</th></tr></thead><tbody><tr><td><strong>LOD + Crossfade</strong></td><td>减少远距离树模型复杂度</td></tr><tr><td><strong>Vegetation Studio Pro / Nature Renderer</strong></td><td>插件增强 GPU 草渲染（支持更远距离、风、阴影）</td></tr><tr><td><strong>Compute Shader Grass（高级）</strong></td><td>自己写草系统，全 GPU 控制，风、互动等</td></tr></tbody></table><p><strong>示例：自定义URP Shader支持Instancing</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>Tags {&#34;RenderType&#34; = &#34;Opaque&#34;}
</span></span><span style=display:flex><span>Pass{
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  CGPROGRAM
</span></span><span style=display:flex><span>  #pragma vertex vert
</span></span><span style=display:flex><span>  #pragma fragment frag
</span></span><span style=display:flex><span>  #pragma multi_compile_instancing
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  UNITY_INSTANCING_BUFFER_START(Props)
</span></span><span style=display:flex><span>  UNITY_INSTANCING_BUFFER_END(Props)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  struct appdata
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    float4 vertex : POSITION;
</span></span><span style=display:flex><span>    UNITY_VERTEX_INPUT_INSTANCE_ID
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  struct v2f
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    float4 pos : SV_POSITION;
</span></span><span style=display:flex><span>    UNITY_VERTEX_INPUT_INSTANCE_ID
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  v2f vert(appdata v)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    UNITY_SETUP_INSTANCE_ID(v);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  ENDCG
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=使用terrain-toolkit插件或gaia等地形生成工具>使用Terrain Toolkit插件或Gaia等地形生成工具</h2><p>TODO</p><h2 id=多地形拼接无缝过渡>多地形拼接、无缝过渡</h2><p>Unity的Terrain是单独的GameObject，每个最多4097*4097高度图/贴图分辨率，单地形很难承载整个世界，因此需要：</p><blockquote><p>将世界划分为多个Terrain块，拼接形成一个整体大地图</p></blockquote><h3 id=拼接方式>拼接方式</h3><h4 id=方法一unity内建-create-neighbor-terrains>方法一：Unity内建 Create Neighbor Terrains</h4><p>见上文</p><h4 id=方法二代码方式设置neighbor>方法二：代码方式设置Neighbor</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>terrain.SetNeighbor(left, top, right, bottom);
</span></span></code></pre></div><p>Unity的渲染系统通过<code>SetNeighbors</code>方法了解哪些Terrain相邻，从而实现：</p><ul><li>地形LOD平滑衔接</li><li>避免裂缝/LOD跳跃</li><li>正确生成相邻地形的阴影、光照探针等</li></ul><h3 id=如何实现高度无缝>如何实现高度无缝</h3><h4 id=方法一在编辑时使用同步工具>方法一：在编辑时使用同步工具</h4><ul><li>用Terrain Tools插件中的<code>Terrain Stitch Tool</code></li><li>或用插件（如Gaia、Wrold Creator）自动生成高度图并拼接</li></ul><h4 id=方法二手动同步边界高度>方法二：手动同步边界高度</h4><p>当你修改Terrain A的边缘时，要同步更新Terrain B相邻边缘的高度（可通过代码或工具完成）</p><h3 id=如何实现纹理无缝>如何实现纹理无缝</h3><p>使用相同的SplatMap（地形图层）</p><ul><li>确保所有Terrain使用相同的Terrain Layer（纹理材质）</li><li>地形混合时，使用相同规则的笔刷强度</li><li>地图边缘刷贴图时过渡得要自然（如混合2~3中Layer）</li></ul><h3 id=生态系统草树边界过渡>生态系统（草/树）边界过渡</h3><ul><li>插件会对自动边界进行生态镜像过渡</li><li>自定义草系统需处理边界草的“半草”同步问题</li><li>植被生成算法需考虑相邻Terrain的坐标范围</li></ul><h3 id=lod无缝过渡与裂缝问题crack>LOD无缝过渡与裂缝问题（Crack）</h3><p>Unity Terrain会自动处理LOD，但如果没有设置邻居关系或高度差距大，会出现裂缝<br>解决办法：</p><ul><li>一定调用<code>SetNeighbors</code></li><li>保证相邻Terrain的边缘高度一致</li><li>使用LOD抗裂缝策略（如添加额外边界顶点）</li></ul><h2 id=结合导航烘焙navmesh--terrain>结合导航烘焙（NavMesh + Terrain）</h2><p><a href=blog/Navigation/>Navigation</a></p><h2 id=runtime地形修改voxel地形破坏>Runtime地形修改（Voxel、地形破坏）</h2><h3 id=运行时地形修改的主流方案概览>运行时地形修改的主流方案概览</h3><table><thead><tr><th>模式</th><th>原理</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>Voxel Terrain</strong></td><td>使用体素数据构建地形并动态生成 Mesh</td><td>灵活，可完全修改、破坏、挖掘</td><td>实现复杂，需要自定义系统</td></tr><tr><td><strong>Custom Mesh Terrain</strong></td><td>自定义网格，允许直接编辑 Mesh 顶点</td><td>控制精细，可用于挤压、凹陷</td><td>不适合大地图或地形细节</td></tr><tr><td><strong>Shader-Based Deformation</strong></td><td>用 Shader 或 Compute Shader 动态修改高度图</td><td>实时效率高，可 GPU 运算</td><td>精度有限，修改不可永久保存</td></tr><tr><td><strong>Unity Terrain Heightmap 修改</strong></td><td>修改 <code>TerrainData.SetHeights()</code></td><td>保留 Unity Terrain 优势</td><td>修改粒度受限，效率较低</td></tr></tbody></table><h3 id=方案一体素地形voxel-terrain>方案一：体素地形（Voxel Terrain）</h3><p>类似<em>Minecraft</em>风格的可破坏地形</p><p>实现流程：<br>1.创建体素数据结构（3D数组）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>byte</span>[,,] voxels = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span>[width, height, depth];
</span></span></code></pre></div><p>2.定义每种方块类型（空气、土、石头等）</p><p>3.使用Marching Cubes或Greedy Mesh算法生成Mesh</p><p>4.实现挖掘、填充逻辑（修改数组，重新生成Mesh）</p><p>5.使用Chunk分块机制优化性能</p><h3 id=方案二修改unity-terrain高度图setheights>方案二：修改Unity Terrain高度图（SetHeights）</h3><p>适用于地形凹陷、爆炸坑、地形塑形</p><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> DigHole(Terrain terrain, Vector3 worldPos, <span style=color:#66d9ef>float</span> radius, <span style=color:#66d9ef>float</span> depth)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  TerrainData tData = terrain.terrainData;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> xRes = tData.heightmapResolution;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> yRes = tData.heightmapResolution;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Vector3 terrainPos = worldPos = terrain.transform.position;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> x = (<span style=color:#66d9ef>int</span>)((terrainPos.x / tData.size.x) * xRes);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> y = (<span style=color:#66d9ef>int</span>)((terrainPos.z / tData.size.z) * yRes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> r = Mathf.RoundToInt((radius / tData.size.x) * xRes);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span>[,] heights = tData.GetHeights(x - r, y - r, r * <span style=color:#ae81ff>2</span>, r * <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; r * <span style=color:#ae81ff>2</span>; ++i)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; r * <span style=color:#ae81ff>2</span>; j++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>float</span> dist = Vector2.Distance(<span style=color:#66d9ef>new</span> Vector2(i, j), <span style=color:#66d9ef>new</span> Vector2(r, r));
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (dist &lt; r) heights[i, j] -= depth * (<span style=color:#ae81ff>1f</span> - dist / r);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  tData.SetHeights(x - r, y - r, heights);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意：</p><ul><li>每次<code>SetHeights</code>开销较大，频繁修改可能掉帧</li><li>修改后不会自动更新NavMesh，需要手动<code>NavMeshSurface.BuildNavMesh()</code></li></ul><h3 id=方案三自定义mesh地形修改>方案三：自定义Mesh地形修改</h3><p>可以用Procedural Mesh创建“可破坏”的Mesh地面，然后直接修改顶点高度</p><p>核心点：</p><ul><li><code>Mesh.vertices</code> + <code>Mesh.RecalculateNormals()</code></li><li>可用于地形凹陷、打击坑</li><li>可结合Shader实现更复杂视觉反馈</li></ul><h3 id=gpu地形修改shadercompute-shader>GPU地形修改（Shader/Compute Shader）</h3><p>适合需要大量实时修改的场景，如地面波纹、动态地形变化</p><p>常用技巧：</p><ul><li>通过<code>RenderTexture</code>存储高度图</li><li>通过Compute Shader修改像素</li><li>在Shader中将高度图应用为<code>vertex displacement</code></li></ul><p>可参考：Unity官方例子<code>GPU Terrain Stamp</code>或Amplify Shader Editor示例</p><h2 id=terrain-api>Terrain API</h2><h3 id=static-properies>Static Properies</h3><table><thead><tr><th>属性名</th><th>中文说明</th></tr></thead><tbody><tr><td><code>activeTerrain</code></td><td>当前活动的 Terrain（场景中主地形）</td></tr><tr><td><code>activeTerrains</code></td><td>场景中所有激活的 Terrain 列表</td></tr><tr><td><code>compressedHolesFormat</code></td><td>压缩后地形洞孔纹理的图形格式</td></tr><tr><td><code>compressedHolesTextureFormat</code></td><td>压缩后地形洞孔纹理的纹理格式</td></tr><tr><td><code>heightmapFormat</code></td><td>地形高度图的图形格式</td></tr><tr><td><code>heightmapRenderTextureFormat</code></td><td>地形高度图的 RenderTextureFormat</td></tr><tr><td><code>holesFormat</code></td><td>未压缩的地形洞孔纹理的图形格式</td></tr><tr><td><code>holesRenderTextureFormat</code></td><td>地形洞孔纹理的 RenderTextureFormat</td></tr><tr><td><code>normalmapFormat</code></td><td>地形法线贴图的图形格式</td></tr><tr><td><code>normalmapRenderTextureFormat</code></td><td>地形法线贴图的渲染纹理格式</td></tr><tr><td><code>normalmapTextureFormat</code></td><td>地形法线贴图的纹理格式</td></tr></tbody></table><h3 id=properties>Properties</h3><table><thead><tr><th>属性名</th><th>中文说明</th></tr></thead><tbody><tr><td><code>allowAutoConnect</code></td><td>是否自动连接邻近地形</td></tr><tr><td><code>bakeLightProbesForTrees</code></td><td>是否为树烘焙内部光照探针（仅编辑器）</td></tr><tr><td><code>basemapDistance</code></td><td>超过该距离时使用预计算的低分辨率底图</td></tr><tr><td><code>bottomNeighbor</code></td><td>下方邻接地形</td></tr><tr><td><code>collectDetailPatches</code></td><td>从内存中收集细节贴片</td></tr><tr><td><code>deringLightProbesForTrees</code></td><td>去除树上的光照探针振铃（仅编辑器）</td></tr><tr><td><code>detailObjectDensity</code></td><td>草和细节对象的密度</td></tr><tr><td><code>detailObjectDistance</code></td><td>草和细节对象的最大可视距离</td></tr><tr><td><code>drawHeightmap</code></td><td>是否绘制地形几何（高度图）</td></tr><tr><td><code>drawInstanced</code></td><td>是否启用 GPU Instancing 渲染地形</td></tr><tr><td><code>drawTreesAndFoliage</code></td><td>是否绘制树和细节对象</td></tr><tr><td><code>editorRenderFlags</code></td><td>控制地形在编辑器中显示哪些内容</td></tr><tr><td><code>enableHeightmapRayTracing</code></td><td>是否启用地形高度图的光线追踪加速结构</td></tr><tr><td><code>groupingID</code></td><td>地形自动连接的分组 ID</td></tr><tr><td><code>heightmapMaximumLOD</code></td><td>地形最大渲染 LOD 级别</td></tr><tr><td><code>heightmapMinimumLODSimplification</code></td><td>最简化的渲染精度</td></tr><tr><td><code>heightmapPixelError</code></td><td>LOD 切换时的误差控制</td></tr><tr><td><code>ignoreQualitySettings</code></td><td>是否忽略 QualitySettings 中的地形配置</td></tr><tr><td><code>keepUnusedRenderingResources</code></td><td>是否在一定帧数后释放未使用的摄像机渲染资源</td></tr><tr><td><code>leftNeighbor</code></td><td>左侧邻接地形（X 方向负方向）</td></tr><tr><td><code>lightmapIndex</code></td><td>静态光照贴图索引</td></tr><tr><td><code>lightmapScaleOffset</code></td><td>静态光照贴图的缩放和偏移</td></tr><tr><td><code>materialTemplate</code></td><td>渲染地形使用的材质模板</td></tr><tr><td><code>normalmapTexture</code></td><td>从高度图生成的法线贴图</td></tr><tr><td><code>patchBoundsMultiplier</code></td><td>地形边界框的缩放倍率</td></tr><tr><td><code>preserveTreePrototypeLayers</code></td><td>树实例的图层处理方式</td></tr><tr><td><code>realtimeLightmapIndex</code></td><td>实时光照贴图索引</td></tr><tr><td><code>realtimeLightmapScaleOffset</code></td><td>实时光照贴图的缩放和偏移</td></tr><tr><td><code>reflectionProbeUsage</code></td><td>反射探针使用方式</td></tr><tr><td><code>renderingLayerMask</code></td><td>地形渲染器的渲染图层遮罩</td></tr><tr><td><code>rightNeighbor</code></td><td>右侧邻接地形（X 方向正方向）</td></tr><tr><td><code>shadowCastingMode</code></td><td>地形阴影模式</td></tr><tr><td><code>terrainData</code></td><td>地形数据资源，包含高度图、纹理等</td></tr><tr><td><code>topNeighbor</code></td><td>上方邻接地形</td></tr><tr><td><code>treeBillboardDistance</code></td><td>树木转为 billboard 的距离</td></tr><tr><td><code>treeCrossFadeLength</code></td><td>树从 Mesh 到 billboard 的过渡距离</td></tr><tr><td><code>treeDistance</code></td><td>树的最大渲染距离</td></tr><tr><td><code>treeLODBiasMultiplier</code></td><td>树 LOD 偏差乘数</td></tr><tr><td><code>treeMaximumFullLODCount</code></td><td>完整 LOD 树的最大数量</td></tr><tr><td><code>treeMotionVectorModeOverride</code></td><td>SpeedTree 的运动矢量渲染模式</td></tr></tbody></table><h3 id=public-methods>Public Methods</h3><table><thead><tr><th>方法名</th><th>中文说明</th></tr></thead><tbody><tr><td><code>AddTreeInstance(TreeInstance)</code></td><td>向地形添加一个树实例</td></tr><tr><td><code>Flush()</code></td><td>强制刷新 Terrain 更改</td></tr><tr><td><code>GetClosestReflectionProbes(List)</code></td><td>获取与地形相交的反射探针及其权重</td></tr><tr><td><code>GetKeepUnusedCameraRenderingResources()</code></td><td>查询摄像机资源是否被保留</td></tr><tr><td><code>GetPosition()</code></td><td>获取地形在世界空间中的位置</td></tr><tr><td><code>GetSplatMaterialPropertyBlock()</code></td><td>获取混合材质的参数设置</td></tr><tr><td><code>SampleHeight(Vector3)</code></td><td>采样地形在某世界位置的高度</td></tr><tr><td><code>SetKeepUnusedCameraRenderingResources(bool)</code></td><td>设置是否保留摄像机的地形资源</td></tr><tr><td><code>SetNeighbors(left, top, right, bottom)</code></td><td>设置地形的邻居（用于 LOD 缝合）</td></tr><tr><td><code>SetSplatMaterialPropertyBlock()</code></td><td>设置混合材质渲染属性</td></tr></tbody></table><h3 id=static-methods>Static Methods</h3><table><thead><tr><th>方法名</th><th>中文说明</th></tr></thead><tbody><tr><td><code>CreateTerrainGameObject(TerrainData)</code></td><td>从 <code>TerrainData</code> 创建带碰撞器的地形 GameObject</td></tr><tr><td><code>GetActiveTerrains(List&lt;Terrain>)</code></td><td>填充一个列表，获取当前激活的所有 Terrain</td></tr><tr><td><code>SetConnectivityDirty()</code></td><td>标记当前连接状态为无效（需重新连接）</td></tr></tbody></table><p><strong>详见<a href=https://docs.unity3d.com/ScriptReference/Terrain.html>UnityScripting Terrain</a></strong></p></div><nav class=post-nav><a href=/blog/tag/ class=hover:underline>pre: Tag</a>
<a href=/blog/texture/ class=hover:underline>next: Texture</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#什么是terrain>什么是Terrain</a></li><li><a href=#terrain的核心结构>Terrain的核心结构</a></li><li><a href=#terrain-data>Terrain Data</a><ul><li><a href=#terraindata保存的内容><code>TerrainData</code>保存的内容</a><ul><li><a href=#高度图heightmap>高度图（Heightmap）</a></li><li><a href=#纹理图层splatmaps>纹理图层（Splatmaps）</a></li><li><a href=#细节对象detailsgrass>细节对象（Details/Grass）</a></li><li><a href=#树对象trees>树对象（Trees）</a></li><li><a href=#分辨率信息>分辨率信息</a></li></ul></li><li><a href=#注意事项>注意事项</a></li></ul></li><li><a href=#terrain-in-inspector>Terrain in Inspector</a><ul><li><a href=#create-neighbor-terrains>Create Neighbor Terrains</a><ul><li><a href=#这是什么>这是什么</a></li><li><a href=#unity会做什么>Unity会做什么</a></li><li><a href=#创建后的terrain有哪些特征>创建后的Terrain有哪些特征</a></li><li><a href=#为什么需要neighbor信息>为什么需要Neighbor信息</a></li><li><a href=#tips>Tips</a></li></ul></li><li><a href=#paintterrain>PaintTerrain</a><ul><li><a href=#sub-tools>Sub Tools</a><ul><li><a href=#1raise-or-lower-terrain>1.Raise or Lower Terrain</a></li><li><a href=#2set-height>2.Set Height</a></li><li><a href=#3smooth-height平滑地形>3.Smooth Height（平滑地形）</a></li><li><a href=#4paint-texture涂地表材质>4.Paint Texture（涂地表材质）</a></li><li><a href=#5terrain-holes>5.Terrain Holes</a></li></ul></li></ul></li><li><a href=#paint-trees>Paint Trees</a><ul><li><a href=#添加树模型>添加树模型</a></li><li><a href=#种树参数设置>种树参数设置</a></li><li><a href=#树木渲染和性能优化>树木渲染和性能优化</a><ul><li><a href=#billboard看板树>Billboard（看板树）</a></li><li><a href=#lod支持>LOD支持</a></li><li><a href=#gpu-instancing>GPU Instancing</a></li></ul></li><li><a href=#树的碰撞>树的碰撞</a></li><li><a href=#几种树的比较>几种树的比较</a></li></ul></li><li><a href=#paint-details>Paint Details</a><ul><li><a href=#如何添加细节类型>如何添加细节类型</a><ul><li><a href=#add-grass-texture>Add Grass Texture</a></li><li><a href=#add-detail-mesh>Add Detail Mesh</a></li></ul></li><li><a href=#paint参数>Paint参数</a></li><li><a href=#渲染与性能优化>渲染与性能优化</a><ul><li><a href=#优化特性>优化特性</a></li><li><a href=#风动效果设置>风动效果设置</a></li></ul></li></ul></li><li><a href=#terrain-settings>Terrain Settings</a><ul><li><a href=#basic-terrain>Basic Terrain</a></li><li><a href=#tree--detail-objects>Tree & Detail Objects</a></li><li><a href=#wind-settings-for-grass>Wind Settings for Grass</a></li><li><a href=#mesh-resolution>Mesh Resolution</a></li><li><a href=#holes-settings>Holes Settings</a></li><li><a href=#texture-resolutions>Texture Resolutions</a></li><li><a href=#lighting>Lighting</a></li><li><a href=#lightmapping>Lightmapping</a></li><li><a href=#quality-settings>Quality Settings</a></li></ul></li></ul></li><li><a href=#主要地形制作方式>主要地形制作方式</a><ul><li><a href=#1手动笔刷绘制适用于小项目快速原型>1.手动笔刷绘制（适用于小项目、快速原型）</a></li><li><a href=#2外部dcc工具制作---导入高度图专业项目常用>2.外部DCC工具制作 -> 导入高度图（专业项目常用）</a></li><li><a href=#3程序生成地形runtime或编译器内>3.程序生成地形（Runtime或编译器内）</a></li><li><a href=#插件生成最强大的方式>插件生成（最强大的方式）</a></li></ul></li><li><a href=#terrain-lod-编写调优>Terrain LOD 编写/调优</a><ul><li><a href=#unity-terrain的lod原理>Unity Terrain的LOD原理</a></li><li><a href=#自定义地形lod-shader>自定义地形LOD Shader</a></li><li><a href=#lod调优策略>LOD调优策略</a></li></ul></li><li><a href=#terrain-gpu-instancing草树渲染优化>Terrain GPU Instancing（草、树渲染优化）</a><ul><li><a href=#什么是gpu-instancing>什么是GPU Instancing</a></li><li><a href=#在unity-terrain中的应用>在Unity Terrain中的应用</a><ul><li><a href=#details-gpu-instancing>Details GPU Instancing</a></li><li><a href=#trees-gpu-instancing>Trees GPU Instancing</a></li></ul></li><li><a href=#注意事项-1>注意事项</a></li><li><a href=#高阶优化>高阶优化</a></li></ul></li><li><a href=#使用terrain-toolkit插件或gaia等地形生成工具>使用Terrain Toolkit插件或Gaia等地形生成工具</a></li><li><a href=#多地形拼接无缝过渡>多地形拼接、无缝过渡</a><ul><li><a href=#拼接方式>拼接方式</a><ul><li><a href=#方法一unity内建-create-neighbor-terrains>方法一：Unity内建 Create Neighbor Terrains</a></li><li><a href=#方法二代码方式设置neighbor>方法二：代码方式设置Neighbor</a></li></ul></li><li><a href=#如何实现高度无缝>如何实现高度无缝</a><ul><li><a href=#方法一在编辑时使用同步工具>方法一：在编辑时使用同步工具</a></li><li><a href=#方法二手动同步边界高度>方法二：手动同步边界高度</a></li></ul></li><li><a href=#如何实现纹理无缝>如何实现纹理无缝</a></li><li><a href=#生态系统草树边界过渡>生态系统（草/树）边界过渡</a></li><li><a href=#lod无缝过渡与裂缝问题crack>LOD无缝过渡与裂缝问题（Crack）</a></li></ul></li><li><a href=#结合导航烘焙navmesh--terrain>结合导航烘焙（NavMesh + Terrain）</a></li><li><a href=#runtime地形修改voxel地形破坏>Runtime地形修改（Voxel、地形破坏）</a><ul><li><a href=#运行时地形修改的主流方案概览>运行时地形修改的主流方案概览</a></li><li><a href=#方案一体素地形voxel-terrain>方案一：体素地形（Voxel Terrain）</a></li><li><a href=#方案二修改unity-terrain高度图setheights>方案二：修改Unity Terrain高度图（SetHeights）</a></li><li><a href=#方案三自定义mesh地形修改>方案三：自定义Mesh地形修改</a></li><li><a href=#gpu地形修改shadercompute-shader>GPU地形修改（Shader/Compute Shader）</a></li></ul></li><li><a href=#terrain-api>Terrain API</a><ul><li><a href=#static-properies>Static Properies</a></li><li><a href=#properties>Properties</a></li><li><a href=#public-methods>Public Methods</a></li><li><a href=#static-methods>Static Methods</a></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
		import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
		mermaid.initialize({startOnLoad: true});
	</script></body></html>