<!doctype html><html lang=en><head><meta charset=UTF-8><title>Frame</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-text.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header><title>How to Develop a Game</title><div class=container><img src=/images/gamelife.jpg alt=Frame class=banner></div></header><nav class=topnav><div class=container><ul><li><a href=/>Home</a></li><li><a href=/article/>Article</a></li><li><a href=/blog/>Blog</a></li><li><a href=/projects/>Projects</a></li><li><a href=/tool/>Tool & Resource</a></li><li><a href=/reference/>Reference</a></li><li><a href=/about/>About</a></li></ul></div></nav><article class=single_article><div class=title>Frame<div class=meta>PublishDate: 2025-06-01 |
CreateDate: 2025-06-01 |
LastModify: 2025-06-01
| Creator：ljf12825</div></div><div class=content><p>在Unity中，Frame（帧）是游戏运行的基本时间单位</p><h2 id=什么是frame>什么是Frame</h2><blockquote><p>Frame：指游戏每渲染并更新一次画面所经历的完整周期
一个Frame包含了物理模拟、逻辑更新、渲染提交等多个阶段</p></blockquote><ul><li>游戏每秒运行多个帧，成为FPS（Frame Per Second），帧率越高越流畅</li><li>如果帧率是60FPS，表示每秒执行60次完整的Frame逻辑</li></ul><h2 id=frame的生命周期>Frame的生命周期</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>Input</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>Physics</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>Update</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>AI</span><span style=color:#f92672>/</span><span style=color:#f92672>Animator</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>LateUpdate</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>Rendering</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>Present</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>详见<a href=blog/Scripts/>Scripts</a></p><h2 id=不同帧的分类>不同帧的分类</h2><table><thead><tr><th>帧类型</th><th>描述</th></tr></thead><tbody><tr><td><strong>逻辑帧（Update 帧）</strong></td><td>每帧都会执行的脚本逻辑</td></tr><tr><td><strong>物理帧（FixedUpdate）</strong></td><td>固定时间调用一次，与帧率无关</td></tr><tr><td><strong>渲染帧</strong></td><td>Unity 渲染一次画面</td></tr></tbody></table><h2 id=frame与多线程>Frame与多线程</h2><p>Unity中每一帧可以大致分为如下几个阶段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mathematica data-lang=mathematica><span style=display:flex><span>Frame <span style=color:#960050;background-color:#1e0010>开始</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>│</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>├─</span> Script Update<span style=color:#960050;background-color:#1e0010>（</span>MonoBehaviour Update<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>├─</span> FixedUpdate<span style=color:#960050;background-color:#1e0010>（每</span> N <span style=color:#960050;background-color:#1e0010>帧触发）</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>├─</span> Animation Update
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>├─</span> Physics Update
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>├─</span> AI Navigation Update
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>├─</span> Culling<span style=color:#960050;background-color:#1e0010>（剔除）</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>├─</span> Rendering Setup
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>│</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>├─</span> Rendering<span style=color:#960050;background-color:#1e0010>（提交</span> DrawCalls <span style=color:#960050;background-color:#1e0010>到</span> GPU<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>│</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>└─</span> EndFrame
</span></span></code></pre></div><p>这些阶段会部分并行执行（也就是说，并非所有都是主线程执行的）</p><h3 id=多线程的参与>多线程的参与</h3><table><thead><tr><th>线程</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td><strong>主线程（Main Thread）</strong></td><td>执行大部分脚本、生命周期函数、UI、调度渲染</td><td>Update、LateUpdate、OnGUI、Animator</td></tr><tr><td><strong>Job System 线程池</strong></td><td>执行并行任务，如变换更新、骨骼动画、AI、路径查找</td><td>DOTS Jobs、Transform System</td></tr><tr><td><strong>渲染线程（Render Thread）</strong></td><td>独立线程打包渲染命令给 GPU</td><td>Draw Call 打包、CommandBuffer</td></tr><tr><td><strong>Worker Threads（如音频）</strong></td><td>异步加载资源、播放音频、网络等</td><td>Audio Thread、Loading Thread</td></tr><tr><td><strong>GPU（设备线程）</strong></td><td>执行实际绘制、后处理、粒子等并行任务</td><td>Shader、Compute Shader、VFX Graph</td></tr></tbody></table><h3 id=一帧中多线程协同的流程图>一帧中多线程协同的流程图</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>             [一帧开始]
</span></span><span style=display:flex><span>                   │
</span></span><span style=display:flex><span>      ┌────────────┴─────────────┐
</span></span><span style=display:flex><span>      │                          │
</span></span><span style=display:flex><span>[Main Thread]              [Job System Threads]
</span></span><span style=display:flex><span>      │                          │
</span></span><span style=display:flex><span> MonoBehaviour.Update()     DOTS Job: 动画、物理、AI计算等
</span></span><span style=display:flex><span>      │                          │
</span></span><span style=display:flex><span> LateUpdate() ←───────────────┘（主线程同步 Job 结果）
</span></span><span style=display:flex><span>      │
</span></span><span style=display:flex><span>[开始渲染准备]
</span></span><span style=display:flex><span>      │
</span></span><span style=display:flex><span>      └─→ [Render Thread] → 提交 GPU 渲染命令
</span></span><span style=display:flex><span>                          │
</span></span><span style=display:flex><span>                          ↓
</span></span><span style=display:flex><span>                   [GPU 渲染这一帧]
</span></span></code></pre></div><h3 id=线程同步与一帧的边界>线程同步与一帧的边界</h3><ul><li>Job在当前帧内启动，也要在当前帧内完成，结果才能同步回主线程</li><li>Unity不允许Job修改UnityEngine.Object</li><li><code>JobHandle.Complete()</code>会阻塞等待Job完成，要合理使用</li></ul><h2 id=frame性能调优>Frame性能调优</h2><p>Frame Optimization是游戏性能优化的核心工作之一，目标是在每一帧内把CPU、GPU、内存、线程、渲染等资源使用最大化、冗余最小化，从而达到稳定的帧率</p><h3 id=一帧的性能结构大脑图>一帧的性能结构（大脑图）</h3><p>Unity中一帧的总耗时通常来自这几个方面：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>一帧时间</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#f92672>Frame</span> <span style=color:#f92672>Time</span><span style=color:#960050;background-color:#1e0010>）</span> <span style=color:#960050;background-color:#1e0010>≈</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>CPU</span> <span style=color:#f92672>脚本逻辑开销</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Physics</span> <span style=color:#f92672>运算</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Animation</span> <span style=color:#f92672>采样</span><span style=color:#f92672>/</span><span style=color:#f92672>骨骼</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Renderer</span> <span style=color:#f92672>准备</span><span style=color:#f92672>/</span><span style=color:#f92672>剔除</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>渲染线程开销</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#f92672>Render</span> <span style=color:#f92672>Thread</span><span style=color:#960050;background-color:#1e0010>）</span><span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>GPU</span> <span style=color:#f92672>渲染耗时</span>
</span></span></code></pre></div><p>目标是：让这些总和 小于 1 / FPS</p><h3 id=调优的目标谁卡就调谁>调优的目标：谁卡，就调谁</h3><table><thead><tr><th>调优对象</th><th>优化目的</th><th>工具</th></tr></thead><tbody><tr><td>CPU 主线程</td><td>减少逻辑卡顿</td><td>Profiler、Timeline</td></tr><tr><td>Job 多线程</td><td>减少不必要的等待</td><td>Profiler、JobDebugger</td></tr><tr><td>Render Thread</td><td>减少 DrawCall 和渲染命令量</td><td>Frame Debugger、Stats</td></tr><tr><td>GPU 渲染</td><td>降低 Shader/像素复杂度</td><td>GPU Profiler、RenderDoc</td></tr><tr><td>内存使用</td><td>减少 GC 和加载卡顿</td><td>Memory Profiler、Deep Profiler</td></tr></tbody></table><h3 id=常见瓶颈与优化方法大致思路>常见瓶颈与优化方法（大致思路）</h3><h4 id=1脚本逻辑太重主线程占满>1.脚本逻辑太重（主线程占满）</h4><table><thead><tr><th>症状</th><th>优化手段</th></tr></thead><tbody><tr><td>Update() 每帧循环太多对象</td><td>改为 Job 或事件驱动、UpdateGroup</td></tr><tr><td>大量使用 <code>Find</code>, <code>GetComponent</code>, LINQ</td><td>改成缓存引用、避免动态分配</td></tr><tr><td>高频调用 GC</td><td>使用对象池、Span、少用 string 拼接</td></tr></tbody></table><h4 id=2draw-call太多--batching失效>2.Draw Call太多 / Batching失效</h4><table><thead><tr><th>症状</th><th>优化方法</th></tr></thead><tbody><tr><td>每帧几千次 DrawCall</td><td>开启 SRP Batching 或 GPU Instancing</td></tr><tr><td>动态物体频繁改变材质</td><td>合并材质、使用 Texture Atlas</td></tr><tr><td>UGUI 每个按钮都独立绘制</td><td>使用 Canvas 分层、合批策略优化（静态 Canvas）</td></tr></tbody></table><h4 id=3渲染管线太重--gpu满载>3.渲染管线太重 / GPU满载</h4><table><thead><tr><th>症状</th><th>优化手段</th></tr></thead><tbody><tr><td>Shader 复杂 / 光照太多</td><td>降低 Shader 复杂度，合并 Pass</td></tr><tr><td>每像素灯光多 / 阴影开销大</td><td>减少实时光源数量，Bake 灯光</td></tr><tr><td>后处理堆叠太多</td><td>合并效果、调低分辨率、关闭没必要的 PostFX</td></tr></tbody></table><h4 id=物理模拟耗时长>物理模拟耗时长</h4><table><thead><tr><th>症状</th><th>优化方法</th></tr></thead><tbody><tr><td>大量 Collider / Rigidbody</td><td>简化碰撞体、使用 Layer 避免不必要检测</td></tr><tr><td>FixedUpdate 太频繁</td><td>调整 Fixed Timestep（如 0.02 → 0.033）</td></tr><tr><td>不必要的物理交互</td><td>设置 isKinematic、启用睡眠</td></tr></tbody></table><h4 id=资源加载卡顿--gc卡顿>资源加载卡顿 / GC卡顿</h4><table><thead><tr><th>症状</th><th>优化方法</th></tr></thead><tbody><tr><td>使用 <code>Resources.Load()</code> 或 <code>Instantiate()</code> 卡顿</td><td>使用 Addressables 异步加载</td></tr><tr><td>不断产生临时对象</td><td>对象池、避免 foreach/ToList/Lambda</td></tr><tr><td>大量 UI 弹窗频繁创建销毁</td><td>UI 预加载 + 缓存 + 对象池化管理</td></tr></tbody></table><p><strong>详见 <a href=blog/Unity-Performance-Tuning/>Unity Performance Tuning</a></strong></p><h2 id=帧的底层原理>帧的底层原理</h2><p>从底层角度说：</p><blockquote><p>一帧 = CPU逻辑执行 + 渲染命令提交 + GPU图像输出 + 系统显示刷新</p></blockquote><h3 id=一帧在底层的完整生命周期>一帧在底层的完整生命周期</h3><table><thead><tr><th>阶段</th><th>描述</th><th>涉及模块</th></tr></thead><tbody><tr><td>时间触发</td><td>到了下一帧时间，Unity 开始执行 Update</td><td>操作系统定时器 / 游戏主循环</td></tr><tr><td>逻辑更新</td><td>执行脚本逻辑（如移动、AI、物理）</td><td>CPU，主线程，Mono</td></tr><tr><td>资源准备</td><td>加载纹理、动画数据、Mesh 等</td><td>CPU + 内存 + IO</td></tr><tr><td>渲染命令生成</td><td>调用 Graphics API：DrawMesh、DrawCall</td><td>Unity C++ 层、RenderThread</td></tr><tr><td>渲染命令提交</td><td>传给 GPU 渲染管线（如 Vulkan、OpenGL）</td><td>RenderThread → GPU</td></tr><tr><td>GPU 执行渲染管线</td><td>顶点着色 → 光栅化 → 像素着色 → 输出到帧缓冲</td><td>GPU Pipeline</td></tr><tr><td>vsync 同步</td><td>等待下一次显示器刷新（如 60Hz）</td><td>SwapChain、VSync</td></tr><tr><td>显示图像</td><td>当前帧图像输出到屏幕</td><td>显示设备、操作系统</td></tr></tbody></table><h3 id=图形api如何控制帧>图形API：如何控制帧</h3><p>Unity底层是通过图形API驱动的，这些API控制：</p><ul><li>帧缓冲区 FrameBuffer</li><li>渲染管线</li><li>命令缓冲区 CommandBuffer</li><li>交换链 SwapChain</li></ul><p><strong>Vulkan或DX中的一帧</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>BeginFrame</span>(); <span style=color:#75715e>// 开始新的一帧（获取缓冲区）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>RecordRenderCommands</span>(); <span style=color:#75715e>// 录制渲染命令
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>SubmitToGPU</span>(); <span style=color:#75715e>// 提交到GPU
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>PresentFrame</span>(); <span style=color:#75715e>// 显示渲染结果（同步vsync）
</span></span></span></code></pre></div><p>Unity在底层封装了这些过程，开发者只看到<code>Update()</code>、<code>LateUpdate()</code>、<code>Render()</code></p><h3 id=帧率和显示器刷新率之间的关系>帧率和显示器刷新率之间的关系</h3><table><thead><tr><th>显示器刷新率</th><th>理想帧率</th><th>VSync</th></tr></thead><tbody><tr><td>60Hz 显示器</td><td>60 FPS</td><td>每 16.67ms 输出一帧</td></tr><tr><td>120Hz 显示器</td><td>120 FPS</td><td>每 8.33ms 输出一帧</td></tr><tr><td>帧生成慢</td><td>掉帧、卡顿</td><td>GPU 没赶上显示器刷新节奏</td></tr><tr><td>帧生成太快</td><td>撕裂（Tearing）</td><td>若无 vsync</td></tr></tbody></table><h3 id=一帧中关键的底层数据引擎角度>一帧中关键的底层数据（引擎角度）</h3><table><thead><tr><th>结构/模块</th><th>功能</th></tr></thead><tbody><tr><td>GameLoop</td><td>每帧驱动所有系统的核心循环</td></tr><tr><td>MonoBehaviourSystem</td><td>驱动 C# 脚本的系统</td></tr><tr><td>RenderLoop</td><td>构建和提交渲染指令</td></tr><tr><td>CommandBuffer</td><td>存储一帧的渲染命令</td></tr><tr><td>SwapChain</td><td>管理图像缓冲与 vsync 交换</td></tr><tr><td>GfxDevice</td><td>抽象的 GPU 设备接口</td></tr><tr><td>NativeContainer</td><td>管理底层数据容器（如 Transform）</td></tr></tbody></table><h3 id=每帧中资源怎么流转>每帧中资源怎么流转</h3><ul><li><code>C# 代码 -> C++ 引擎 -> GfxDevice -> GPU Pipeline -> 帧缓冲 -> 显示器</code></li><li>Unity做了大量C# &lt;-> C++ &lt;-> GPU间的数据传输</li></ul><h2 id=unity的高效框架优化>Unity的高效框架优化</h2><blockquote><p>这些操作能在一帧时间内完成，是因为Unity通过了“并行化 + 最小化处理 + GPU卸载 + 帧缓冲机制”等一套高效框架优化，最大程度压缩了每一帧的工作流程</p></blockquote><h3 id=为什么一帧能做这么多事>为什么一帧能做这么多事</h3><table><thead><tr><th>原因</th><th>说明</th></tr></thead><tbody><tr><td><strong>并行处理</strong></td><td>利用多个线程同时处理物理、动画、渲染准备等</td></tr><tr><td><strong>GPU 异步渲染</strong></td><td>渲染任务交给 GPU，CPU 继续处理逻辑，不等待</td></tr><tr><td><strong>渲染缓存机制</strong></td><td>当前帧 CPU 和上一帧 GPU 同时工作</td></tr><tr><td><strong>分帧处理</strong></td><td>大任务（如寻路、加载）分帧执行，避免卡帧</td></tr><tr><td><strong>批处理 + 合批</strong></td><td>合并多个渲染对象为一次提交，减少 GPU 压力</td></tr><tr><td><strong>剔除（Culling）优化</strong></td><td>只渲染玩家能看到的东西</td></tr><tr><td><strong>时间预算模型</strong></td><td>每帧只做预算时间内的任务，多余的等下一帧</td></tr></tbody></table><h3 id=多线程并行架构>多线程并行架构</h3><p>Unity实际上一帧涉及多个并行线程</p><table><thead><tr><th>线程</th><th>负责内容</th></tr></thead><tbody><tr><td>主线程</td><td>脚本、GameObject 生命周期、逻辑</td></tr><tr><td>渲染线程</td><td>提交 DrawCall，生成 GPU 命令</td></tr><tr><td>Job System</td><td>并发处理物理、动画、AI 等任务</td></tr><tr><td>GPU 线程</td><td>执行渲染（光栅化、着色器等）</td></tr></tbody></table><p><strong>多线程图示（简化）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scss data-lang=scss><span style=display:flex><span><span style=color:#f92672>帧</span> #N
</span></span><span style=display:flex><span><span style=color:#f92672>主线程</span><span style=color:#960050;background-color:#1e0010>：</span>   <span style=color:#960050;background-color:#1e0010>─────►</span> <span style=color:#f92672>Update</span><span style=color:#f92672>()</span> <span style=color:#960050;background-color:#1e0010>──►</span> <span style=color:#f92672>PrepareRender</span> <span style=color:#960050;background-color:#1e0010>─►</span> <span style=color:#f92672>Present</span>
</span></span><span style=display:flex><span><span style=color:#f92672>渲染线程</span><span style=color:#960050;background-color:#1e0010>：</span>           <span style=color:#960050;background-color:#1e0010>─────►</span> <span style=color:#f92672>Submit</span> <span style=color:#f92672>Commands</span>
</span></span><span style=display:flex><span><span style=color:#f92672>GPU</span> <span style=color:#f92672>线程</span><span style=color:#960050;background-color:#1e0010>：</span>                     <span style=color:#960050;background-color:#1e0010>─────►</span> <span style=color:#f92672>渲染执行</span>
</span></span></code></pre></div><p>每个线程在同时工作，不是等待某个线程跑完再开始</p><h3 id=最小化处理>最小化处理</h3><p>Unity在每一帧中，只处理真正必要、真正可见、真正变化的内容，而不是对所有对象、组件、资源都进行全量遍历和更新<br>这是一种性能优化策略，目的是</p><ul><li>减少CPU和内存的使用</li><li>减少主线程压力</li><li>减少渲染压力</li><li>保证帧率稳定</li></ul><h4 id=最小化处理的核心原则>最小化处理的核心原则</h4><table><thead><tr><th>原则</th><th>举例</th></tr></thead><tbody><tr><td>只更新<strong>变化</strong>的对象</td><td>静止物体不会触发动画或物理</td></tr><tr><td>只渲染<strong>可见</strong>的物体</td><td>被遮挡或不在视野内的对象被剔除（Culling）</td></tr><tr><td>只处理<strong>在场景中激活</strong>的对象</td><td>非激活 GameObject 不调用生命周期函数</td></tr><tr><td>只计算<strong>必要精度</strong>的数据</td><td>LOD 降级，简化远处模型</td></tr><tr><td>按需执行<strong>系统模块</strong></td><td>关闭未使用系统，如 NavMesh、布料、粒子</td></tr></tbody></table><h4 id=unity常见的最小化处理机制>Unity常见的“最小化处理”机制</h4><h5 id=1剔除culling>1.剔除（Culling）</h5><p>Unity会自动或手动剔除无用物体，跳过渲染或逻辑更新</p><table><thead><tr><th>类型</th><th>功能</th></tr></thead><tbody><tr><td>Frustum Culling</td><td>相机视锥外的物体不渲染</td></tr><tr><td>Occlusion Culling</td><td>被遮挡的物体不渲染</td></tr><tr><td>LOD Group</td><td>距离远时使用低面数模型</td></tr><tr><td>Static Batching</td><td>静态物体合批减少绘制指令</td></tr></tbody></table><h5 id=2非激活物体不处理>2.非激活物体不处理</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>gameObject.SetActive(<span style=color:#66d9ef>false</span>);
</span></span></code></pre></div><ul><li>不会执行<code>Update()</code></li><li>不会被物理系统检测</li><li>不参与渲染</li><li>节省计算资源</li></ul><h5 id=3脚本生命周期函数的懒执行>3.脚本生命周期函数的懒执行</h5><p>Unity不会在每一帧中调用所有函数，只有对应条件满足才会触发<br>比如：</p><table><thead><tr><th>函数</th><th>条件</th></tr></thead><tbody><tr><td><code>Update()</code></td><td>每帧调用（激活物体）</td></tr><tr><td><code>FixedUpdate()</code></td><td>只在固定帧率更新（物理开启）</td></tr><tr><td><code>OnBecameVisible()</code></td><td>物体刚出现在相机里时</td></tr><tr><td><code>LateUpdate()</code></td><td>Update之后才调</td></tr><tr><td><code>OnTriggerEnter()</code></td><td>只有碰撞才调</td></tr></tbody></table><h5 id=4jobsystem--burst的细粒度任务调度>4.JobSystem / Burst的细粒度任务调度</h5><ul><li>Job System会把数据分片并发处理，并自动分配到空闲进程</li><li>Burst编译器会将运算变成SIMD、无分支命令，极致压缩计算量</li></ul><p>目标：尽量避免主线程阻塞和不必要的处理</p><h5 id=5实例化和资源加载的最小化>5.实例化和资源加载的最小化</h5><table><thead><tr><th>技术</th><th>优化点</th></tr></thead><tbody><tr><td>对象池（Object Pool）</td><td>重用对象，避免频繁 Instantiate/Destroy</td></tr><tr><td>Addressables 异步加载</td><td>只在用到时加载资源</td></tr><tr><td>场景流（Scene Streaming）</td><td>只加载玩家附近区域的场景</td></tr><tr><td>延迟加载（Lazy Init）</td><td>某些组件在用到时再初始化</td></tr></tbody></table><h3 id=gpu卸载>GPU卸载</h3><p>GPU卸载，是指将计算密集、并行性强的工作从CPU转交给GPU来完成，以释放CPU的压力，从而提升整帧执行效率</p><h3 id=原因>原因</h3><ul><li>GPU并行能力极强：GPU内部拥有成千上万个核心，能同时处理大量数据（如像素、顶点）</li><li>CPU是瓶颈：Unity主线程常因逻辑繁忙，成为帧率瓶颈</li><li>渲染任务天然适合GPU：像素计算、顶点变换、光照、后处理等可并行处理</li><li>渲染和逻辑可并行执行</li></ul><h3 id=哪些任务会被卸载到gpu>哪些任务会被卸载到GPU</h3><table><thead><tr><th>卸载内容</th><th>描述</th></tr></thead><tbody><tr><td>顶点变换</td><td>模型的顶点坐标变换（MVP矩阵）</td></tr><tr><td>光照计算</td><td>每像素 / 顶点光照、反射、阴影等</td></tr><tr><td>像素着色</td><td>Color blending、贴图、Fog、后期特效等</td></tr><tr><td>后处理</td><td>Bloom、AO、DOF、MotionBlur 等</td></tr><tr><td>GPU Instancing</td><td>一次性绘制成千上万相同模型</td></tr><tr><td>Compute Shader</td><td>通用并行任务，如粒子模拟、布料、体积雾等</td></tr></tbody></table><h3 id=unity如何实现gpu卸载>Unity如何实现GPU卸载</h3><p>主线程构建渲染命令 -> 渲染线程提交 -> GPU异步执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Unity C#层伪流程</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    UpdateLogic(); <span style=color:#75715e>// 脚本逻辑运行（CPU）</span>
</span></span><span style=display:flex><span>    UpdateAnimaion(); <span style=color:#75715e>// 动画采样（CPU或Job）</span>
</span></span><span style=display:flex><span>    PrepareDrawCalls(); <span style=color:#75715e>// 构建绘制命令</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 提交给GPU渲染线程 </span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>PrepareDrawCalls()</code>把数据交给GPU（通过command buffer）</li><li>GPU异步处理，不阻塞主线程</li></ul><h3 id=gpu着色器>GPU着色器</h3><table><thead><tr><th>类型</th><th>用途</th></tr></thead><tbody><tr><td>Vertex Shader</td><td>每个顶点执行一次，变换模型到裁剪空间</td></tr><tr><td>Fragment (Pixel) Shader</td><td>每像素执行一次，计算最终颜色</td></tr><tr><td>Geometry / Tessellation Shader</td><td>细分曲面或生成额外几何体</td></tr><tr><td>Compute Shader</td><td>并行通用计算，不限于渲染任务（如粒子模拟）</td></tr></tbody></table><p><strong>Unity Standard Shader如何借助GPU完成渲染</strong>
当你使用Unity内置Shader，如Standard Shader，它会自动在GPU上执行如下操作：</p><ul><li>变换每个顶点位置（MVP）</li><li>对每个像素计算光照、纹理贴图、法线贴图</li><li>对半透明物体进行混合</li><li>对反射、环境光遮蔽等做实时计算</li></ul><blockquote><p>如果这些都在CPU上完成，一帧可能要跑1分钟</p></blockquote><p><strong>图示：Unity渲染流程（CPU -> GPU）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scss data-lang=scss><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>C</span># <span style=color:#f92672>脚本逻辑</span> <span style=color:#f92672>Update</span><span style=color:#f92672>()]</span>        <span style=color:#960050;background-color:#1e0010>┐</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>动画采样</span><span style=color:#f92672>/</span><span style=color:#f92672>物理运算</span><span style=color:#f92672>]</span>          <span style=color:#960050;background-color:#1e0010>├─</span> <span style=color:#f92672>CPU</span> <span style=color:#f92672>(</span><span style=color:#f92672>主线程</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>构建</span> <span style=color:#f92672>DrawCall</span> <span style=color:#f92672>命令</span><span style=color:#f92672>]</span>         <span style=color:#960050;background-color:#1e0010>┘</span>
</span></span><span style=display:flex><span>         <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>渲染线程打包命令</span><span style=color:#f92672>]</span> <span style=color:#960050;background-color:#1e0010>─→</span> <span style=color:#f92672>CommandBuffer</span>
</span></span><span style=display:flex><span>         <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>GFX</span> <span style=color:#f92672>Device</span> <span style=color:#f92672>发给</span> <span style=color:#f92672>GPU</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>         <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>GPU</span> <span style=color:#f92672>执行</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#f92672>Shader</span> <span style=color:#960050;background-color:#1e0010>➜</span> <span style=color:#f92672>Raster</span> <span style=color:#960050;background-color:#1e0010>➜</span> <span style=color:#f92672>PostFX</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><h3 id=cpu与gpu的帧缓冲双缓冲机制>CPU与GPU的帧缓冲双缓冲机制</h3><p>Unity会将“本帧CPU逻辑”和上一帧“GPU渲染”并行进行</p><ul><li>当前帧：CPU构建渲染命令</li><li>上一帧：GPU正在执行渲染</li></ul><p>这样就不会阻塞CPU，也不会GPU空转</p></div><nav class=post-nav><a href=/blog/event-driven-architecture/ class=hover:underline>pre: Event-Driven Architecture</a>
<a href=/blog/fsm/ class=hover:underline>next: FSM</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#什么是frame>什么是Frame</a></li><li><a href=#frame的生命周期>Frame的生命周期</a></li><li><a href=#不同帧的分类>不同帧的分类</a></li><li><a href=#frame与多线程>Frame与多线程</a><ul><li><a href=#多线程的参与>多线程的参与</a></li><li><a href=#一帧中多线程协同的流程图>一帧中多线程协同的流程图</a></li><li><a href=#线程同步与一帧的边界>线程同步与一帧的边界</a></li></ul></li><li><a href=#frame性能调优>Frame性能调优</a><ul><li><a href=#一帧的性能结构大脑图>一帧的性能结构（大脑图）</a></li><li><a href=#调优的目标谁卡就调谁>调优的目标：谁卡，就调谁</a></li><li><a href=#常见瓶颈与优化方法大致思路>常见瓶颈与优化方法（大致思路）</a><ul><li><a href=#1脚本逻辑太重主线程占满>1.脚本逻辑太重（主线程占满）</a></li><li><a href=#2draw-call太多--batching失效>2.Draw Call太多 / Batching失效</a></li><li><a href=#3渲染管线太重--gpu满载>3.渲染管线太重 / GPU满载</a></li><li><a href=#物理模拟耗时长>物理模拟耗时长</a></li><li><a href=#资源加载卡顿--gc卡顿>资源加载卡顿 / GC卡顿</a></li></ul></li></ul></li><li><a href=#帧的底层原理>帧的底层原理</a><ul><li><a href=#一帧在底层的完整生命周期>一帧在底层的完整生命周期</a></li><li><a href=#图形api如何控制帧>图形API：如何控制帧</a></li><li><a href=#帧率和显示器刷新率之间的关系>帧率和显示器刷新率之间的关系</a></li><li><a href=#一帧中关键的底层数据引擎角度>一帧中关键的底层数据（引擎角度）</a></li><li><a href=#每帧中资源怎么流转>每帧中资源怎么流转</a></li></ul></li><li><a href=#unity的高效框架优化>Unity的高效框架优化</a><ul><li><a href=#为什么一帧能做这么多事>为什么一帧能做这么多事</a></li><li><a href=#多线程并行架构>多线程并行架构</a></li><li><a href=#最小化处理>最小化处理</a><ul><li><a href=#最小化处理的核心原则>最小化处理的核心原则</a></li><li><a href=#unity常见的最小化处理机制>Unity常见的“最小化处理”机制</a><ul><li><a href=#1剔除culling>1.剔除（Culling）</a></li><li><a href=#2非激活物体不处理>2.非激活物体不处理</a></li><li><a href=#3脚本生命周期函数的懒执行>3.脚本生命周期函数的懒执行</a></li><li><a href=#4jobsystem--burst的细粒度任务调度>4.JobSystem / Burst的细粒度任务调度</a></li><li><a href=#5实例化和资源加载的最小化>5.实例化和资源加载的最小化</a></li></ul></li></ul></li><li><a href=#gpu卸载>GPU卸载</a></li><li><a href=#原因>原因</a></li><li><a href=#哪些任务会被卸载到gpu>哪些任务会被卸载到GPU</a></li><li><a href=#unity如何实现gpu卸载>Unity如何实现GPU卸载</a></li><li><a href=#gpu着色器>GPU着色器</a></li><li><a href=#cpu与gpu的帧缓冲双缓冲机制>CPU与GPU的帧缓冲双缓冲机制</a></li></ul></li></ul></li></ul></nav></aside><script>document.addEventListener("DOMContentLoaded",()=>{const n=document.querySelectorAll(".single_article h1, .single_article h2, .single_article h3, .single_article h4, .single_article h5, .single_article h6"),e=document.querySelectorAll(".toc a");let t=!1;e.forEach(n=>{n.addEventListener("click",s=>{e.forEach(e=>e.classList.remove("active")),n.classList.add("active"),t=!0,setTimeout(()=>{t=!1},800)})});const s=new IntersectionObserver(n=>{if(t)return;n.forEach(t=>{if(t.isIntersecting){let n=t.target.getAttribute("id");e.forEach(e=>{e.classList.toggle("active",e.getAttribute("href")==="#"+n)})}})},{rootMargin:"-20% 0px -70% 0px",threshold:0});n.forEach(e=>s.observe(e))})</script><footer><div class=container><p>© 2025 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSE.md>Full License</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="http"]').forEach(e=>{e.setAttribute("target","_blank")})})</script></body></html>