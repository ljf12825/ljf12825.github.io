<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Concurrency & Parallelism</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/csbasic/>★</a></li><li><a href=/csbasic/lab/>Lab</a></li><li><a href=/csbasic/lib/>Lib</a></li><li><a href=/csbasic/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/framework/ href=/framework/>Framework</a>       |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |                                |
|                        /    |                                |
|                       /     |                                |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |                <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |                <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                          <a class=nav-item data-path=/csbasic/ href=/csbasic/>CSBasic</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Concurrency & Parallelism<div class=meta>Modified: 2025-12-31
| Author：ljf12825</div></div><div class=content><h1 id=并发concurrency与并行parallelism>并发(Concurrency)与并行(Parallelism)</h1><ul><li>并发(Concurrency)<ul><li>本质是结构问题，关注如何组织多个任务</li><li>是一种设计模型</li><li>在有限CPU上制造“同时”的幻觉</li><li>逻辑上“同时存在”，任意时刻仅处理一个任务</li></ul></li><li>并行(Parallelism)<ul><li>本质是硬件问题，关注是否真的同时执行</li><li>是一种硬件能力</li><li>物理上“同时执行”，任意时刻任务数>=1</li></ul></li></ul><h1 id=历史背景>历史背景</h1><h2 id=单任务时代1940s-1960s>单任务时代(1940s-1960s)</h2><p>一台机器 = 一个程序</p><p>最早的计算机，没有操作系统，没有进程，没有并发</p><p>程序运行的方式：装纸带 -> 运行 -> 打印结果 -> 人工更换程序</p><p>问题</p><ul><li>CPU大量空闲（I/O时空转）</li><li>每次换程序要停机</li><li>没有“任务切换”概念</li></ul><p>痛点：机器太贵，CPU太慢，人类时间浪费</p><h2 id=批处理与多道程序1960s-1970s>批处理与多道程序(1960s-1970s)</h2><p>并发的第一次觉醒</p><p>目标：让CPU不要空着</p><p>IBM, UNIX早期系统引入</p><ul><li>多道程序(Multiprogramming)</li><li>中断</li><li>作业队列</li><li>内存分区</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>P1 等待IO
</span></span><span style=display:flex><span>-&gt; CPU 切给 P2
</span></span><span style=display:flex><span>-&gt; P2 等待
</span></span><span style=display:flex><span>-&gt; 切给 P3
</span></span></code></pre></div><p>这就是早期的并发调度思想</p><p>关键突破</p><ul><li>中断机制</li><li>上下文切换</li><li>进程状态机</li></ul><p>从这里开始：程序 =/ 进程，进程 = 可被调度的“活体”</p><h2 id=分时系统1970s>分时系统(1970s)</h2><p>并发变成“交互式需求”</p><p>UNIX, MULTICS出现多用户使用一台主机，每个人“感觉自己独占CPU”</p><p>引入</p><ul><li>时间片轮转(Round Robin)</li><li>就绪队列</li><li>抢占式调度</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>P1 10ms -&gt; P2 10ms -&gt; P3 10ms -&gt; ...
</span></span></code></pre></div><p>并发从“提高利用率”变成了“提升用户体验”</p><h2 id=进程模型的确立1970s-1980s>进程模型的确立(1970s-1980s)</h2><p>并发 = 隔离 + 调度</p><p>UNIX给了进程三个核心属性</p><table><thead><tr><th>维度</th><th>含义</th></tr></thead><tbody><tr><td>地址空间</td><td>隔离</td></tr><tr><td>资源表</td><td>文件、信号</td></tr><tr><td>执行上下文</td><td>可调度</td></tr></tbody></table><p>进程成为：资源的容器 + 调度的单位</p><p>但问题开始显现</p><ul><li>进程切换太慢</li><li>共享数据非常困难(IPC)</li><li>并发粒度太粗</li></ul><h2 id=线程诞生1980s-1990s>线程诞生(1980s-1990s)</h2><p>并发细化</p><p>服务器、GUI、数据库系统出现</p><ul><li>一个程序内部需要并发</li><li>不想为每个任务创建进程</li></ul><p>于是：把“执行流”从进程中拆出来</p><p>线程模型诞生</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Process
</span></span><span style=display:flex><span>|-- Thread A
</span></span><span style=display:flex><span>|-- Thread B
</span></span><span style=display:flex><span>|__ Thread C
</span></span></code></pre></div><p>目标</p><ul><li>更细粒度并发</li><li>更快切换</li><li>更容易共享数据</li></ul><p>新问题</p><ul><li>数据竞争</li><li>死锁</li><li>优先级反转</li><li>内存可见性</li></ul><p>并发从OS问题，变成了程序员问题</p><h2 id=多核时代2005->多核时代(2005-)</h2><p>并行成为现实</p><p>频率墙(3~4GHz)，单核提速结束，只能靠“核数”提升性能</p><p>并发不再是“时间片假象”，而是真实的物理同时执行</p><p>这使得</p><ul><li>竟态真正发生</li><li>cache一致性成为瓶颈</li><li>锁成为系统级灾难</li></ul><h2 id=高并发互联网2010s>高并发互联网(2010s)</h2><p>线程崩溃</p><p>Web服务器、游戏、IM系统，10万连接，每个连接一个线程 -> 内存炸、切换炸</p><p>线程模型出现天花板</p><table><thead><tr><th>问题</th><th>原因</th></tr></thead><tbody><tr><td>栈内存</td><td>每线程1-8MB</td></tr><tr><td>切换</td><td>内核态切换</td></tr><tr><td>锁</td><td>共享地狱</td></tr><tr><td>阻塞</td><td>放大效应</td></tr></tbody></table><h2 id=协程与用户态调度2010s->协程与用户态调度(2010s-)</h2><p>并发抽象的第三次革命</p><p>目标：像写顺序代码一样写并发</p><p>做法</p><ul><li>把调度权从内核拿回</li><li>在用户态保存/恢复栈</li><li>非阻塞I/O</li><li>少量线程 + 海量协程</li></ul><p>代表</p><table><thead><tr><th>系统</th><th>模型</th></tr></thead><tbody><tr><td>Go</td><td>goroutine + M:N</td></tr><tr><td>Python</td><td>asyncio</td></tr><tr><td>Lua</td><td>coroutine</td></tr><tr><td>C++20</td><td>coroutine</td></tr><tr><td>游戏引擎</td><td>Fiber + Job</td></tr></tbody></table><h1 id=进程>进程</h1><p>进程是计算机中正在执行的程序的实例。它是操作系统进行资源分配和调度的基本单位，也是程序在操作系统中的运行实体</p><h2 id=定义>定义</h2><p>核心概念</p><ul><li>动态实体：进程有创建、运行、暂停、终止的生命周期</li><li>资源容器：操作系统为进程分配内存、CPU时间、文件句柄等资源</li><li>执行上下文：包含程序代码、数据、堆栈、寄存器状态等</li></ul><p>进程是程序在操作系统中一次执行的实例</p><ul><li>程序是静态的代码（存储在磁盘上）</li><li>进程是动态的执行体（在内存中运行，拥有状态）</li></ul><table><thead><tr><th>特性</th><th>程序</th><th>进程</th></tr></thead><tbody><tr><td>本质</td><td>静态的指令集合（如.exe文件）</td><td>动态的执行实例</td></tr><tr><td>状态</td><td>存储在磁盘上</td><td>在内存中运行</td></tr><tr><td>生命周期</td><td>永久存在</td><td>有创建到终止的过程</td></tr><tr><td>资源占用</td><td>不占用系统资源</td><td>占用CPU、内存等资源</td></tr></tbody></table><ul><li>程序 = 菜谱</li><li>进程 = 烹饪过程</li></ul><p>每个进程都有自己的资源和执行上下文</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>程序代码（Text）</td><td>可执行指令</td></tr><tr><td>数据区（Data）</td><td>全局变量、静态变量</td></tr><tr><td>堆（Heap）</td><td>动态分配内存（malloc/new）</td></tr><tr><td>栈（Stack）</td><td>局部变量、函数调用信息</td></tr><tr><td>程序计数器（PC）</td><td>下一条要执行的指令地址</td></tr><tr><td>寄存器状态</td><td>CPU寄存器当前内容</td></tr><tr><td>进程ID（PID）</td><td>唯一标识</td></tr></tbody></table><h2 id=进程的生命周期>进程的生命周期</h2><p>进程从创建到终止大体经历五个状态</p><ol><li>新建（New）：进程正在被创建</li><li>就绪（Ready）：进程准备运行，等待CPU调度</li><li>运行（Running）：CPU正在执行该进程</li><li>阻塞/等待（Blocked/Waiting）：进程等待某些事件（I/O，信号等）</li><li>终止（Terminated）：进程执行完成或被杀死</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>New --&gt; Ready --&gt; Running --&gt; Terminated
</span></span><span style=display:flex><span>           |       ^
</span></span><span style=display:flex><span>           v       |
</span></span><span style=display:flex><span>         Waiting --^
</span></span></code></pre></div><ul><li>就绪队列：所有等待CPU的进程</li><li>等待队列：所有等待I/O或事件的进程</li></ul><h2 id=进程的基本操作>进程的基本操作</h2><h3 id=进程创建与终止>进程创建与终止</h3><ul><li>Unix/Linux: <code>fork()</code>，创建一个子进程，几乎是父进程的拷贝</li><li>Windows: <code>CreateProcess()</code>，指定要执行的程序，并创建全新进程</li></ul><p>子进程继承父进程的大部分资源，每个进程都有唯一PID</p><h4 id=创建方式>创建方式</h4><ol><li>系统初始化：操作系统启动时创建（init/systemd进程）</li><li>用户请求：用户运行程序（shell中输入命令）</li><li>进程派生：现有进程调用<code>fork()</code>创建子进程</li></ol><p>Unix/Linux进程创建示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pid_t</span> pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>fork</span>(); <span style=color:#75715e>// 创建子进程
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 子进程
</span></span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Child Process PID: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>getpid</span>());
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 父进程
</span></span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Parent Process PID: %d, Child PID: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>getpid</span>(), pid);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// fork失败
</span></span></span><span style=display:flex><span>        <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;fork failed&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=进程终止原因>进程终止原因</h4><ol><li>正常结束：执行<code>exit()</code>系统调用</li><li>异常结束：<ul><li>除零错误、越界访问</li><li>收到信号（如<code>SIGKILL</code>, <code>SIGSEGV</code>）</li></ul></li><li>外部终止：被其他进程终止</li></ol><h2 id=进程调度process-scheduling>进程调度(Process Scheduling)</h2><p>进程调度，调度方式，决定了系统快不快，卡不卡，公平不公平\</p><p>CPU是稀缺资源，而进程很多</p><ul><li>多个进程同时就绪</li><li>CPU一次只能运行一个（单核）</li><li>OS必须决定：下一个运行谁？运行多久？什么时候切换？</li></ul><p>这个决策过程就是进程调度</p><h3 id=调度发生时机>调度发生时机</h3><table><thead><tr><th>场景</th><th>说明</th></tr></thead><tbody><tr><td>进程创建</td><td>新进程进入就绪队列</td></tr><tr><td>时间片用完</td><td>时钟中断</td></tr><tr><td>进程阻塞</td><td>等待IO</td></tr><tr><td>进程退出</td><td>CPU空闲</td></tr><tr><td>更高优先级进程就绪</td><td>抢占</td></tr></tbody></table><h3 id=相关概念>相关概念</h3><ol><li>就绪队列(Ready Queue)
所有可以运行、但没拿到CPU的进程</li><li>时间片(Time Slice)
一个进程一次最多运行的时间，防止“霸占CPU”</li><li>抢占(Preemption)
OS强制中断正在运行的进程，让更适合的进程上CPU</li><li>饥饿(Starvation)
进程因长期得不到所需资源而无法进展的状态</li></ol><h3 id=调度的目标>调度的目标</h3><p>一个好的调度算法，要在多个目标之间权衡</p><table><thead><tr><th>目标</th><th>含义</th></tr></thead><tbody><tr><td>吞吐量</td><td>单位时间完成多少进程</td></tr><tr><td>响应时间</td><td>用户多久能看到反应</td></tr><tr><td>等待时间</td><td>就绪队列中等多久</td></tr><tr><td>周转时间</td><td>提交到完成的总时间</td></tr><tr><td>公平性</td><td>不饿死任何进程</td></tr></tbody></table><p>这些目标互相冲突</p><h3 id=调度层次>调度层次</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>长期调度（作业调度）
</span></span><span style=display:flex><span>    v （选择哪些进程进入内存）
</span></span><span style=display:flex><span>中级调度（内存调度）  
</span></span><span style=display:flex><span>    v （内外存交换，挂起/唤醒）
</span></span><span style=display:flex><span>短期调度（CPU调度）   &lt;- 主要讨论这个
</span></span><span style=display:flex><span>    v （毫秒级，决定下个运行的进程）
</span></span></code></pre></div><h3 id=调度与进程状态切换>调度与进程状态切换</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Running
</span></span><span style=display:flex><span>  │  时间片到
</span></span><span style=display:flex><span>  v
</span></span><span style=display:flex><span>Ready
</span></span><span style=display:flex><span>  ^
</span></span><span style=display:flex><span>Blocked &lt;- IO 等待
</span></span></code></pre></div><p>每次切换都伴随</p><ul><li>上下文保存</li><li>TLB/cache影响</li></ul><h4 id=上下文切换的开销>上下文切换的开销</h4><p>典型上下文切换步骤</p><ol><li>保存当前进程的寄存器状态 -> 内存</li><li>更新PCB（进程控制块）</li><li>更新内存管理单元（MMU）寄存器</li><li>恢复下一个进程的寄存器</li><li>刷新TLB（转换检测缓冲区）</li><li>更新缓存</li></ol><p>开销：几百到几千始终周期<br>现代CPU优化：快速上下文切换</p><h3 id=经典调度算法>经典调度算法</h3><h4 id=fcfs先来先服务>FCFS（先来先服务）</h4><ul><li>原理：按进入就绪队列的顺序执行</li><li>优点：实现简单，无饥饿</li><li>缺点：护航效应（长进程拖慢短进程），响应时间差</li></ul><p>适合批处理系统</p><h4 id=sjfsjn最短作业优先>SJF/SJN（最短作业优先）</h4><ul><li>原理：优先执行运行时间最短的进程</li><li>优点：理论上平均等待时间最小</li><li>缺点：无碍准确预测运行时间，长作业可能饿死</li></ul><p>理论最优，但现实难用</p><h4 id=srtf最短剩余时间优先>SRTF（最短剩余时间优先）</h4><p>SJF的抢占版本，新短任务到来可抢占当前进程<br>响应性更好，但实现更复杂</p><h4 id=round-robin-rr时间片轮转>Round Robin, RR（时间片轮转）</h4><p>原理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>P1 -&gt; P2 -&gt; P3 -&gt; P1 -&gt; ...
</span></span></code></pre></div><ul><li>每个进程运行一个时间片</li><li>时间片用完就切换</li></ul><p>优点：公平、响应快</p><p>缺点</p><ul><li>时间片太小 -> 切换开销大</li><li>时间片太大 -> 退化成FCFS</li></ul><p>交互式系统常用</p><h4 id=priority-scheduling优先级调度>Priority Scheduling（优先级调度）</h4><ul><li>原理：优先级高的先运行</li><li>风险：饥饿、优先级反转</li><li>解决：优先级老化(Aging)、优先级继承</li></ul><h3 id=多级调度队列算法现代os常用>多级调度队列算法（现代OS常用）</h3><h4 id=多级队列mlq>多级队列(MLQ)</h4><ul><li>就绪队列分层<ul><li>前台交互</li><li>后台计算</li></ul></li><li>不同队列不同算法</li></ul><p>队列之间通常不迁移 -> 不公平</p><h4 id=多级反馈队列mlfq>多级反馈队列(MLFQ)</h4><p>核心思想：用“行为”推测进程类型</p><ul><li>短CPU burst -> 交互型 -> 高优先级</li><li>长CPU burst -> 计算型 -> 地优先级</li></ul><p>规则简化版</p><ol><li>新进程进入最高优先级</li><li>用完整时间片 -> 降级</li><li>主动让出CPU -> 升级</li></ol><p>非常适合混合负载</p><h3 id=现代linux调度器cfs>现代Linux调度器（CFS）</h3><p>设计思想：CFS仍有调度周期（sched period），但不再是固定时间片，而是根据权重动态分配运行时间</p><ul><li>每个进程获得相同的虚拟运行时间</li><li>谁“欠CPU”，谁先跑</li></ul><h4 id=核心概念>核心概念</h4><table><thead><tr><th>概念</th><th>含义</th></tr></thead><tbody><tr><td>vruntime</td><td>虚拟运行时间</td></tr><tr><td>红黑树</td><td>按vruntime排序</td></tr><tr><td>nice值</td><td>权重（优先级）</td></tr></tbody></table><p>调度策略：选择vruntime最小的进程</p><h4 id=cfs优缺点>CFS优缺点</h4><p>公平、适合通用系统<br>实时性不强（另有RT调度器）</p><h2 id=进程通信ipc-inter-process-communication>进程通信（IPC, Inter-Process Communication）</h2><h3 id=为什么需要ipc>为什么需要IPC？</h3><p>进程 = 独立的虚拟地址空间，一个进程不能直接访问另一个进程的内存<br>这保证了安全性和稳定性<br>代价就是：想协作，必须走操作系统提供的通道</p><p>IPC解决两类问题</p><ul><li>通信（进程如何传数据）</li><li>同步（进程如何保证顺序与互斥）</li></ul><p>现实中通信几乎一定伴随同步</p><h3 id=ipc历史演进>IPC历史演进</h3><ul><li>早期Unix (1970s)：信号、管道</li><li>System V IPC (1980s)：消息队列、信号量、共享内存</li><li>BSD Socket (1980s)：网络IPC</li><li>POSIX IPC (1990s)：标准化接口</li><li>现代IPC：D-Bus, gRPC, ZeroMQ等</li></ul><h3 id=ipc分类>IPC分类</h3><h4 id=两大模型>两大模型</h4><ul><li>消息传递（Message Passing）：不共享内存，只传消息<ul><li>管道</li><li>消息队列</li><li>Socket</li></ul></li></ul><p>特点：内核中转、安全、简单、较慢</p><ul><li>共享内存（Shared Memory）：多个进程映射同一块物理内存<ul><li><code>shm</code></li><li><code>mmap</code></li></ul></li></ul><p>特点：极快，但必须自己做同步（锁/信号量）</p><h4 id=按通信关系分类>按通信关系分类</h4><div class=mermaid>graph TD
A[IPC通信方式] --> B[直接通信]
A --> C[间接通信]
B --> B1[信号]
B --> B2[Sockets]
C --> C1[管道]
C --> C2[消息队列]
C --> C3[共享内存]
C --> C4[文件]</div><h4 id=按数据传输分类>按数据传输分类</h4><table><thead><tr><th>类型</th><th>示例</th><th>特点</th></tr></thead><tbody><tr><td>面向字节流</td><td>管道、TCP Socket</td><td>无消息边界，像流水</td></tr><tr><td>面向消息</td><td>消息队列、UDP Socket</td><td>有明确消息边界</td></tr><tr><td>面向共享</td><td>共享内存</td><td>直接读写内存</td></tr></tbody></table><p>进程间需要通信来协作完成任务</p><h3 id=ipc-机制>IPC 机制</h3><h4 id=管道pipe>管道(Pipe)</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ls | grep <span style=color:#e6db74>&#34;.txt&#34;</span> <span style=color:#75715e># ls的输出作为grep的输入</span>
</span></span></code></pre></div><p>原理：内核维护一块缓冲区，一端写，一端读，单向</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> fd[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span><span style=color:#a6e22e>pipe</span>(fd);
</span></span></code></pre></div><p>特点</p><ul><li>只能用于有亲缘关系的进程</li><li>自动同步（阻塞读写）</li><li>单向通信（半双工）</li><li>缓冲区有限（通常4KB-64KB）</li></ul><h4 id=命名管道fifo>命名管道（FIFO）</h4><p>有名字的管道（文件系统中），无亲缘关系进程可通信</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>mkfifo mypipe
</span></span></code></pre></div><p>行为类似pipe</p><h4 id=消息队列message-queue>消息队列（Message Queue）</h4><p>原理：内核维护消息链表，每条消息有：类型、长度、优先级</p><p>特点：</p><ul><li>支持不同进程间的结构化数据交换</li><li>消息边界清晰</li><li>顺序由内核保证</li><li>消息有类型，可以按类型接收</li><li>独立于进程存在（进程结束队列仍保留）</li><li>需要显式删除(<code>msgctl(..., IPC_RMID, ...)</code>)</li><li>可通过<code>ipcs -q</code>查看，<code>ipcrm -q</code>删除</li><li>拷贝开销</li><li>容量限制</li></ul><h4 id=共享内存>共享内存</h4><p>原理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Process A
</span></span><span style=display:flex><span>   ↓
</span></span><span style=display:flex><span>  [ shared physical memory ]
</span></span><span style=display:flex><span>   ↑
</span></span><span style=display:flex><span>Process B
</span></span></code></pre></div><p>映射同一块物理内存</p><p>优点：零拷贝，极快</p><p>缺点：必须同步，极易出bug（竟态/死锁）</p><p>常见组合</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>共享内存 + 信号量 / 互斥锁
</span></span></code></pre></div><h4 id=信号signal>信号（Signal）</h4><p>特点：不传数据，只传事件，异步中断</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>kill</span>(pid, SIGTERM);
</span></span></code></pre></div><p>用途：通知，控制进程行为，回收子进程（SIGCHLD）</p><h4 id=socket>Socket</h4><p>特点：可本地/可网络，面向字节流或数据报</p><table><thead><tr><th>类型</th><th>用途</th></tr></thead><tbody><tr><td>Unix Domain Socket</td><td>本机高效IPC</td></tr><tr><td>TCP Socket</td><td>网络通信</td></tr><tr><td>UDP Socket</td><td>快速但不可靠</td></tr></tbody></table><h3 id=现代ipc>现代IPC</h3><table><thead><tr><th>维度</th><th>D-Bus</th><th>ZeroMQ</th><th>gRPC</th></tr></thead><tbody><tr><td>定位</td><td>桌面 / 系统总线</td><td>高性能消息库</td><td>远程 RPC 框架</td></tr><tr><td>通信模型</td><td>消息 + 总线</td><td>消息模式</td><td>请求 / 响应</td></tr><tr><td>是否依赖内核</td><td>是（Unix Socket）</td><td>否（用户态）</td><td>否（TCP/HTTP2）</td></tr><tr><td>是否跨机器</td><td>基本不</td><td>可以</td><td>天生支持</td></tr><tr><td>是否跨语言</td><td>有限</td><td>是</td><td>是</td></tr><tr><td>是否有中心</td><td>有（bus daemon）</td><td>无</td><td>无</td></tr><tr><td>复杂度</td><td>中</td><td>中</td><td>高</td></tr><tr><td>典型场景</td><td>Linux 桌面 / 系统服务</td><td>分布式组件</td><td>微服务</td></tr></tbody></table><h4 id=d-bus桌面总线>D-Bus（桌面总线）</h4><h5 id=解决的问题>解决的问题</h5><p>在Linux桌面/系统中</p><ul><li>蓝牙服务</li><li>NetworkManager</li><li>电源管理</li><li>音量、亮度</li><li>systemd 服务</li></ul><p>这些进程必须互相通知、调用、监听事件</p><p>而且要求</p><ul><li>安全（权限控制）</li><li>稳定（不能乱发）</li><li>结构化（不是字节流）</li></ul><p>这就是D-Bus要解决的问题</p><h5 id=核心设计思想总线模型>核心设计思想：总线模型</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>┌─────────┐
</span></span><span style=display:flex><span>│ Process │
</span></span><span style=display:flex><span>└────┬────┘
</span></span><span style=display:flex><span>     │
</span></span><span style=display:flex><span>┌────▼────┐
</span></span><span style=display:flex><span>│  D-Bus  │  ← bus daemon（中心）
</span></span><span style=display:flex><span>└────┬────┘
</span></span><span style=display:flex><span>     │
</span></span><span style=display:flex><span>┌────▼────┐
</span></span><span style=display:flex><span>│ Process │
</span></span><span style=display:flex><span>└─────────┘
</span></span></code></pre></div><ul><li>所有通信都经过bus</li><li>bus负责：路由、权限校验、广播</li></ul><h5 id=通信模式>通信模式</h5><p>D-Bus不只是“发消息”，而是三种</p><ol><li>Method Call（像RPC）</li><li>Signal（广播事件）</li><li>Property（可观察属性）</li></ol><h5 id=特点>特点</h5><ul><li>安全模型清晰</li><li>非常适合系统服务</li><li>事件驱动</li><li>依赖中心节点（bus）</li><li>性能一般</li><li>不适合高吞吐</li></ul><p>它不是给业务系统用的，是给系统组件用的</p><h4 id=grpcgoogle-rpc>gRPC(Google RPC)</h4><h5 id=解决问题>解决问题</h5><p>当系统变成：多语言、多团队、多机器、要长期维护<br>你需要：强类型接口、明确契约、自动生成代码、版本管理</p><p>gRPC的做法是：RPC + IDL + 工具链</p><h5 id=核心架构>核心架构</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Client
</span></span><span style=display:flex><span>  v
</span></span><span style=display:flex><span>Stub（自动生成）
</span></span><span style=display:flex><span>  v
</span></span><span style=display:flex><span>HTTP/2
</span></span><span style=display:flex><span>  v
</span></span><span style=display:flex><span>Server
</span></span></code></pre></div><ul><li>基于HTTP/2</li><li>使用Protobuf</li><li>双向流支持</li></ul><h5 id=grpc优势>gRPC优势</h5><ul><li>强约束<ul><li>接口先行</li><li>编译期检查</li></ul></li><li>工程化<ul><li>监控</li><li>负载均衡</li><li>超时/重试</li></ul></li><li>跨语言</li></ul><h5 id=grpc代价>gRPC代价</h5><ul><li>重<ul><li>学习成本高</li><li>不适合小工具</li><li>不适合本地IPC</li></ul></li></ul><p>它是为“组织规模”服务的</p><h4 id=zeromq>ZeroMQ</h4><h5 id=解决的问题-1>解决的问题</h5><p>传统IPC/Socket的痛点</p><ul><li>sned/recv太底层</li><li>协议自己写</li><li>错误多</li><li>状态复杂</li></ul><p>ZeroMQ的目标：像用容器一样用通信</p><h5 id=核心哲学模式而不是api>核心哲学：模式，而不是API</h5><p>ZeroMQ不说“发”/“收”，而是</p><ul><li>PUB/SUB</li><li>REQ/REP</li><li>PUSH/PULL</li><li>DEALER/ROUTER</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Publisher &gt;&gt;&gt; Subscribers
</span></span></code></pre></div><p>你需要关心的是：想要什么通信关系，而不是socket + select + buffer + retry</p><h5 id=特点-1>特点</h5><h6 id=快>快</h6><ul><li>完全用户态，自己管理buffer, queue, IO线程，绕开内核调度瓶颈</li></ul><p>本质上是“通信虚拟机”</p><h6 id=zeromq的代价>ZeroMQ的代价</h6><p>ZeroMQ不是协议，它不保证：消息一定送达、不丢、顺序；你必须自己设计语义</p><p>自由但危险</p><h3 id=进程间同步ipc-synchronization>进程间同步(IPC Synchronization)</h3><p>进程间同步就是当多个进程访问共享资源（文件、共享内存、设备等）时，确保访问顺序正确、数据不冲突的技术</p><ul><li>线程共享同一个进程的内存空间，同步主要是内存访问</li><li>进程内存空间独立，同步通常需要操作系统提供的机制</li></ul><p>典型场景</p><ul><li>多个进程写同一个日志文件</li><li>父子进程写作完成任务</li><li>多个进程操作共享内存缓冲区</li></ul><h4 id=为什么需要进程间同步>为什么需要进程间同步</h4><p>问题根源是共享资源的访问冲突</p><p>共享文件：file.txt<br>进程A写：100<br>进程B写：200<br>如果没有同步 -> 文件内容可能混乱或丢失</p><p>同步可以保证</p><ul><li>互斥（Mutual Exclusion）：一次只有一个进程访问共享资源</li><li>顺序（Order）：按一定顺序执行操作，避免竟态条件</li></ul><h4 id=进程间同步方法>进程间同步方法</h4><h5 id=信号量semaphore>信号量(Semaphore)</h5><ul><li>定义：一个整数值，用于控制多个进程对共享资源的访问</li><li>操作<ul><li><code>P()</code>/<code>wait()</code>/<code>down()</code> -> 占用资源</li><li><code>V()</code>/<code>signal()</code>/<code>up()</code> -> 释放资源</li></ul></li></ul><p>示例(POSIX信号量)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;semaphore.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>sem_t</span> sem;
</span></span><span style=display:flex><span><span style=color:#a6e22e>sem_init</span>(<span style=color:#f92672>&amp;</span>sem, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 1 表示共享线程，初始值1
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sem_wait</span>(<span style=color:#f92672>&amp;</span>sem); <span style=color:#75715e>// 占用
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 访问共享资源
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>sem_post</span>(<span style=color:#f92672>&amp;</span>sem); <span style=color:#75715e>// 释放
</span></span></span></code></pre></div><ul><li>用途：控制资源数量、互斥访问</li><li>特点：可用于多个进程同步，甚至跨机器（特殊实现）</li></ul><h5 id=互斥锁mutex>互斥锁(Mutex)</h5><ul><li>作用类似信号量，但专门用于互斥访问</li><li>POSIX提供进程共享互斥锁</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>pthread_mutex_t</span> mutex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pthread_mutexattr_t</span> attr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>pthread_mutexattr_init</span>(<span style=color:#f92672>&amp;</span>attr);
</span></span><span style=display:flex><span><span style=color:#a6e22e>pthread_mutexattr_setpshared</span>(<span style=color:#f92672>&amp;</span>attr, PTHREAD_PROCESS_SHARED);
</span></span><span style=display:flex><span><span style=color:#a6e22e>pthread_mutex_init</span>(<span style=color:#f92672>&amp;</span>mutex, <span style=color:#f92672>&amp;</span>attr);
</span></span></code></pre></div><ul><li>只能由一个进程在同一时间持有</li><li>常与共享内存一起使用</li></ul><h5 id=条件变量condition-variable>条件变量(Condition Variable)</h5><ul><li>当进程需要等待某个条件才执行时使用</li><li>通常配合互斥锁使用</li><li>示例</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>pthread_cond_t</span> cond;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pthread_mutex_t</span> mutex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>pthread_mutex_lock</span>(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>condition) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pthread_cond_wait</span>(<span style=color:#f92672>&amp;</span>cond, <span style=color:#f92672>&amp;</span>mutex); <span style=color:#75715e>// 等待条件满足
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 条件满足，继续执行
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>pthread_mutex_unlock</span>(<span style=color:#f92672>&amp;</span>mutex);
</span></span></code></pre></div><h5 id=消息队列message-queue-1>消息队列(Message Queue)</h5><ul><li>进程通信 + 同步</li><li>进程发送/接收消息时，操作系统保证顺序与完整性</li><li>POSIX示例</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;mqueue.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>mqd_t</span> mq <span style=color:#f92672>=</span> <span style=color:#a6e22e>mq_open</span>(<span style=color:#e6db74>&#34;/myqueue&#34;</span>, O_CREAT <span style=color:#f92672>|</span> O_RDWR, <span style=color:#ae81ff>0666</span>, NULL);
</span></span><span style=display:flex><span><span style=color:#a6e22e>mq_send</span>(mq, <span style=color:#e6db74>&#34;hello&#34;</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>10</span>];
</span></span><span style=display:flex><span><span style=color:#a6e22e>mq_receive</span>(mq, buf, <span style=color:#ae81ff>10</span>, NULL);
</span></span></code></pre></div><ul><li>优点：可以传递数据，同时实现同步</li><li>缺点：相对慢，依赖内核</li></ul><h5 id=共享内存--锁>共享内存 + 锁</h5><ul><li>共享内存：速度最快，但需要手动同步</li><li>方案：<ul><li>创建共享内存区域</li><li>进程访问共享内存前先加锁（信号量/互斥锁）</li><li>访问完成后释放锁</li></ul></li></ul><p>进程间同步主要依赖操作系统提供机制，因为进程不共享内存，不能像线程那样直接用普通变量做锁</p><h4 id=进程同步的注意事项>进程同步的注意事项</h4><ol><li>死锁<ul><li>两个或多个进程互相等待资源 -> 程序挂起</li><li>解决：避免循环等待，设置超时</li></ul></li><li>优先级反转<ul><li>高优先级进程等待低优先级进程释放资源</li><li>解决：优先级继承机制</li></ul></li><li>开销<ul><li>进程同步比线程同步慢</li><li>因为需要操作系统内核介入</li></ul></li></ol><h2 id=进程上下文context>进程上下文（Context）</h2><p>每次CPU切换进程时，会保存/恢复进程的上下文\</p><ul><li>上下文切换（Context Switch）<ul><li>保存当前进程的PC和寄存器</li><li>切换到下一个进程的PC和寄存器</li><li>CPU从新的进程继续执行</li></ul></li></ul><p>开销：</p><ul><li>上下文切换不是免费的，会有CPU和内存开销</li><li>因此操作系统会尽量减少频繁切换</li></ul><h2 id=进程表process-table>进程表（Process Table）</h2><p>操作系统用来“统一管理所有PCB的数据结构”<br>操作系统需要</p><ol><li>跟踪每个进程的状态</li><li>快速找到要调度的进程</li><li>管理进程资源</li><li>实现进程间通信</li><li>提供调试和监控信息</li></ol><p>进程表就是这些信息的集中存储</p><p>进程表不描述单个进程，描述的是系统中所有进程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>进程表
</span></span><span style=display:flex><span> ├── PCB (PID 1)
</span></span><span style=display:flex><span> ├── PCB (PID 2)
</span></span><span style=display:flex><span> ├── PCB (PID 3)
</span></span><span style=display:flex><span> └── PCB (PID N)
</span></span></code></pre></div><p>早期OS（教学模型），进程表就是一张表/数组</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span>PCB process_table[MAX_PROCESS];
</span></span></code></pre></div><p>现代OS（如Linux），不存在一张统一的“进程表”，而是链表、红黑树、哈希表多个子结构组合<br>进程表是一个概念，不是一个具体结构体</p><h3 id=linux中的进程表>Linux中的进程表</h3><p>现代Linux没有“统一数组”，而是多个子数据结构组合</p><h4 id=1-task_struct>1. task_struct</h4><ul><li>每个进程对应一个<code>struct task_struct</code></li><li>相当于PCB</li><li>存储了进程的所有信息（状态、调度、内存、文件、信号等）</li></ul><h4 id=2-链表红黑树哈希表>2. 链表/红黑树/哈希表</h4><p>Linux维护多种索引</p><table><thead><tr><th>数据结构</th><th>用途</th></tr></thead><tbody><tr><td>双向链表<code>tasks</code></td><td>遍历系统所有进程</td></tr><tr><td>红黑树<code>pid_tree</code></td><td>PID查找</td></tr><tr><td>其他链表</td><td>就绪队列、等待队列、僵尸队列</td></tr></tbody></table><h4 id=3-调度器视角>3. 调度器视角</h4><ul><li>就绪队列/多级反馈队列不是PCB的一部分，而是指向task_struct的指针集合</li><li>CPU调度通过这些队列找到task_struct，并切换上下文</li></ul><h4 id=task_struct字段><code>task_struct</code>字段</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Linux内核中的进程表实际上是task_struct的链表/树
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 位于：include/linux/sched.h
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> task_struct {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 标识信息 ==========
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>pid_t</span> pid;                    <span style=color:#75715e>// 进程ID
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>pid_t</span> tgid;                   <span style=color:#75715e>// 线程组ID（主线程的PID）
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>pid_t</span> ppid;                   <span style=color:#75715e>// 父进程ID
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 状态信息 ==========
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>long</span> state;          <span style=color:#75715e>// 进程状态
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>        TASK_RUNNING     (0) 正在运行或可运行
</span></span></span><span style=display:flex><span><span style=color:#75715e>        TASK_INTERRUPTIBLE (1) 可中断睡眠
</span></span></span><span style=display:flex><span><span style=color:#75715e>        TASK_UNINTERRUPTIBLE (2) 不可中断睡眠
</span></span></span><span style=display:flex><span><span style=color:#75715e>        TASK_STOPPED     (4) 停止状态
</span></span></span><span style=display:flex><span><span style=color:#75715e>        TASK_TRACED      (8) 被调试器跟踪
</span></span></span><span style=display:flex><span><span style=color:#75715e>        EXIT_ZOMBIE     (16) 僵尸状态
</span></span></span><span style=display:flex><span><span style=color:#75715e>        EXIT_DEAD       (32) 死亡状态
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> exit_code;                <span style=color:#75715e>// 退出代码
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> exit_signal;              <span style=color:#75715e>// 导致退出的信号
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 调度信息 ==========
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> prio;                     <span style=color:#75715e>// 动态优先级
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> static_prio;              <span style=color:#75715e>// 静态优先级
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> normal_prio;              <span style=color:#75715e>// 归一化优先级
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sched_class <span style=color:#f92672>*</span>sched_class;  <span style=color:#75715e>// 调度类
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sched_entity se;       <span style=color:#75715e>// 调度实体
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sched_rt_entity rt;    <span style=color:#75715e>// 实时调度实体
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> policy;          <span style=color:#75715e>// 调度策略
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 内存管理 ==========
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> mm_struct <span style=color:#f92672>*</span>mm;         <span style=color:#75715e>// 内存描述符
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> mm_struct <span style=color:#f92672>*</span>active_mm;  <span style=color:#75715e>// 活动内存描述符
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 文件系统 ==========
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> fs_struct <span style=color:#f92672>*</span>fs;         <span style=color:#75715e>// 文件系统信息
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> files_struct <span style=color:#f92672>*</span>files;   <span style=color:#75715e>// 打开文件表
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 信号处理 ==========
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> signal_struct <span style=color:#f92672>*</span>signal; <span style=color:#75715e>// 信号处理
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sighand_struct <span style=color:#f92672>*</span>sighand; <span style=color:#75715e>// 信号处理器
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>sigset_t</span> blocked;            <span style=color:#75715e>// 阻塞的信号
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>sigset_t</span> real_blocked;       <span style=color:#75715e>// 实际阻塞的信号
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 时间统计 ==========
</span></span></span><span style=display:flex><span>    u64 utime;                   <span style=color:#75715e>// 用户态CPU时间
</span></span></span><span style=display:flex><span>    u64 stime;                   <span style=color:#75715e>// 内核态CPU时间
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> nvcsw;         <span style=color:#75715e>// 自愿上下文切换次数
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> nivcsw;        <span style=color:#75715e>// 非自愿上下文切换次数
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 关系链 ==========
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>real_parent;  <span style=color:#75715e>// 真实父进程
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>parent;       <span style=color:#75715e>// 父进程（可能被ptrace替换）
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> list_head children;        <span style=color:#75715e>// 子进程链表
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> list_head sibling;         <span style=color:#75715e>// 兄弟进程链表
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 其他 ==========
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> comm[TASK_COMM_LEN];    <span style=color:#75715e>// 可执行文件名
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> flags;          <span style=color:#75715e>// 进程标志
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>cpu_mask_t</span> cpus_allowed;     <span style=color:#75715e>// 允许运行的CPU掩码
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 链接结构 ==========
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> list_head tasks;      <span style=color:#75715e>// 所有进程链表节点
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> hlist_node pid_chain; <span style=color:#75715e>// PID哈希链表节点
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=windows的eprocess>Windows的EPROCESS</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Windows内核的进程表结构（部分）
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_EPROCESS</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 对象头 ==========
</span></span></span><span style=display:flex><span>    KPROCESS Pcb;                <span style=color:#75715e>// 进程控制块
</span></span></span><span style=display:flex><span>    EX_PUSH_LOCK ProcessLock;    <span style=color:#75715e>// 进程锁
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 标识信息 ==========
</span></span></span><span style=display:flex><span>    LIST_ENTRY ActiveProcessLinks; <span style=color:#75715e>// 活动进程链表
</span></span></span><span style=display:flex><span>    HANDLE UniqueProcessId;      <span style=color:#75715e>// 进程ID
</span></span></span><span style=display:flex><span>    HANDLE InheritedFromUniqueProcessId; <span style=color:#75715e>// 父进程ID
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 内存管理 ==========
</span></span></span><span style=display:flex><span>    PVOID SectionBaseAddress;    <span style=color:#75715e>// 映像基地址
</span></span></span><span style=display:flex><span>    PVOID VadRoot;               <span style=color:#75715e>// 虚拟地址描述符树根
</span></span></span><span style=display:flex><span>    SIZE_T VirtualSize;          <span style=color:#75715e>// 虚拟大小
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 句柄表 ==========
</span></span></span><span style=display:flex><span>    PHANDLE_TABLE ObjectTable;   <span style=color:#75715e>// 对象句柄表
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 时间统计 ==========
</span></span></span><span style=display:flex><span>    LARGE_INTEGER CreateTime;    <span style=color:#75715e>// 创建时间
</span></span></span><span style=display:flex><span>    LARGE_INTEGER ExitTime;      <span style=color:#75715e>// 退出时间
</span></span></span><span style=display:flex><span>    LARGE_INTEGER KernelTime;    <span style=color:#75715e>// 内核时间
</span></span></span><span style=display:flex><span>    LARGE_INTEGER UserTime;      <span style=color:#75715e>// 用户时间
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 线程信息 ==========
</span></span></span><span style=display:flex><span>    LIST_ENTRY ThreadListHead;   <span style=color:#75715e>// 线程链表头
</span></span></span><span style=display:flex><span>    ULONG ActiveThreads;         <span style=color:#75715e>// 活动线程数
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 安全信息 ==========
</span></span></span><span style=display:flex><span>    PACCESS_TOKEN Token;         <span style=color:#75715e>// 访问令牌
</span></span></span><span style=display:flex><span>    QUAD Vm;                     <span style=color:#75715e>// 虚拟内存计数器
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ========== 其他 ==========
</span></span></span><span style=display:flex><span>    ULONG SessionId;             <span style=color:#75715e>// 会话ID
</span></span></span><span style=display:flex><span>    CHAR ImageFileName[<span style=color:#ae81ff>16</span>];      <span style=color:#75715e>// 映像文件名
</span></span></span><span style=display:flex><span>    ULONG PriorityClass;         <span style=color:#75715e>// 优先级类
</span></span></span><span style=display:flex><span>} EPROCESS, <span style=color:#f92672>*</span>PEPROCESS;
</span></span></code></pre></div><h2 id=进程控制块pcb>进程控制块（PCB）</h2><p>PCB是操作系统管理进程的核心数据结构，每个进程对应一个PCB，操作系统通过PCB来管理和控制进程</p><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>PID</td><td>唯一标识</td></tr><tr><td>状态</td><td>New/Ready/Running/Waiting/Terminated</td></tr><tr><td>程序计数器</td><td>下一条指令地址</td></tr><tr><td>寄存器内容</td><td>CPU状态</td></tr><tr><td>内存管理信息</td><td>页表、段表</td></tr><tr><td>打开文件表</td><td>进程打开的文件</td></tr><tr><td>信号量/IPC信息</td><td>等待的事件或通信信息</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> ProcessControlBlock {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 进程标识信息
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pid; <span style=color:#75715e>// 进程ID
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ppid <span style=color:#75715e>// 父进程ID
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 进程状态信息
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> state { <span style=color:#75715e>// 进程状态
</span></span></span><span style=display:flex><span>        NEW, READY, RUNNING,
</span></span><span style=display:flex><span>        WAITING, TERMINATED
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. CPU状态信息
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> program_counter; <span style=color:#75715e>// 程序计数器
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> registers[<span style=color:#ae81ff>16</span>]; <span style=color:#75715e>// 寄存器组
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 其他CPU状态
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=进程的重要特性>进程的重要特性</h2><ol><li>并发性<ul><li>多个进程可以交替进行，给人同时运行的错觉</li><li>单核CPU通过时间片轮转实现并发</li></ul></li><li>独立性<ul><li>每个进程有独立的地址空间</li><li>一个进程崩溃不会直接影响其他进程</li><li>通过进程间通信（IPC）进行数据交换</li></ul></li><li>异步性<ul><li>进程以不可预知的速度推进</li><li>需要同步机制协调顺序</li></ul></li></ol><h2 id=unix-like-进程>Unix-like 进程</h2><p>这个概念在Windows中并不显著，Unix是类文件系统层次结构，所有东西都是进程，Windows则是独立对象模型</p><h3 id=父子进程parentchild-process>父子进程（Parent/Child Process）</h3><p>在Unix/Linux中，进程只能同另一个进程创建</p><ul><li>创建者 -> 父进程</li><li>被创建者 -> 子进程</li><li>主要方式：<code>fork()</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>pid_t</span> pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>fork</span>();
</span></span></code></pre></div><table><thead><tr><th>fork 返回值</th><th>进程</th></tr></thead><tbody><tr><td>> 0</td><td>父进程（返回子进程PID）</td></tr><tr><td>= 0</td><td>子进程</td></tr><tr><td>&lt; 0</td><td>创建失败</td></tr></tbody></table><p>父子进程几乎是完整拷贝</p><ul><li>虚拟内存(COW)</li><li>文件描述符</li><li>环境变量</li></ul><p>但它们是两个独立的进程</p><h4 id=父子进程的关系>父子进程的关系</h4><ul><li>子进程继承父进程<ul><li>打开的文件</li><li>工作目录</li><li>信号处理方式
= 不共享地址空间（除非共享内存）</li></ul></li></ul><p>这也是为什么进程间通信需要IPC</p><table><thead><tr><th>特性</th><th>父进程</th><th>子进程</th></tr></thead><tbody><tr><td>PID</td><td>保持不变</td><td>获得新的唯一PID</td></tr><tr><td>PPID</td><td>自己的父进程</td><td>父进程的PID</td></tr><tr><td>文件描述符</td><td>共享，但独立维护</td><td>复制父进程的文件表</td></tr><tr><td>未处理的信号</td><td>不继承</td><td>继承，但某些信号重置</td></tr><tr><td>资源统计</td><td>独立计数</td><td>从0开始计数（CPU时间等）</td></tr><tr><td>进程组</td><td>通常相同</td><td>通常相同（除非调用setpgid）</td></tr></tbody></table><h3 id=孤儿进程orphan-process>孤儿进程(Orphan Process)</h3><p>父进程先退出，子进程还在继续，子进程就成了孤儿进程</p><p>孤儿进程不会出问题<br>内核会自动把孤儿进程的父进程设为PID 1<br>传统是<code>init</code>，现代是<code>systemd</code>，会负责回收它</p><p>孤儿进程不危险，是正常现象，很多后台程序就是主动“变孤儿”的</p><h3 id=守护进程daemon-process>守护进程(Daemon Process)</h3><p>守护进程是在后台运行、脱离终端、长期存在的进程</p><p>典型例子</p><ul><li><code>sshd</code></li><li><code>cron</code></li><li><code>systemd</code></li><li>日志服务、监控服务</li></ul><p>守护进程的核心特征</p><table><thead><tr><th>特征</th><th>说明</th></tr></thead><tbody><tr><td>无控制终端</td><td>不会因终端关闭而退出</td></tr><tr><td>长时间运行</td><td>生命周期长</td></tr><tr><td>后台运行</td><td>不与用户交互</td></tr><tr><td>通常是孤儿</td><td>被init/systemd接管</td></tr></tbody></table><h4 id=守护进程的标准创建流程>守护进程的标准创建流程</h4><p>标准守护化步骤</p><ol><li>fork,父进程退出</li><li>子进程 setsid()，脱离终端</li><li>再fork,防止重新获得终端</li><li>该工作目录/</li><li>重设文件权限掩码</li><li>关闭标准输入输出</li></ol><h3 id=僵尸进程zombie-process>僵尸进程(Zombie Process)</h3><p>僵尸进程 = 已经死了，但还没被父进程“收尸”的进程</p><ul><li>子进程已经退出(<code>exit()</code>)</li><li>资源已释放（内存、文件）</li><li>但PCB还留在内核中</li></ul><p>状态标记<code>Z</code></p><h4 id=为什么会有僵尸进程>为什么会有僵尸进程</h4><p>这是Unix的设计选择，不是bug<br>父进程需要知道：子进程是否正常退出，退出码是多少</p><p>所以内核会保留子进程的PID + 退出状态，等待父进程调用</p><h4 id=僵尸进程的问题>僵尸进程的问题</h4><p>僵尸进程不占CPU,但占PID/PCB<br>大量僵尸进程 -> 进程表耗尽 -> 新进程创建失败</p><h4 id=如何避免僵尸进程>如何避免僵尸进程</h4><p>父进程正确回收</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>wait</span>(NULL);
</span></span></code></pre></div><p>捕获SIGCHLD</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>signal</span>(SIGCHLD, SIG_IGN);
</span></span></code></pre></div><p>双fork（守护进程常用）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>父
</span></span><span style=display:flex><span>└─子
</span></span><span style=display:flex><span>  └─孙（真正工作）
</span></span></code></pre></div><h3 id=进程相关系统调用>进程相关系统调用</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>进程相关系统调用
</span></span><span style=display:flex><span>├─ 创建 / 装载
</span></span><span style=display:flex><span>│   ├─ fork / vfork / clone
</span></span><span style=display:flex><span>│   └─ exec*
</span></span><span style=display:flex><span>│
</span></span><span style=display:flex><span>├─ 终止 / 回收
</span></span><span style=display:flex><span>│   ├─ exit / _exit
</span></span><span style=display:flex><span>│   └─ wait / waitpid / waitid
</span></span><span style=display:flex><span>│
</span></span><span style=display:flex><span>├─ 身份 / 关系
</span></span><span style=display:flex><span>│   ├─ getpid / getppid
</span></span><span style=display:flex><span>│   ├─ setpgid / getsid
</span></span><span style=display:flex><span>│   └─ setsid
</span></span><span style=display:flex><span>│
</span></span><span style=display:flex><span>├─ 调度 / 优先级
</span></span><span style=display:flex><span>│   ├─ nice / setpriority
</span></span><span style=display:flex><span>│   ├─ sched_yield
</span></span><span style=display:flex><span>│   └─ sched_* 系列
</span></span><span style=display:flex><span>│
</span></span><span style=display:flex><span>├─ 信号
</span></span><span style=display:flex><span>│   ├─ kill / tgkill
</span></span><span style=display:flex><span>│   ├─ sigaction
</span></span><span style=display:flex><span>│   └─ pause
</span></span><span style=display:flex><span>│
</span></span><span style=display:flex><span>├─ 资源限制 / 统计
</span></span><span style=display:flex><span>│   ├─ getrlimit / setrlimit
</span></span><span style=display:flex><span>│   ├─ times / getrusage
</span></span><span style=display:flex><span>│   └─ prlimit
</span></span><span style=display:flex><span>│
</span></span><span style=display:flex><span>├─ 控制 / 管理
</span></span><span style=display:flex><span>│   ├─ ptrace
</span></span><span style=display:flex><span>│   ├─ prctl
</span></span><span style=display:flex><span>│   └─ seccomp
</span></span><span style=display:flex><span>│
</span></span><span style=display:flex><span>└─ 命名空间 / 隔离（现代）
</span></span><span style=display:flex><span>    ├─ unshare
</span></span><span style=display:flex><span>    ├─ setns
</span></span><span style=display:flex><span>    └─ clone (flags)
</span></span></code></pre></div><h4 id=fork---exec---exit---wait>fork -> exec -> exit -> wait</h4><h5 id=fork><code>fork()</code></h5><h6 id=功能>功能</h6><ul><li>创建一个几乎完整拷贝的子进程</li><li>父子进程几乎一样<ul><li>代码段（共享，只读）</li><li>数据段（写时复制COW）</li><li>文件描述符</li><li>信号处理</li></ul></li></ul><p>不同点</p><ul><li>子进程获得新的PID</li><li>子进程的父进程PID = 父进程的PID</li><li>返回值区分父子</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>pid_t</span> pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>fork</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;fork failed&#34;</span>);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 子进程
</span></span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//  父进程，pid = 子进程PID
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><h6 id=fork的特性>fork的特性</h6><ul><li>Copy-on-write(COW)
数据段不会立即复制，只有子进程或父进程写入时才分配新页</li><li>文件描述符共享，但偏移独立</li><li>环境变量继承</li><li>资源独立（堆、栈、信号量计数等）</li></ul><h5 id=exec><code>exec()</code></h5><h6 id=功能-1>功能</h6><ul><li>不创建新进程</li><li>将当前进程的内存空间（代码 + 数据 + 堆栈）替换成新程序</li><li>PID保持不变</li></ul><p>常用函数族</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>execl</span>(<span style=color:#e6db74>&#34;/bin/ls&#34;</span>, <span style=color:#e6db74>&#34;ls&#34;</span>, <span style=color:#e6db74>&#34;-l&#34;</span>, NULL);
</span></span><span style=display:flex><span><span style=color:#a6e22e>execv</span>(<span style=color:#e6db74>&#34;/bin/ls&#34;</span>, argv);
</span></span><span style=display:flex><span><span style=color:#a6e22e>execvp</span>(<span style=color:#e6db74>&#34;ls&#34;</span>, argv); <span style=color:#75715e>// PATH 搜索
</span></span></span></code></pre></div><h6 id=使用场景>使用场景</h6><ul><li>通常fork + exec 配合使用</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>父进程 fork()
</span></span><span style=display:flex><span>    v
</span></span><span style=display:flex><span>子进程 exec() 执行新程序
</span></span></code></pre></div><p>这样可以</p><ol><li>父进程继续执行</li><li>子进程执行其他程序（shell命令、后台服务）</li></ol><h5 id=exit><code>exit()</code></h5><h6 id=功能-2>功能</h6><ul><li>终止当前进程</li><li>释放资源（内存、打开文件）</li><li>保存退出状态，父进程可以通过<code>wait()</code>获取</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>0</span>); <span style=color:#75715e>// 正常退出
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 立即退出，绕过缓冲区
</span></span></span></code></pre></div><h6 id=注意点>注意点</h6><ul><li>子进程exit后，如果父进程没有wait,会变成僵尸进程</li><li>exit的状态码：0表示正常，非0表示异常</li></ul><h5 id=waitwaitpid><code>wait()</code>/<code>waitpid()</code></h5><h6 id=功能-3>功能</h6><ul><li>父进程等待子进程退出</li><li>回收子进程PCB（避免僵尸）</li><li>获取子进程退出码</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> status;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pid_t</span> child_pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>wait</span>(<span style=color:#f92672>&amp;</span>status);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>WIFEXITED</span>(status)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Child exited with %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>WEXITSTATUS</span>(status));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>wait()</code> 阻塞父进程直到有子进程退出</li><li><code>waitpid(pid, &amp;status, options)</code>可选择特定子进程或非阻塞</li></ul><h6 id=常见问题>常见问题</h6><ul><li>父进程不调用<code>wait()</code> -> 僵尸进程</li><li>父进程提前<code>exit()</code> -> 孤儿进程<ul><li>内核把孤儿交给<code>init/systemd</code>处理</li></ul></li></ul><h5 id=四者组合示意>四者组合示意</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Parent Process
</span></span><span style=display:flex><span>┌─────────────┐
</span></span><span style=display:flex><span>│ fork()      │  ----&gt; Child Process
</span></span><span style=display:flex><span>│             │        │ exec(&#34;/bin/ls&#34;)
</span></span><span style=display:flex><span>│ wait()      │ &lt;---- exit()
</span></span><span style=display:flex><span>└─────────────┘
</span></span></code></pre></div><ul><li><code>fork()</code> -> 创建子进程</li><li><code>exec()</code> -> 子进程换程序</li><li><code>exit()</code> -> 子进程退出</li><li><code>wait()</code> -> 父进程回收子进程</li></ul><h5 id=细节和工程实践>细节和工程实践</h5><ol><li>fork多次 -> 可以生成进程树</li><li>双fork -> 守护进程模式（防止控制终端干扰）</li><li>COW优化 -> 进程创建成本低</li><li>wait/SIGCHLD -> 非阻塞回收子进程</li></ol><h1 id=线程>线程</h1><p>线程是操作系统能够进行运算调度的最小单位，是进程中的一个执行流程。一个进程可以包含多个线程，所有线程共享进程的资源（如内存空间、文件句柄），但每个线程拥有自己独立的执行栈和程序计数器</p><h2 id=线程-vs-进程>线程 vs 进程</h2><table><thead><tr><th>特性</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>资源拥有</td><td>独立的内存和资源</td><td>共享进程的资源</td></tr><tr><td>通信方式</td><td>IPC（管道、消息队列等）</td><td>共享内存、更简单的通信</td></tr><tr><td>创建开销</td><td>较大（需分配独立内存）</td><td>较小（共享进程资源）</td></tr><tr><td>切换开销</td><td>较大（需切换地址空间）</td><td>较小（不切换地址空间）</td></tr><tr><td>独立性</td><td>完全独立</td><td>依赖于进程存在</td></tr></tbody></table><p>线程是进程中的执行单元，是CPU调度的基本单位（现代OS）<br>进程负责而“资源隔离”（容器），线程负责“并发执行”（工作单位）</p><p>从CPU的角度看，CPU不关心进程，CPU实际调度的是执行上下文，在现代OS中，这个执行上下文就是线程。所以线程才是真正跑在CPU上的东西</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Process
</span></span><span style=display:flex><span>├── Thread 1  ← CPU 实际调度
</span></span><span style=display:flex><span>├── Thread 2
</span></span><span style=display:flex><span>├── Thread 3
</span></span><span style=display:flex><span>└── 共享资源
</span></span><span style=display:flex><span>    ├── 地址空间
</span></span><span style=display:flex><span>    ├── 堆
</span></span><span style=display:flex><span>    ├── 全局变量
</span></span><span style=display:flex><span>    ├── 文件描述符
</span></span></code></pre></div><p>在Linux中</p><table><thead><tr><th>维度</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>内核对象</td><td>task_struct</td><td>task_struct</td></tr><tr><td>调度实体</td><td>是</td><td>是</td></tr><tr><td>地址空间</td><td>独立 mm_struct</td><td>共享 mm_struct</td></tr><tr><td>PID</td><td>唯一</td><td>共享 TGID</td></tr><tr><td>切换成本</td><td>高</td><td>低</td></tr></tbody></table><p>在Linux中，线程和进程没有本质区别，都是task_struct；区别只是clone()时共享了什么</p><h3 id=线程存在意义>线程存在意义</h3><p>如果只有进程，进程切换会造成</p><ul><li>页表切换</li><li>TLB flush</li><li>cache污染</li></ul><p>IPC成本高，创建成本高</p><p>线程的存在，使得</p><ul><li>创建成本降低</li><li>切换成本降低</li><li>数据共享高效（直接访问）</li><li>并发粒度细</li></ul><p>线程是在不牺牲隔离模型的前提下，把并发粒度做细</p><h2 id=线程本质结构>线程本质结构</h2><p>线程 =/ 轻量进程，线程轻在资源上，不在调度上</p><p>一个线程拥有以下内容</p><ul><li>程序计数器（PC）：下一条指令</li><li>寄存器：CPU状态</li><li>栈（Stack）：局部变量、调用链</li><li>TLS：线程局部存储</li></ul><h2 id=线程生命周期>线程生命周期</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>新建(New) → 就绪(Runnable) → 运行(Running) → 阻塞(Blocked) → 终止(Terminated)
</span></span><span style=display:flex><span>          ^                    v
</span></span><span style=display:flex><span>          |__ 等待(Waiting) ___|
</span></span></code></pre></div><ul><li>新建(New)：线程对象已创建，但尚未启动</li><li>就绪(Runnable)：线程准备好运行，等待CPU分配时间片</li><li>运行(Running)：线程正在执行</li><li>阻塞(Blocked)：线程等待某个条件（如I/O操作、锁等）</li><li>等待(Waiting)：线程无限期等待其他线程通知</li><li>超时等待(Timed Waiting)：线程等待特定时间</li><li>终止(Terminated)：线程执行完毕或异常退出</li></ul><h2 id=线程创建与使用>线程创建与使用</h2><h3 id=创建>创建</h3><p>线程一定是内核创建的，但通常不是直接找内核要</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>代码
</span></span><span style=display:flex><span>v
</span></span><span style=display:flex><span>语言/运行时
</span></span><span style=display:flex><span>v
</span></span><span style=display:flex><span>系统调用
</span></span><span style=display:flex><span>v
</span></span><span style=display:flex><span>内核线程
</span></span></code></pre></div><h4 id=操作系统层>操作系统层</h4><p>这里是线程真正诞生的地方</p><h5 id=linux-clone>Linux <code>clone()</code></h5><p>在Linux里，没有线程这个独立概念，本质上都是<code>task_struct</code></p><p>创建线程时，内核进行以下流程</p><ol><li>分配一个新的<code>task_struct</code></li><li>分配线程栈</li><li>复制寄存器上下文</li><li>共享 or 不共享资源（关键！）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>clone</span> (
</span></span><span style=display:flex><span>fn,
</span></span><span style=display:flex><span>stack,
</span></span><span style=display:flex><span>CLONE_VM <span style=color:#f92672>|</span> CLONE_FS <span style=color:#f92672>|</span> CLONE_FILES <span style=color:#f92672>|</span> CLONE_SIGHAND <span style=color:#f92672>|</span> CLONE_THREAD,
</span></span><span style=display:flex><span>arg
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><ul><li><code>CLONE_VM</code>：共享地址空间</li><li><code>CLONE_FILES</code>：共享fd表</li><li><code>CLONE_THREAD</code>：同一线程组</li></ul><p>这些flag决定是“新进程”还是“同进程线程”<br>线程只是“共享更多资源的进程”</p><h5 id=用户态线程绿色线程>用户态线程（绿色线程）</h5><ul><li>用户态线程：切换快，单不能利用多核</li><li>内核线程：可调度，可多核</li></ul><p>现代Linux/Windows是1:1线程模型（用户线程 = 内核线程）</p><h5 id=windowscreatethread>Windows：<code>CreateThread</code></h5><p>Windows中，线程是一等公民，有独立的<code>ETHREAD</code><br>创建时：分配TEB（线程环境块），分配用户栈，挂到进程里</p><h4 id=语言层>语言层</h4><p>对系统调用的封装</p><h5 id=posix-pthread_create>POSIX <code>pthread_create</code></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>pthread_t</span> tid;
</span></span><span style=display:flex><span><span style=color:#a6e22e>pthread_create</span>(<span style=color:#f92672>&amp;</span>tid, nullptr, worker, arg);
</span></span></code></pre></div><p>背后</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>pthread_create
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>clone()
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>task_struct
</span></span></code></pre></div><p>你能控制的东西</p><ul><li>栈大小</li><li>调度策略（有限）</li><li>亲和性（affinity）</li></ul><h5 id=c-stdthread>C++ <code>std::thread</code></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> t([] {
</span></span><span style=display:flex><span>    do_work();
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>t.join();
</span></span></code></pre></div><p>本质：RAII包装，底层还是pthread/Win32</p><h5 id=c>C#</h5><p>早期：真Thread</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>new</span> Thread(Work).Start();
</span></span></code></pre></div><p>问题：</p><ul><li>太重</li><li>不可控</li></ul><p>现代：线程池 + 任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Task.Run(() =&gt; Work());
</span></span></code></pre></div><p>这已经不是创建线程了</p><h3 id=使用>使用</h3><p>创建线程的场景很少，使用线程的场景很多</p><p>正确的方式是：少量线程 + 大量任务</p><h4 id=线程使用的四种经典模型>线程使用的四种经典模型</h4><h5 id=一线程一任务过时>一线程一任务（过时）</h5><p>简单，不可扩展</p><h5 id=线程池主流>线程池（主流）</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>任务队列
</span></span><span style=display:flex><span>v
</span></span><span style=display:flex><span>N 个 worker创建
</span></span></code></pre></div><h5 id=线程--事件循环>线程 + 事件循环</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>1~2 个线程
</span></span><span style=display:flex><span>v
</span></span><span style=display:flex><span>epoll / IOCP
</span></span><span style=display:flex><span>v
</span></span><span style=display:flex><span>回调
</span></span></code></pre></div><h5 id=线程--协程现代>线程 + 协程（现代）</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>少量线程
</span></span><span style=display:flex><span>v
</span></span><span style=display:flex><span>成千上万个协程
</span></span></code></pre></div><h4 id=注意事项>注意事项</h4><p>线程使用时，必须注意以下问题</p><ol><li>生命周期</li><li>栈是私有的<ul><li>每个线程一条栈</li><li>默认1-8MB</li><li>栈溢出 = 直接崩</li></ul></li><li>数据共享是危险的</li><li>同步原语</li><li>可见性 & 顺序<ul><li>CPU重排序</li><li>编译器重排序</li><li>memory order</li></ul></li><li>线程不是越多越好<ul><li>CPU 密集型：线程数量约等于核心数</li><li>IO 密集型：线程数量是核心数的2～4倍</li></ul></li></ol><p>线程是昂贵的执行资源，应该被“管理”，而不是被“随意创建”</p><h2 id=线程通信与同步>线程通信与同步</h2><ul><li>通信：怎么交换数据</li><li>同步：怎么保证顺序与一致性</li></ul><p>通信但不同步 -> 数据错<br>同步但不通信 -> 无意义</p><h3 id=通信>通信</h3><p>线程通信，共享内存是默认通道，同一进程内的线程，天然共享地址空间，这即是优势也是灾难源头</p><h4 id=共享变量>共享变量</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Data</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> b;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data g_data;
</span></span></code></pre></div><ul><li>快</li><li>简单</li><li>必须同步</li></ul><h4 id=共享队列>共享队列</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Producer Thread
</span></span><span style=display:flex><span>v
</span></span><span style=display:flex><span>Queue
</span></span><span style=display:flex><span>v
</span></span><span style=display:flex><span>Consumer Thread
</span></span></code></pre></div><ul><li>解耦</li><li>好同步</li><li>容易扩展成线程池/Job System</li></ul><h4 id=线程本地存储tls>线程本地存储（TLS）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>thread_local</span> <span style=color:#66d9ef>int</span> counter;
</span></span></code></pre></div><ul><li>通信的反面</li><li>每个线程一份</li><li>用来避免通信</li></ul><h3 id=同步>同步</h3><p>同步解决三个问题：</p><ol><li>互斥(Mutual Exclusion)</li><li>顺序(Ordering)</li><li>可见性(Visibility)</li></ol><h4 id=互斥一次只能一个进入>互斥：一次只能一个进入</h4><h5 id=mutex>Mutex</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>mutex m;
</span></span><span style=display:flex><span>m.lock();
</span></span><span style=display:flex><span>x<span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>m.unlock();
</span></span></code></pre></div><ul><li>保护临界区</li><li>阻塞线程</li><li>代价：上下文切换</li></ul><h5 id=spinlock自旋锁>Spinlock（自旋锁）</h5><ul><li>不睡眠</li><li>忙等</li></ul><p>适合</p><ul><li>临界区极短</li><li>CPU核心多</li></ul><h4 id=顺序谁先谁后>顺序：谁先谁后</h4><h5 id=condition-variable>Condition Variable</h5><p>经典模型：生产者 - 消费者</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>condition_variable cv;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>mutex m;
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> ready <span style=color:#f92672>=</span> false;
</span></span></code></pre></div><ul><li>等待某个条件</li><li>避免忙等</li></ul><h5 id=信号量semaphore-1>信号量(Semaphore)</h5><ul><li>计数资源</li><li>常用于限流</li></ul><h4 id=可见性修改是否可见>可见性：修改是否可见</h4><p>问题来源：</p><ul><li>CPU缓存</li><li>编译器优化</li><li>指令重排</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> done <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Thread A: done <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>Thread B: <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>done) {}
</span></span></code></pre></div><p>可能死循环</p><p>解决方案</p><ul><li>mutex（隐含内存屏障）</li><li>atomic</li><li>正确的memory_order</li></ul><h4 id=原子操作不加锁同步atomic>原子操作：不加锁同步<code>atomic</code></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> x;
</span></span><span style=display:flex><span>x.fetch_add(<span style=color:#ae81ff>1</span>);
</span></span></code></pre></div><ul><li>单条原子指令</li><li>不会被打断</li></ul><p>使用场景</p><ul><li>计数器</li><li>状态标志</li><li>无锁队列</li></ul><p><code>atomic</code>只能保证单变量安全，不保证多变量一致性，跨多个变量仍然需要锁</p><h3 id=通信--同步的经典组合模式>通信 + 同步的经典组合模式</h3><h4 id=生产者-消费者>生产者-消费者</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Queue + Mutex + ConditionVariable
</span></span></code></pre></div><h4 id=读多写少>读多写少</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>shared_mutex
</span></span></code></pre></div><h4 id=工作窃取work-stealing>工作窃取（Work Stealing）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>每线程本地队列 + 偶尔偷
</span></span></code></pre></div><p>线程通信，本质是共享内存的设计问题<br>线程同步，本质是时间顺序与可见性的约束问题<br>最好的并发设计，是减少共享，而不是堆锁</p><p>并发问题70%是数据结构问题，30%才是锁的问题</p><h2 id=线程安全与并发>线程安全与并发</h2><h2 id=tls>TLS</h2><h2 id=伪共享false-sharing>伪共享（False Sharing）</h2><h2 id=多线程>多线程</h2><h2 id=同步-1>同步</h2><h1 id=轻量线程>轻量线程</h1><h2 id=coroutine协程>Coroutine（协程）</h2><h2 id=goroutine>goroutine</h2><h2 id=fiber纤程>Fiber（纤程）</h2></div><nav class=post-nav><a href=/csbasic/file/operationsystem/filesystem/ class=hover:underline>next: File System</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><a href=#并发concurrency与并行parallelism>并发(Concurrency)与并行(Parallelism)</a></li><li><a href=#历史背景>历史背景</a><ul><li><a href=#单任务时代1940s-1960s>单任务时代(1940s-1960s)</a></li><li><a href=#批处理与多道程序1960s-1970s>批处理与多道程序(1960s-1970s)</a></li><li><a href=#分时系统1970s>分时系统(1970s)</a></li><li><a href=#进程模型的确立1970s-1980s>进程模型的确立(1970s-1980s)</a></li><li><a href=#线程诞生1980s-1990s>线程诞生(1980s-1990s)</a></li><li><a href=#多核时代2005->多核时代(2005-)</a></li><li><a href=#高并发互联网2010s>高并发互联网(2010s)</a></li><li><a href=#协程与用户态调度2010s->协程与用户态调度(2010s-)</a></li></ul></li><li><a href=#进程>进程</a><ul><li><a href=#定义>定义</a></li><li><a href=#进程的生命周期>进程的生命周期</a></li><li><a href=#进程的基本操作>进程的基本操作</a><ul><li><a href=#进程创建与终止>进程创建与终止</a><ul><li><a href=#创建方式>创建方式</a></li><li><a href=#进程终止原因>进程终止原因</a></li></ul></li></ul></li><li><a href=#进程调度process-scheduling>进程调度(Process Scheduling)</a><ul><li><a href=#调度发生时机>调度发生时机</a></li><li><a href=#相关概念>相关概念</a></li><li><a href=#调度的目标>调度的目标</a></li><li><a href=#调度层次>调度层次</a></li><li><a href=#调度与进程状态切换>调度与进程状态切换</a><ul><li><a href=#上下文切换的开销>上下文切换的开销</a></li></ul></li><li><a href=#经典调度算法>经典调度算法</a><ul><li><a href=#fcfs先来先服务>FCFS（先来先服务）</a></li><li><a href=#sjfsjn最短作业优先>SJF/SJN（最短作业优先）</a></li><li><a href=#srtf最短剩余时间优先>SRTF（最短剩余时间优先）</a></li><li><a href=#round-robin-rr时间片轮转>Round Robin, RR（时间片轮转）</a></li><li><a href=#priority-scheduling优先级调度>Priority Scheduling（优先级调度）</a></li></ul></li><li><a href=#多级调度队列算法现代os常用>多级调度队列算法（现代OS常用）</a><ul><li><a href=#多级队列mlq>多级队列(MLQ)</a></li><li><a href=#多级反馈队列mlfq>多级反馈队列(MLFQ)</a></li></ul></li><li><a href=#现代linux调度器cfs>现代Linux调度器（CFS）</a><ul><li><a href=#核心概念>核心概念</a></li><li><a href=#cfs优缺点>CFS优缺点</a></li></ul></li></ul></li><li><a href=#进程通信ipc-inter-process-communication>进程通信（IPC, Inter-Process Communication）</a><ul><li><a href=#为什么需要ipc>为什么需要IPC？</a></li><li><a href=#ipc历史演进>IPC历史演进</a></li><li><a href=#ipc分类>IPC分类</a><ul><li><a href=#两大模型>两大模型</a></li><li><a href=#按通信关系分类>按通信关系分类</a></li><li><a href=#按数据传输分类>按数据传输分类</a></li></ul></li><li><a href=#ipc-机制>IPC 机制</a><ul><li><a href=#管道pipe>管道(Pipe)</a></li><li><a href=#命名管道fifo>命名管道（FIFO）</a></li><li><a href=#消息队列message-queue>消息队列（Message Queue）</a></li><li><a href=#共享内存>共享内存</a></li><li><a href=#信号signal>信号（Signal）</a></li><li><a href=#socket>Socket</a></li></ul></li><li><a href=#现代ipc>现代IPC</a><ul><li><a href=#d-bus桌面总线>D-Bus（桌面总线）</a><ul><li><a href=#解决的问题>解决的问题</a></li><li><a href=#核心设计思想总线模型>核心设计思想：总线模型</a></li><li><a href=#通信模式>通信模式</a></li><li><a href=#特点>特点</a></li></ul></li><li><a href=#grpcgoogle-rpc>gRPC(Google RPC)</a><ul><li><a href=#解决问题>解决问题</a></li><li><a href=#核心架构>核心架构</a></li><li><a href=#grpc优势>gRPC优势</a></li><li><a href=#grpc代价>gRPC代价</a></li></ul></li><li><a href=#zeromq>ZeroMQ</a><ul><li><a href=#解决的问题-1>解决的问题</a></li><li><a href=#核心哲学模式而不是api>核心哲学：模式，而不是API</a></li><li><a href=#特点-1>特点</a><ul><li><a href=#快>快</a></li><li><a href=#zeromq的代价>ZeroMQ的代价</a></li></ul></li></ul></li></ul></li><li><a href=#进程间同步ipc-synchronization>进程间同步(IPC Synchronization)</a><ul><li><a href=#为什么需要进程间同步>为什么需要进程间同步</a></li><li><a href=#进程间同步方法>进程间同步方法</a><ul><li><a href=#信号量semaphore>信号量(Semaphore)</a></li><li><a href=#互斥锁mutex>互斥锁(Mutex)</a></li><li><a href=#条件变量condition-variable>条件变量(Condition Variable)</a></li><li><a href=#消息队列message-queue-1>消息队列(Message Queue)</a></li><li><a href=#共享内存--锁>共享内存 + 锁</a></li></ul></li><li><a href=#进程同步的注意事项>进程同步的注意事项</a></li></ul></li></ul></li><li><a href=#进程上下文context>进程上下文（Context）</a></li><li><a href=#进程表process-table>进程表（Process Table）</a><ul><li><a href=#linux中的进程表>Linux中的进程表</a><ul><li><a href=#1-task_struct>1. task_struct</a></li><li><a href=#2-链表红黑树哈希表>2. 链表/红黑树/哈希表</a></li><li><a href=#3-调度器视角>3. 调度器视角</a></li><li><a href=#task_struct字段><code>task_struct</code>字段</a></li></ul></li><li><a href=#windows的eprocess>Windows的EPROCESS</a></li></ul></li><li><a href=#进程控制块pcb>进程控制块（PCB）</a></li><li><a href=#进程的重要特性>进程的重要特性</a></li><li><a href=#unix-like-进程>Unix-like 进程</a><ul><li><a href=#父子进程parentchild-process>父子进程（Parent/Child Process）</a><ul><li><a href=#父子进程的关系>父子进程的关系</a></li></ul></li><li><a href=#孤儿进程orphan-process>孤儿进程(Orphan Process)</a></li><li><a href=#守护进程daemon-process>守护进程(Daemon Process)</a><ul><li><a href=#守护进程的标准创建流程>守护进程的标准创建流程</a></li></ul></li><li><a href=#僵尸进程zombie-process>僵尸进程(Zombie Process)</a><ul><li><a href=#为什么会有僵尸进程>为什么会有僵尸进程</a></li><li><a href=#僵尸进程的问题>僵尸进程的问题</a></li><li><a href=#如何避免僵尸进程>如何避免僵尸进程</a></li></ul></li><li><a href=#进程相关系统调用>进程相关系统调用</a><ul><li><a href=#fork---exec---exit---wait>fork -> exec -> exit -> wait</a><ul><li><a href=#fork><code>fork()</code></a><ul><li><a href=#功能>功能</a></li><li><a href=#fork的特性>fork的特性</a></li></ul></li><li><a href=#exec><code>exec()</code></a><ul><li><a href=#功能-1>功能</a></li><li><a href=#使用场景>使用场景</a></li></ul></li><li><a href=#exit><code>exit()</code></a><ul><li><a href=#功能-2>功能</a></li><li><a href=#注意点>注意点</a></li></ul></li><li><a href=#waitwaitpid><code>wait()</code>/<code>waitpid()</code></a><ul><li><a href=#功能-3>功能</a></li><li><a href=#常见问题>常见问题</a></li></ul></li><li><a href=#四者组合示意>四者组合示意</a></li><li><a href=#细节和工程实践>细节和工程实践</a></li></ul></li></ul></li></ul></li></ul></li><li><a href=#线程>线程</a><ul><li><a href=#线程-vs-进程>线程 vs 进程</a><ul><li><a href=#线程存在意义>线程存在意义</a></li></ul></li><li><a href=#线程本质结构>线程本质结构</a></li><li><a href=#线程生命周期>线程生命周期</a></li><li><a href=#线程创建与使用>线程创建与使用</a><ul><li><a href=#创建>创建</a><ul><li><a href=#操作系统层>操作系统层</a><ul><li><a href=#linux-clone>Linux <code>clone()</code></a></li><li><a href=#用户态线程绿色线程>用户态线程（绿色线程）</a></li><li><a href=#windowscreatethread>Windows：<code>CreateThread</code></a></li></ul></li><li><a href=#语言层>语言层</a><ul><li><a href=#posix-pthread_create>POSIX <code>pthread_create</code></a></li><li><a href=#c-stdthread>C++ <code>std::thread</code></a></li><li><a href=#c>C#</a></li></ul></li></ul></li><li><a href=#使用>使用</a><ul><li><a href=#线程使用的四种经典模型>线程使用的四种经典模型</a><ul><li><a href=#一线程一任务过时>一线程一任务（过时）</a></li><li><a href=#线程池主流>线程池（主流）</a></li><li><a href=#线程--事件循环>线程 + 事件循环</a></li><li><a href=#线程--协程现代>线程 + 协程（现代）</a></li></ul></li><li><a href=#注意事项>注意事项</a></li></ul></li></ul></li><li><a href=#线程通信与同步>线程通信与同步</a><ul><li><a href=#通信>通信</a><ul><li><a href=#共享变量>共享变量</a></li><li><a href=#共享队列>共享队列</a></li><li><a href=#线程本地存储tls>线程本地存储（TLS）</a></li></ul></li><li><a href=#同步>同步</a><ul><li><a href=#互斥一次只能一个进入>互斥：一次只能一个进入</a><ul><li><a href=#mutex>Mutex</a></li><li><a href=#spinlock自旋锁>Spinlock（自旋锁）</a></li></ul></li><li><a href=#顺序谁先谁后>顺序：谁先谁后</a><ul><li><a href=#condition-variable>Condition Variable</a></li><li><a href=#信号量semaphore-1>信号量(Semaphore)</a></li></ul></li><li><a href=#可见性修改是否可见>可见性：修改是否可见</a></li><li><a href=#原子操作不加锁同步atomic>原子操作：不加锁同步<code>atomic</code></a></li></ul></li><li><a href=#通信--同步的经典组合模式>通信 + 同步的经典组合模式</a><ul><li><a href=#生产者-消费者>生产者-消费者</a></li><li><a href=#读多写少>读多写少</a></li><li><a href=#工作窃取work-stealing>工作窃取（Work Stealing）</a></li></ul></li></ul></li><li><a href=#线程安全与并发>线程安全与并发</a></li><li><a href=#tls>TLS</a></li><li><a href=#伪共享false-sharing>伪共享（False Sharing）</a></li><li><a href=#多线程>多线程</a></li><li><a href=#同步-1>同步</a></li></ul></li><li><a href=#轻量线程>轻量线程</a><ul><li><a href=#coroutine协程>Coroutine（协程）</a></li><li><a href=#goroutine>goroutine</a></li><li><a href=#fiber纤程>Fiber（纤程）</a></li></ul></li></ul></nav></aside><script defer src=/js/scrollspy.js></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>