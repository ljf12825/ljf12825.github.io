<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Network Layer</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/csbasic/>★</a></li><li><a href=/csbasic/lab/>Lab</a></li><li><a href=/csbasic/lib/>Lib</a></li><li><a href=/csbasic/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/system/ href=/system/>System</a>          |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |                                |
|                        /    |                                |
|                       /     |                                |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |                <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |                <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                          <a class=nav-item data-path=/csbasic/ href=/csbasic/>CSBasic</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Network Layer<div class=meta>Modified: 2025-12-31
| Author：ljf12825</div></div><div class=content><p>OSI七层模型中的第3层，网络层的主要职责是处理数据的路由、转发以及寻址问题，确保数据从源主机到目标主机的顺利传输</p><h2 id=网络层的核心功能>网络层的核心功能</h2><table><thead><tr><th>功能名称</th><th>解释</th></tr></thead><tbody><tr><td>1. 路由选择（Routing）</td><td>找一条最优路径把数据包从源送到目的地，涉及路由协议（如 OSPF、BGP）</td></tr><tr><td>2. 逻辑寻址（IP地址）</td><td>给每台设备分配全球唯一的地址（如 IPv4 / IPv6 地址）</td></tr><tr><td>3. 分段与重组</td><td>将较大的数据包切分为适合链路层传输的片段，接收端再重组</td></tr><tr><td>4. 差错处理</td><td>一些最基本的错误检查（如 IP头部的校验和）</td></tr><tr><td>5. 拥塞控制（可选）</td><td>不是核心职责，但有时配合其他层（如 ICMP 源抑制）参与拥塞管理</td></tr></tbody></table><h3 id=1路由选择routing>1.路由选择（Routing）</h3><p>网络层的核心任务之一是路由选择。路由选择是指通过网络中的路由器选择一条最优路径来传输数据包。路由选择并非是一个孤立的过程，而是依赖于一系列的路由协议，这些协议帮助路由器在复杂的网络拓扑中找到最优路径<br>常见的路由协议包括：</p><ul><li>RIP(Routing Information Protocol)：基于跳数的路由协议，简单易懂，但不适用于大型网络</li><li>OSPF(Open Shortest Path First)：基于链路状态的协议，能够更有效地找到最短路径</li><li>BGP(Border Gateway Protocol)：用于自治系统（AS）之间的路由选择，是互联网的骨干协议</li></ul><h3 id=2逻辑寻址ip地址>2.逻辑寻址（IP地址）</h3><p>IP地址是网络层进行设备标识和路由选择的基础。每台设备都需要一个唯一的IP地址，这个地址分为两个部分：网络号和主机号。网络号标识设备所在的网络，而主机号则标识网络中的具体设备</p><p>IP地址不仅仅是用于标识设备的唯一身份，它还帮助路由器在网络间转发数据包。例如，当一个数据包从源主机发送到目标主机时，网络层会检查目标主机的IP地址，根据路由表决定数据包的转发途径</p><h3 id=3分段与重组>3.分段与重组</h3><p>由于每个链路层（如以太网）对传输的数据包大小有一定的限制，而数据包可能会因为应用层发送的数据量过大而无法直接传输。网络层负责将数据包进行分段，将过大的数据包分割成更小的片段以适应链路的传输。接收端的网络层再进行重组，将数据恢复成原始数据包</p><p>这一过程是透明的，用户和应用层并不需要关心数据包是否被分段，网络层会自动处理</p><h3 id=4差错处理>4.差错处理</h3><p>虽然IP协议本身并不负责重传丢失的数据包，但它会进行简单的差错检测。例如，IP头部中的校验和字段帮助检查数据包在传输过程中是否损坏。如果发现错误，数据包会被丢弃，发送方通常通过高层协议（如TCP）请求重传</p><h3 id=5拥塞控制可选>5.拥塞控制（可选）</h3><p>虽然拥塞控制通常是传输层的职责（如TCP协议），但网络层也可以参与其中。例如，ICMP协议中有源抑制消息，告诉源主机当前网络发生了拥塞，建议它减慢发送速度</p><h2 id=路由协议>路由协议</h2><h3 id=rip协议>RIP协议</h3><p>RIP是一种用于动态路由选择的协议，它通过交换路由表来计算和更新网络中到达目的地的最短路径。RIP是距离向量路由协议的一种，它基于“跳数”作为衡量路径距离的标准，通常用于小型或中型网络中</p><p>RIP的工作原理非常简单，并且通过周期性地交换路由表来维护路由信息。RIP版本有多个，其中最常用的是RIP v1和RIP v2，此外还有RIPng（适用于IPv6）</p><h4 id=rip工作原理>RIP工作原理</h4><p>RIP使用距离向量算法，通过以下步骤来计算和更新路由表：</p><ol><li><p>距离度量：
RIP使用跳数作为衡量距离的标准。跳数表示从源设备到目的设备经过的路由器数量。最大跳数为15，超过15跳的目标被认为是不可达的</p></li><li><p>路由更新：
RIP协议通过周期性地交换路由表（每30秒一次）来更新网络中的路由信息。每个路由器会将自己的路由表发送给相邻的路由器，更新它们的信息</p></li><li><p>路由表更新：
路由器根据接收到的路由信息来更新自己的路由表。如果某个目的地的路由表中的跳数变小，路由器会选择更新该路由。如果目的地不可达，它会从路由表中删除该条目</p></li><li><p>路由的计算：
路由器根据跳数来选择最佳路径。如果两个路径的跳数相同，路由器可能根据其他标准（如路由的带宽）来选择路径</p></li><li><p>定期更新：
RIP会定期向相邻的路由器发送更新包，以便在网络拓扑发生时，及时更新路由表</p></li></ol><h4 id=rip协议的特点>RIP协议的特点</h4><ol><li><p>距离向量算法
RIP是一种距离向量路由协议，通过不断交换路由表来计算每个网络的最短路径。每个路由器只知道与邻居路由器的距离，不知道其他路由器的完整网络拓扑</p></li><li><p>跳数限制
路由计算的最大跳数为15跳，如果两个网络之间的跳数超过15，那么它们就被认为是不可达的。这意味着RIP协议仅适用于小型到中型的网络</p></li><li><p>收敛速度较慢
由于RIP是基于周期性路由更新的，因此收敛速度较慢。如果网络拓扑发生变化（如链路失败），RIP可能需要较长的时间才能更新路由信息</p></li><li><p>适用于小型网络
由于跳数限制和较慢的收敛速度，RIP更适合用于较小的网络，不能满足大规模网络的路由需求。对于大型或复杂的网络，通常会选择OSPF或BGP等更高级的协议</p></li><li><p>广播更新
RIP协议每隔一段时间向所有路由器广播自己的路由表，这回导致网络带宽的浪费。特别是在大型网络中，广播更新可能会带来性能问题</p></li></ol><h4 id=rip版本>RIP版本</h4><ol><li>RIP v1:</li></ol><ul><li>协议类型：使用广播方式发送更新消息</li><li>缺点：不支持子网掩码，因此只能支持类地址的网络。这使得RIP v1无法进行CIDR的路由选择，也不支持VLSM（变长子网掩码）</li><li>网络设计：RIP v1不支持路由认证和多播更新（广播传输）</li></ul><ol start=2><li>RIP v2：</li></ol><ul><li>协议类型：使用多播方式发送路由更新包，减少了广播的负担</li><li>新特性：<ul><li>支持CIDR和VLSM，使得RIP v2更加灵活，可以支持不同的子网掩码</li><li>支持路由认证，增强了安全性</li><li>支持多播，即通过多播地址<code>224.0.0.9</code>发送路由更新包，从而减少了网络上的广播流量</li></ul></li><li>缺点：仍然存在跳数限制和收敛速度慢的问题</li></ul><ol start=3><li>RIPng:</li></ol><ul><li>支持IPv6：RIPng是RIP协议的扩展，专门用于支持IPv6地址的网络</li><li>特点：与RIP v2相似，但RIPng使用了多播地址<code>FF02::9</code>来发送路由更新包</li></ul><h4 id=rip的路由表更新过程>RIP的路由表更新过程</h4><ol><li><p>发送更新：
每30秒，路由器回想所有相邻的路由器发送包含自己路由表信息的更新包</p></li><li><p>接收更新：
当一个路由器接收到来自邻居的更新信息时，它会更新自己的路由表，选择最短的路径</p></li><li><p>触发更新：
如果网络拓扑发生变化（如路由器或链路故障），路由器会在180秒内发送一个触发更新（Trigger Update），使网络更快地收敛</p></li><li><p>路由表项的过期：
如果路由器长时间没有接收到某条路由的信息，路由表中的该条路由会被标记为不再有效，并被删除。RIP使用30秒的间隔来定期更新路由</p></li></ol><h4 id=rip协议的优缺点>RIP协议的优缺点</h4><p>优点：</p><ol><li>简单易懂</li><li>易于配置</li><li>广泛支持</li></ol><p>缺点：</p><ol><li>跳数限制</li><li>收敛速度慢</li><li>浪费带宽</li><li>网络负载：频繁的路由更新包会增加网络负载，影响网络性能</li></ol><h3 id=ospf协议>OSPF协议</h3><p>OSPF（Open Shortest Path First）是一种链路状态路由协议，广泛用于大型企业网络和ISP（Internet Service Providers）的内部网路由协议i。它是RIP协议的替代品，并且比RIP更适合大规模网络</p><p>OSPF协议由IETF（Internet Engineering Task Force）开发，属于内部网关协议（IGP），其设计目标是根据网络拓扑信息动态计算并选择最佳路径</p><h4 id=ospf的基本特点>OSPF的基本特点</h4><ol><li>链路状态协议：</li></ol><ul><li>与RIP不同，OSPF是链路状态协议。每个路由器只向相邻路由器广播其链路状态，而不是整个路由表。所有路由器基于接收到的状态信息构建出相同的路由表</li></ul><ol start=2><li>使用Dijkstra算法：</li></ol><ul><li>OSPF使用Dijkstra算法（也成为SPF算法，Shortest Path First）来计算最短路径</li></ul><ol start=3><li>无环路协议</li></ol><ul><li>OSPF可以确保计算出的路由是无环的</li></ul><ol start=4><li>分层设计：</li></ol><ul><li>OSPF允许将一个大的网络分割成多个区域（Area），以减少路由器的负担。通常，区域0是核心区域（也叫骨干区域），其他区域必须通过区域0连接</li></ul><ol start=5><li><p>支持VLSM和CIDR</p></li><li><p>支持负载均衡</p></li></ol><ul><li>OSPF支持等价负载均衡，可以在多个路由之间进行负载均衡，优化带宽的利用</li></ul><ol start=7><li>按成本计算路径：</li></ol><ul><li>OSPF使用一个称为成本（Cost）的度量来表示路径的开销，成本与链路带宽成反比。成本较低的路径更为优选</li></ul><ol start=8><li>支持认证：</li></ol><ul><li>OSPF支持路由认证，可以在增加路由器之间的安全性，确保只有授权的路由器才能参与路由计算</li></ul><h4 id=ospf的工作原理>OSPF的工作原理</h4><ol><li>OSPF邻居关系建立</li></ol><ul><li>OSPF路由器首先通过Hello协议相互发现邻居。Hello包是OSPF用来发现和维护邻居关系的协议。路由器通过交换Hello包建立邻居关系，确保彼此可以通信</li><li>邻居状态机（Neighbor State Machine）描述了OSPF建立邻居关系的过程。邻居关系有不同的状态，常见的状态有：<ul><li>Down：没有接收到Hello包</li><li>Attempt：正在尝试发送Hello包，建立连接</li><li>Init：收到对方的Hello包，但尚未交换数据</li><li>2-Way：双方已经交换Hello包，确定对方是有效的邻居</li><li>ExStart：准备交换LSA（Link-State Advertisement）信息</li><li>Exchange：交换LSA信息</li><li>Loading：加载LSA信息</li><li>Full：邻居关系完全建立，路由表同步</li></ul></li></ul><ol start=2><li>LSR（Link-State Request）和LSA（Link-State Advertisement）交换</li></ol><ul><li>当邻居关系建立后，路由器开始交换链路状态信息。每个路由器会生成一个LSA，其中包含了该路由器的链路状态（如接口的状态和带宽等信息）。LSA信息是OSPF的核心</li><li>路由器通过LSR请求邻居路由器提供链路状态信息，并根据收到的LSA生成自己的拓扑数据库</li></ul><ol start=3><li>计算最短路径</li></ol><ul><li>每个路由器根据接收到的LSA信息，使用Dijkstra算法计算从自己到其他网络的最短路径<ul><li>SPF树：每个路由器会根据链路状态信息生成最短路径树，这棵树的根节点是该路由器，树中的每一条边表示一条路径</li></ul></li></ul><ol start=4><li>更新路由表</li></ol><ul><li>根据计算出的最短路径树，路由器将计算出的路由信息（即最短路径）加入到自己的路由表中</li><li>如果网络拓扑发生变化（例如链路故障或路由器重启），路由器会重新计算SPF树并更新路由表</li></ul><h4 id=ospf的区域划分>OSPF的区域划分</h4><p>OSPF支持将网络分为多个区域（Area），这有助于减轻路由器的负担并优化路由计算。每个区域内的路由器只与该区域内的路由器交换链路状态信息，而区域之间的路由信息由骨干区域（Area0）传递</p><ul><li>区域0（骨干区域）：所有其他区域都必须直接或间接连接到区域0</li><li>非骨干区域：可以是多个子区域，用于分割大型网络以减少路由表的规模</li></ul><h4 id=ospf路由器类型>OSPF路由器类型</h4><ol><li>内部路由器（Internal Router, IR）</li></ol><ul><li>只在同一区域内操作的路由器</li></ul><ol start=2><li>边界路由器（ABR，Area Border Router）</li></ol><ul><li>连接多个区域的路由器，负责在区域之间传递路由信息</li></ul><ol start=3><li>骨干路由器（Backbone Router）</li></ol><ul><li>属于区域0的路由器，负责核心网络的路由信息交换</li></ul><ol start=4><li>AS边界路由器（ASBR，Autonomous System Boundary Router）</li></ol><ul><li>连接OSPF与其他自治系统（例如，BGP）之间的路由器</li></ul><h4 id=ospf的lsa类型>OSPF的LSA类型</h4><p>OSPF使用LSA（链路状态通告）来交换链路状态信息，LSA的类型由多个，最常用的包括：</p><ol><li>Type 1 LSA (Router LSA)</li></ol><ul><li>路由器生成自己的LSA，描述其所有直接连接的链路（接口）</li></ul><ol start=2><li>Type 2 LSA (Network LSA)</li></ol><ul><li>用于描述网络中所有交换机与路由器之间的连接</li></ul><ol start=3><li>Type 3 LSA (Summary LSA)</li></ol><ul><li>边界路由器生成，用于将其他区域的路由信息汇总并传播到其他区域</li></ul><ol start=4><li>Type 4 LSA (ASBR Summary LSA)</li></ol><ul><li>用于将ASBR的路由信息传播到其他区域</li></ul><ol start=5><li>Type 5 LSA (External LSA)</li></ol><ul><li>ASBR用于传播外部网络的路由信息（通常来自BGP）</li></ul><h4 id=ospf的优缺点>OSPF的优缺点</h4><p>优点</p><ol><li>快速收敛</li><li>支持大规模网络：OSPF支持区域划分</li><li>使用最短路径算法</li><li>VLSM支持</li></ol><p>缺点</p><ol><li>复杂度较高</li><li>开销较大：OSPF需要更多的计算资源和内存</li><li>初始配置复杂：需要规划区域和接口设置，初始部署较为复杂</li></ol><h3 id=bgp协议>BGP协议</h3><p>BGP（Border Gateway Protocol）是互联网的核心路由协议，用于在不同的自治系统（AS）之间交换路由信息。它是一种路径向量协议，不同于传统的链路状态协议和距离矢量协议。BGP在全球范围内的互联网路由选择中起着至关重要的作用，负责选择跨自治系统（AS）的最佳路径</p><h4 id=bgp的基本特点>BGP的基本特点</h4><ol><li>路径向量协议</li></ol><ul><li>BGP是路径向量协议，路由器交换信息时不仅包含目的网络地址，还包括到达目标网络的路径信息（即AS路径）。路径向量协议中的路径信息是一系列自治系统的标识符</li></ul><ol start=2><li>基于AS（自治系统）</li></ol><ul><li>BGP的核心概念是自治系统，它代表一个由单一技术管理的网络。每个AS都有一个唯一的AS号，BGP通过交换AS号信息来确定路由的路径</li></ul><ol start=3><li>用于跨自治系统的路由：</li></ol><ul><li>BGP是外部网关协议（EGP），用于在不同自治系统之间交换路由信息。与OSPF和RIP等内部网关协议（IGP）不同，BGP负责管理跨域路由</li></ul><ol start=4><li>不使用度量值</li></ol><ul><li>与其他协议不同，BGP选择路径时，并不依赖于像带宽、延迟等度量标准，而是使用路径的AS路径长度、策略和其他属性来决定最佳路径</li></ul><ol start=5><li>支持策略控制</li></ol><ul><li>BGP允许使用策略来影响路由的选择，比如通过AS路径过滤、前缀过滤、路由聚合等手段控制路由的选择，这使得BGP成为管理互联网路由的灵活工具</li></ul><ol start=6><li>支持聚合：</li></ol><ul><li>BGP支持IP地址前缀聚合，使得多个网络段可以合并成一个更简洁的网络前缀，从而减少路由表的规模</li></ul><h4 id=bgp的工作原理>BGP的工作原理</h4><p>BGP的工作原理可以概括为以下几个步骤：</p><ol><li>BGP邻居关系的建立（Session Estabishment）</li></ol><ul><li>BGP是一个基于TCP连接的协议，通常使用179端口</li><li>在BGP邻居之间建立连接时，首先会进行握手，通过OPEN报文来交换必要的配置信息，如AS号、BGP版本、路由器ID等</li><li>在邻居之间建立起BGP会话后，路由器就可以开始交换路由信息</li></ul><ol start=2><li>BGP路由信息交换（Route Advertisement）</li></ol><ul><li>在BGP会话建立后，路由器通过UPDATE报文交换路由信息。每个路由通告包含了目标网络（即IP前缀）以及与该目标网络相关的AS路径和其他属性</li><li>AS路径：指明了数据包从源到达目的网络时所经过的自治系统的序列。AS路径用于避免环路，作为为路由选择的一部分</li><li>BGP属性：BGP路由中包含多个属性，常见的有：<ul><li>AS路径（AS Path）：列出了到达目标网络所经过的AS</li><li>下一跳（Next Hop）：指明了到达目标网络的下一跳地址</li><li>前缀长度（Prefix Length）：指明网络地址的位数</li><li>多路径（Multipath）：如果BGP路由器支持多路径，可能有多个有效路径</li><li>本地优先级（Local Preference）：用于在同一个AS内选择最佳路径</li><li>MED（Multi-Exit Discriminator）：用于影响跨多个AS的路由选择</li></ul></li></ul><ol start=3><li>路由选择与更新</li></ol><ul><li>路由器根据AS路径和BGP属性来选择最佳路径。BGP采用的路径选择规则如下（优先级从高到低）<ol><li>优先选择本地优先级（Local Preference）</li><li>选择AS路径最短的路径</li><li>选择路由跳数最少的路径（即“下一跳”）</li><li>选择MED值最小的路径</li><li>根据BGP协议的配置选择，如某些路由的可靠性、带宽等</li></ol></li><li>一旦选择了最佳路径，路由器会将其添加到本地路由表，并根据该路径转发流量</li></ul><ol start=4><li>BGP路由的撤销与更新</li></ol><ul><li>如果网络拓扑发生变化，比如某个AS无法到达，BGP会通过UPDATE报文将无效路由撤销，并通过新的路径信息更新路由表</li><li>BGP收敛：BGP的收敛速度相对较慢，尤其是在全球互联网规模下，可能需要几分钟或更长时间才能重新计算并传播新的路由信息</li></ul><h4 id=bgp的路由类型>BGP的路由类型</h4><p>BGP路由分为两种类型：</p><ol><li>内部BGP（即iBGP）：
- iBGP用于同一自治系统内的路由器之间，通过iBGP交换的路由信息不会直接传递给外部，只在AS内传播</li><li>外部BGP（即eBGP）
- eBGP用于不同自治系统之间的路由器之间交换路由信息。通常，互联网服务商（ISP）会使用eBGP与其他AS交换路由信息</li></ol><h4 id=bgp的路由属性>BGP的路由属性</h4><p>BGP路由的选择不仅依赖于路径信息，还依赖于一些路由属性：</p><ol><li>AS Path（AS路径）：</li></ol><ul><li>AS路径是BGP最重要的路由属性之一。它记录了路由信息通过所有自治系统的标识。AS路径长度越短，表示路径越优选</li></ul><ol start=2><li>Next Hop（下一跳）：</li></ol><ul><li>下一跳的地址是BGP路由信息中的一项重要属性，它表示从当前路由器到目的地网络的下一跳点的IP地址</li></ul><ol start=3><li>Local Preference（本地优先级）：</li></ol><ul><li>本地优先级是BGP内部（iBGP）使用的一个属性，用于指示不同路径之间的优先级。值越大，优先级越高，路由器会选择具有较高本地优先级的路径</li></ul><ol start=4><li>Multi-Exit Discriminator（MED）（多出口区分符）：</li></ol><ul><li>MED用于指示不同自治系统之间的优先级，它告诉BGP路由器如何选择通过多个出口通道进入某个AS的路径</li></ul><ol start=5><li>Communities（社区属性）：</li></ol><ul><li>社区属性用于BGP路由策略的分组，它可以对多个路由进行标记，便于网络管理员对不同类型的流量进行控制</li></ul><h4 id=bgp的优缺点>BGP的优缺点</h4><p>优点</p><ol><li>大规模网络支持</li><li>灵活的策略控制</li></ol><ul><li>BGP根据AS路径、前缀长度、优先级等多种因素对路由器进行灵活的控制和定制</li></ul><ol start=3><li>支持路由聚合</li></ol><ul><li>BGP支持路由聚合，可以将多个网络地址合并成一个较小的地址块，从而减少路由表的规模</li></ul><ol start=4><li>支持冗余与负载均衡</li></ol><ul><li>BGP支持多路径负载均衡，能够选择多个路由用于同一目的网络，增强网络的可靠性和带宽利用率</li></ul><p>缺点</p><ol><li>收敛速度较慢</li><li>配置复杂</li><li>依赖TCP协议</li></ol><ul><li>BGP依赖于TCP连接（端口179），这使得BGP在某些环境下可能面临连接不稳定或带宽消耗的问题</li></ul><h2 id=路由器router>路由器（Router）</h2><h3 id=定义>定义</h3><p>路由器是网络层的设备，它的主要功能是根据数据包的目标地址，决定如何将数据包从源主机转发到目标主机。路由器通过查阅路由表来决定数据包的最佳转发路径</p><h3 id=功能>功能</h3><ul><li>数据包转发：路由器根据目标IP地址和路由表，选择适合的下一跳设备，将数据包转发到正确的网络</li><li>网络互联：路由器负责连接不同类型的网络，例如局域网（LAN）与广域网（WAN）之间的通信，或者两个不同的子网之间的数据传输</li><li>地址解析：通过ARP协议，路由器将IP地址解析为MAC地址，用于链路层的数据传输</li><li>选择最优路径：使用动态或静态路由协议（如OSPF、BGP），路由器可以选择最优路径进行数据转发</li></ul><h3 id=路由器的工作流程>路由器的工作流程</h3><ul><li>接收数据包：路由器接收到来自源主机的数据包</li><li>查看IP头部：路由器查看数据包的目标IP地址，依据目标地址决定数据包的转发路径</li><li>查阅路由表：路由器根据目标IP地址查阅路由表，选择下一跳</li><li>转发数据包：路由器将数据包转发到下一个路由器或目标主机</li></ul><h3 id=路由器的类型>路由器的类型：</h3><ul><li>传统路由器：用于局域网、广域网、企业网络等，负责内部网络和外部网络的连接</li><li>三层交换机：结合了路由器和交换机的功能，能够在数据链路层和网络层之间进行高速转发</li><li>核心路由器：用于互联网骨干网络中，负责不同网络之间的大规模数据转发</li><li>边缘路由器：位于网络的边缘，主要负责用户访问外部网络</li></ul><h2 id=路由routing>路由（Routing）</h2><p>路由是指数据包从源主机到目标主机在不同网络之间的传输过程。具体来说，路由时指数据包的选择路径，通常由路由协议和路由表决定。简而言之，路由器是决定数据包如何从一个网络传输到另一个网络的过程</p><h3 id=路由的过程>路由的过程</h3><ul><li>路径选择：路由的核心目标时选择数据包从源头到目的地的最佳路径。路径的选择依赖于多个因素，如网络拓扑、链路状态、带宽、延迟等</li><li>路由协议：动态路由协议（如OSPF、BGP、RIP等）负责计算最优路径并更新路由表，确保数据包能沿着最佳路径进行传输</li><li>静态路由：管理员手动配置的固定路径，通常用于简单的网络中，或当动态路由协议不可用时使用</li></ul><h3 id=路由的实现方式>路由的实现方式</h3><ul><li>静态路由：管理员手动设置路由路径。这种方式简单且节省资源，但当网络拓扑发生变化时，需要手动更新路由配置
在一个简单的网络中，管理员可能手动配置路由器，使得数据包从源主机到目标主机有一个固定的路径<br>特点：</li><li>不可变</li><li>优先级高：静态路由通常优于动态路由</li><li>灵活性差</li></ul><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>Network</span> 192.168.1.0<span style=color:#e6db74>/24</span> <span style=color:#e6db74>-&gt;</span> <span style=color:#e6db74>Next</span> <span style=color:#e6db74>Hop</span> 192.168.2.1
</span></span></code></pre></div><p>路由器会根据这个配置，直接将数据包发送到下一个跳点<code>192.169.2.1</code></p><ul><li><p>动态路由：由路由协议自动计算并维护路由路径。动态路由根据网络状态的变化自动调整路由路径，适用于大规模或经常变化的网络
在一个较大的网络中，路由器可能无法事先配置所有的路由。相反，路由器会使用动态路由协议来计算最佳路径，并根据网络状态变化动态更新路由表<br>例如，假设某个路由器发现到达某个网络的路径变得不可达，它会通过BGP协议通知相邻路由器，并选择一条新的路径来替代原有的路径<br>特点：</p></li><li><p>自动更新</p></li><li><p>灵活性强</p></li><li><p>开销较高</p></li><li><p>默认路由（Default Route）
默认路由是当数据包的目标地址不再路由表中时使用的路由。它相当于一个“备选”路由。通常，默认路由会将数据包发送到一个网关，这个网关负责转发数据包到目标网络。默认路由的目标网络通常是<code>0.0.0.0/0</code></p></li></ul><p>默认路由的配置示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ip route add default via 192.168.1.1
</span></span></code></pre></div><p>这意味着任何目的地址不在路由表中的数据包都会被发送到<code>192.168.1.1</code>，通常是网络的出口路由器</p><h3 id=路由表routing-table>路由表（Routing Table）</h3><p>路由表时网络设备用来决定数据包转发路径的重要数据。每个路由器都有自己的路由表，路由表记录了网络中不同目标地址的路由信息，帮助路由器决定将数据包转发到哪个下一跳。</p><p>路由表的核心任务是决定数据包的最佳转发路径</p><h4 id=路由表的基本结构>路由表的基本结构</h4><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td><strong>目标网络（Destination Network）</strong></td><td>数据包的目标地址所在的网络。例如，<code>192.168.1.0/24</code>。</td></tr><tr><td><strong>子网掩码（Netmask）</strong></td><td>用来指定目标网络的大小，即地址范围。例如，<code>255.255.255.0</code>。</td></tr><tr><td><strong>下一跳（Next Hop）</strong></td><td>下一个路由器的IP地址或目标设备的地址。如果目标设备在本地子网，下一跳可能是直接连接的接口。</td></tr><tr><td><strong>出接口（Interface）</strong></td><td>路由器将通过哪个接口发送数据包。每个网络接口（如以太网口、Wi-Fi口）都有一个唯一的标识。</td></tr><tr><td><strong>路由类型（Route Type）</strong></td><td>指明该路由是<strong>静态路由</strong>（手动配置）还是<strong>动态路由</strong>（由路由协议动态计算得出）。</td></tr><tr><td><strong>度量值（Metric）</strong></td><td>路由的“成本”，用于比较不同路径的优劣。度量值越小，路径越优先。通常，动态路由协议会使用度量值来选择最优路径。</td></tr></tbody></table><p><strong>举例</strong><br>假设有以下路由表条目</p><table><thead><tr><th>目标网络</th><th>子网掩码</th><th>下一跳</th><th>出接口</th><th>路由类型</th></tr></thead><tbody><tr><td><code>192.168.1.0</code></td><td><code>255.255.255.0</code></td><td><code>192.168.0.1</code></td><td><code>eth0</code></td><td>静态路由</td></tr><tr><td><code>0.0.0.0</code></td><td><code>0.0.0.0</code></td><td><code>192.168.0.1</code></td><td><code>eth0</code></td><td>默认路由</td></tr><tr><td><code>192.168.2.0</code></td><td><code>255.255.255.0</code></td><td><code>192.168.1.1</code></td><td><code>eth1</code></td><td>动态路由</td></tr></tbody></table><p>解释：</p><ul><li>第一条路由条目指示，任何目的地址是<code>192.168.1.0/24</code>网络的数据包都应该通过下一跳<code>192.168.0.1</code>，并使用<code>eth0</code>接口转发</li><li>第二条条目是一个默认路由，表示所有不在其它网络范围内的目标地址都会通过<code>192.168.0.1</code>发送</li><li>第三条条目是一个动态路由，目的地址是<code>192.168.2.0/24</code>，下一跳是<code>192.168.1.1</code>，出接口是<code>eth1</code></li></ul><h4 id=路由表的工作原理>路由表的工作原理</h4><ul><li>接收数据包：当路由器接收到一个数据包时，首先查看数据包的目标IP地址</li><li>查找路由表：路由器会在自己的路由表中查找一个匹配目标地址的路由条目。路由表中的目标网络通常使用子网掩码于数据包目标地址进行匹配</li><li>选择路径：一旦找到匹配的路由条目，路由器会根据路由表中的信息选择一个下一跳地址和出接口。路由器使用这个信息将数据包转发到下一跳路由器或目标设备</li></ul><h4 id=最长前缀匹配longest-prefix-match>最长前缀匹配（Longest Prefix Match）</h4><p>当目标IP地址有多个匹配的路由条目时，路由器会选择最长前缀匹配的路由。最长前缀匹配原则意味着，如果有多个路由条目与目标地址匹配，路由器会选择子网掩码最长的那一条规则</p><p>例如，如果目标地址是<code>192.168.1.100</code>，路由器的路由表有以下两条规则：</p><ul><li>192.168.0.0/24</li><li>192.168.1.0/24</li></ul><p>路由器会选择<code>192.168.1.0/24</code>路由条目，因为它的子网掩码（<code>255.255.255.0</code>）比<code>192.168.0.0/24</code>的子网掩码更长，匹配度更高</p><h2 id=网络层中的典型协议>网络层中的典型协议</h2><table><thead><tr><th>协议名</th><th>功能</th></tr></thead><tbody><tr><td><strong>IP</strong></td><td>Internet Protocol，提供不可靠的包传输服务，是网络层的核心协议</td></tr><tr><td><strong>ICMP</strong></td><td>用于报告差错信息和诊断问题（如 ping）</td></tr><tr><td><strong>IGMP</strong></td><td>管理组播组成员（组播=一个发给多个）</td></tr><tr><td><strong>ARP/RARP</strong></td><td>虽属于链路层，但与IP地址紧密协作（地址解析协议）</td></tr><tr><td><strong>IPSec</strong></td><td>用于加密IP包（网络层的安全协议）</td></tr></tbody></table><h3 id=ip协议>IP协议</h3><p>IP协议（Internet Protocol）是网络层的核心协议，它负责为数据包添加源IP和目标IP地址，实现数据包的路由和转发。IP协议有两个版本</p><ul><li>IPv4：32位地址空间，广泛应用于全球大部分网络</li><li>IPv6：128位空间地址，逐渐替代IPv4，解决了IPv4地址短缺的问题</li></ul><p>IP协议在提供跨网络的数据传输时非常有效，但它本身是不可靠的。这意味着，IP协议并不保证数据包的到达、顺序或重传</p><h4 id=ipv4协议>IPv4协议</h4><p>IPv4是目前最广泛使用的IP协议版本，它使用32位地址，支持的地址范围为<code>0.0.0.0</code>到<code>255.255.255.255</code>，即理论上支持大约43亿个唯一地址</p><h5 id=ipv4地址结构>IPv4地址结构</h5><p>IPv4地址由32位二进制数构成，通常使用四个十进制数表示，每个数代表8位二进制数。每个十进制数的范围是<code>0~255</code>，例如<code>192.168.1.1</code></p><p>IP地址 = 网络号 + 主机号</p><ul><li>网络号（Network Portion）：标识网络的部分，用于将不同的设备分组到同一网络中</li><li>主机号（Host Portion）：标识网络中各个设备的部分，唯一地标识一个设备</li></ul><h5 id=ipv4包格式>IPv4包格式</h5><p>IPv4数据包包括以下几个字段：</p><table><thead><tr><th>字段名</th><th>长度</th><th>说明</th></tr></thead><tbody><tr><td><strong>版本（Version）</strong></td><td>4位</td><td>表示IP协议的版本，IPv4的值为4。</td></tr><tr><td><strong>头部长度（Header Length）</strong></td><td>4位</td><td>表示IP包头部的长度，以4字节为单位。</td></tr><tr><td><strong>服务类型（Type of Service）</strong></td><td>8位</td><td>用于指定数据包的优先级和处理要求。</td></tr><tr><td><strong>总长度（Total Length）</strong></td><td>16位</td><td>数据包的总长度（包括头部和数据）。</td></tr><tr><td><strong>标识（Identification）</strong></td><td>16位</td><td>用于标识数据包分片的序列号。</td></tr><tr><td><strong>标志（Flags）</strong></td><td>3位</td><td>用于控制和标识数据包是否可以分片。</td></tr><tr><td><strong>片偏移（Fragment Offset）</strong></td><td>13位</td><td>指示数据包分片的位置。</td></tr><tr><td><strong>生存时间（TTL，Time to Live）</strong></td><td>8位</td><td>表示数据包在网络中存活的最大跳数。</td></tr><tr><td><strong>协议（Protocol）</strong></td><td>8位</td><td>表示数据包的上层协议（例如TCP、UDP等）。</td></tr><tr><td><strong>头部校验和（Header Checksum）</strong></td><td>16位</td><td>用于检查IP头部是否出错。</td></tr><tr><td><strong>源IP地址（Source IP Address）</strong></td><td>32位</td><td>发送数据包的设备的IP地址。</td></tr><tr><td><strong>目的IP地址（Destination IP Address）</strong></td><td>32位</td><td>目标设备的IP地址。</td></tr><tr><td><strong>选项（Options）</strong></td><td>可变</td><td>可选字段，提供附加的控制信息。</td></tr><tr><td><strong>数据（Data）</strong></td><td>可变</td><td>数据部分，包含上层协议的数据（例如TCP/UDP数据）。</td></tr></tbody></table><h5 id=ipv4的重要特性>IPv4的重要特性</h5><ul><li>无连接：IP协议本身不建立连接，不保证数据的可靠性和顺序</li><li>不可靠：数据包可能会丢失、重复、顺序错乱</li><li>分片和重组：IPv4可以在数据包大小超过链路MTU（最大传输单元）时进行分片，并在接收端重组</li></ul><h5 id=特殊ip地址>特殊IP地址</h5><ol><li>网络地址</li></ol><ul><li>是子网中的第一个地址，用来表示整个子网。它的主机部分全是0</li><li>对于任何子网，网络地址都是该子网段的首地址</li><li>不可分配给主机</li></ul><ol start=2><li>广播地址</li></ol><ul><li>是子网中的最后一个地址，用来进行广播通信，它的主机部分全是1</li><li>对于任何子网，广播地址都是该子网段的尾地址</li><li>不可分配给主机</li></ul><ol start=3><li>默认网关地址</li></ol><ul><li>默认网关（Default Gateway）是一个特殊的地址，用于在主机无法通过本地网络通信时，将数据包发送到外部网络。通常，默认网关是本地网络的路由器地址</li><li>默认网关通常设置为子网中的第一个可用主机地址（例如，<code>192.168.1.1</code>，如果子网是<code>192.168.1.0/24</code>）。路由器将通过这个地址与其他子网或互联网进行通信</li></ul><ol start=4><li>0.0.0.0</li></ol><ul><li><code>0.0.0.0</code>是一个非常特殊的地址，它有几个用途：<ul><li>源地址：在网络通信中，<code>0.0.0.0</code>可以表示“无效”或“未知”源地址，通常在路由表中用于表示默认路由</li><li>默认路由：在路由器的路由表中，<code>0.0.0.0</code>通常用于表示默认路由，即当没有其他匹配的路由时，数据包会被发送到这个路由</li></ul></li><li>在实际使用中，<code>0.0.0.0</code>并不代表一个特定的主机，而是一个表示“任意地址”的占位符</li></ul><ol start=5><li>127.0.0.0/8</li></ol><ul><li><p>环回地址（Loopback Address）：<code>127.0.0.0/8</code>范围内的地址被保留用于本地通信，通常<code>127.0.0.1</code>被称为本地回环地址（<code>localhost</code>），它用于指向发送者本身。任何发往<code>127.x.x.x</code>地址的数据包都会被路由器发送到发送者</p></li><li><p>用途：</p><ul><li>用于测试本机的网络协议栈，不经过网络硬件</li><li>比如<code>ping 127.0.0.1</code>可以测试本机的网络连通性</li></ul></li></ul><ol start=6><li>私有地址</li></ol><ul><li>私有IP地址是为内部网络保留的，不能直接在互联网上路由。私有地址段的定义如下：<ul><li>A类私有地址：<code>10.0.0.0 - 10.255.255.255</code>(<code>10.0.0.0/8</code>)</li><li>B类私有地址：<code>172.16.0.0 - 172.31.255.255</code>(<code>172.16.0.0/12</code>)</li><li>C类私有地址：<code>192.168.0.0 - 192.168.255.255</code>(<code>192.168.0.0/16</code>)</li></ul></li><li>这些地址可以在局域网中使用，但不能直接在互联网中使用。为了让私有地址与公网通信，通常需要使用NAT（网络地址转换）技术</li></ul><ol start=7><li>多播地址</li></ol><ul><li><p>多播地址用于支持一对多的通信，不同于广播（全网通信），多播允许数据包仅发送到特定的接收者组。多播地址的范围通常是<code>224.0.0.0 - 233.255.255.255</code></p></li><li><p>特征：</p><ul><li>多播数据包仅发送给指定组的成员，而非整个网络中的每个设备</li><li>使用IGMP来管理多播组</li></ul></li></ul><ol start=8><li>链路本地地址</li></ol><ul><li>链路本地地址是指用于在单一网络段内进行通信的地址。在IPv6中，链路本地地址的范围是<code>fe80::/10</code><ul><li>链路本地地址是由操作系统自动配置的，不需要由DHCP或其他方式分配，它通常用于局域网内的自动配置</li><li>在IPv4中，链路本地地址通常是<code>169.254.0.0/16</code>，这种地址通常在设备无法获取有效的DHCP地址时自动配置（APIPA地址）</li></ul></li></ul><h5 id=子网掩码subnet-mask>子网掩码（Subnet Mask）</h5><p>为了划分网络，IPv4地址使用了子网掩码，它与IP地址配合使用，决定了网络中哪些部分是网络号，哪些部分是主机号。</p><p>子网掩码是一个32位的二进制数，与IP地址进行按位与操作，帮助识别IP地址中的网络部分和主机部分。</p><p>子网掩码决定了一个网络的大小（即子网中主机的数量）</p><p>子网掩码并不单独用于标识某个网络，而是与IP地址配合使用，以指示该地址的网络部分和主机部分</p><p>子网掩码通常以点分十进制标识，与IP地址结构相同，例如：<code>255.255.255.0</code>。每个十进制数表示8位二进制</p><h6 id=子网掩码的结构>子网掩码的结构</h6><p>子网掩码由<strong>连续</strong>的1部分（表示网络部分）和<strong>连续</strong>的0部分（表示主机部分）组成。网络部分的1表示网络号，主机部分的0表示主机号</p><p>例如：</p><ul><li>IP地址：192.168.1.0</li><li>子网掩码：255.255.255.0</li></ul><p>二进制表示如下：</p><ul><li>IP地址：11000000.10101000.00000001.00000000</li><li>子网掩码：11111111.11111111.11111111.00000000</li></ul><p>通过对IP地址和子网掩码进行按位与运算，可以得到该地址所属的网络部分。例如，192.168.1.0/24表示一个拥有256个地址（包括网络地址和广播地址）的子网，/24表示子网掩码为255.255.255.0，即前24位是网络部分</p><h5 id=cidrclassless-inter-domain-routing>CIDR（Classless Inter-Domain Routing）</h5><p>CIDR是IPv4的一种地址分配方式，避免了传统的类A、类B、类C地址的限制。CIDR表示法通过斜杠后跟随一个数字来表示子网掩码的长度</p><p>CIDR和子网掩码本质上是相同的</p><p>通过CIDR表示法，路由器和设备能够更加方便地进行路由选择和网络划分。CIDR允许使用任何前缀长度。这使得IP地址的分配更加灵活，尤其在IPv4地址资源枯竭的今天，CIDR提供了一个有效的解决方案</p><p>例如：</p><ul><li><code>192.168.1.0/24</code>表示网络<code>192.168.1.0</code>，子网掩码为<code>255.255.255.0</code>，其中<code>/24</code>代表前24位是网络号</li></ul><h5 id=类地址系统>类地址系统</h5><p>在IPv4的早期设计中，网络地址分配采用了类地址系统，这种系统通过将IP地址划分为不同的类别，来组织和分配IP地址。每个类别定义了特定的网络大小和主机数量</p><p>类地址系统的划分方式并不灵活，固定了每个类别的子网掩码，因此在分配地址时容易造成浪费，尤其是当某些网络的设备数少于分配给它的IP地址时。</p><p>类地址系统在当时简化了网络的设计和配置</p><h6 id=类地址系统的分类>类地址系统的分类</h6><p>类地址系统将IPv4地址划分为五个主要类别：A类，B类，C类，D类，E类。每个类别的网络号和主机号部分的分配不同，导致每个类别可容纳的主机数量也不同</p><p>ChatGPT said:
类地址系统（Classful Addressing System）概述
在IPv4地址的早期设计中，网络地址分配采用了类地址系统（Classful Addressing），这种系统通过将IP地址划分为不同的“类别”（Class）来组织和分配IP地址。每个类别定义了特定的网络大小和主机数量。</p><p>类地址系统的划分方式并不灵活，固定了每个类别的子网掩码，因此在分配地址时容易造成浪费，尤其是当某些网络的设备数少于分配给它的IP地址时。不过，类地址系统在当时简化了网络的设计和配置。</p><p>类地址系统的分类
类地址系统将IPv4地址（32位）划分为五个主要类别：A类、B类、C类、D类和E类。每个类别的网络号和主机号部分的分配不同，导致每个类别可容纳的主机数量也不同。</p><ol><li>A类地址（Class A）</li></ol><ul><li>地址范围：0.0.0.0 到 127.255.255.255</li><li>网络号：前 8 位（即第 1 字节）</li><li>主机号：剩余 24 位</li><li>默认子网掩码：255.0.0.0（即 /8）</li><li>可用网络数：128 个（2^7 - 2 = 128个，减去 0.0.0.0 和 127.0.0.0 作为保留地址）</li><li>每个网络的主机数：16,777,214 个（2^24 - 2）</li><li>用途：适用于大型企业或数据中心，网络中可以有大量的主机。A类地址分配给了全球最大的网络。</li><li>示例：10.0.0.0/8</li></ul><ol start=2><li>B类地址（Class B）</li></ol><ul><li>地址范围：128.0.0.0 到 191.255.255.255</li><li>网络号：前 16 位（即前 2 字节）</li><li>主机号：剩余 16 位</li><li>默认子网掩码：255.255.0.0（即 /16）</li><li>可用网络数：16,384 个（2^14 - 2）</li><li>每个网络的主机数：65,534 个（2^16 - 2）</li><li>用途：适用于中型到大型网络。B类地址分配给了中型组织，支持较多的设备。</li><li>示例：172.16.0.0/16</li></ul><ol start=3><li>C类地址（Class C）</li></ol><ul><li>地址范围：192.0.0.0 到 223.255.255.255</li><li>网络号：前 24 位（即前 3 字节）</li><li>主机号：剩余 8 位</li><li>默认子网掩码：255.255.255.0（即 /24）</li><li>可用网络数：2,097,152 个（2^21 - 2）</li><li>每个网络的主机数：254 个（2^8 - 2）</li><li>用途：适用于小型网络。C类地址用于家庭、办公室、学校等小型局域网，每个网络最多容纳 254 台设备。</li><li>示例：192.168.1.0/24</li></ul><ol start=4><li>D类地址（Class D）（多播地址）</li></ol><ul><li>地址范围：224.0.0.0 到 239.255.255.255</li><li>用途：D类地址用于 多播（Multicast），即向一组特定设备发送数据，而不是单独向某一设备发送。多播技术常用于音视频流传输等应用。</li><li>示例：224.0.0.0/4（通常没有子网掩码）</li></ul><ol start=5><li>E类地址（Class E）（保留地址）</li></ol><ul><li>地址范围：240.0.0.0 到 255.255.255.255</li><li>用途：E类地址是为 实验和研究用途 保留的，不用于公开的网络通信。它通常不会在实际的网络中使用。</li><li>示例：240.0.0.0/4</li></ul><h6 id=类地址系统的优势与局限>类地址系统的优势与局限</h6><p>优势：</p><ul><li>简单易懂：类地址系统通过固定的网络号和主机号位数，使得地址分配变得相对简单，适合早期的网络架构。</li><li>快速配置：网络管理员可以通过简单的 IP地址范围和子网掩码 来划分网络，无需进行复杂的计算。</li></ul><p>局限：</p><ul><li>地址浪费：<ul><li>类A、类B、类C地址的固定大小导致了 IP地址的浪费，尤其是在类A和类B地址范围内。当一个小型公司申请一个类A或类B地址时，可能会有大量未使用的IP地址。例如，类A网络可以容纳约 1677 万个主机，而许多实际需求远远小于此，导致大量的地址无法利用。</li></ul></li><li>无法灵活划分：<ul><li>类地址系统基于固定的网络和主机部分，无法灵活地适应不同规模的网络需求。例如，类C只能有254个设备，这对于一些需要更多主机的网络来说是不够的，而类B或类A又存在地址浪费问题。</li></ul></li><li>不适合大规模的互联网：<ul><li>随着互联网的发展，全球对IPv4地址的需求激增，类地址系统的限制显得尤为突出。由于IP地址空间有限，互联网运营商不得不采取其他技术（如 CIDR）来有效利用地址空间，避免大量浪费。</li></ul></li></ul><h5 id=cidr与子网掩码例子和计算>CIDR与子网掩码例子和计算</h5><p>IP地址：<code>192.168.1.0/24</code></p><ul><li>前24位固定，即<code>192.168.1</code>表示网络号，后8位为主机号</li><li>可容纳256个IP地址（从192.168.1.0到192.168.1.255）</li><li>可用主机范围为<code>192.168.1.1</code>到<code>192.168.1.254</code></li><li><code>192.168.1.0</code>是网络地址，表示该网络本身，不能用于分配给网络中的设备</li><li><code>192.168.1.255</code>是广播地址，用于给子网中所有设备发送数据</li></ul><p>IP地址：<code>10.0.0.0/8</code></p><ul><li>前8位固定，即<code>10</code>代表网络号，主机号为后24位</li><li>可用主机范围<code>10.0.0.1</code>到<code>10.0.0.254</code></li></ul><p><strong>子网掩码与CIDR的相互转换</strong></p><p>子网掩码转换为CIDR</p><ul><li>数1的数量</li><li><code>255.255.255.0</code>转换为<code>/24</code></li><li><code>255.255.255.128</code>转换位<code>/25</code></li></ul><p>CIDR转换为子网掩码</p><ul><li><code>/24</code>转换为<code>255.255.255.0</code></li><li><code>/26</code>转换位<code>255.255.255.192</code></li></ul><p>可以看到，网络号每增加一位，即子网掩码的前缀长度增加一位，每个子网的可容纳设备数会大大减少，这种做法具有以下几个重要的优点，特别是在IP地址管理和网络优化方面：</p><ol><li>提高地址利用率</li></ol><ul><li>减少浪费：在传统的类地址系统中，A类，B类，C类等地址范围常常会导致地址浪费。例如，使用<code>A类地址(/8)</code>为一个小型办公室分配了几百万个地址，而实际上只需要很少的IP地址，这种情况在IP地址资源紧张时尤为突出。通过子网划分，管理员可以根据实际需求分配适当大小的子网，避免大量IP地址浪费</li><li>更灵活的分配：通过CIDR，管理员可以将IP地址划分为不同规模的子网，灵活调整每个子网的大小，确保每个子网只包含必要的设备，从而更有效地利用地址空间</li></ul><ol start=2><li>提高网络安全性</li></ol><ul><li>隔离不同的网络：将大型网络划分为多个小型子网（比如通过增加子网掩码的位数），可以有效地隔离不同的网络区域。每个子网中的设备仅能与该子网中的其他设备通信，减少了不必要的广播和潜在的安全风险。例如，将企业内部不同部门（如财务、研发、销售等）分别划分到不同的子网，这样即便某个部门的设备遭到攻击，其他部门也可以相对安全</li><li>安全策略和访问控制：子网划分后，可以更精细地为不同子网配置安全策略和访问控制，控制哪些子网可以互相访问，哪些子网对外部访问受限，从而提高网络的安全性</li></ul><ol start=3><li>优化网络性能</li></ol><ul><li>减少广播域的大小：在没有子网划分的网络中，广播数据会在整个网络中传播，所有设备都会收到广播请求（例如ARP请求）。如果网络规模很大，广播流量会导致网络带宽的浪费，并且影响整体的性能。通过将网络划分为多个小子网，可以有效减少广播域的大小，从而减轻广播流量的影响，提升网络的整体性能</li><li>简化路由表：网络被划分成多个小子网后，路由器只需要维护每个子网的路由信息，而不是整个大网络的路由信息，这不仅减小的路由表的规模，还提高了路由效率，使得数据包的转发更加快速</li></ul><ol start=4><li>提高网络的灵活性</li></ol><ul><li>简化故障排查：当网络出现问题时，通过子网划分，网络管理者可以快速定位故障，因为问题通常会局限在某个子网中。网络故障不再影响整个网络的运行，减少了排错的难度</li><li>更高效的IP地址分配：每个子网分配的IP地址数量由需求决定，这使得管理员可以根据设备数量动态调整子网大小，更加灵活。比如，在办公区域划分一个子网，而在工厂车间划分另一个子网，这样可以根据各个部门或区域的实际需求来分配IP地址，避免了大规模地址分配的浪费</li></ul><ol start=5><li>便于网络扩展</li></ol><ul><li>便于网络拓展和规划：通过子网划分，可以将整个网络分成多个相对独立的区域，使得网络 扩展和规划 更加容易。当网络规模增加时，只需要在现有的子网结构基础上增加新的子网，避免了重新规划整个网络架构。</li><li>便于未来扩展：在设计网络时，管理员可以根据需要将每个子网留出一定的扩展空间。比如，如果某个部门或区域预计会增长，可以预留一定的IP地址范围，以便未来无缝扩展，而不会影响到现有网络。</li></ul><ol start=6><li>支持VLAN和QoS（服务质量）</li></ol><ul><li>支持VLAN（虚拟局域网）：子网划分是 VLAN的基础，可以通过子网划分将不同的部门、区域、功能等设备分配到不同的虚拟局域网中。VLAN提供了逻辑上的网络隔离，进而提高了网络的安全性和管理效率。</li><li>更好的服务质量控制（QoS）：通过子网划分，可以为不同的子网配置不同的 优先级和带宽分配，更好地实现QoS。例如，办公区域的子网可以配置较高的优先级，而设备监控区域则可以配置较低的优先级，这样可以保证网络资源的合理分配。</li></ul><ol start=7><li>满足IP地址规划需求</li></ol><ul><li>跨网络的通信：子网划分后，即使某个区域的设备数量不多，管理员也可以灵活选择不同的子网大小进行规划。这样，在整个企业网络中可以实现合理的 跨网络通信，既节省了IP地址，又保证了网络内部的通信质量。</li><li>为不同区域分配不同网络号：通过子网划分，管理员可以为不同的网络区域分配不同的IP网络号。例如，分配给办公室一个子网，分配给生产设备的工厂一个子网，分配给管理层的子网，所有这些子网可以共享一个大的IP地址范围，同时又能够保持合理的分配。</li></ul><h5 id=vlsmvariable-length-subnet-mask变长子网掩码>VLSM（Variable Length Subnet Mask，变长子网掩码）</h5><p>VLSM是IP地址子网划分的一种技术，它允许根据网络的需要，灵活地使用不同长度的子网掩码。通过这种方法，可以为网络的不同部分分配适当大小的子网，从而更有效地利用IP地址空间</p><p>VLSM是基于CIDR的思想，它解决了传统类地址系统的局限性，在IP地址分配时不再使用固定的子网掩码长度，而是允许不同的子网使用不同的掩码长度</p><h6 id=vlsm的工作原理>VLSM的工作原理</h6><p>VLSM的基本思想是：</p><ol><li><p>根据需要划分子网：将一个网络划分为多个子网，并根据每个子网的实际需求（如设备数量）选择适当的子网掩码</p></li><li><p>节省IP地址：通过为不同规模的子网分配大小不同的地址块，可以更高效地利用有限的IP地址空间，避免了子网地址的浪费</p></li></ol><h6 id=vlsm的优势>VLSM的优势</h6><ul><li>更高效的IP地址利用：VLSM允许网络管理员根据每个子网的需求分配IP地址，避免了不必要的浪费。比如，一个有10台设备的小网络不需要分配<code>255.255.255.0</code>这样的较大子网掩码，而是可以使用<code>255.255.255.240</code></li><li>灵活性：与传统的固定子网掩码不同，VLSM可以为网络的不同部分使用不同长度的子网掩码，提高更灵活的子网划分方式</li><li>适应不同网络规模：VLSM可以根据不同子网的需求灵活调整网络规模，在减少浪费的同时，避免了过多的IP地址分配给较小的网络</li></ul><h6 id=vlsm的计算步骤>VLSM的计算步骤</h6><p>假设有以下需求：</p><ul><li>一个大网络<code>192.168.1.0/24</code>，我们需要将其划分为多个子网，其中每个子网的主机数分别如下：<ul><li>子网1：50个</li><li>子网2：30</li><li>子网3：10</li><li>子网4：5</li></ul></li></ul><p>则对于子网1：可分配<code>2 ^ 6 = 64</code>，即后六位是设备号，子网掩码：<code>255.255.255.192</code>，CIDR：/26</p><p>对于子网2：可分配<code>2 ^ 5 = 32</code>，即后5位是设备号，子网掩码：<code>255.255.255.224</code>，CIDR：/27</p><p>其他同理</p><h4 id=ipv6协议>IPv6协议</h4><p>IPv6是为了弥补IPv4地址耗尽问题而设计的，它使用128位地址，支持2的128次方（约340万亿个）地址，极大地扩展了可用的地址空间</p><h5 id=ipv6地址结构>IPv6地址结构</h5><p>IPv6地址由8个16位的十六进制数构成，每个数字范围为<code>0000</code>到<code>FFFF</code>。IPv6地址通常表示为8个由冒号分隔的4位16进制数字<br>例如：</p><p>2001:0db8:0000:0042:0000:8a2e:0370:7334</p><p><strong>可压缩写法规则</strong></p><ol><li>前导0可以省略：<code>0042</code>→<code>42</code></li><li>连续的0段可以用<code>::</code>表示（只能出现一次）</li></ol><p>最终简写为：</p><p>2001:db8::42:0:8a2e:370:7334</p><h5 id=地址类型>地址类型</h5><table><thead><tr><th>类型</th><th>前缀或格式</th><th>描述</th></tr></thead><tbody><tr><td>单播地址</td><td>Global Unicast</td><td>类似 IPv4 公网地址</td></tr><tr><td>链路本地地址</td><td><code>fe80::/10</code></td><td>本地网络通信，不可路由</td></tr><tr><td>多播地址</td><td><code>ff00::/8</code></td><td>一对多通信</td></tr><tr><td>任播地址</td><td>与单播类似</td><td>发给最近的接收者（路由最近）</td></tr><tr><td>回环地址</td><td><code>::1</code></td><td>相当于 IPv4 的 <code>127.0.0.1</code></td></tr></tbody></table><p>IPv6的主要特点：</p><ul><li>更大的地址空间：IPv6的地址空间大大超越了IPv4，使得每个设备都能拥有一个全球唯一的地址</li><li>简化的头部格式：IPv6的头部比IPv4更简洁，去除了许多不必要的字段，优化了路由器处理的效率</li><li>内建的安全性：IPv6通过IPsec协议提供端到端的加密和认证支持，增加了网络通信的安全性</li><li>自动配置：IPv6支持无状态地址自动配置（SLAAC），可以使用设备自动获取IP地址，而不依赖DHCP</li></ul><h5 id=ipv6包格式>IPv6包格式</h5><p>与IPv4相比，IPv6的包头更简洁</p><table><thead><tr><th>字段名</th><th>长度</th><th>说明</th></tr></thead><tbody><tr><td><strong>版本（Version）</strong></td><td>4位</td><td>表示协议版本，IPv6的值为6。</td></tr><tr><td><strong>流量类别（Traffic Class）</strong></td><td>8位</td><td>用于定义数据包的优先级。</td></tr><tr><td><strong>流标签（Flow Label）</strong></td><td>20位</td><td>用于标识属于同一流的数据包。</td></tr><tr><td><strong>有效载荷长度（Payload Length）</strong></td><td>16位</td><td>数据部分的长度。</td></tr><tr><td><strong>下一个头部（Next Header）</strong></td><td>8位</td><td>表示上层协议（如TCP、UDP等）。</td></tr><tr><td><strong>跳数限制（Hop Limit）</strong></td><td>8位</td><td>与TTL类似，限制数据包在网络中的跳数。</td></tr><tr><td><strong>源地址（Source Address）</strong></td><td>128位</td><td>发送数据包的设备的IPv6地址。</td></tr><tr><td><strong>目的地址（Destination Address）</strong></td><td>128位</td><td>目标设备的IPv6地址。</td></tr></tbody></table><h5 id=ipv4-vs-ipv6>IPv4 vs IPv6</h5><table><thead><tr><th>特性</th><th>IPv4</th><th>IPv6</th></tr></thead><tbody><tr><td>地址长度</td><td>32 位</td><td>128 位</td></tr><tr><td>地址表示</td><td>十进制（如 192.168.1.1）</td><td>十六进制，冒号分隔（如 <code>2001:0db8:85a3::8a2e:0370:7334</code>）</td></tr><tr><td>地址数量</td><td>~42 亿</td><td>2¹²⁸ ≈ 3.4×10³⁸</td></tr><tr><td>配置方式</td><td>需手动或通过 DHCP</td><td>支持自动地址配置（SLAAC）</td></tr><tr><td>广播支持</td><td>有广播</td><td>没有广播，改为<strong>多播（Multicast）</strong></td></tr><tr><td>分片与重组</td><td>源端或中间路由器都可分片</td><td>只允许<strong>发送端分片</strong></td></tr><tr><td>安全</td><td>选配 IPsec</td><td><strong>强制支持 IPsec</strong></td></tr><tr><td>NAT 支持</td><td>广泛依赖</td><td>不再需要 NAT（地址够用）</td></tr></tbody></table><h5 id=ipv6的问题>IPv6的问题</h5><ul><li>部署成本高：需要升级硬件、操作系统、网络设备</li><li>防火墙/NAT改变了策略</li><li>应用兼容性问题：有些老应用不支持IPv6</li><li>安全性问题：虽然支持IPsec，但也带来更复杂的攻击面（NDP伪造等）</li></ul><h5 id=ipv6过渡方案>IPv6过渡方案</h5><p>因为全球IPv6并未完全部署，现阶段主要使用过渡机制：</p><ol><li>双栈（Dual Stack）</li></ol><ul><li>主机和路由器同时运行IPv4和IPv6协议，谁能同就用谁</li><li>目前最常见的过渡方式</li></ul><ol start=2><li>隧道机制（Tunneling）</li></ol><ul><li>把IPv6封装在IPv4中传输，适合IPv4-only网络中传输IPv6</li></ul><ol start=3><li>NAT64/DNS64</li></ol><ul><li>让IPv6-only主机访问IPv4-only服务，靠翻译来完成通信</li></ul><h5 id=ipv6关键协议>IPv6关键协议</h5><table><thead><tr><th>协议名</th><th>功能描述</th></tr></thead><tbody><tr><td><strong>ICMPv6</strong></td><td>替代 ICMP，支持 NDP、Ping 等功能</td></tr><tr><td><strong>NDP</strong></td><td>邻居发现协议，替代 ARP、Router Discovery</td></tr><tr><td><strong>DHCPv6</strong></td><td>IPv6 的动态地址配置协议</td></tr><tr><td><strong>SLAAC</strong></td><td>无状态地址自动配置</td></tr><tr><td><strong>IPSec</strong></td><td>安全协议，强制支持，加密 IPv6 流量</td></tr></tbody></table><h4 id=分片与重组fragmentation-and-reassembly>分片与重组（Fragmentation and Reassembly）</h4><p>分片与重组是计算机网络中在数据传输过程中，尤其是在IP层，处理大数据包或网络层数据包的一个重要机制。它用于确保在不同网络技术中（例如不同的链路协议）之间传输时，数据包能够适应格子的最大传输单元（MUT, Maximum Transmission Unit）限制</p><h5 id=分片>分片</h5><p>分片是指将一个过大的数据包（通常是 IP 数据包）切割成多个更小的片段（Fragment），每个片段都符合链路层的最大传输单元（MTU）要求。分片通常发生在 发送端的 网络层，当数据包的大小超过了某个网络段的 MTU 限制时。</p><p><strong>分片原因</strong><br>不同的网络技术支持不同大小的数据包（MTU）。例如，以太网的默认 MTU 是 1500 字节，而 PPPoE（Point-to-Point Protocol over Ethernet）则可能只有 1492 字节。如果数据包的大小超过了某一网络的 MTU，则需要分片。</p><p>当一个数据包无法通过一个链路传输时，必须将其拆分成多个小片段，通过链路逐个传送。</p><p><strong>分片过程</strong><br>当IP数据包需要进行分片时，以下几个字段会被处理：</p><ul><li>ID（Identification）：分片数据包会使用相同的ID，这样接收端可以识别它们属于同一个原始数据包</li><li>Flags（标志位）：标志位中有一个<code>More Fragment(MF)</code>字段，用于指示该数据包是否为最后一个片段</li><li>Offset（片偏移量）：每个片段会记录它在原始数据包中的位置，偏移量单位为8字节（即64位），用于接收端重组时判断各片段的位置</li></ul><p><strong>分片细节</strong></p><ul><li>数据包头部：分片后，原始IP数据包的头部仍然存在，每个片段会包含其原始头部的一部分，但每个片段的负载数据会有所不同</li><li>分片大小：每个片段的大小通常是固定的，除最后一个片段外，都会是MTU-20字节（IP头部大小）。最后一个片段可能会小于这个大小</li></ul><h5 id=重组>重组</h5><p>重组是指接收端根据收到的分片数据包，按照一定的顺序将它们拼接成原始的完整数据包。重组的过程发生在 接收端的网络层，它会将所有的数据片段重新组合成完整的 IP 数据包，然后将其传递给上层协议（如 TCP 或 UDP）</p><p><strong>重组的条件</strong></p><ul><li>ID（Identification）：所有分片都包含相同的 ID，因此接收端可以通过这个 ID 来识别哪些片段属于同一个数据包。</li><li>Flags（标志位）：接收端通过标志位中的 <code>More Fragment (MF)</code> 字段来判断数据包是否完整。如果接收到的片段中 <code>MF</code> 标志为 0，则说明这是最后一个片段。</li><li>Offset（片偏移量）：每个片段包含一个偏移量，用于指示该片段在原始数据包中的位置。接收端通过这个偏移量重新组合数据包。</li></ul><p><strong>重组的步骤</strong></p><ol><li>接收分片：接收端接收来自不同路径的数据片段，它们可能到达的顺序不一致</li><li>检查ID和Flags:接收端通过分片的 ID 和标志位判断这些分片是否属于同一个数据包。如果 ID 不同，说明它们不是同一个数据包，不能进行重组</li><li>排序片段：接收端根据每个片段的偏移量来排序所有片段，确保它们按正确顺序进行组合</li><li>重组数据包：接收端将所有片段的数据按照顺序拼接起来，形成原始的数据包</li><li>传递给上层：数据包重组完成后，接收端将完整的数据包传递给上层协议（如 TCP 或 UDP）</li></ol><p><strong>重组的局限性</strong></p><ul><li>分片丢失：如果在传输过程中有某个片段丢失，接收端无法完成重组，整个数据包的接收将失败，直到丢失的片段被重传</li><li>分片顺序问题：分片到达的顺序可能不一致，接收端需要根据偏移量重排片段，确保数据包的完整性</li><li>重组延迟：大量分片的重组需要时间，尤其是当片段较多时，重组的过程可能会增加延迟</li></ul><h5 id=ip分片的例子>IP分片的例子</h5><p>假设有一个原始的IP数据包大小为3000字节，而网络的MTU为1500字节，分片过程如下：</p><ol><li>第一个片段：</li></ol><ul><li>包含IP头部和前1480字节的数据</li><li>偏移量为0，MF标志位为1（表示后面还有分片）</li><li>该片段的大小为1500字节（包含头部）</li></ul><ol start=2><li>第二个片段：</li></ol><ul><li>包含IP头部和接下来的1480字节数据</li><li>偏移量为1480 / 8 = 185（单位为8字节）</li><li>MF标志位为1</li><li>片段大小1500字节</li></ul><ol start=3><li>第三个片段：</li></ol><ul><li>包含IP头部和剩余的数据部分，最后的40字节数据</li><li>偏移量为2960 / 8 = 370（单位为8字节）</li><li>MF标志位为0（表示这是最后一个片段）</li><li>该片段大小为520字节</li></ul><h5 id=分片与重组的优缺点>分片与重组的优缺点</h5><p>优点</p><ul><li>适应不同的MTU：分片允许大数据包在不同MTU的网络上进行传输，避免了因MTU限制导致的数据丢失或传输失败</li><li>灵活性：分片和重组使得网络通信在不同类型的物理介质（如以太网、无限网络）之间变得更加灵活</li></ul><p>缺点</p><ul><li>效率低下：分片和重组需要额外的处理和带宽开销，尤其是在需要频繁分片和重组的情况下，可能会影响网络的效率</li><li>丢包问题：如果一个片段丢失，整个数据包就无法成功重组，导致整个数据包丢失，需要重传</li><li>复杂性：分片和重组增加了协议栈的复杂性，并且在高负载或复杂网络环境下，可能会引发更多的问题</li></ul><h5 id=分片重组的应用>分片重组的应用</h5><ul><li>IP网络中：分片和重组是IPv4协议的核心功能之一。在现代网络中，虽然IPv6通过路径MTU发现（PMTUD）避免了分片，但IPv4网络依然依赖于分片来适应不同的链路层MTU</li><li>VPN和隧道协议：在一些VPN或隧道协议中，分片和重组机制用来确保数据在不同的网络中安全、有效地传输</li></ul><h3 id=icmp协议>ICMP协议</h3><p>ICMP(Internet Control Message Protocol)是互联网协议族中的一个核心协议，主要用于设备网络（如路由器、主机）之间交换控制消息和错误报告。IC辑以其简洁高效的设计，成为IP协议族的重要补充，它帮助网络设备进行故障诊断、路径控制、报告错误等</p><p>ICMP协议与IP协议紧密关联，通常作为IP协议的一部分来工作，提供了网络通信中的必要支持。常见的工具如ping和traceroute就是利用ICMP协议来诊断网络连接问题的</p><h4 id=icmp的基本特点>ICMP的基本特点</h4><ol><li>控制消息和错误报告：</li></ol><ul><li>ICMP被设计用来报告网络中发生的错误和异常情况。它通过回馈ICMP消息来告知发起主机或路由器网络通信中的问题</li></ul><ol start=2><li>无连接协议：</li></ol><ul><li>ICMP不提供端到端的连接，它只是发送简单的控制消息，完成基本的网络诊断和错误报告</li></ul><ol start=3><li>与IP协议共同工作：</li></ol><ul><li>ICMP通过IP协议承载，且与IP协议紧密相关，它的消息通常嵌入在IP数据包中传输</li></ul><ol start=4><li>用于网络诊断和管理：</li></ol><ul><li>ICMP常用于检查主机和路由器之间的连通性，诊断网络问题，分析延迟和丢包率</li></ul><ol start=5><li>简单性和高效性：</li></ol><ul><li>ICMP消息通常很简短，不包含复杂的字段，因此其处理效率较高</li></ul><h4 id=icmp的工作原理>ICMP的工作原理</h4><ol><li>ICMP消息类型：</li></ol><ul><li>ICMP消息有多种类型，最常见的类型包括回显请求/回显应答（ping）和目标不可达（Destination Unreachable）等</li></ul><ol start=2><li>ICMP封包格式：</li></ol><ul><li>ICMP报文通常是嵌入在IP数据包中传输的，其结构较为简单。ICMP数据包的基本格式如下：</li></ul><table><thead><tr><th>字段名</th><th>长度</th><th>说明</th></tr></thead><tbody><tr><td><strong>类型</strong></td><td>1字节</td><td>消息类型标识，决定消息的种类</td></tr><tr><td><strong>代码</strong></td><td>1字节</td><td>与类型一起决定错误的具体类型</td></tr><tr><td><strong>校验和</strong></td><td>2字节</td><td>用于验证ICMP数据包的完整性</td></tr><tr><td><strong>附加数据</strong></td><td>可变</td><td>根据ICMP类型，附加相关信息</td></tr></tbody></table><ol start=3><li>常见的ICMP消息类型：</li></ol><ul><li><p>回显请求和回显应答（Echo Request and Echo Reply）：</p><ul><li>这类ICMP消息用于测试网络的连通性。ping工具就是通过发送ICMP回显请求消息，接收回显应答消息来验证目标主机的可达性</li><li>回显请求：发起方向目标主机发送的请求消息</li><li>回显应答：目标主机收到回显请求后，向发起方返回的响应消息</li><li>格式：<ul><li>类型（8）表示回显请求，类型（0）表示回显应答</li><li>代码字段通常为0</li><li>数据部分通常会包含一些时间戳、标识符等信息</li></ul></li></ul></li><li><p>目标不可达（Destination Unreachable）：</p><ul><li>该消息用于通知源主机数据包无法到达目标地址的情况。根据具体的错误原因，目标不可达消息有多个子类型，例如：<ul><li>网络不可达：数据包无法找到目标网络</li><li>主机不可达：目标主机无法访问</li><li>端口不可达：目标主机的特定端口无法访问</li></ul></li><li>格式：<ul><li>类型（3）表示目标不可达</li><li>代码字段表示具体的错误类型，如网络不可达、主机不可达等</li><li>其附加数据部分通常会携带触发该错误的数据包头部，以便接收方能够定位问题</li></ul></li></ul></li></ul><ol start=3><li><p>时间超过（Time Exceeded）：
- 用于通知源主机其数据包在传输过程中超出了TTL。TTL字段用于限制数据包在网络中的生命周期，防止数据包在网络中无限循环
- 格式：</p><ul><li>类型（11）表示时间超过</li><li>代码字段通常为0</li><li>数据部分携带导致超时的原始IP数据包信息</li></ul></li><li><p>参数问题（Parameter Problem）：
- 当IP包头中的某些字段出现错误或缺失时，目标路由器会发送这种ICMP消息来报告问题
- 格式：</p><ul><li>类型（12）表示参数问题</li><li>代码字段为0</li><li>数据部分通常会包含出现问题的IP数据包的相关信息</li></ul></li><li><p>重定向（Redirect）：
- 当路由器发现某个数据包的转发路径不合适时，会发送这种消息要求发送方更新路由
- 格式：</p><ul><li>类型（5）表示重定向</li><li>代码字段指定重定向的原因</li><li>数据部分包含用于改进路由选择的信息</li></ul></li></ol><h4 id=icmp协议的作用>ICMP协议的作用</h4><ol><li>网络诊断：</li></ol><ul><li>ping工具使用ICMP回显请求和回显应答消息，来检测目标主机是否可达</li><li>traceroute 使用ICMP的“时间超过”消息来确定数据包从源主机到目标主机经过的路由路径</li></ul><ol start=2><li>错误报告：</li></ol><ul><li>ICMP通过目标不可达、时间超过、参数问题等消息向源主机报告网络中的各种错误信息，帮助定位问题所在</li></ul><ol start=3><li>网络管理：</li></ol><ul><li>ICMP通过向路由器发送重定向消息，帮助源主机改进路由选择。网络管理员也可以使用ICMP来分析网络拓扑、性能等</li></ul><h4 id=icmp的局限性和安全问题>ICMP的局限性和安全问题</h4><ol><li>ICMP被用于DDos攻击：</li></ol><ul><li>Ping of Death：攻击者发送恶意的ICMP回显请求包，导致目标主机的系统崩溃</li><li>Smurf Attack：攻击者利用ICMP广播请求和伪造的源地址，通过网络广播请求发送给大量设备，造成目标服务器的DDos攻击</li></ul><ol start=2><li>ICMP不可用于复杂通信：</li></ol><ul><li>ICMP协议是无连接的，适用于简单的网络控制消息和诊断，无法提供可靠的通信服务，且不支持数据的传输</li></ul><ol start=3><li>ICMP封包可能被防火墙阻止：</li></ol><ul><li>由于ICMP容易被用于攻击，很多防火墙和路由器会限制或过滤ICMP消息，尤其是在公共网络和企业网络中。防火墙可能会屏蔽ICMP回显请求，防止Ping扫描</li></ul><h4 id=icmp的安全性增强>ICMP的安全性增强</h4><ol><li>ICMP的认证：</li></ol><ul><li>一些网络设备和系统支持对ICMP报文进行认证，以防止伪造的ICMP报文攻击。通常，ICMP报文的认证机制基于共享密钥或公钥加密技术</li></ul><ol start=2><li>ICMP限制：</li></ol><ul><li>为防止ICMP被滥用，管理员通常会在路由器或防火墙上限制ICMP的传输，尤其是公共区域和公网IP的ICMP消息</li></ul><h4 id=ping>ping</h4><p><code>ping</code>是一种非常常见的网络工具，主要用于检测网络连接的可达性，并通过发送ICMP回显请求来检查另一台计算机或网络设备是否在线。它广泛用于故障排查和网络调试</p><h5 id=工作原理>工作原理</h5><p>当你在中断输入<code>ping&lt;destination address></code>时，系统会执行一下步骤：</p><ol><li><p>发送Echo Request：你的计算机向目标地址发送一个ICMP Echo Request包。通常，这个包会包含一些信息，如发包时间、包的大小、序列号等</p></li><li><p>目标主机响应Echo Reply：目标地址收到请求后，会回复一个ICMP Echo Reply包，内容通常与请求的包一样</p></li><li><p>计算时延：<code>ping</code>计算从发送请求到收到回复所花费的时间，这个时间通常以毫秒为单位。这个过程会进行多次，以便获得更精确的延迟信息</p></li><li><p>返回统计信息：通常，<code>ping</code>会返回：</p></li></ol><ul><li>发送的包数</li><li>成功接收到的包数</li><li>丢包率</li><li>平均往返时延</li></ul><h5 id=ping输出的内容>ping输出的内容</h5><p>在Linux或Windows上执行<code>ping</code>命令时，常见的输出信息通常如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>Pinging google<span style=color:#f92672>.</span>com [<span style=color:#ae81ff>8.8.8.8</span>] <span style=color:#66d9ef>with</span> <span style=color:#ae81ff>32</span> bytes of data:
</span></span><span style=display:flex><span>Reply <span style=color:#f92672>from</span> <span style=color:#ae81ff>8.8.8.8</span>: bytes<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span> time<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>ms TTL<span style=color:#f92672>=</span><span style=color:#ae81ff>56</span>
</span></span><span style=display:flex><span>Reply <span style=color:#f92672>from</span> <span style=color:#ae81ff>8.8.8.8</span>: bytes<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span> time<span style=color:#f92672>=</span><span style=color:#ae81ff>9</span>ms TTL<span style=color:#f92672>=</span><span style=color:#ae81ff>56</span>
</span></span><span style=display:flex><span>Reply <span style=color:#f92672>from</span> <span style=color:#ae81ff>8.8.8.8</span>: bytes<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span> time<span style=color:#f92672>=</span><span style=color:#ae81ff>11</span>ms TTL<span style=color:#f92672>=</span><span style=color:#ae81ff>56</span>
</span></span><span style=display:flex><span>Reply <span style=color:#f92672>from</span> <span style=color:#ae81ff>8.8.8.8</span>: bytes<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span> time<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>ms TTL<span style=color:#f92672>=</span><span style=color:#ae81ff>56</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Ping statistics <span style=color:#66d9ef>for</span> <span style=color:#ae81ff>8.8.8.8</span>:
</span></span><span style=display:flex><span>    Packets: Sent <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>, Received <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>, Lost <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>%</span> loss),
</span></span><span style=display:flex><span>Approximate round trip times <span style=color:#f92672>in</span> milli<span style=color:#f92672>-</span>seconds:
</span></span><span style=display:flex><span>    Minimum <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>ms, Maximum <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>ms, Average <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>ms
</span></span></code></pre></div><p>解释：</p><ul><li>Reply from：显示返回响应的IP地址</li><li>bytes：数据包的大小（通常为32字节）</li><li>time：往返时间（RTT，Round Trip Time），即从发送请求到收到响应所需的时间</li><li>TTL：Time To Live，指示数据包在网络中存活的最大跃点数，防止数据包在网络中永远循环</li></ul><h5 id=ping的用途>ping的用途</h5><ul><li>网络连通性检查：最常见的用途之一：确保目标主机或设备在网络中是可达的</li><li>延迟检查：可以检测目标主机的网络延迟，通常用于诊断性能问题</li><li>丢包检测：如果在多次请求中有部分丢包，这就意味着存在网络问题，可能是路由器或交换机出现了故障，或者网络带宽不足</li><li>防火墙设置检查：如果目标主机不响应ping请求，可能是目标主机的防火墙设置了阻止ICMP请求的规则</li></ul><h5 id=ping的常用参数>ping的常用参数</h5><p>在执行<code>ping</code>时，除了基本的目标地址参数外，还可以使用一些常见的选项来控制ping的行为：</p><ul><li><code>-t</code>(Windows)：持续ping目标，直到手动停止</li><li><code>-c &lt;count></code>(Linux)：指定ping的次数</li><li><code>-l &lt;size></code>（Windows）：指定发送的包的大小</li><li><code>-i &lt;TTL></code>(Linux)：指定数据包的TTL</li></ul><h5 id=ping的常见问题>ping的常见问题</h5><ul><li>丢包：丢包可能由网络拥塞、设备故障或错误的路由配置引起。丢包导致应用程序或服务的性能下降</li><li>延迟过高：高延迟通常指示网络中存在瓶颈。可能是由于网络路径长、路由不优化、或中间网络设备的性能问题</li><li>防火墙问题：某些网络设备或防火墙可能会阻止ICMP流量，因此无法响应ping请求。很多服务器会出于安全考虑关闭ICMP响应</li></ul><h5 id=ping的局限性>ping的局限性</h5><ul><li>不能证明服务可用：虽然ping可以验证设备是否在线，但它不能证明目标服务正常允许。例如，ping通过的服务器可能没有启动Web服务</li><li>防火墙与过滤器：一些防火墙或安全设备专门过滤ICMP流量，从而导致ping请求失败，但这不一定意味着目标主机不可达</li></ul><h4 id=traceroute>traceroute</h4><p><code>traceroute</code>是另一个非常有用的网络工具，它和<code>ping</code>类似，但它提供了更详细的信息，主要用于追踪数据包从源主机到目标主机的路径，并显示沿途经过的每个路由器（或称为“跃点”）</p><h5 id=traceroute的工作原理>traceroute的工作原理</h5><p><code>traceroute</code>的核心工作原理基于TTL值得逐跳递增机制。TTL是一个限制数据包在网络中传输得最大跳数，防止数据包在环路中无限循环。<code>traceroute</code>通过发送多个带有不同TTL的数据包，逐步增加TTL的值，并在每个跃点上请求ICMP超时消息来获得路径信息</p><p>步骤：</p><ol><li><p>初始TTL = 1：<code>traceroute</code>发送第一个数据包，TTL设置为1.当数据包到达第一个路由器时，TTL被减1，变成0，路由器无法转发该数据包，于是返回一个ICMP Time Exceeded消息，告知源主机数据包超时</p></li><li><p>TTL递增：<code>traceroute</code>会发送第二个数据包，将TTL设置为2，这时数据包会经过第一个路由器并到达第二个路由器。在第二个路由器，TTL再次减1，变成0，导致第二个路由器返回一个ICMP Time Exceeded消息</p></li><li><p>重复过程：这个过程不断进行，TTL从1递增到最大值，直到目标主机收到数据包并返回一个ICMP Echo Reply消息，表示目标主机可达</p></li></ol><h5 id=traceroute命令的输出>traceroute命令的输出</h5><p>在Linux上使用<code>traceroute</code>命令时，Windows上是<code>tracert</code>，输出的第一行代表一个跃点（路由器），通常看起来像这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>traceroute</span> <span style=color:#e6db74>to</span> <span style=color:#e6db74>google.com</span> <span style=color:#e6db74>(8.8.8.8),</span> <span style=color:#ae81ff>30</span> <span style=color:#e6db74>hops</span> <span style=color:#e6db74>max,</span> <span style=color:#ae81ff>60</span> <span style=color:#e6db74>byte</span> <span style=color:#e6db74>packets</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span>  192.168.1.1 <span style=color:#e6db74>(192.168.1.1)</span>  <span style=color:#ae81ff>1</span><span style=color:#e6db74>.098</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>0</span><span style=color:#e6db74>.967</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>0</span><span style=color:#e6db74>.872</span> <span style=color:#e6db74>ms</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span>  10.0.0.1 <span style=color:#e6db74>(10.0.0.1)</span>  <span style=color:#ae81ff>3</span><span style=color:#e6db74>.145</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>2</span><span style=color:#e6db74>.976</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>3</span><span style=color:#e6db74>.321</span> <span style=color:#e6db74>ms</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>3</span>  72.14.235.45 <span style=color:#e6db74>(72.14.235.45)</span>  <span style=color:#ae81ff>9</span><span style=color:#e6db74>.710</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>9</span><span style=color:#e6db74>.587</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>9</span><span style=color:#e6db74>.470</span> <span style=color:#e6db74>ms</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>4</span>  108.170.242.129 <span style=color:#e6db74>(108.170.242.129)</span>  <span style=color:#ae81ff>13</span><span style=color:#e6db74>.128</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>13</span><span style=color:#e6db74>.010</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>13</span><span style=color:#e6db74>.091</span> <span style=color:#e6db74>ms</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>5</span>  72.14.233.34 <span style=color:#e6db74>(72.14.233.34)</span>  <span style=color:#ae81ff>15</span><span style=color:#e6db74>.998</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>15</span><span style=color:#e6db74>.823</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>15</span><span style=color:#e6db74>.931</span> <span style=color:#e6db74>ms</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>6</span>  8.8.8.8 <span style=color:#e6db74>(8.8.8.8)</span>  <span style=color:#ae81ff>17</span><span style=color:#e6db74>.912</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>17</span><span style=color:#e6db74>.852</span> <span style=color:#e6db74>ms</span>  <span style=color:#ae81ff>17</span><span style=color:#e6db74>.980</span> <span style=color:#e6db74>ms</span>
</span></span></code></pre></div><p>解释输出：</p><ul><li>跳数：每一行的开头是跃点的编号</li><li>IP地址：跃点的IP地址</li><li>延迟：每个跃点的延迟时间，通常以毫秒为单位。在输出中，会显示三个延迟值，代表三次发送数据包的时间。这个数字有助于检测网络拥堵或路由问题</li></ul><h5 id=traceroute的常用选项>traceroute的常用选项</h5><p><code>traceroute</code>命令也提供了很多选项，帮助我们定制追踪过程</p><ul><li><code>-m &lt;max_hops></code>：设置最大跳数。默认情况下，<code>traceroute</code>会设置为30跳</li><li><code>-w &lt;wait_time></code>：设置等待每个响应的超时时间（默认1秒）</li><li><code>-q &lt;num_queries></code>：设置每个跳点发送的数据包数量。默认是三个数据包</li><li><code>-p &lt;port></code>：指定发送的端口（默认为33434），通常用于防火墙绕过</li><li><code>-I</code>：使用ICMP数据包而不是默认的UDP数据包，适用于防火墙配置限制UDP的场景</li></ul><h5 id=traceroute的用途>traceroute的用途</h5><ul><li>网络路径诊断：<code>traceroute</code>可以帮助我们查看从源主机到目标主机的具体路径，特别是在网络出现问题时，能够帮助定位故障发生的路由器或设备网络</li><li>分析延迟：通过查看每个跃点的延迟，我们可以分析网络的瓶颈位置。如果某个跃点的延迟突然增高，可能表明该设备出现了性能问题或网络拥堵</li><li>检测丢包和路由环路：如果在某些跃点上丢包，或某个跃点的延迟异常高，可能说明网络中某个设备由问题。如果路径出现环路，<code>traceroute</code>会表现为某个跃点IP地址不断重复</li></ul><h5 id=traceroute的局限性>traceroute的局限性</h5><ul><li>防火墙拦截：许多防火墙或路由器会拦截<code>traceroute</code>的探测包，导致其无法获取精确的路径信息。这是因为<code>traceroute</code>默认发送的时UDP数据包（或者ICMP），很多设备会限制这些包</li><li>跨越多个路由器：<code>traceroute</code>显示的路径信息是从源主机到目标主机的路径中所有跃点的信息，但这些跃点并不一定反映真实的网络拓扑，尤其是在使用多个路由器的复杂网络中</li></ul><h3 id=arp协议>ARP协议</h3><p>ARP协议（Address Resolution Protocol）用于将IP地址映射到MAC地址，这是一个桥接网络层和链路层的协议。在局域网中，数据链路层使用MAC地址进行通信，而网络层则使用IP地址。ARP协议通过广播请求来查询某个IP地址对应的MAC地址，设备响应并进行地址解析</p><p>简单来说，ARP允许设备在本地网络中通过IP地址找到目标设备的MAC地址，进而进行数据帧的发送</p><p>ARP主要应用于局域网（LAN），在IPv4网络中尤其重要。在现代网络中，几乎所有设备都会以来ARP来通信</p><h4 id=arp基本原理>ARP基本原理</h4><p>当一个设备需要向另一个设备发送数据时，它会使用目标设备的 IP 地址，但是数据链路层（例如以太网）需要的是 MAC 地址。因此，如果源设备不知道目标设备的 MAC 地址，它就会使用 ARP 协议来查询目标设备的 MAC 地址。</p><p>具体流程如下：</p><ol><li>发送 ARP 请求：当设备 A（源设备）需要与设备 B（目标设备）通信时，它会查看 ARP 缓存，看看是否已经存在目标设备的 IP 地址与 MAC 地址的映射。如果没有，它就会发送一个广播 ARP 请求包：</li></ol><ul><li>请求包内容：询问“谁拥有 IP 地址 x.x.x.x？请告诉我你的 MAC 地址”。</li></ul><ol start=2><li>ARP 响应：目标设备 B 收到请求后，会检查自己是否对应请求中的 IP 地址。如果是，它会发送一个 ARP 响应包，告诉设备 A 它的 MAC 地址。</li></ol><ul><li>响应包内容：发送者设备的 IP 地址和对应的 MAC 地址。</li></ul><ol start=3><li>更新 ARP 缓存：设备 A 收到响应后，会将目标设备的 IP 地址和 MAC 地址的映射信息保存在自己的 ARP 缓存中。这样，以后设备 A 就可以直接使用这个 MAC 地址与设备 B 通信。</li></ol><h4 id=arp数据包结构>ARP数据包结构</h4><p>ARP请求和响应都是以特定格式的ARP数据包进行交换的。每个ARP数据包包含以下字段：</p><table><thead><tr><th>字段名称</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td><strong>硬件类型 (HTYPE)</strong></td><td>2 字节</td><td>表示硬件类型，Ethernet 的硬件类型为 1。</td></tr><tr><td><strong>协议类型 (PTYPE)</strong></td><td>2 字节</td><td>表示协议类型，IPv4 的协议类型为 0x0800。</td></tr><tr><td><strong>硬件地址长度 (HLEN)</strong></td><td>1 字节</td><td>硬件地址（即 MAC 地址）的长度，Ethernet 为 6 字节。</td></tr><tr><td><strong>协议地址长度 (PLEN)</strong></td><td>1 字节</td><td>协议地址（即 IP 地址）的长度，IPv4 为 4 字节。</td></tr><tr><td><strong>操作 (OP)</strong></td><td>2 字节</td><td>请求或响应类型，1 表示请求，2 表示响应。</td></tr><tr><td><strong>发送方硬件地址 (SHA)</strong></td><td>6 字节</td><td>发送方的 MAC 地址。</td></tr><tr><td><strong>发送方协议地址 (SPA)</strong></td><td>4 字节</td><td>发送方的 IP 地址。</td></tr><tr><td><strong>目标硬件地址 (THA)</strong></td><td>6 字节</td><td>目标方的 MAC 地址（在请求中为空，响应中为目标设备的 MAC 地址）。</td></tr><tr><td><strong>目标协议地址 (TPA)</strong></td><td>4 字节</td><td>目标方的 IP 地址。</td></tr></tbody></table><h4 id=arp请求与响应>ARP请求与响应</h4><ul><li><p>ARP请求示例：
假设设备A需要查询设备B的MAC地址，A的IP地址为<code>192.168.1.1</code>, B的IP地址为<code>192.168.1.2</code>，则A会向网络中广播一个ARP请求：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>请求：
</span></span><span style=display:flex><span>设拥有IP地址192.168.1.2？请告诉我你的MAC地址
</span></span></code></pre></div></li><li><p>ARP响应示例：
设备B收到请求后，如果它的IP地址为<code>192.168.1.2</code>，则会返回：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>响应：
</span></span><span style=display:flex><span>192.168.1.2的MAC地址是00:1A:2B:3C:4D:5E
</span></span></code></pre></div></li></ul><h4 id=arp缓存>ARP缓存</h4><p>ARP 请求和响应会被存储在设备的 ARP 缓存中。ARP 缓存是一个映射表，用来缓存 IP 地址和 MAC 地址的对应关系，以便设备不需要每次都广播 ARP 请求。</p><p>Linux和Windows中通过<code>arp -a</code>查看ARP缓存</p><h4 id=arp协议的工作场景>ARP协议的工作场景</h4><ul><li><p>局域网内的通信：例如，当你向局域网内的某个设备发送数据时，设备必须知道目标设备的 MAC 地址。此时，ARP 负责解析 IP 地址和 MAC 地址的映射关系。</p></li><li><p>网关通信：如果设备需要与不同子网的设备通信，它会将数据发送到网关（路由器），网关的 IP 地址与 MAC 地址也需要通过 ARP 解析。</p></li></ul><h4 id=arp欺骗arp-spoofing>ARP欺骗（ARP Spoofing）</h4><p>ARP 协议没有验证数据的机制，这就给了攻击者可乘之机，ARP 欺骗 是一种常见的攻击方式。在 ARP 欺骗中，攻击者伪造 ARP 响应，欺骗网络中的设备，使其认为攻击者的 MAC 地址是目标设备的 MAC 地址。</p><p>这种攻击的后果可能包括：</p><ul><li><p>中间人攻击（MITM）：攻击者可以拦截并修改通信内容。</p></li><li><p>网络嗅探：攻击者获取敏感信息（如密码、账号等）。</p></li></ul><p>为了防止 ARP 欺骗，一些网络安全技术可以使用静态 ARP 表或基于协议的认证机制。</p><h4 id=arp与ipv6>ARP与IPv6</h4><p>在IPv6中，ARP被邻居发现协议（Neighbor Discovery Protocol， NDP）取代。NDP使用ICMPv6消息来哦代替ARP请求和响应。NDP与ARP有相似的功能，但它更加安全且功能强大</p><h4 id=arp与路由器>ARP与路由器</h4><p>路由器也会使用 ARP 来确定其网关设备的 MAC 地址。例如，路由器通常有多个网络接口，每个接口都有一个 IP 地址。当它需要通过某个接口发送数据时，必须先通过 ARP 确定目标接口的 MAC 地址。</p><h3 id=rarp协议>RARP协议</h3><p>RARP（Reverse Address Resolution Protocol，反向地址解析协议）是一个用于将MAC地址映射到IP地址的协议。它是ARP协议的反向操作，主要用于通过已知的物理地址查找IP地址</p><h4 id=工作原理-1>工作原理</h4><p>RARP的工作原理和ARP类似，但是它们的目标相反</p><p>通常，RARP协议用于那些没有硬盘或其他存储设备的计算机或设备，尤其是在启动时（如网络启动的情况）。这些设备只知道自己的MAC地址，不能直接获取IP地址，RARP就是解决这一问题的协议</p><ol><li><p>RARP请求
当一台设备（比如一台无硬盘的工作站）启动时，它通过广播 RARP 请求，请求网络中某台服务器为它提供对应的 IP 地址。RARP 请求包包含了设备的 MAC 地址，这个地址是设备的物理硬件地址。</p></li><li><p>RARP响应
在接收到 RARP 请求后，网络中的 RARP 服务器（通常是一个专门的服务器或路由器）会查询其映射表，查找该 MAC 地址对应的 IP 地址。如果找到对应的 IP 地址，RARP 服务器会通过 RARP 响应 将该 IP 地址返回给请求的设备。</p></li><li><p>网络启动
一旦设备收到 RARP 响应，它就可以使用这个 IP 地址继续进行网络上的通信，完成启动过程。这对于那些没有存储设备，无法预先设置 IP 地址的设备（例如一些嵌入式系统、旧式的终端设备）尤为重要。</p></li></ol><h4 id=rarp消息格式>RARP消息格式</h4><table><thead><tr><th>字段</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td><strong>硬件类型（HTYPE）</strong></td><td>2 字节</td><td>描述网络设备的硬件类型，通常为 1（Ethernet）。</td></tr><tr><td><strong>协议类型（PTYPE）</strong></td><td>2 字节</td><td>描述协议类型，通常为 0x0800（IPv4）。</td></tr><tr><td><strong>硬件地址长度（HLEN）</strong></td><td>1 字节</td><td>硬件地址长度，Ethernet 为 6 字节。</td></tr><tr><td><strong>协议地址长度（PLEN）</strong></td><td>1 字节</td><td>协议地址长度，IPv4 为 4 字节。</td></tr><tr><td><strong>操作（OPER）</strong></td><td>2 字节</td><td>请求类型（1 表示请求，2 表示响应）。</td></tr><tr><td><strong>发送者硬件地址</strong></td><td>6 字节</td><td>发送者的 MAC 地址（设备的物理地址）。</td></tr><tr><td><strong>发送者协议地址</strong></td><td>4 字节</td><td>发送者的 IP 地址（在 RARP 响应中为空）。</td></tr><tr><td><strong>目标硬件地址</strong></td><td>6 字节</td><td>目标设备的 MAC 地址。</td></tr><tr><td><strong>目标协议地址</strong></td><td>4 字节</td><td>目标设备的 IP 地址（在 RARP 请求中为空）。</td></tr></tbody></table><h4 id=rarp应用场景>RARP应用场景</h4><ul><li>无硬盘设备：某些设备（如工作站、网络打印机等）没有硬盘或其他持久存储，无法预存 IP 地址。它们只能在网络启动时通过 RARP 获取自己的 IP 地址。</li><li>嵌入式设备：一些嵌入式设备（如路由器、传感器等）可能会在启动时使用 RARP 协议获取 IP 地址。</li><li>网络启动（PXE Boot）：在没有本地存储的计算机上，使用 RARP 获取 IP 地址后，可以通过网络启动操作系统（例如 PXE 启动）。</li></ul><h4 id=rarp的局限性>RARP的局限性</h4><ol><li><p>只有一个 RARP 服务器
RARP 协议依赖于专门的 RARP 服务器，这个服务器需要为每台设备维护一个 MAC 地址与 IP 地址的映射表。RARP 的使用要求网络中有专门的服务器来管理这些映射，限制了它的扩展性和灵活性。</p></li><li><p>无法跨子网
RARP 协议只适用于同一子网内的设备。由于 RARP 是基于 MAC 地址进行请求和响应的，而 MAC 地址是局域网内的唯一标识，因此，RARP 无法在不同子网之间工作。</p></li><li><p>没有 IP 地址的动态分配机制
RARP 协议要求在网络中为每个设备预配置 MAC 地址与 IP 地址的映射表。这使得 RARP 不如现代的 DHCP（动态主机配置协议）灵活。DHCP 可以动态地为设备分配 IP 地址，而不需要预先配置映射表。</p></li></ol><h4 id=rarp的替代协议dhcp>RARP的替代协议：DHCP</h4><p>由于 RARP 的局限性，DHCP（动态主机配置协议） 成为了更为广泛和高效的替代协议。DHCP 不仅可以提供 IP 地址，还可以动态地分配子网掩码、网关地址、DNS 服务器等信息。</p><p>与 RARP 不同，DHCP 允许设备从网络中的 DHCP 服务器获取配置，而无需依赖单个专门的服务器来维护 MAC 地址和 IP 地址的静态映射表。DHCP 还可以跨子网工作，提供更多的配置选项，极大提高了灵活性和管理效率。</p><h3 id=dhcp协议>DHCP协议</h3><p>DHCP(Dynamic Host COnfiguration Protocol), 动态主机配置协议，它的核心职责是：自动给网络中的设备分配IP地址、子网掩码、默认网关以及DNS服务器等配置信息</p><h4 id=工作流程>工作流程</h4><ol><li>DHCP Discover：客户端广播寻找DHCP服务器</li><li>DHCP Offer：服务器回应一个可用的IP地址和配置信息</li><li>DHCP Request：客户端请求使用服务器提供的IP地址</li><li>DHCP ACK：服务器确认客户端可以使用该地址</li></ol><h4 id=协议细节>协议细节</h4><ul><li>使用UDP协议：客户端发Discover消息使用UDP 68端口，服务器响应用UDP 67端口</li><li>租约机制：IP地址不是永久分配的，而是“租用”，过期了要续约或释放，避免地址浪费</li><li>支持自动/手动/静态分配：<ul><li>自动分配：随机给空闲地址</li><li>手动分配：管理员预设映射，特定设备固定IP</li><li>静态分配：绑定MAC地址，保证设备永远用同一个IP</li></ul></li></ul><h4 id=dhcp提供的其他信息>DHCP提供的其他信息</h4><p>除了IP地址，DHCP还能下发：子网掩码、默认网关、DNS服务器地址、域名、NTP服务器、代理服务器等</p><p>这让设备连上网络后立即能正常工作，零配置上线</p><h4 id=dhcp的意义>DHCP的意义</h4><ul><li>简化管理：设备上网自动拿地址，减少人工配置错误</li><li>灵活分配：适应设备频繁上线下线、移动办公等环境</li><li>节约资源：地址复用防止地址浪费和冲突</li><li>支持大规模网络：校园网、企业网、ISP都靠它运转</li></ul><h3 id=ipsec协议>IPSec协议</h3><p>IPSec协议提供了对IP数据包的加密、认证和完整性保护，是网络层的安全协议。IPSec能够保护IP层的数据流，常用于虚拟专用网络（VPN）中，保障数据的隐私和安全</p><h4 id=概述>概述</h4><p>IPSec对IP数据包提供加密和认证服务，确保数据在传输过程中不被篡改、窃取或伪造</p><p>它是基于IP协议之上工作的，能够与国中应用协议兼容，无论是HTTP、FTP还是其他应用</p><p>IPSec是一个非常灵活的协议，它支持多种加密和认证算法，可以根据实际需求进行配置</p><h4 id=ipsec的基本目标>IPSec的基本目标</h4><p>IPSec的主要目标是提供以下几种功能：</p><ul><li>数据保密性（Confidentiality）：确保数据内容在传输过程中不被未经授权的第三方查看。</li><li>数据完整性（Integrity）：确保数据在传输过程中没有被篡改。</li><li>身份验证（Authentication）：确保通信双方的身份是可信的。</li><li>重放攻击防护（Anti-Replay Protection）：防止攻击者通过重发已捕获的数据包来干扰通信。</li></ul><h4 id=ipsec的工作原理>IPSec的工作原理</h4><p>IPSec 通过两种模式工作：传输模式（Transport Mode） 和 隧道模式（Tunnel Mode）</p><h5 id=传输模式transport-mode>传输模式（Transport Mode）</h5><p>在传输模式下，IPSec 仅加密数据部分（即 IP 数据包的负载部分），而不会对整个数据包进行加密。IP 头部仍然保持原样，只有负载（数据部分）被加密和认证。</p><ul><li>优点：传输模式对性能影响较小，因为只加密数据部分。</li><li>缺点：IP 头部信息（如源 IP 和目的 IP 地址）不被加密，可能暴露一些敏感信息。</li></ul><p>这种模式通常用于 端到端通信，例如两个设备之间直接的安全通信。</p><h5 id=隧道模式tunnel-mode>隧道模式（Tunnel Mode）</h5><p>在隧道模式下，IPSec 会加密整个数据包，包括 IP 头和数据部分。它在原始 IP 数据包外包裹一个新的 IP 头，从而隐藏原始数据包的所有信息。</p><ul><li>优点：隧道模式提供更强的隐私保护，整个 IP 数据包（包括源地址和目的地址）都被加密。</li><li>缺点：由于加密了整个数据包，性能开销较大。</li></ul><p>这种模式通常用于 网关到网关 或 远程访问 VPN，即在两个不同网络之间建立安全隧道。</p><h4 id=ipsec的核心协议>IPSec的核心协议</h4><p>IPSec 由两个核心协议组成，分别为 AH（Authentication Header）和 ESP（Encapsulating Security Payload）</p><h5 id=ahauthentication-header>AH（Authentication Header）</h5><p>AH 主要用于数据包的认证，它提供数据的完整性、身份验证和防止重放攻击功能。AH 在数据包头和负载中添加了认证信息，以确保数据未被篡改并且源 IP 地址可信。</p><ul><li>功能：提供数据完整性和身份验证，但不加密数据。</li><li>缺点：由于 AH 不加密数据，它并不能提供数据的保密性，因此通常不单独使用。</li></ul><h5 id=espencapsulating-sercurity-payload>ESP（Encapsulating Sercurity Payload）</h5><p>ESP 提供数据的加密、数据完整性和身份验证。与 AH 不同，ESP 能够保护数据的保密性，它会加密数据部分并为数据提供完整性验证。</p><ul><li>功能：提供数据的加密、身份验证、完整性保护以及防止重放攻击。</li><li>优点：它能有效保护数据内容的保密性，因此 ESP 通常用于大多数 VPN 方案中。</li></ul><h4 id=ipsec的认证与加密算法>IPSec的认证与加密算法</h4><p>IPSec支持多种认证和加密算法，以下是常见的几种：</p><h5 id=认证算法>认证算法</h5><ul><li>HMAC（Hash-Based Message Authentication Code）：用于生成消息认证码，确保数据完整性和身份验证。</li><li>SHA-1、SHA-2：哈希算法，用于生成数据的哈希值进行认证。</li></ul><h5 id=加密算法>加密算法</h5><ul><li>AES（Advanced Encryption Standard）：目前最常用的对称加密算法，提供高安全性。</li><li>3DES（Triple DES）：一种较为老旧的加密算法，三重数据加密标准。</li><li>Blowfish：也是一种对称加密算法，但由于安全性问题，已经逐渐被替代。</li></ul><h5 id=密钥交换协议>密钥交换协议</h5><ul><li>Diffie-Hellman（DH）：用于安全地交换加密密钥，通常在建立 IPSec 连接时使用。</li><li>RSA：常用于数字签名和加密过程中的公钥加密。</li></ul><h4 id=ipsec-vpn>IPSec VPN</h4><p>IPSec 是创建 VPN（虚拟专用网络）的常见协议之一。它通过加密和认证提供安全的远程访问或站点到站点通信。</p><ol><li><p>站点到站点 VPN（Site-to-Site VPN）
在这种模式下，两个不同的网络通过网关设备建立安全隧道。每个网关使用 IPSec 协议来加密通过公共网络（如互联网）传输的流量。这种 VPN 通常用于连接分支机构、远程办事处或数据中心。</p></li><li><p>远程访问 VPN（Remote Access VPN）
远程访问 VPN 允许远程用户通过公共网络（如互联网）安全地连接到公司或组织的内部网络。用户可以使用 IPSec VPN 客户端软件与组织的网关建立安全连接。</p></li></ol><h4 id=ipsec-vpn的工作流程>IPSec VPN的工作流程</h4><ol><li>IKE（Internet Key Exchange）协议：在建立 IPSec 连接之前，设备需要通过 IKE 协议交换加密密钥。IKE 协议通过协商身份验证方法、加密算法和密钥来建立安全的通信隧道。</li><li>IPSec 隧道建立：一旦密钥交换完成，设备就可以使用 IPSec 来加密和认证数据。通信双方之间的数据流量会通过 IPSec 隧道进行加密、解密、认证，确保数据安全。</li></ol><h4 id=ipsec的优缺点>IPSec的优缺点</h4><p>优点：</p><ul><li>强大的安全性：通过加密、身份验证、数据完整性保护等机制，IPSec 提供了高等级的安全保障。</li><li>灵活性：IPSec 支持多种加密和认证算法，可以根据需求进行配置。</li><li>透明性：IPSec 在网络层工作，因此对应用程序和操作系统透明，几乎不需要应用层的修改。</li><li>广泛支持：IPSec 是 VPN 技术中广泛支持的协议，几乎所有现代操作系统和网络设备都支持 IPSec。</li></ul><p>缺点：</p><ul><li>性能开销：加密和解密操作会消耗计算资源，可能对性能产生影响，尤其是在低性能设备上。</li><li>配置复杂：虽然 IPSec 提供了强大的安全性，但其配置过程可能较为复杂，尤其是在密钥管理和 VPN 连接配置方面。</li><li>难以穿越防火墙和 NAT：由于 IPSec 会修改数据包的头部，它在一些网络环境（如防火墙或 NAT）后面可能遇到问题，需要使用 NAT-T（Network Address Translation Traversal）技术进行支持。</li></ul><h3 id=igmp协议>IGMP协议</h3><p>IGMP协议（Internet Group Management Protocol）用于IPv4网络中管理组播组成员。</p><p>组播是一种“一对多”或“多对多”的通信方式，允许一个数据源同时向多个接收者发送数据。</p><p>IGMP协议帮助路由器确定哪些主机属于同一组播组，从而实现高效的组播通信</p><h4 id=组播multicast与广播broadcast的区别>组播（Multicast）与广播（Broadcast）的区别</h4><ul><li>广播：将数据发送给同一网络上的所有主机，无论它们是否需要这些数据</li><li>组播：将数据发送给一组特定的主机，只有那些明确加入某个组播组的主机才会接收到数据</li></ul><p>组播通过组播地址（例如IPv4中的<code>224.0.0.0</code>到<code>239.255.255.255</code>）来标识数据接收者，这些地址是预先定义好的，并且分配给特定的组播组</p><h4 id=igmp的工作原理>IGMP的工作原理</h4><p>IGMP主要用于以下操作：</p><ol><li>主机加入组播组：当主机希望接收某个组播地址的数据时，主机通过IGMP向路由器发送加入组播组的请求</li><li>主机离开组播组：当主机不再需要接收某个组播组的数据，主机通过IGMP向路由器发送离开组播组的请求</li><li>路由器查询主机的组播成员状态：路由器定期向网络上的所有主机发送IGMP查询请求，询问它们是否需要继续接收特定的组播流量</li></ol><h4 id=igmp版本>IGMP版本</h4><h5 id=igmp-v1>IGMP v1</h5><ul><li>发布：1989年</li><li>功能：IGMP v1 允许主机加入组播组并通知路由器，但没有离开组播组的机制。因此，如果主机不再需要某个组播流量，路由器仍然会继续转发数据。</li><li>查询方式：路由器定期发送 IGMP 查询请求，主机响应是否需要该组的数据。</li></ul><h5 id=igmp-v2>IGMP v2</h5><ul><li>发布：1997年</li><li>改进：IGMP v2 增加了主机主动离开组播组的功能。主机可以发送离开组播组的请求，这样路由器可以立即停止将组播流量转发给该主机。</li><li>离开机制：IGMP v2 允许主机通过发送 <code>IGMP Leave</code> 消息来告知路由器它不再需要该组的数据。这加速了路由器停止转发数据的过程。</li></ul><h5 id=igmp-v3>IGMP v3</h5><ul><li>发布：2002年</li><li>改进：IGMP v3 增加了对 源特定组播（SSM，Source-Specific Multicast）的支持。SSM 允许主机指定它只对来自某个特定源的组播流量感兴趣，从而减少了不必要的组播流量。</li><li>源特定组播：在 IGMP v3 中，主机不仅可以加入特定的组播组，还可以指定它希望接收来自哪些源的流量。</li><li>增强的查询：IGMP v3 支持多播源和目标的更精细化控制，使得路由器可以根据具体需求转发数据。</li></ul><h4 id=igmp消息格式>IGMP消息格式</h4><table><thead><tr><th>字段名称</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td><strong>类型（Type）</strong></td><td>1 字节</td><td>消息的类型，如查询（0x11）、加入（0x16）、离开（0x17）等。</td></tr><tr><td><strong>最大响应时间（Max Resp Time）</strong></td><td>1 字节</td><td>表示接收方在发送响应消息之前的最大等待时间（只对查询消息有效）。</td></tr><tr><td><strong>检验和（Checksum）</strong></td><td>2 字节</td><td>用于消息完整性校验。</td></tr><tr><td><strong>组播地址（Group Address）</strong></td><td>4 字节</td><td>指定所请求加入或离开的组播地址。</td></tr><tr><td><strong>源地址（Source Address）</strong></td><td>4 字节（仅在 IGMPv3 中）</td><td>仅在 IGMP v3 中使用，指定特定的源 IP 地址。</td></tr></tbody></table><h4 id=igmp在网络中的作用>IGMP在网络中的作用</h4><ul><li>动态管理组播成员：IGMP 使得路由器能够知道哪些主机需要接收哪些组播数据，从而避免不必要的组播流量。</li><li>减少带宽浪费：通过 IGMP，只有加入特定组播组的主机才能接收到相关的数据，减少了带宽浪费。</li><li>支持高效的组播通信：通过 IGMP，网络能够实现高效的组播通信，减少了广播流量，提高了网络性能。</li></ul><h4 id=igmp的应用场景>IGMP的应用场景</h4><ul><li>IPTV（互联网电视）：IPTV 服务依赖组播来向多个用户发送视频流，IGMP 用于管理用户的订阅，确保视频流只发送给需要的用户。</li><li>视频会议：在大规模视频会议中，使用组播技术来发送实时的视频流，IGMP 用于管理哪些主机（用户）接收视频流。</li><li>在线游戏：某些在线游戏可能使用组播技术来广播游戏状态，IGMP 可以用来确保游戏的更新只传送给需要的玩家。</li></ul><h4 id=igmp的优缺点>IGMP的优缺点</h4><p>优点：</p><ul><li>节省带宽：IGMP 通过允许只有需要接收特定组播流量的主机加入组播组，从而避免了不必要的数据流量。</li><li>提高网络效率：通过减少广播流量，IGMP 可以提高网络的整体性能。</li><li>灵活的组播管理：IGMP 提供了灵活的组播加入和离开机制，使得组播通信更加高效。</li></ul><p>缺点：</p><ul><li>安全性问题：IGMP 协议本身没有内建的安全机制，可能会遭遇如 IGMP 欺骗 等攻击。攻击者可能伪造 IGMP 消息，加入或离开组播组，从而影响网络流量或进行拒绝服务（DoS）攻击。</li><li>资源消耗：IGMP 查询和响应会增加网络中的通信量，尤其是在网络中有大量主机和组播流量的情况下。</li></ul><h3 id=nat协议>NAT协议</h3><p>NAT（Network Address Translation，网络地址转换）是一种在 IP 层（第 3 层）对 IP 地址进行修改的技术，主要用于解决 IPv4 地址不足的问题，允许多个设备共享一个公网 IP 地址与外部网络通信。NAT 能够在网络地址之间建立映射关系，将内部私有地址与外部公网地址进行转换，从而节省公网 IP 地址的使用，并增加网络的安全性。</p><h4 id=nat的基本原理>NAT的基本原理</h4><p>NAT 的基本工作原理是，当一台设备（例如一台计算机或路由器）向外部网络发送数据时，它会将自己内部的私有 IP 地址转换为路由器的公网 IP 地址，并将该请求的端口号一起记录在 NAT 表中。返回的数据会根据该表反向映射回原始设备。</p><p>具体过程如下：</p><ul><li>发起请求：设备发送数据包到外部网络，请求数据时，它的源 IP 地址是一个私有 IP 地址（例如 <code>192.168.1.100</code>）</li><li>地址转换：路由器接收到请求后，将私有 IP 地址转换为自己的公网 IP 地址（例如 203.0.113.1），并将源端口号映射到一个新的端口上</li><li>响应回传：外部网络的服务器响应该请求时，数据包的目标 IP 地址为公网 IP 地址（203.0.113.1），目标端口为刚才映射的端口号。路由器通过 NAT 表找到原始设备的私有 IP 地址和端口，将数据包正确地转发给设备</li></ul><h4 id=nat的种类>NAT的种类</h4><ol><li>静态NAT（Static NAT）
静态 NAT 会将内部网络中的一个私有 IP 地址与一个公网 IP 地址进行一对一的永久映射。这种映射是静态的，即内部的某个私有 IP 地址总是映射到相同的公网 IP 地址。</li></ol><ul><li>优点：容易配置，适用于需要通过公网访问内部设备的场景，例如 Web 服务器。</li><li>缺点：每个私有 IP 地址需要一个公网 IP 地址，这在公网 IP 地址有限时不太实用。</li></ul><ol start=2><li>动态NAT（Dynamic NAT）
动态 NAT 会在私有网络和公网之间进行动态映射。内部的私有 IP 地址会与一组公网 IP 地址进行映射，这些公网 IP 地址是从一个地址池中动态分配的。</li></ol><ul><li>优点：不需要为每个私有 IP 地址分配一个公网 IP 地址。</li><li>缺点：如果公网 IP 地址池用尽，可能无法为新的设备提供公网 IP 地址。</li></ul><ol start=3><li>端口地址转换（PAT, Port Address Translation）
PAT 是 NAT 最常见的一种实现方式，通常也称为 NAT Overloading。在 PAT 中，多个内部设备的私有 IP 地址共享一个公网 IP 地址，但使用不同的端口号来区分不同的连接。也就是说，路由器通过记录每个连接的源 IP 地址和源端口号来进行 NAT 操作。</li></ol><ul><li>优点：多个内部设备可以共享一个公网 IP 地址，大大节省了公网 IP 地址。</li><li>缺点：所有设备共享一个公网 IP 地址，可能会出现端口冲突或连接数限制。</li></ul><h4 id=nat的工作过程>NAT的工作过程</h4><p>NAT 的工作过程可以分为以下几个步骤：</p><ol><li>数据发送：</li></ol><ul><li>内部设备（如计算机）向外部网络（如互联网）发送请求。请求的数据包的源 IP 地址是私有 IP 地址。</li></ul><ol start=2><li>地址转换：</li></ol><ul><li>路由器接收到数据包后，将源 IP 地址转换为公网 IP 地址，并为每个连接分配一个唯一的端口号（如果是 PAT）。路由器会记录这些映射信息到 NAT 表中。</li></ul><ol start=3><li>数据返回：</li></ol><ul><li>外部网络的响应数据包会返回给公网 IP 地址和端口号。路由器根据 NAT 表找到原始的私有 IP 地址和端口号，然后将数据包转发到正确的内部设备。</li></ul><ol start=4><li>映射解除：</li></ol><ul><li>当连接关闭或超时后，路由器会删除 NAT 表中的映射信息。</li></ul><h4 id=nat表>NAT表</h4><p>NAT 表是路由器用于存储转换信息的表格。它包含以下几个关键字段：</p><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td><strong>源 IP 地址</strong></td><td>内部设备的私有 IP 地址。</td></tr><tr><td><strong>源端口号</strong></td><td>内部设备发起请求时的源端口号（在 PAT 中使用）。</td></tr><tr><td><strong>目标 IP 地址</strong></td><td>外部网络的目标 IP 地址。</td></tr><tr><td><strong>目标端口号</strong></td><td>外部网络服务器的目标端口号。</td></tr><tr><td><strong>映射的公网 IP 地址</strong></td><td>将内部私有 IP 地址转换为的公网 IP 地址。</td></tr><tr><td><strong>映射的公网端口号</strong></td><td>在 PAT 中，外部连接的公网端口号。</td></tr></tbody></table><h4 id=nat的优缺点>NAT的优缺点</h4><p>优点：</p><ul><li>节省公网 IP 地址：NAT 允许多个设备共享一个公网 IP 地址，这大大缓解了 IPv4 地址不足的问题。</li><li>提高安全性：NAT 可以隐藏内部网络的结构，使得外部网络无法直接访问内部设备。外部数据包必须通过路由器进行处理，从而增加了安全性。</li><li>简化管理：内部网络设备使用私有 IP 地址，无需每台设备都有一个公网 IP 地址，减少了网络管理复杂度。</li></ul><p>缺点：</p><ul><li>影响点对点连接：由于 NAT 将多个内部设备映射到一个公网 IP 地址，外部设备通常无法直接与内部设备建立点对点连接。需要借助端口映射或特殊协议（如 UPnP）来解决。</li><li>协议兼容性问题：一些应用协议（如 FTP、SIP、IPsec）可能与 NAT 不兼容，需要进行特殊配置或 NAT 穿透。</li><li>性能瓶颈：NAT 路由器需要处理大量的连接和转换，可能会成为性能瓶颈，尤其在高流量网络中。</li><li>NAT 表的管理：当网络中有大量的设备时，NAT 表可能会变得非常庞大，管理和维护也变得更加困难。</li></ul><h4 id=nat穿透>NAT穿透</h4><p>有时，由于 NAT 的存在，设备之间的点对点连接变得困难。这种问题常见于对等网络（如 P2P 文件共享、VoIP 通话、在线游戏等）。NAT 穿透（NAT Traversal）技术被用来解决这个问题。常见的 NAT 穿透技术包括：</p><ul><li>UPnP（Universal Plug and Play）：允许设备自动配置 NAT 设备（如路由器），以便使外部设备能够访问内部设备。</li><li>STUN（Session Traversal Utilities for NAT）：一种协议，帮助设备在 NAT 网络下确定自己在公网中的可达性。</li><li>TURN（Traversal Using Relays around NAT）：在 NAT 网络中通过中继服务器转发数据，以绕过 NAT。</li></ul><h4 id=nat的应用场景>NAT的应用场景</h4><ul><li>家庭和小型办公室网络：家庭或小型办公室通常使用一个公网 IP 地址，通过 NAT 将多个设备连接到互联网。大多数家庭路由器都支持 NAT 功能。</li><li>企业网络：大型企业可能会使用 NAT 来管理大量设备访问互联网，同时保护内部网络的安全。</li><li>IPv6 过渡：在从 IPv4 向 IPv6 过渡过程中，NAT 可能被用作临时解决方案来连接 IPv4 网络和 IPv6 网络。</li></ul><h2 id=网络层工作流程>网络层工作流程</h2><h3 id=数据包在网络层的处理流程>数据包在网络层的处理流程</h3><p>以浏览器发送HTTP请求为例，数据包在网络层的传输过程如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>应用层</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#f92672>HTTP报文</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>传输层</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#f92672>TCP添加端口号</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>网络层</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#f92672>IP添加源地址和目的地址</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>数据链路层</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#f92672>封装为帧</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#f92672>添加MAC地址</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>物理层</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#f92672>比特流传输</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>在这个过程中，网络层的主要任务是为数据包添加源IP地址和目标IP地址，然后将其交给下层的数据链路层进行封装。到达目标主机时，数据包会按照相反的顺序进行拆解和解码</p><h2 id=子网划分与子网>子网划分与子网</h2><p>它们涉及到如何将一个大范围的IP地址分割成多个更小的、更易管理的子网</p><h3 id=什么是子网>什么是子网</h3><p>子网 是一个小型的网络，它是通过将一个更大的网络（通常是一个类C、类B或类A网络）划分成多个部分来创建的。这种划分是为了提高网络管理的灵活性和效率。每个子网都拥有自己的网络地址范围、子网掩码和广播地址，每个子网是一个独立的广播域，限制了广播流量的范围</p><p>子网通过将“主机部分”分割成更多的部分来创建更多的网络，使得网络内的设备分布更加合理，减少冲突，提高性能，子网划分可以提高网络的安全性，通过隔离不同的网络区域，减少潜在的安全风险</p><h3 id=子网划分>子网划分</h3><p>子网划分 是指将一个网络划分为多个子网络的过程。通过子网划分，网络管理员可以更高效地管理 IP 地址、减少广播风暴、提高网络的安全性、并使得网络的拓扑更加清晰。</p><p>子网划分的核心在于合理利用子网掩码，将 IP 地址空间划分成更小的子网。我们通过修改子网掩码来决定“网络部分”和“主机部分”的边界，从而将原本一个大的网络拆分成多个小的子网。</p><h2 id=网关gateway>网关（GateWay）</h2><p>网关（Gateway） 是一个网络设备或系统，它充当不同网络之间的桥梁，允许数据在不同协议、不同地址范围的网络之间转发。简而言之，网关是不同网络间的“中介”，它帮助网络之间进行通信，尤其是当网络采用不同的通信协议时。</p><p>网关通常位于不同子网或不同网络的边缘，负责接收从一个网络发出的数据包，并将其转发到目标网络或外部网络。它不仅处理路由，还可能涉及协议转换、数据封装、加解密等复杂任务。</p><h3 id=网关的工作原理>网关的工作原理</h3><p>网关的基本工作原理是接收来自一个网络的数据包，然后基于目标地址，将其转发到另一个网络。如果两个网络之间使用不同的协议，网关还会进行协议转换。</p><p>例如：</p><ul><li><p>局域网与广域网之间的通信：当局域网中的设备需要与广域网（例如互联网）中的设备通信时，网关（通常是路由器）会接收本地设备发出的数据包，并将其转发到互联网中。</p></li><li><p>不同协议之间的转换：假设你有两个使用不同协议的网络（例如一个使用 IPv4，另一个使用 IPv6），网关还需要在这两个网络之间进行协议转换。</p></li></ul><h3 id=网关的类型>网关的类型</h3><h4 id=默认网关default-gateway>默认网关（Default Gateway）</h4><p>在计算机网络中，默认网关 是一个设备（通常是路由器），它作为设备访问外部网络（如互联网）时的默认路径。如果设备的目标 IP 地址不在本地子网范围内，设备会将数据包发送到默认网关，由网关转发到其他网络。</p><ul><li>作用：默认网关是设备与外部网络之间的通信桥梁。当一个设备需要访问位于不同子网或外部网络的目标时，它会将数据包发送给默认网关。</li></ul><p>例如，假设你在本地网络中，IP 地址为 192.168.1.100，而默认网关的地址是 192.168.1.1。当你访问一个互联网网站时，数据包首先会通过网关 192.168.1.1 传送。</p><h4 id=网络网关network-gateway>网络网关（Network Gateway）</h4><p>网络网关通常是一个路由器，连接着两个不同的网络，它负责在不同的网络之间转发数据。网络网关可以是：</p><ul><li>局域网和广域网（如互联网）之间的网关。</li><li>不同协议的网络之间的网关（如 IPv4 和 IPv6 网络）。</li><li>设备之间的通信网关（如 Modem 网关）。</li></ul><h4 id=应用网关application-gateway>应用网关（Application Gateway）</h4><p>应用网关通常用在处理应用层协议（如 HTTP、FTP 等）的场景中。它可以对进入和离开应用的请求进行过滤、修改、加密或解密等操作，通常用于提高网络安全性。</p><p>例如，一个 HTTP 网关可以帮助组织通过监控和控制 Web 流量，进行 Web 访问控制和数据过滤，阻止不安全的内容或防止未经授权的访问。</p><h4 id=代理网关proxy-gateway>代理网关（Proxy Gateway）</h4><p>代理网关充当两个网络之间的中介，接受来自内部网络的请求并代表它们向外部网络发起请求，反之亦然。它通常用于：</p><ul><li><p>访问控制：限制内部用户访问外部资源，或者限制特定资源的访问。</p></li><li><p>安全性增强：代理网关可以隐藏内部网络的结构，增加安全性。</p></li></ul><h3 id=网关的功能>网关的功能</h3><ul><li><p>路由功能：网关能够根据目标地址，将数据包从源网络转发到目标网络。这意味着网关负责选择最佳路径以确保数据能够顺利到达目的地。</p></li><li><p>协议转换：当两个网络使用不同协议时，网关需要进行协议转换。比如，IPv4 网络和 IPv6 网络之间的通信，需要网关进行协议转换。</p></li><li><p>数据封装和解封装：一些网关可能需要对数据进行封装和解封装处理，例如，VPN 网关会将传输的私密数据封装成安全的加密形式，再进行解封装。</p></li><li><p>流量控制：网关可以对进出网络的数据流量进行控制，限制流量、进行负载均衡等。</p></li><li><p>安全功能：网关也充当防火墙角色，可以过滤恶意数据包，防止未授权的访问，保护网络安全。</p></li></ul><h3 id=网关与路由器的区别>网关与路由器的区别</h3><p>虽然网关和路由器在很多情况下可以互换使用，但它们实际上有一些区别：</p><ul><li>路由器：通常工作在网络层，主要负责不同子网之间的数据转发。它根据目标IP地址来选择最佳路径进行路由</li><li>网关：网关则是一个更为广泛的概念，它不仅仅涉及路由，通常还包括协议转换、数据封装、加密等功能。网关可以在更高的层次（如应用层）工作</li></ul><h3 id=网关的使用场景>网关的使用场景</h3><ul><li><p>家庭网络：家庭中通常有一个 默认网关，它连接到互联网。这个网关通常是由 ISP 提供的路由器，家庭中的所有设备都通过这个网关访问外部网络。</p></li><li><p>企业网络：企业的局域网通常会通过多个网关连接到外部网络或互联网。不同的网关会负责不同类型的流量，如数据流、Web 流量、VoIP 等。</p></li><li><p>VPN 网络：在虚拟专用网络（VPN）中，网关通过加密通道连接不同的远程网络，为公司员工提供安全的远程访问。</p></li></ul><h3 id=默认网关的配置>默认网关的配置</h3><p>在Windows中，可以使用<code>ipconfig</code>命令查看并配置默认网关，在Linux中使用<code>ip route</code>或<code>netstat -r</code>来查看路由表</p><h2 id=三层交换机layer-3-switch>三层交换机（Layer 3 Switch）</h2><p>三层交换机（Layer 3 Switch）是一种结合了传统二层交换机与路由器功能的网络设备，具备高速的数据帧交换能力，同时支持 IP 层的路由功能。它能够在不同子网或 VLAN 之间进行高效的数据转发，是现代企业局域网（LAN）中核心网络设备的重要组成部分。</p><h3 id=为什么需要三层交换机>为什么需要三层交换机</h3><p>在传统网络架构中，不同 VLAN 或子网之间的通信需要通过路由器完成。但这种方式存在性能瓶颈，因为路由器通常依赖软件处理路由功能，转发效率较低，无法满足高带宽环境下的实时通信需求。</p><p>三层交换机通过将路由功能集成到交换芯片中，以硬件方式实现高速路由转发，不仅保留了二层交换机的高性能特点，还能承担一定的三层转发任务，在效率与功能之间取得平衡。</p><h3 id=工作原理-2>工作原理</h3><p>三层交换机融合了二层与三层的转发机制，其核心原理如下：</p><ol><li>二层交换功能（基于MAC）</li></ol><ul><li>与传统二层交换机一致，根据帧头中的目标MAC地址查找转发表</li><li>实现同一子网内设备的快速通信</li></ul><ol start=2><li>三层转发功能（基于IP）</li></ol><ul><li>当检测到数据包的源和目标地址位于不同子网时，三层交换机会参考其路由表，基于IP地址进行转发</li><li>这一过程在硬件中完成（使用ASIC芯片），性能远高于传统软件路由器</li></ul><ol start=3><li>支持SVI（Switched Visual Interface）</li></ol><ul><li>每个VLAN可以配置一个虚拟三层接口（SVI），三层交换机通过这些接口实现不同的VLAN之间的通信</li><li>比传统“交换机 + 路由器”架构更高效、简洁</li></ul><h3 id=适用场景>适用场景</h3><ul><li>不同VLAN之间需要频繁通信</li><li>局域网内设备多、网段复杂</li></ul><h3 id=安全与扩展功能>安全与扩展功能</h3><p>现代三层交换机通常支持以下功能，提升网络的安全性和可管理性</p><ul><li>ACL（访问控制列表）：基于IP、端口等实现精细化访问控制</li><li>DHCP Snooping、ARP Inspection：防止伪造主机信息</li><li>QoS（服务质量）：保障关键业务流量优先级</li><li>VRRP/HSRP：实现核心层设备的高可用</li></ul></div><nav class=post-nav><a href=/csbasic/file/computernetwork/data-link-layer/ class=hover:underline>pre: Data Link Layer</a>
<a href=/csbasic/file/computernetwork/network-layer-model/ class=hover:underline>next: Network Layer Model</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#网络层的核心功能>网络层的核心功能</a><ul><li><a href=#1路由选择routing>1.路由选择（Routing）</a></li><li><a href=#2逻辑寻址ip地址>2.逻辑寻址（IP地址）</a></li><li><a href=#3分段与重组>3.分段与重组</a></li><li><a href=#4差错处理>4.差错处理</a></li><li><a href=#5拥塞控制可选>5.拥塞控制（可选）</a></li></ul></li><li><a href=#路由协议>路由协议</a><ul><li><a href=#rip协议>RIP协议</a><ul><li><a href=#rip工作原理>RIP工作原理</a></li><li><a href=#rip协议的特点>RIP协议的特点</a></li><li><a href=#rip版本>RIP版本</a></li><li><a href=#rip的路由表更新过程>RIP的路由表更新过程</a></li><li><a href=#rip协议的优缺点>RIP协议的优缺点</a></li></ul></li><li><a href=#ospf协议>OSPF协议</a><ul><li><a href=#ospf的基本特点>OSPF的基本特点</a></li><li><a href=#ospf的工作原理>OSPF的工作原理</a></li><li><a href=#ospf的区域划分>OSPF的区域划分</a></li><li><a href=#ospf路由器类型>OSPF路由器类型</a></li><li><a href=#ospf的lsa类型>OSPF的LSA类型</a></li><li><a href=#ospf的优缺点>OSPF的优缺点</a></li></ul></li><li><a href=#bgp协议>BGP协议</a><ul><li><a href=#bgp的基本特点>BGP的基本特点</a></li><li><a href=#bgp的工作原理>BGP的工作原理</a></li><li><a href=#bgp的路由类型>BGP的路由类型</a></li><li><a href=#bgp的路由属性>BGP的路由属性</a></li><li><a href=#bgp的优缺点>BGP的优缺点</a></li></ul></li></ul></li><li><a href=#路由器router>路由器（Router）</a><ul><li><a href=#定义>定义</a></li><li><a href=#功能>功能</a></li><li><a href=#路由器的工作流程>路由器的工作流程</a></li><li><a href=#路由器的类型>路由器的类型：</a></li></ul></li><li><a href=#路由routing>路由（Routing）</a><ul><li><a href=#路由的过程>路由的过程</a></li><li><a href=#路由的实现方式>路由的实现方式</a></li><li><a href=#路由表routing-table>路由表（Routing Table）</a><ul><li><a href=#路由表的基本结构>路由表的基本结构</a></li><li><a href=#路由表的工作原理>路由表的工作原理</a></li><li><a href=#最长前缀匹配longest-prefix-match>最长前缀匹配（Longest Prefix Match）</a></li></ul></li></ul></li><li><a href=#网络层中的典型协议>网络层中的典型协议</a><ul><li><a href=#ip协议>IP协议</a><ul><li><a href=#ipv4协议>IPv4协议</a><ul><li><a href=#ipv4地址结构>IPv4地址结构</a></li><li><a href=#ipv4包格式>IPv4包格式</a></li><li><a href=#ipv4的重要特性>IPv4的重要特性</a></li><li><a href=#特殊ip地址>特殊IP地址</a></li><li><a href=#子网掩码subnet-mask>子网掩码（Subnet Mask）</a><ul><li><a href=#子网掩码的结构>子网掩码的结构</a></li></ul></li><li><a href=#cidrclassless-inter-domain-routing>CIDR（Classless Inter-Domain Routing）</a></li><li><a href=#类地址系统>类地址系统</a><ul><li><a href=#类地址系统的分类>类地址系统的分类</a></li><li><a href=#类地址系统的优势与局限>类地址系统的优势与局限</a></li></ul></li><li><a href=#cidr与子网掩码例子和计算>CIDR与子网掩码例子和计算</a></li><li><a href=#vlsmvariable-length-subnet-mask变长子网掩码>VLSM（Variable Length Subnet Mask，变长子网掩码）</a><ul><li><a href=#vlsm的工作原理>VLSM的工作原理</a></li><li><a href=#vlsm的优势>VLSM的优势</a></li><li><a href=#vlsm的计算步骤>VLSM的计算步骤</a></li></ul></li></ul></li><li><a href=#ipv6协议>IPv6协议</a><ul><li><a href=#ipv6地址结构>IPv6地址结构</a></li><li><a href=#地址类型>地址类型</a></li><li><a href=#ipv6包格式>IPv6包格式</a></li><li><a href=#ipv4-vs-ipv6>IPv4 vs IPv6</a></li><li><a href=#ipv6的问题>IPv6的问题</a></li><li><a href=#ipv6过渡方案>IPv6过渡方案</a></li><li><a href=#ipv6关键协议>IPv6关键协议</a></li></ul></li><li><a href=#分片与重组fragmentation-and-reassembly>分片与重组（Fragmentation and Reassembly）</a><ul><li><a href=#分片>分片</a></li><li><a href=#重组>重组</a></li><li><a href=#ip分片的例子>IP分片的例子</a></li><li><a href=#分片与重组的优缺点>分片与重组的优缺点</a></li><li><a href=#分片重组的应用>分片重组的应用</a></li></ul></li></ul></li><li><a href=#icmp协议>ICMP协议</a><ul><li><a href=#icmp的基本特点>ICMP的基本特点</a></li><li><a href=#icmp的工作原理>ICMP的工作原理</a></li><li><a href=#icmp协议的作用>ICMP协议的作用</a></li><li><a href=#icmp的局限性和安全问题>ICMP的局限性和安全问题</a></li><li><a href=#icmp的安全性增强>ICMP的安全性增强</a></li><li><a href=#ping>ping</a><ul><li><a href=#工作原理>工作原理</a></li><li><a href=#ping输出的内容>ping输出的内容</a></li><li><a href=#ping的用途>ping的用途</a></li><li><a href=#ping的常用参数>ping的常用参数</a></li><li><a href=#ping的常见问题>ping的常见问题</a></li><li><a href=#ping的局限性>ping的局限性</a></li></ul></li><li><a href=#traceroute>traceroute</a><ul><li><a href=#traceroute的工作原理>traceroute的工作原理</a></li><li><a href=#traceroute命令的输出>traceroute命令的输出</a></li><li><a href=#traceroute的常用选项>traceroute的常用选项</a></li><li><a href=#traceroute的用途>traceroute的用途</a></li><li><a href=#traceroute的局限性>traceroute的局限性</a></li></ul></li></ul></li><li><a href=#arp协议>ARP协议</a><ul><li><a href=#arp基本原理>ARP基本原理</a></li><li><a href=#arp数据包结构>ARP数据包结构</a></li><li><a href=#arp请求与响应>ARP请求与响应</a></li><li><a href=#arp缓存>ARP缓存</a></li><li><a href=#arp协议的工作场景>ARP协议的工作场景</a></li><li><a href=#arp欺骗arp-spoofing>ARP欺骗（ARP Spoofing）</a></li><li><a href=#arp与ipv6>ARP与IPv6</a></li><li><a href=#arp与路由器>ARP与路由器</a></li></ul></li><li><a href=#rarp协议>RARP协议</a><ul><li><a href=#工作原理-1>工作原理</a></li><li><a href=#rarp消息格式>RARP消息格式</a></li><li><a href=#rarp应用场景>RARP应用场景</a></li><li><a href=#rarp的局限性>RARP的局限性</a></li><li><a href=#rarp的替代协议dhcp>RARP的替代协议：DHCP</a></li></ul></li><li><a href=#dhcp协议>DHCP协议</a><ul><li><a href=#工作流程>工作流程</a></li><li><a href=#协议细节>协议细节</a></li><li><a href=#dhcp提供的其他信息>DHCP提供的其他信息</a></li><li><a href=#dhcp的意义>DHCP的意义</a></li></ul></li><li><a href=#ipsec协议>IPSec协议</a><ul><li><a href=#概述>概述</a></li><li><a href=#ipsec的基本目标>IPSec的基本目标</a></li><li><a href=#ipsec的工作原理>IPSec的工作原理</a><ul><li><a href=#传输模式transport-mode>传输模式（Transport Mode）</a></li><li><a href=#隧道模式tunnel-mode>隧道模式（Tunnel Mode）</a></li></ul></li><li><a href=#ipsec的核心协议>IPSec的核心协议</a><ul><li><a href=#ahauthentication-header>AH（Authentication Header）</a></li><li><a href=#espencapsulating-sercurity-payload>ESP（Encapsulating Sercurity Payload）</a></li></ul></li><li><a href=#ipsec的认证与加密算法>IPSec的认证与加密算法</a><ul><li><a href=#认证算法>认证算法</a></li><li><a href=#加密算法>加密算法</a></li><li><a href=#密钥交换协议>密钥交换协议</a></li></ul></li><li><a href=#ipsec-vpn>IPSec VPN</a></li><li><a href=#ipsec-vpn的工作流程>IPSec VPN的工作流程</a></li><li><a href=#ipsec的优缺点>IPSec的优缺点</a></li></ul></li><li><a href=#igmp协议>IGMP协议</a><ul><li><a href=#组播multicast与广播broadcast的区别>组播（Multicast）与广播（Broadcast）的区别</a></li><li><a href=#igmp的工作原理>IGMP的工作原理</a></li><li><a href=#igmp版本>IGMP版本</a><ul><li><a href=#igmp-v1>IGMP v1</a></li><li><a href=#igmp-v2>IGMP v2</a></li><li><a href=#igmp-v3>IGMP v3</a></li></ul></li><li><a href=#igmp消息格式>IGMP消息格式</a></li><li><a href=#igmp在网络中的作用>IGMP在网络中的作用</a></li><li><a href=#igmp的应用场景>IGMP的应用场景</a></li><li><a href=#igmp的优缺点>IGMP的优缺点</a></li></ul></li><li><a href=#nat协议>NAT协议</a><ul><li><a href=#nat的基本原理>NAT的基本原理</a></li><li><a href=#nat的种类>NAT的种类</a></li><li><a href=#nat的工作过程>NAT的工作过程</a></li><li><a href=#nat表>NAT表</a></li><li><a href=#nat的优缺点>NAT的优缺点</a></li><li><a href=#nat穿透>NAT穿透</a></li><li><a href=#nat的应用场景>NAT的应用场景</a></li></ul></li></ul></li><li><a href=#网络层工作流程>网络层工作流程</a><ul><li><a href=#数据包在网络层的处理流程>数据包在网络层的处理流程</a></li></ul></li><li><a href=#子网划分与子网>子网划分与子网</a><ul><li><a href=#什么是子网>什么是子网</a></li><li><a href=#子网划分>子网划分</a></li></ul></li><li><a href=#网关gateway>网关（GateWay）</a><ul><li><a href=#网关的工作原理>网关的工作原理</a></li><li><a href=#网关的类型>网关的类型</a><ul><li><a href=#默认网关default-gateway>默认网关（Default Gateway）</a></li><li><a href=#网络网关network-gateway>网络网关（Network Gateway）</a></li><li><a href=#应用网关application-gateway>应用网关（Application Gateway）</a></li><li><a href=#代理网关proxy-gateway>代理网关（Proxy Gateway）</a></li></ul></li><li><a href=#网关的功能>网关的功能</a></li><li><a href=#网关与路由器的区别>网关与路由器的区别</a></li><li><a href=#网关的使用场景>网关的使用场景</a></li><li><a href=#默认网关的配置>默认网关的配置</a></li></ul></li><li><a href=#三层交换机layer-3-switch>三层交换机（Layer 3 Switch）</a><ul><li><a href=#为什么需要三层交换机>为什么需要三层交换机</a></li><li><a href=#工作原理-2>工作原理</a></li><li><a href=#适用场景>适用场景</a></li><li><a href=#安全与扩展功能>安全与扩展功能</a></li></ul></li></ul></li></ul></nav></aside><script defer src=/js/scrollspy.js></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>