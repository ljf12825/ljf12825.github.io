<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Data Link Layer</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/csbasic/>★</a></li><li><a href=/csbasic/lab/>Lab</a></li><li><a href=/csbasic/lib/>Lib</a></li><li><a href=/csbasic/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /             <a class=nav-item data-path=/engine/ href=/engine/>Engine</a>         |
|                             |  /                 |           |
|                             | /                  |           |
|                             |/                   |           |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/framework/ href=/framework/>Framework</a>       |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                          <a class=nav-item data-path=/csbasic/ href=/csbasic/>CSBasic</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Data Link Layer<div class=meta>Modified: 2025-12-31
| Author：ljf12825</div></div><div class=content><p>数据链路层处于OSI模型的第2层，负责在相邻节点之间可靠地传输数据帧（Frame），并进行差错检测、帧定界、流量控制等工作</p><h2 id=它处理什么问题>它处理什么问题</h2><table><thead><tr><th>问题</th><th>说明</th></tr></thead><tbody><tr><td><strong>成帧（Framing）</strong></td><td>把网络层的分组（Packet）封装成帧（Frame），方便底层传输。</td></tr><tr><td><strong>差错检测与校正（Error Detection and Correction）</strong></td><td>通过 CRC、奇偶校验等方式检查数据在传输过程中是否损坏。</td></tr><tr><td><strong>流量控制（Flow Control）</strong></td><td>控制发送速率，防止接收方来不及处理。</td></tr><tr><td><strong>介质访问控制（MAC）</strong></td><td>多个设备共享物理媒介时，控制谁可以发数据（如以太网中的 CSMA/CD）。</td></tr><tr><td><strong>物理地址寻址（MAC Address）</strong></td><td>使用物理地址（MAC地址）来标识链路上的节点。</td></tr></tbody></table><h2 id=数据链路层的结构>数据链路层的结构</h2><p>数据链路层通常分为两个子层（尤其在IEEE 802中）</p><table><thead><tr><th>子层</th><th>功能</th></tr></thead><tbody><tr><td><strong>LLC（逻辑链路控制）子层</strong></td><td>提供差错检测、帧同步等服务，定义帧格式。</td></tr><tr><td><strong>MAC（介质访问控制）子层</strong></td><td>控制设备如何访问共享物理媒介（决定谁能“说话”）。</td></tr></tbody></table><h2 id=层间关系>层间关系</h2><ul><li>上接网络层：数据链路层接收来自网络层的分组（Packet），打包成帧</li><li>下接物理层：把帧转换为比特流，交给物理层传输</li></ul><h2 id=帧的组成通用结构>帧的组成（通用结构）</h2><p>尽管不同链路层协议的帧结构会略有不同，但帧通常包含以下几个部分：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+---------+-----------+---------+------------+--------+
</span></span></span><span style=display:flex><span>| 帧头    | 地址信息   | 控制字段 | 数据载荷    | 帧尾   |
</span></span><span style=display:flex><span><span style=color:#a6e22e>+---------+-----------+---------+------------+--------+
</span></span></span></code></pre></div><table><thead><tr><th>区域</th><th>内容和作用</th></tr></thead><tbody><tr><td><strong>帧头</strong></td><td>表示帧的起始位置，一般用于帧定界，比如标识“一个帧从这里开始”</td></tr><tr><td><strong>地址信息</strong></td><td>包含发送方和接收方的 <strong>MAC地址</strong>（物理地址），用于局域网中标识设备</td></tr><tr><td><strong>控制字段</strong></td><td>表示帧类型、编号、确认、流量控制等（用于差错控制/顺序控制）</td></tr><tr><td><strong>数据载荷</strong></td><td>来自上层网络层（IP）的数据包，即真正要传送的“内容”</td></tr><tr><td><strong>帧尾</strong></td><td>包含<strong>差错检测码</strong>，比如 CRC，用来检查帧在传输过程中是否出错（通常不能纠错）</td></tr></tbody></table><h3 id=帧的界定>帧的界定</h3><p>帧的界定，指的是接收方如何识别和划分一个个帧的起始和结束<br>因为在链路上传输的是一串连续的比特流，接收端必须知道从哪开始读、读到哪结束，这就是帧的界定要解决的问题</p><h4 id=为什么需要帧的界定>为什么需要帧的界定</h4><p>链路层是点到点或点到多点之间的通信，如果不做帧的划分：</p><ul><li>接收方不知道哪里是一条完整的信息</li><li>无法检测丢包、校验错误</li><li>多帧数据连在一起将造成“比特流混乱”</li></ul><h4 id=常见的帧界定方式>常见的帧界定方式</h4><h5 id=字节计数法byte-count>字节计数法（Byte Count）</h5><ul><li>在帧的开头写一个字段，表示后面帧的长度</li><li>例如：<code>[5][Data1][Data2][Data3][Data4][Data5]</code></li></ul><p>优点：结构简单，开销小<br>缺点：如果长度字段出错，整个帧就错乱，恢复困难</p><h5 id=字符充填法character-stuffing>字符充填法（Character Stuffing）</h5><ul><li>使用特殊字符（如<code>FLAG=01111110</code>）作为帧起始和结束的标志</li><li>如果数据中出现<code>FLAG</code>，就插入一个转义字符（如<code>ESC</code>）进行转义</li></ul><p>例如：<br>发送帧：[FLAG][data1][ESC][FLAG][data2][FLAG]<br>接收端通过<code>ESC</code>识别数据中的特殊字符不是标志位</p><p>优点：可靠，能处理控制字符冲突<br>缺点：只适用于字符流，效率略低</p><h5 id=比特充填法bit-stuffing以太网使用>比特充填法（Bit Stuffing）以太网使用</h5><ul><li>也使用固定的比特标志（如<code>01111110</code>）作为帧的起始和结束</li><li>若数据中出现连续5个1，就在后面插入一个0（防止误判为结束标志）</li></ul><p>例如：<br>原始数据：<code>01111110</code>（冲突）<br>比特充填后：<code>01111101</code><br>接收端发现连续5个1后自动删掉后面的0，还原原始数据</p><p>优点：适用于任意比特流<br>缺点：需要位级处理，稍复杂</p><p>比特填充法的局限就在于：<br>它假设连续5个1后跟的0一定是充填的，无法判断它是不是数据本身的0<br>为了避免误判，协议的设计者必须保证：</p><ul><li>数据编码不要主动制造出连续的<code>0111110</code>序列；</li><li>比如在HDLC、PPP等协议中，这种情况是通过充填机制主动生成的，不会自然出现</li><li>如果你是自己设计的通信协议，就要避免出现这样的字节，或者使用额外校验字段辅助识别边界</li></ul><h5 id=基于物理层的编码规则如曼彻斯特编码>基于物理层的编码规则（如曼彻斯特编码）</h5><p>某些链路技术（如以太网物理层）使用编码规律来隐式地帮助同步帧界限，例如通过信号边缘检测等</p><h2 id=差错检测>差错检测</h2><p>差错检测保证数据传输的正确性和可靠性</p><h3 id=差错为什么发生>差错为什么发生</h3><p>数据在物理媒介上传输时，可能因为干扰、噪声、电磁波、硬件故障等原因，导致传输的比特发生错误（比如0变成1，1变成0）<br>这些错误如果不检测出来，接收方就会得到错误数据，造成系统错误</p><h3 id=差错检测的目标>差错检测的目标</h3><ul><li>检测数据中的错误，保证接收到的数据和发送的数据一致</li><li>尽可能快速且有效，不能增加过多传输负担</li><li>差错检测 != 差错纠正，检测到错误后一般是丢弃或请求重传</li></ul><h3 id=常见差错检测的方法>常见差错检测的方法</h3><h4 id=奇偶校验parity-check>奇偶校验（Parity Check）</h4><ul><li>最简单的差错检测方法</li><li>在数据末尾加一个比特，保证整段数据中1的个数是偶数（偶校验）或奇数（奇校验）</li><li>缺点：只能检测单个比特错误，不能检测多比特错误</li></ul><h4 id=循环冗余校验crccyclic-redundancy-check>循环冗余校验（CRC，Cyclic Redundancy Check）</h4><ul><li>最常用且强大的差错检测方法，广泛用于以太网、HDLC、USB等协议</li><li>原理：<ul><li>把数据看成一个二进制多项式（系数是0或1），用一个固定生成多项式（简称“生成多项式”）对数据进行模2除法</li><li>除法的余数就是CRC校验码，附加到数据末尾一起发送</li></ul></li><li>接收方用同样生成多项式除收到的数据，如果余数为0，说明没有检测到错误</li><li>优势：能检测大多数随机错误和突发错误，检测能力远胜奇偶校验</li><li>复杂度：算法可以用硬件实现，高速计算</li></ul><h4 id=校验和checksum>校验和（Checksum）</h4><ul><li>数据各部分数值相加（按字节或字），然后取反码或模某数</li><li>用于IP、TCP、UDP等协议</li><li>差错检测能力比CRC差，但计算更简单</li></ul><h4 id=哈希函数>哈希函数</h4><ul><li>现代一些网络协议或存储设备中会用加密哈希算法（如MD5、SHA）校验完整性，但计算复杂，不常用于链路层</li></ul><h3 id=差错检测流程简述>差错检测流程简述</h3><p>1.发送端：</p><ul><li>原始数据经过CRC计算，得到CRC校验码</li><li>将校验码附加在数据后面一起发送</li></ul><p>2.接收端：</p><ul><li>收到数据 + 校验码</li><li>对全部数据进行同样的CRC计算</li><li>若结果为0，数据正确；否则，检测出错误</li></ul><h3 id=差错检测的局限性>差错检测的局限性</h3><blockquote><p>如果数据和校验码都被篡改了，接收端的校验结果依然“正确”，怎么办</p></blockquote><p>所有差错检测码（包括CRC）都是基于数学算法设计的，它们并不能保证100%发现所有错误</p><p><strong>为什么</strong></p><ul><li>差错检验码本质上是给数据生成一个“指纹”</li><li>如果数据和校验码同时发生了“巧合性”的变化，导致指纹看起来没变（校验和依然正确），这种情况称为“未检测错误（Undetected Error）”</li></ul><p><strong>发生这种情况的概率极低</strong></p><ul><li>CRC的设计目标就是让这种“巧合”概率极小，通常在十亿甚至万亿分之一的量级</li><li>在现实环境下，突发性的噪声通常不会“精确”改变数据和校验码，使得校验刚好通过</li></ul><p><strong>但是仍然可能存在（理论上）</strong></p><ul><li>这种错误一般只出现在极端恶劣的信道条件，或者数据遭遇恶意攻击（篡改）时</li><li>对于一般的网络通信，CRC足够强大，误检率非常低，通常可以忽略</li></ul><p><strong>解决方案与防范措施</strong></p><ul><li><p>更高级的完整性验证</p><ul><li>端到端校验（如TCP的校验和）</li><li>应用层校验（如文件校验码、数字签名）</li><li>加密哈希算法（SHA-256等）保证数据完整性和防篡改</li></ul></li><li><p>可靠传输协议</p><ul><li>发现错误后由更高层协议负责重传（如TCP）</li><li>如果校验码未检测到错误，可能会传递错误数据，但这在概率上很低</li></ul></li></ul><p><strong>结论</strong></p><p>差错检测码不是绝对完美的，但它是网络传输中非常高效且可靠的第一道防线。它把大部分错误都拦截了，高层协议和应用层再负责剩下的</p><h2 id=mac地址>MAC地址</h2><ul><li>MAC地址（Media Access Control Address），又称物理地址或硬件地址</li><li>是分配给网络接口卡（NIC）的唯一标识符</li><li>长度为48位（6字节），通常以十六进制表示</li><li>形如：<code>8C:85:90:2F:34:91</code>或<code>8C-85-90-2F-34-91</code></li><li>高位 -> 低位</li></ul><h3 id=mac地址的结构>MAC地址的结构</h3><p>48位分成两个部分：</p><table><thead><tr><th>部分</th><th>长度</th><th>说明</th></tr></thead><tbody><tr><td><strong>前24位</strong>（OUI）</td><td>3字节（24位）</td><td>组织唯一标识符，分配给设备制造商（IEEE授权）</td></tr><tr><td><strong>后24位</strong></td><td>3字节（24位）</td><td>设备序列号，由制造商自行分配</td></tr></tbody></table><h3 id=mac地址的作用>MAC地址的作用</h3><ul><li>用于局域网内部设备的唯一识别</li><li>以太网帧头包含源MAC地址和目标MAC地址，帮助设备定位帧的发送者和接收者</li><li>与IP地址不同，MAC地址是硬编码在硬件里的（虽然可以软件修改，但一般不变）</li></ul><h3 id=mac地址的类型>MAC地址的类型</h3><p>1.单播地址（Unicast）</p><ul><li>唯一对应一个设备的地址，最高位（第一个字节的最低位）为0</li></ul><p>2.组播地址（Multicast）</p><ul><li>用于一组设备，最高位为1</li></ul><p>3.广播地址（Broadcast）</p><ul><li>特殊地址，所有位全为1（FF:FF:FF:FF:FF:FF），表示网络上所有设备</li></ul><h3 id=mac地址在通信中的流程>MAC地址在通信中的流程</h3><p>1.当一台设备要发送数据给另一台设备时，它会在帧头写上目标设备的MAC地址</p><p>2.以太网交换机会根据MAC地址转发帧</p><p>3.接收设备收到帧后，会检查目标MAC地址是否与自己匹配，匹配则处理数据，不匹配则丢弃</p><h3 id=补充arp协议>补充：ARP协议</h3><ul><li>IP地址时网络层地址，需要通过地址解析协议（ARP）将IP映射为对应的MAC地址，才能在链路层发送数据</li><li>ARP是IPv4环境下常见的协议，IPv6使用类似的邻居发现协议（NDP）</li></ul><h2 id=冲突检测>冲突检测</h2><p>这是以太网中一个非常重要的机制，尤其是在传统共享介质环境下保证通信顺畅的关键技术</p><h3 id=什么是冲突>什么是冲突</h3><p>在以太网的共享媒介（比如早期集线器环境）中，多个设备可能同时尝试发送数据</p><ul><li>当两个或多个设备同时发送时，信号会在媒介上叠加，导致数据冲突</li><li>冲突会导致传输的帧出现错误，所有冲突的数据都无法正确接收</li></ul><h3 id=以太网中的冲突检测机制csmacd>以太网中的冲突检测机制：CSMA/CD</h3><p>CSMA/CD = Carrier Sense Multiple Access With Collision Detection<br>载波监听多路访问/冲突检测</p><h3 id=csmacd工作流程>CSMA/CD工作流程</h3><p>1.载波监听（Carrier Sense）</p><ul><li>设备在发送数据前先“听”信道，确认当前信道是否空闲</li></ul><p>2.多路访问（Multiple Access）</p><ul><li>如果信道空闲，设备开始发送数据</li></ul><p>3.冲突检测（Collision Detection）</p><ul><li>设备在发送数据时，同时监听媒介信号</li><li>如果检测信号异常（冲突信号），说明冲突发生</li></ul><p>4.冲突处理</p><ul><li>发送设备立即停止发送数据</li><li>发送一个称为“冲突信号”的特殊信号，通知其他设备冲突发生</li></ul><p>5.退避算法（Backoff）</p><ul><li>设备等待一个随机时间（用二进制指数退避算法计算）</li><li>等待时间到后重新尝试发送</li></ul><h3 id=为什么要冲突检测>为什么要冲突检测</h3><ul><li>避免冲突导致数据长时间冲突和丢失</li><li>快速终止冲突传输，减少信道浪费</li><li>协调多个设备公平访问共享信道</li></ul><h3 id=举例>举例</h3><p>假设设备A和设备B同时监听到信道空闲，都开始发送：</p><ul><li>他们发送的信号在物理媒介上叠加，导致信号混乱</li><li>设备A和B检测到信号异常（冲突），立即停止发送</li><li>两个设备随机等待不同时间后，重新尝试发送</li></ul><h3 id=现代网络中的情况>现代网络中的情况</h3><ul><li>交换机网络（Switched Ethernet）几乎没有冲突，因为每个端口都是独占链路，支持全双工通信</li><li>因此，现代以太网实际应用中，CSMA/CD主要是历史遗留机制</li></ul><p>冲突检测主要存在于传统的以太网共享介质环境，但它不是所有网络技术都有的机制</p><h2 id=介质控制访问>介质控制访问</h2><p>主要负责协调多个设备如何共享同一物理传输媒介，保证数据有序、有效地传输</p><h3 id=什么是介质访问控制>什么是介质访问控制</h3><ul><li>介质访问控制是数据链路层的子层，解决多个设备如何共享公共传输介质的问题</li><li>它的核心任务是决定“谁什么时候能发送数据”，避免数据碰撞，提高网络效率</li></ul><h3 id=为什么需要介质访问控制>为什么需要介质访问控制</h3><p>假设多个设备共用一根网线或无线信道</p><ul><li>如果同时发送，信号就会碰撞，造成数据错误</li><li>需要一种机制协调设备访问权，避免冲突或减少冲突影响</li></ul><h3 id=常见的介质访问控制方法>常见的介质访问控制方法</h3><h4 id=竞争式访问contention-based-access>竞争式访问（Contention-based Access）</h4><p>设备竞争使用信道，常见协议有：</p><ul><li>CSMA/CD：以太网使用，监听信道，发现冲突后退避重发</li><li>CSMA/CA：无线网络Wi-Fi使用，通过监听信道和ACK确认避免冲突</li></ul><h4 id=非竞争式访问contention-free-access>非竞争式访问（Contention-free Access）</h4><p>采用集中管理，设备按顺序或规则访问信道：</p><ul><li><p>令牌环（Token Ring）
设备按顺序传递一个“令牌”，拥有令牌的设备才能发送</p></li><li><p>时分多址（TDMA，Time Division Multiple Access）
把时间分成若干时隙，设备在分配的时隙内发送</p></li><li><p>频分多址（FDMA，Frequency Division Multiple Access）
把频带划分成多个频道，每个设备用固定频道发送</p></li><li><p>码分多址（CDMA，Code Division Multiple Access）
设备用不同码序列共享同一频带</p></li></ul><p>优点：冲突少，适合高负载，实时要求高的场景</p><h2 id=数据链路层的典型协议>数据链路层的典型协议</h2><table><thead><tr><th>协议</th><th>用途</th></tr></thead><tbody><tr><td><strong>Ethernet</strong>（以太网）</td><td>局域网中最常见的数据链路层协议。</td></tr><tr><td><strong>PPP</strong>（点对点协议）</td><td>常用于串口连接、电话拨号网络等。</td></tr><tr><td><strong>HDLC</strong></td><td>思科设备之间通信常用，控制帧可靠传输。</td></tr><tr><td><strong>802.11（Wi-Fi）</strong></td><td>无线局域网数据链路层协议，包含复杂的MAC管理逻辑。</td></tr></tbody></table><h3 id=ethernet>Ethernet</h3><p>Ethernet是计算机网络中最重要、最经典的链路层协议之一，是日常生活和工作中局域网通信的基础协议。它实现了数据链路层的大部分功能，尤其是在局域网（LAN）中广泛使用</p><blockquote><p>Ethernet是一种数据链路协议，用于在局域网中传输数据帧，由IEEE定义为IEEE 802.3标准</p></blockquote><p>它解决了：</p><ul><li>如何打包数据成帧（帧格式）</li><li>如何给设备分配地址（MAC地址）</li><li>如何管理共享媒介（CSMA/CD）</li><li>如何检测和处理错误（CRC）</li></ul><table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td>传输介质</td><td>传统用双绞线、光纤，也支持同轴电缆</td></tr><tr><td>带宽速度</td><td>从10Mbps到10Gbps，甚至更高</td></tr><tr><td>访问控制方式</td><td>传统采用CSMA/CD，现代交换机全双工避免冲突</td></tr><tr><td>物理拓扑</td><td>早期是总线拓扑，现在多用星型拓扑</td></tr><tr><td>帧格式</td><td>固定帧结构，包含MAC地址、类型字段等</td></tr><tr><td>设备地址</td><td>使用唯一的48位MAC地址标识设备</td></tr></tbody></table><h4 id=以太网帧结构最常见的帧格式>以太网帧结构（最常见的帧格式）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>+------------+------------+--------------+-----------+---------------------+
</span></span><span style=display:flex><span>| 目标 MAC地址 | 源 MAC地址  | 类型字段（Type） | 数据部分    | CRC校验码      |
</span></span><span style=display:flex><span>| (6 Bytes)   | (6 Bytes)   | (2 Bytes)       | (46~1500B) | (4 Bytes)     |
</span></span><span style=display:flex><span>+------------+------------+--------------+-----------+---------------------+
</span></span></code></pre></div><table><thead><tr><th>字段</th><th>大小</th><th>作用</th></tr></thead><tbody><tr><td>目的 MAC 地址</td><td>6 字节</td><td>接收方设备的 MAC 地址</td></tr><tr><td>源 MAC 地址</td><td>6 字节</td><td>发送方设备的 MAC 地址</td></tr><tr><td>类型字段</td><td>2 字节</td><td>指明数据部分携带的是哪种协议（如 IPv4 为 0x0800）</td></tr><tr><td>数据部分（Payload）</td><td>46~1500 字节</td><td>传输的有效载荷（如IP数据包）</td></tr><tr><td>CRC 校验码</td><td>4 字节</td><td>检测数据是否在传输过程中出错</td></tr></tbody></table><blockquote><p>以太网帧最小长度为64字节，数据部分不足时会自动充填，最大为1518字节（不包括VLAN等扩展）</p></blockquote><h4 id=以太网帧界定>以太网帧界定</h4><p>以太网使用如下方式实现帧界定：</p><ul><li>前导码（Preamble）：<code>101010...10101011</code>（共8字节）</li><li>表示一个帧即将开始，帮助接收端时钟同步</li><li>后面紧跟着的是以太网帧的正式内容</li></ul><p>这不是“标识符”分隔，而是通过信号模式和协议规范来界定帧的开始</p><h3 id=ppp>PPP</h3><p>常用在点对点连接上，特别是拨号网络和某些宽带接入场景</p><h4 id=什么是ppp协议>什么是PPP协议</h4><ul><li>PPP协议是一种链路层协议，主要用于两个节点之间直接通信的点对点链路</li><li>它定义了链路的封装格式、链路建立、认证、协商以及错误检测等机制</li><li>适用范围：串口拨号连接（如早期的调制解调器拨号上网）、DSL宽带、VPN隧道等</li></ul><h4 id=ppp协议特点>PPP协议特点</h4><table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td>面向点对点链路</td><td>连接仅限两个端点，避免冲突和多路访问问题</td></tr><tr><td>封装灵活</td><td>支持多种网络层协议（IP、IPX、AppleTalk等）</td></tr><tr><td>链路控制</td><td>支持链路建立、维护和拆除</td></tr><tr><td>认证机制</td><td>支持PAP、CHAP等多种认证方式</td></tr><tr><td>差错检测</td><td>使用CRC16进行帧校验</td></tr></tbody></table><h4 id=ppp帧格式>PPP帧格式</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+--------+--------+---------+------------+----------+---------+
</span></span></span><span style=display:flex><span>| 标志位 | 地址   | 控制    | 协议字段    | 信息字段 | FCS校验  |
</span></span><span style=display:flex><span>| 1字节  | 1字节  | 1字节   | 2字节       | 变长     | 2字节    |
</span></span><span style=display:flex><span><span style=color:#a6e22e>+--------+--------+---------+------------+----------+---------+
</span></span></span></code></pre></div><ul><li>标志位（Flag）：固定为 <code>0x7E</code>，表示帧的开始和结束</li><li>地址（Address）：通常是广播地址 <code>0xFF</code></li><li>控制（Control）：通常为 <code>0x03</code>，表示无编号信息帧</li><li>协议字段（Protocol）：标识上层封装的协议类型（如IP为0x0021）</li><li>信息字段（Information）：封装的网络层数据。</li><li>帧校验序列（FCS）：16位CRC，用于检测传输错误。</li></ul><h4 id=ppp协议的工作过程>PPP协议的工作过程</h4><p>1.链路建立：通过LCP（链路控制协议）协商链路参数（最大传输单元、认证方式等）</p><p>2.认证阶段（可选）：使用PAP或CHAP认证连接双方身份</p><p>3.网络层协议协商：通过NCP（网络控制协议）协商所使用的网络层协议参数（如IP地址）</p><p>4.数据传输：链路建立和认证完成后，开始传输封装好的网络层数据</p><p>5.链路终止：通信结束时拆除链路</p><h4 id=ppp优点>PPP优点</h4><ul><li>灵活，支持多种网络协议</li><li>简单，适合点对点链路</li><li>支持身份认证，提高安全性</li><li>支持多种链路管理功能</li></ul><h4 id=应用场景>应用场景</h4><ul><li>早期拨号上网（通过电话线连接ISP）</li><li>DSL宽带连接</li><li>VPN隧道（例如PPTP就是用PPP封装的）</li><li>串口和同步链路通信</li></ul><h2 id=从帧转换成比特>从帧转换成比特</h2><h3 id=基本概念>基本概念</h3><ul><li>帧（Frame）：是数据链路层的基本传输单位，包含了“头部 + 数据 + 尾部”</li><li>比特（Bit）：是物理层的传输单位，0和1</li></ul><p>帧 -> 比特流：本质上就是将一整帧的数据按照物理层的编码方式，转成一串二进制信号，在线上发送</p><h3 id=转换过程>转换过程</h3><h4 id=1构建帧>1.构建帧</h4><p>例如以太网帧结构如下：</p><table><thead><tr><th>字段</th><th>长度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>前导码</td><td>7</td><td>帮助接收方同步</td></tr><tr><td>帧开始定界符（SFD）</td><td>1</td><td>标记帧开始</td></tr><tr><td>目的 MAC 地址</td><td>6</td><td></td></tr><tr><td>源 MAC 地址</td><td>6</td><td></td></tr><tr><td>类型 / 长度</td><td>2</td><td></td></tr><tr><td>数据（Payload）</td><td>46–1500</td><td></td></tr><tr><td>CRC（循环冗余校验）</td><td>4</td><td></td></tr></tbody></table><p>举例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>整个帧可能是：
</span></span><span style=display:flex><span>[前导码][SFD][目的MAC][源MAC][类型][数据][CRC]
</span></span></code></pre></div><p>这是完整的帧结构，每一项都是字节或多个字节组成</p><h4 id=2字节--比特准备物理层发送>2.字节 → 比特（准备物理层发送）</h4><p>每个字节 = 8个比特</p><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>字节：0x4F = 01001111
</span></span></code></pre></div><p>整个帧会被逐字节转成二进制流</p><h4 id=3比特--物理信号在物理层>3.比特 → 物理信号（在物理层）</h4><p>比特转信号依赖于编码方式（如曼彻斯特编码、NRZ、NRZI等）和物理媒介（如双绞线、光纤、无线电波）</p><p>例子：曼彻斯特编码</p><ul><li>0 -> 高 -> 低</li><li>1 -> 低 -> 高</li></ul><p>这样可以通过电压变化表示一个个比特。网卡会把这些编码后信号发送到传输媒介上</p><h3 id=发生位置>发生位置</h3><h4 id=发送端的网卡nic>发送端的网卡（NIC）</h4><p>这是转换帧为比特流、发送信号的核心设备，发生以下过程</p><table><thead><tr><th>阶段</th><th>动作</th><th>发生在</th></tr></thead><tbody><tr><td>构造帧</td><td>操作系统内核/驱动将数据打包成帧（如以太网帧）</td><td>CPU + 驱动软件</td></tr><tr><td>帧 ➝ 比特流</td><td>网卡把帧转成一串比特</td><td>网卡硬件</td></tr><tr><td>比特 ➝ 电信号</td><td>网卡将比特编码（如曼彻斯特）并转换为电压/光信号</td><td>网卡的物理层电路</td></tr><tr><td>物理信号传输</td><td>电信号通过网线、光纤或无线天线发送出去</td><td>网卡 + 媒介</td></tr></tbody></table><h4 id=接收端的网卡>接收端的网卡</h4><p>接收端网卡进行逆向过程</p><table><thead><tr><th>阶段</th><th>动作</th><th>发生在</th></tr></thead><tbody><tr><td>接收电信号</td><td>接收从线路来的信号（电压/光波）</td><td>网卡</td></tr><tr><td>电信号 ➝ 比特流</td><td>解码为 0/1 的比特流</td><td>网卡</td></tr><tr><td>比特流 ➝ 帧</td><td>按照协议组装出完整帧</td><td>网卡驱动</td></tr><tr><td>帧 ➝ 数据</td><td>交给操作系统协议栈（如 TCP/IP）处理</td><td>操作系统内核</td></tr></tbody></table><h4 id=实际例子>实际例子</h4><p>在浏览器中访问一个网站</p><ul><li>数据通过TCP/IP协议层层封装</li><li>系统调用网卡驱动，构造以太网帧</li><li>网卡将帧转换成比特流</li><li>比特流变成电信号，通过网线发送到路由器</li><li>路由器再转发这些帧，最后达到目标服务器</li><li>目标服务器的网卡解码比特流，解析帧，交给系统处理</li></ul></div><nav class=post-nav><a href=/csbasic/file/computernetwork/computernetwork/ class=hover:underline>pre: Computer Network</a>
<a href=/csbasic/file/computernetwork/network-layer/ class=hover:underline>next: Network Layer</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#它处理什么问题>它处理什么问题</a></li><li><a href=#数据链路层的结构>数据链路层的结构</a></li><li><a href=#层间关系>层间关系</a></li><li><a href=#帧的组成通用结构>帧的组成（通用结构）</a><ul><li><a href=#帧的界定>帧的界定</a><ul><li><a href=#为什么需要帧的界定>为什么需要帧的界定</a></li><li><a href=#常见的帧界定方式>常见的帧界定方式</a><ul><li><a href=#字节计数法byte-count>字节计数法（Byte Count）</a></li><li><a href=#字符充填法character-stuffing>字符充填法（Character Stuffing）</a></li><li><a href=#比特充填法bit-stuffing以太网使用>比特充填法（Bit Stuffing）以太网使用</a></li><li><a href=#基于物理层的编码规则如曼彻斯特编码>基于物理层的编码规则（如曼彻斯特编码）</a></li></ul></li></ul></li></ul></li><li><a href=#差错检测>差错检测</a><ul><li><a href=#差错为什么发生>差错为什么发生</a></li><li><a href=#差错检测的目标>差错检测的目标</a></li><li><a href=#常见差错检测的方法>常见差错检测的方法</a><ul><li><a href=#奇偶校验parity-check>奇偶校验（Parity Check）</a></li><li><a href=#循环冗余校验crccyclic-redundancy-check>循环冗余校验（CRC，Cyclic Redundancy Check）</a></li><li><a href=#校验和checksum>校验和（Checksum）</a></li><li><a href=#哈希函数>哈希函数</a></li></ul></li><li><a href=#差错检测流程简述>差错检测流程简述</a></li><li><a href=#差错检测的局限性>差错检测的局限性</a></li></ul></li><li><a href=#mac地址>MAC地址</a><ul><li><a href=#mac地址的结构>MAC地址的结构</a></li><li><a href=#mac地址的作用>MAC地址的作用</a></li><li><a href=#mac地址的类型>MAC地址的类型</a></li><li><a href=#mac地址在通信中的流程>MAC地址在通信中的流程</a></li><li><a href=#补充arp协议>补充：ARP协议</a></li></ul></li><li><a href=#冲突检测>冲突检测</a><ul><li><a href=#什么是冲突>什么是冲突</a></li><li><a href=#以太网中的冲突检测机制csmacd>以太网中的冲突检测机制：CSMA/CD</a></li><li><a href=#csmacd工作流程>CSMA/CD工作流程</a></li><li><a href=#为什么要冲突检测>为什么要冲突检测</a></li><li><a href=#举例>举例</a></li><li><a href=#现代网络中的情况>现代网络中的情况</a></li></ul></li><li><a href=#介质控制访问>介质控制访问</a><ul><li><a href=#什么是介质访问控制>什么是介质访问控制</a></li><li><a href=#为什么需要介质访问控制>为什么需要介质访问控制</a></li><li><a href=#常见的介质访问控制方法>常见的介质访问控制方法</a><ul><li><a href=#竞争式访问contention-based-access>竞争式访问（Contention-based Access）</a></li><li><a href=#非竞争式访问contention-free-access>非竞争式访问（Contention-free Access）</a></li></ul></li></ul></li><li><a href=#数据链路层的典型协议>数据链路层的典型协议</a><ul><li><a href=#ethernet>Ethernet</a><ul><li><a href=#以太网帧结构最常见的帧格式>以太网帧结构（最常见的帧格式）</a></li><li><a href=#以太网帧界定>以太网帧界定</a></li></ul></li><li><a href=#ppp>PPP</a><ul><li><a href=#什么是ppp协议>什么是PPP协议</a></li><li><a href=#ppp协议特点>PPP协议特点</a></li><li><a href=#ppp帧格式>PPP帧格式</a></li><li><a href=#ppp协议的工作过程>PPP协议的工作过程</a></li><li><a href=#ppp优点>PPP优点</a></li><li><a href=#应用场景>应用场景</a></li></ul></li></ul></li><li><a href=#从帧转换成比特>从帧转换成比特</a><ul><li><a href=#基本概念>基本概念</a></li><li><a href=#转换过程>转换过程</a><ul><li><a href=#1构建帧>1.构建帧</a></li><li><a href=#2字节--比特准备物理层发送>2.字节 → 比特（准备物理层发送）</a></li><li><a href=#3比特--物理信号在物理层>3.比特 → 物理信号（在物理层）</a></li></ul></li><li><a href=#发生位置>发生位置</a><ul><li><a href=#发送端的网卡nic>发送端的网卡（NIC）</a></li><li><a href=#接收端的网卡>接收端的网卡</a></li><li><a href=#实际例子>实际例子</a></li></ul></li></ul></li></ul></li></ul></nav></aside><script defer src=/js/scrollspy.js></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>