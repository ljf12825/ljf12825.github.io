---
title: "Game Development Core Concepts"
date: 2025-06-01
categories: [Note]
tags: [Fundamental]
author: "ljf12825"
summary: Abstraction and system layered design in game developmnet
---
数学的核心是形式化，工程的核心是权衡，计算机科学的核心就是抽象\
从底层到顶层，从电路到软件，抽象以各种形式存在于各个过程

## 为什么说抽象是核心
- 体系层面：计算机世界是人为构建的，没有自然规律必须规定“这样做”。一切系统都是分层设计的产物；真实的硬件指令、晶体管电路过于庞杂，人类无法直接操作这些细节；抽象层帮助屏蔽掉底层复杂性，让开发者用更高层的“模型”去思考问题
- 概念层面：在计算机科学中，抽象不仅是对实现细节的屏蔽，更是对问题的本质建模；人为划分的学科是对某个领域的抽象，某个领域是一系列相关概念的集合，而概念本身就是一种抽象，例如：
  - 数据结构是对存储方式和操作的抽象
  - 算法是对解决步骤的抽象
  - 进程是对程序运行的抽象
  - 类是对现实事物和行为的抽象

开发者不是直接跟“机器”打交道，而是用“概念”去思考和操作。而抽象是把“具体细节”提炼成“普遍概念”。而编程能力 = 使用抽象的能力 + 构建抽象的能力

## 游戏开发
游戏开发是技术性、艺术性和商业性的融合，它包括：
- 计算机科学的抽象：算法、数据结构、图形学、网络、AI
- 工程抽象：引擎架构、模块化、组件系统、工具链
- 艺术抽象：视觉（美术、动画、特效）、听觉（音乐、音效）
- 人类学抽象：交互设计、玩家心理学、叙事学

游戏开发的特点在于以下几个方面
- 架构与主循环
  - 传统软件
    - 多是事件驱动：用户点击按钮 -> 程序响应 -> 完成一次逻辑
    - 没有严格的全局循环，更多依赖操作系统的消息机制
  - 游戏开发
    - Game Loop是核心
    - 每一帧都要处理输入、物理、AI、渲染 -> 保证实时性
- 数据与状态管理
  - 大量瞬时数据（角色坐标、速度、动画状态、AI决策等）
  - 状态每帧都在更新，生命周期可能只有几毫秒
  - 引擎常用ECS架构或对象池优化性能
- 图形与界面
  - 实时渲染管线：3D模型、材质、光照、阴影、后处理
  - UI也是游戏世界的一部分（血条、HUD、动态菜单）
  - 需要GPU编程（Shader、OpenGL/DirectX/Vulkan/Metal）
- 输入处理
  - 输入是连续流：键盘、鼠标、手柄、触摸、VR控制器
  - 必须处理高频输入事件，并和游戏循环绑定（如角色移动、镜头旋转）
  - 需要支持多平台输入抽象（PC、主机、移动）
- 性能与优化
  - 性能优化是日常工作
    - CPU -> AI/物理/逻辑优化
    - GPU -> Draw Call减少、LOD、光照烘焙
    - 内存 -> 对象池、资源管理
- 多人与网络
  - 多人游戏需要实时同步（50~60次/秒）
  - 处理网络延迟与抖动：预测（Client Prediction）、插值、回滚（Rollback Netcode）
  - 技术难度远高于传统C/S架构
- 调试与测试
  - 自动化测试覆盖有限（尤其是“手感”“平衡性”）
  - 调试常依赖游戏内调试工具（DebugUI、可视化碰撞框、日志叠加）
  - QA需要人工长时间试玩，找“试玩bug”
- 团队协作
  - 多工种融合：程序 + 美术 + 设计师 + 音效 + 策划
  - 美术资源和程序逻辑高度耦合（模型、贴图、动画都要引擎支持）
  - 迭代过程常常是“美术换素材 -> 程序适配 -> 调整玩法”

### 技术层面的抽象概念
抛开引擎，语言，工具链，游戏开发的核心本质可以抽象为以下层面
#### 最底层的抽象：状态与变换
- 游戏本质上是：在时间维度上不断更新状态
- 状态：数据
- 变换规则：物理公式、输入逻辑、AI决策、脚本事件...
- 抽象公式：$State_{t+1} = f(State_t, Input_t, \Delta t)$
> 单机游戏是确定性状态机（输入决定下一步）；网络游戏是部分不确定状态机（网络延迟、同步问题让同一状态在不同客户端不一致，需要预测/回滚）

所有游戏逻辑，都可以抽象为“状态机 + 时间推进”

#### 核心抽象：循环（Game Loop）
Game Loop是游戏引擎的心脏，所有游戏逻辑、渲染、输入处理、物理更新都围绕它转\
**核心思想：循环 + 时间驱动**\
每一帧游戏世界都要经历一套固定流程\
```cpp
while (game_is_running) {
    process_input();   // 处理输入：键盘、鼠标、手柄、触屏
    update(deltaTime); // 更新游戏逻辑：AI、动画、物理、状态
    render();          // 渲染：把当前世界画出来
}
```
- 输入：把玩家和外部事件（键盘、鼠标、网络消息）收集进来
- 更新：基于输入和时间推进游戏世界状态。这会涉及物理计算、角色移动、碰撞检测、AI逻辑等
- 渲染：把结果绘制到屏幕，交给GPU显示

游戏引擎的核心就是封装了这个主循环

##### 时间控制：`deltaTime`
CPU/GPU性能和环境不同，循环速度会变化。为了保证游戏逻辑的一致性，需要引入帧间隔时间：
- `deltaTime` = 当前帧时间 - 上一帧时间
- 所有物体移动、动画更新都基于`deltaTime`来计算，而不是“每帧加1”
```cpp
position += velocity * deltaTime;
```

##### 固定更新 vs 可变更新
很多引擎（比如Unity、Unreal）会区分
- Fixed Update：逻辑、物理更新用固定时间步长（比如0.02秒一次）。保证物理模拟稳定、确定
- Variable Update：渲染和输入随帧率变化，每次循环一次

这就是为什么Unity里有`Update()`和`FixedUpdate()`两个钩子


#### 结构抽象：实体与组件
- 游戏事件由许多对象组成
- 最常见的抽象是ECS（Entity-Component-System）或Node/Scene
- 公式化：
  - 实体（Entity）：唯一ID，对象存在本身
  - 组件（Component）：数据（位置、生命、动画...）
  - 系统（System）：处理逻辑（移动系统、渲染系统...）

这就是现代引擎常见的设计模式

#### 行为抽象：事件与消息
- 游戏逻辑不是线性流程，而是大量事件驱动
  - 玩家按下键 -> 发射子弹
  - 怪物死亡 -> 掉落物品
- 所以技术抽象是：事件系统 / 信号系统
- 这让不同模块解耦，支持扩展

#### 表现抽象：渲染管线
- 游戏最终要呈现给玩家
- 渲染管线抽象：
  - 世界数据（模型、灯光、材质）
  - 变换（矩阵：世界 -> 摄像机 -> 投影）
  - 光照/Shader计算
  - 输出像素到屏幕

渲染其实就是：数学变换 + 并行计算

#### 系统抽象：资源与时间
- 游戏是大规模资源的组织：纹理、音效、脚本、AI
- 技术抽象上，需要资源管理（加载、缓存、卸载）
- 同时要保证实时性：60fps/120fps的节奏约束

游戏开发技术层面的抽象概念是“实时状态机 + 事件驱动的交互循环”，引擎则是帮助把这些抽象组织好
