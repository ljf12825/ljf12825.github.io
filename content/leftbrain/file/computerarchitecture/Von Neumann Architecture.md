---
title: Von Neumann Architecture
date: 2025-12-31
author: ljf12825
summary: Von Neumann Architecture
type: file
---

# 冯·诺依曼体系结构
这是计算机科学中最重要的基础概念之一，它被称为“存储程序计算机”的蓝图，至今仍然是几乎所有现代计算机设计的理论基础\
它的核心思想是**存储程序**\
在 Von 之前，早期的计算机（如ENIAC）是为特定任务而设计的，通过重新布线或配置开关来改变其功能，这非常繁琐且效率低下\
Von 在1945年的一份报告中提出了一个革命性的思想：将程序指令和数据一起存储在计算机内存中\
这意味着计算机不需要物理上的重新布线来执行新任务，只需加载不同的程序即可。这使得计算机成为了真正的通用机器

![Von Neumann Architecture](/images/content/Von_Neumann_Architecture.svg)

## 组成核心
冯氏架构将计算机划分为五个核心部件，它们通过“数据/指令总线”互相连接：
1. 运算器
  - 功能：负责执行所有的算数运算（加、减、乘、除）和逻辑运算（与、或、非、比较）
  - 类比：人的大脑中负责计算的部分

2. 控制器
  - 功能：是整个计算机的“指挥中心”。它从内存中读取指令，进行解码，然后向其他所有部件发出控制信号，协调它们一步一步地执行指令
  - 关键点：运算器和控制器结合在一起，就是我们现在常说的CPU

3. 存储器
  - 功能：用于存储程序（指令）和数据。它是一个线性的、按地址访问的存储空间
  - 关键特性：
    - 可寻址：每个存储单元都有一个唯一的地址，CPU通过地址来读写数据
    - 统一存储：指令和数据不加区分地存放在同一个存储器中。这是冯氏架构的核心特征
  - 类比：人的记忆，既要记得做什么事（程序），也记着事情的具体信息（数据）

4. 输入设备
  - 功能：用于将程序和数据从外部世界输入到计算机内部
  - 例子：键盘、鼠标、扫描仪、触摸屏等
  - 类比：人的眼睛、耳朵、皮肤等感官

5. 输出设备
  - 功能：用于将计算机处理后的结果呈现给外部世界
  - 例子：显示器、打印机、音响等
  - 类比：人的嘴巴、手（用于书写和动作）

![Von Neumann Architecture Flow Chart](/images/content/VonNeumannArchitectureFlowChart.svg)

## 特点
1. 以运算单元为中心
  - 内容：在最初的设计中，所有部件的操作都围绕运算器展开
    - 数据从存储器送到运算器进行处理
    - 处理结果从运算器送回到存储器
    - 输入设备的数据通过运算器送入存储器
    - 存储器的数据通过运算器送给输出设备
  - 现代演变：这个特点在现代计算机中已经发生了巨大变化。由于I/O操作比CPU运算慢得多，让高速的CPU等待低速的I/O设备是极大的浪费。因此，现代计算机结构已经转变为以存储器（内存）为中心
    - 数据流：数据直接在存储器和I/O设备之间流动（通过[DMA](#dmadirect-memory-access)技术），不再需要经过CPU的运算器，极大地提高了效率。CPU只负责发起和控制这些传输

2. 采用存储程序原理
这是最根本、最革命性的特点，将指令作为一种特殊的数据来处理让机器能够改变自身的行为
  - 内容：程序（指令）和数据以二进制形式不加区分地存储在同一个存储器（内存）中
  - 意义：
    - 通用性：计算机通过读取并执行不同的程序来完成不同的任务，而无需更改硬件结构。这使得计算机从专用机器变成了通用机器
    - 自动化：程序可以像数据一样被处理（例如，由编译器生成、被操作系统加载）。计算机可以自动地、顺序地从内存中取出指令执行，从而实现高度自动化

**与“哈佛结构”的对比**\
哈佛结构将程序指令和数据存储在两个物理上独立的存储器中。这在现代处理器中很常见（如很多DSP、ARM芯片的一级缓存），因为它可以同时读取指令和数据，速度更快。但在宏观层面，现代计算机仍然是冯·诺依曼机器，因为它的主内存（RAM）仍然是统一存储程序和数据的

3. 存储器是按地址访问，按线性编址的空间
  - 按地址访问：内存被划分为大量微小的、大小固定的存储单元（通常是1个字节，即8位）。每个单元都被赋予一个唯一的、永久的内存地址；CPU要访问（读取或写入）内存中的数据或指令时，必须提供其所在的地址。内存控制器根据这个地址，找到对应的物理存储单元，然后进行数据操作
  - 按线性编址：所有存储单元的地址从0开始，依次递增（0, 1, 2, 3, ...），形成一个连续、一维的地址空间
    - 简单性：这种一维的编址方式使得硬件设计（如地址总线、内存控制器）变得非常简单和统一
    - 可预测性：如果知道了一个数据的起始地址和它的数据类型，CPU就能轻松计算出下一个数据的位置（+offset）

4. 控制流由指令流产生
  - 程序控制：整个计算机的工作过程，就是连续自动地执行预先存储在内存中的程序的过程。控制器根据程序指令，发出微操作命令，控制全机协调工作

5. 指令由操作码和地址码组成
  - 一条典型的机器指令包含两个核心字段：
    - 操作码：做什么
    - 地址码：对谁做

6. 数据以二进制编码
  - 二进制：计算机内部使用二进制（0和1）来表示一切信息（指令、数据、地址），因为二进制物理上更容易实现（高低电平、通断开关）

7. 顺序执行
  - 内容：CPU通常顺序地执行指令。它有一个叫做程序计数器的关键寄存器，里面存放下一条要执行的指令的地址。CPU取出指令后，程序计数器通常自动+1，指向下一条指令
  - 意义：这是一种简单而有效的控制流程方式。虽然现代CPU有流水线、乱序执行等复杂技术来提高效率，但在逻辑上，它们最终仍然需要伪装成顺序执行的结果，以保证程序的正确性


## 瓶颈
核心瓶颈：以存储器为中心的单一通道\
问题的本质：在经典冯氏架构中，CPU（运算器 + 控制器）和存储器之间只有一条共享的数据通道（总线）\
这意味着：
1. CPU无法同时做两件事：它不能再同一次操作中既读取指令又写入指令
2. 指令和数据争夺通道：指令和数据都要通过同一条通道来回运输。当数据量大时，指令就得等待，反之亦然

这个单一的、共享的通道，严重限制了处理器和内存之间的数据传输速率，从而成为整个系统性能的主要制约因素。CPU的速度再快，如果无法及时从内存拿到指令和数据，也只能空转

### 具体表现与衍生问题
这个核心瓶颈再现代计算中具体表现为以下几个主要方面：
1. CPU与内存的速度鸿沟
CPU的处理速度（纳秒级）远远超过内存的读写速度（百纳秒级）。CPU执行一条指令可能只需要一个时钟周期，但从内存读取数据可能需要上百个时钟周期。大部分时间CPU都处于等待数据的停滞状态。虽然用高速缓存来缓解这个问题，但缓存本身也是冯·诺依曼瓶颈的一种“补丁”，而非架构上的根本解决

2. 访存冲突
由于指令和数据存放在同一存储器，当CPU需要同时进行取指令和取操作数时（这在流水线操作中非常常见），就会发生冲突，只能分时进行，降低了效率

3. 有限的并行性
传统的冯氏架构本质上是串行的。它一次执行一条指令，处理一个数据流。这种“单指令流单数据流”模型难以高效地处理那些可以并行计算的任务（如图形处理、科学计算、大数据分析等）。虽然我们现在有多核处理器，但这本质上是在一个芯片上放了多个独立的“冯·诺依曼机器”，并通过复杂的缓存一致性协议让它们协作，是一种“横向扩展”，而非改变其核心工作模式

4. 安全性问题
“存储程序”思想意味着指令和数据不加区分。这为某些安全漏洞提供了土壤。例如，如果程序存在缺陷（如缓冲区溢出），攻击者可以精心构造数据，并让程序将这些数据当作指令来执行，从而植入并运行恶意代码

### 现代计算机的改进
现代架构没有推翻冯·诺依曼体系，而是通过各种技术在其框架内尽力缓解这些瓶颈
1. 存储器层次结构：引入高速缓存。在CPU和主内存之间增加多级高速、小容量的缓存，存放最常用的指令和数据，极大减少了CPU访问慢速主内存的次数
2. 流水线技术：将指令执行过程分解为多个阶段（取指、译码、执行、访存、写回），让多条指令的不同阶段重叠执行，就像工厂的装配线，提高了吞吐率
3. 哈佛架构及其变种：
  - 纯哈佛架构：为指令和数据提供独立的存储空间和总线，可以同时取指令和读数据
  - 现代存储器的做法：在芯片内部（尤其是一级缓存L1 Cache）采用哈佛架构（分设指令缓存和数据缓存）而在外部连接主内存时仍使用冯·诺依曼架构。这兼顾了效率和通用性
4. 多核与并行计算：通过集成多个处理核心，真正同时执行多个指令流，应对并行任务
5. 预取技术：CPU预测下一步可能需要的数据，提前将其从内存加载到缓存中
6. 更宽的总线：增加数据通道宽度，一次可以传输更多数据

## 哈佛架构
核心思想：独立的存储与通路\
哈佛架构最根本的特点是：将程序指令和数据存储在两个物理上相互独立的存储器中，并分别为它们提供独立的数据通路和地址总线

### 特点
#### 优势
1. 更高的执行效率（解决冯·诺依曼瓶颈）
  - CPU可以同时读取一条指令和一个数据字（例如，进行上一次计算的结果写回），而无需共享一条总线。这实现了并行操作，大大提升了吞吐率
  - 避免了指令流和数据流争夺同一总线带来的冲突

2. 可能更小的指令尺寸
  - 由于指令存储器和数据存储器是分开的，指令字长可以针对最佳编码密度进行优化，而不必与数据的字长相同

3. 更高的可靠性/安全性
  - 程序指令和数据物理隔离，使得程序指令通常不会被意外地修改，提高了系统的稳定性
  - 这也提供了一层天然的安全保护：数据空间的内容很难作为代码被执行，在一定程度上防范了某些基于代码注入的攻击

#### 缺陷
1. 设计更复杂，成本更高
  - 需要两套完整的存储系统、两套总线（数据总线和地址总线），增加了硬件设计的复杂性和芯片制造成本

2. 灵活性降低
  - 在纯粹的哈佛架构中，指令存储器是只读的，程序一旦加载就无法动态修改。这使得运行时代码生成、自我修改代码等技术无法实现，限制了某些高级编程技术的应用
  - 内存管理变得更加复杂，需要为两种内存分别分配和管理空间

### 现代应用：改良的哈佛架构
纯粹的哈佛架构（两条完全独立的总线）在通用计算机中很少见，但其思想被广泛采纳和发展，形成了“改良的哈佛架构”

其特点是：
- 在CPU内部缓存级别采用哈佛架构。例如，现代CPU的一级缓存通常分为指令缓存和数据缓存
- 在CPU外部（连接主内存）仍使用冯·诺依曼架构，共享同一主内存和系统总线

工作流程：
1. CPU从主存（统一存储）中将指令和数据批量加载到内部的高速缓存中
2. 在缓存级别，CPU核心可以同时、高速地访问I-Cache和D-Cache，享受哈佛架构的并行性带来的高性能
3. 当缓存未命中时，才去访问统一的慢速主内存

这种设计完美地结合了两种架构的优点：
- 高性能：通过内部的缓存并行提升了速度
- 通用性和灵活性：外部的统一内存使得程序可以灵活加载和修改，操作系统管理内存也更简单

### 主要应用领域
1. 数字信号处理器：是哈佛架构的经典应用领域。DSP处理的数据流非常庞大，需要极高的、可预测的吞吐率，同时读取指令和处理数据至关重要
2. 微控制器：如ARM9系列、Microchip的PIC系列、Intel的8051等。这些芯片将程序固化在片内Flash（指令存储器）中，而将变量存放在片内RAM（数据存储器）中，结构简单，效率高
3. 现代CPU的缓存设计

## TODO:
### DMA（Direct Memory Access）
> 操作系统开发，嵌入式开发，驱动开发需要学习

直接内存访问技术，能够让外设与内存直接交换数据，绕过CPU，从而提高数据传输效率和处理速度。它广泛应用于高速数据传输、音视频处理、网络设备等需要高效数据交换的场景