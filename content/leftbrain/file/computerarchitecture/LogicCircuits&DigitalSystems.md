---
title: Logic Circuits and Digital System
date: 2025-12-31
author: ljf12825
summary: logic circuits and digital system
type: file
---

逻辑电路与数字系统是计算机硬件和电子学的基础，涉及信号的处理、存储和运算等基本操作\
它们由一系列的逻辑门、寄存器、时序逻辑单元等构成，通过逻辑运算实现特定功能

## 逻辑电路
逻辑电路由基本的逻辑门组成，这些门接受输入信号并根据特定的规则产生输出

### 逻辑门

| 名称 | 描述 | 真值表 |
| - | - | - |
| 与门（AND Gate）| 只有所有输入都是1时，输出才为1 | `A AND B = A * B` |
| 或门（OR Gate）| 只要有一个输入为1, 输出就为1 | `A OR B = A + B` |
| 非门（NOT Gate）| 对输入信号进行反转，0变1, 1变0 | `NOT A = A'` |
| 异或门（XOR Gate）| 只有输入不同才输入1, 相同则输出0 | `A XOR B = A ⊕ B` |
| 与非门（NAND Gate）| 与门输出取反 | `A NAND B = (A * B)'` |
| 或非门（NOR Gate）| 或门输出取反 | `A NOR B = (A + B)'` |

## 组合逻辑电路
组合逻辑电路是指其输出只与当前输入相关的电路，不依赖于先前的输入。常见的组合逻辑电路有
- 加法器：二进制加法器，如半加器和全加器，用于二进制加法运算
  - 半加器：两位二进制数相加
  - 全加器：两个半加器
- 乘法器：二进制乘法器，可以通过加法器和位移操作实现
- 比较器：比较输入值的大小，输出相应的比较结果

### 加法器
加法器是数字电路中最基本、最重要的运算单元之一，它的核心功能是执行两个二进制数的算术加法。它是CPU中算术逻辑单元（ALU）的基石

#### 半加器
想象一下，我们只计算两个1位的二进制数相加，比如0+0, 1+1, 0+1, 1+0 这需要两个输出
- 和：当前位的计算结果
- 进位：如果结果大于1,就需要向更高位进位

能完成这个功能的电路就叫半加器
- 输入：两个1位二进制数，通常称为A和B 
- 输出：
  - 和：通常用S表示
  - 进位：通常用C_out表示

**真值表**

| A | B | S | C_out |
| - | - | - | - |
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |

观察真值表，可以发现
- S的输出和异或门一模一样。所以`S = A XOR B`
- C_out 的输出和与门一模一样。所以`C_out = A AND B`

**电路图**
```text 
A ──┐
    │ XOR ──> S
B ──┘

A ──┐
    │ AND ──> C_out
B ──┘
```

> 为什么叫半加器，因为它只能处理两个输入，无法处理来自低位的进位。在真正的多位加法中，每一位的计算都需要考虑三个输入：A, B和来自低位的而进位

#### 全加器
为了解决半加器的缺陷，引入了全加器。全加器是构建任何多位加法器的核心模块
- 输入：三个1位二进制数
  - A（被加数的一位）
  - B（加数的一位）
  - C_in（来自低位的进位）
- 输出
  - S(本位的和)
  - C_out（向高位的进位）

**真值表**
| A | B | C_in | S | C_out |
| - | - | - | - | - |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |

**实现方式**
全加器可以用两个半加器和一个或门来构建
1. 第一个半加器计算A和B的和与进位
  - `S1 = A XOR B`
  - `C1 = A AND B`
2. 第二个半加器计算S1和C_in的和与进位
  - `S = S1 XOR C_in`（这就是最终的和）
  - `C2 = S1 AND C_in`
3. 最终的进位输出是C1或C2任何一个为真即可
  - `C_out = C1 OR C2`

**电路图（由两个半加器构成）**
```text 
        ┌──────────┐
A ──────┤          │      ┌──────────┐
        │  半加器1 ├─S1───┤          │
B ──────┤          │      │  半加器2 ├─── S (最终和)
        └──────────┘      │          │
            │ C1      C_in└──────────┘
            │              │
            │              │ C2
            └──────────────┼────┐
                           │    │ OR ─── C_out (最终进位)
                           └────┘
```

#### 多位加法器：串联全加器
可以用全加器来构建计算多位二进制数（比如4位、8位、32位、64位）的加法器\
最直接的方式是行波进位加法器

**结构**
- 将n个全加器串联起来
- 第一个全加器的C_in接地（表示0）
- 每一个全加器的C_out连接到下一个全加器的C_in 

**4位行波进位加法器示意图**
```text 
    A3 B3        A2 B2        A1 B1        A0 B0
     │  │         │  │         │  │         │  │
    ┌▼──▼┐       ┌▼──▼┐       ┌▼──▼┐       ┌▼──▼┐
C_in│    │   C_in│    │   C_in│    │   C_in│    │
◄───┤ FA ├──────►┤ FA ├──────►┤ FA ├──────►┤ FA ├───► C_final
    │    │C_out  │    │C_out  │    │C_out  │    │C_out 
    └──┬─┘       └──┬─┘       └──┬─┘       └──┬─┘
       S3           S2           S1           S0
```

**缺点**
- 速度慢：进位信号必须像波浪一样从最低位（FAO）传递到最高位(FA3）。如果FA0产生了进位，这个进位必须等待它经过FA1、FA2，才能最终影响FA3的结果。这被称为进位传播延迟
- 对于32位或64位的CPU来说，这种延迟是不可接受的

#### 现代高速加法器：超前进位加法器
超前进位加法器的设计为了解决行波进位的速度问题

##### 核心思想
与其等待进位信号一步步传递，不如提前计算每一位的进位\
它通过一个复杂的逻辑电路，直接根据所有位的输入（A0, B0, A1, B1, ...）和最初的C_in, 并行地计算出每一位的进位（C1, C2, C3, ...）

##### 实现原理
它利用了“进位生成”和“进位传播”的概念
- 生成：如果A和B都是1, 那么这一位一定会产生进位
  - `G = A AND B`
- 传播：如果A或B是1, 那么来自低位的进位将会传递到高位
  - `P = A XOR B` 

那么，每一位的进位可以表示为：
- `C0 = C_in`（已知）
- `C1 = G0 OR (P0 AND C0)`
- `C2 = G1 OR (P1 AND G0) OR (P1 AND P0 AND C0)`
- `C3 = G2 OR (P2 AND G1) OR (P2 AND P1 AND G0) OR (P2 AND P1 AND P0 AND C0)`
- ... ...

可以看到，只要有了A0~A3, B0~B3和C_in，通过一层多输入的逻辑门（与或门），就可以同时算出C1, C2, C3, 而不需要等待前一级的结果

##### 优缺点
- 优点：速度极快，延迟基本固定，与位数关系不大。是现代CPU的首选
- 缺点：电路非常复杂，位数越高，进位计算逻辑的输入就越多，电路规模呈指数级增长。因此，在实际中通常采用折中方案（如分组超前进位）

> 从简单的半加器到复杂的超前进位加法器，这个演进过程完美地体现了计算机工程中的一个核心权衡：在速度、复杂度和成本之间做出取舍。而这一切，都始于对"1 + 1 = 10" 这个二进制运算的深刻理解

> 一句话概括超前进位加法器核心思想：水到渠成

#### 总结


| 类型 | 功能 |	关键输入 | 关键输出 | 特点 |
| - | - | - | - | - |
| 半加器 | 两个1位二进制数相加 | A, B | S, C_out | 基础单元，无法处理进位输入 |
| 全加器 | 三个1位二进制数相加 | A, B, C_in	| S, C_out | 构建任何加法器的核心模块 |
| 行波进位加法器 | 多位二进制数相加	| A[n], B[n] | S[n]	| 结构简单，速度慢，有进位延迟 |
| 超前进位加法器 | 多位二进制数相加	| A[n], B[n] | S[n]	| 结构复杂，速度极快，无进位延迟 |


### 乘法器
乘法的基础是”位移与加法“\
以两个4位二进制数`A(A3 A2 A1 A0)`和`B(B3 B2 B1 B0)`为例，其计算过程类似于十进制乘法
```text 
         A3 A2 A1 A0  (被乘数)
       x B3 B2 B1 B0  (乘数)
----------------------
         A3 A2 A1 A0  <-- B0为1时，这是第一行部分积
       A3 A2 A1 A0    <-- B1为1时，这是第二行部分积（左移1位）
     A3 A2 A1 A0      <-- B2为1时，这是第三行部分积（左移2位）
   A3 A2 A1 A0        <-- B3为1时，这是第四行部分积（左移3位）
----------------------
P7 P6 P5 P4 P3 P2 P1 P0  (最终乘积)
```
乘法器的核心任务就是高效地生成这些部分积，并将它们相加

#### 移位加法乘法器
这是最直观、最容易理解的方法，直接模拟上述手算过程

##### 工作原理（以4位为例）
1. 初始化：将一个8位的乘积寄存器`P`清零
2. 循环检查：从最低位开始，依次检查乘数`B`的每一位`B[i]`
3. 判断与加法：如果`B[i] == 1`，则将被乘数`A`左移`i`位后的值，加到乘积寄存器`P`
4. 循环：重复步骤2和3,直到检查完乘数`B`的所有位

##### 结构示意图
```text 
    被乘数 A (4位) ────┐
                       │
    乘数 B (4位) ──> [控制逻辑] ──> (检查当前位B[i]是否为1)
                       │
    乘积 P (8位) <── [加法器] <── (左移器，根据i移位A)
                       │
                    [移位控制] (控制左移位数)
```

##### 优缺点
- 优点：电路结构非常简单，占用资源少
- 缺点：速度非常慢。对于一个n位乘法，需要大约n个时钟周期（检查n位），并且每个周期都可能进行一次n位的加法。延迟是O(n)量级

#### 阵列乘法器
为了提升速度，采用”空间换时间“，将多个加法器组织成一个阵列，以便并行地计算部分积的和

**核心思想：同时生成所有部分积，并用一个加法器阵列一次性将它们加起来**

##### 结构（以4位无符号数为例）
1. 部分积生成：通过一排与门阵列实现。`B0`和`A`的每一位相与，生成第一行部分积；`B1`和`A`的每一位相与，生成第二行（左移1位），以此类推。这样就得到了四个部分积
2. 加法器阵列：使用全加器作为基本单元，以类似”人工计算“时按列相加的方式，将部分积斜向对齐后，一层一层地加起来

##### 简化示意图（体现按列相加的思想）
```text 
        A3   A2   A1   A0
      x B3   B2   B1   B0
-------------------------
      P03  P02  P01  P00  (B0 & A) <- 第一行部分积
   P13  P12  P11  P10     (B1 & A) <- 第二行部分积
P23  P22  P21  P20        (B2 & A) <- 第三行部分积
P33  P32  P31  P30        (B3 & A) <- 第四行部分积
-------------------------
[全加器阵列，按斜线连接的列进行加法，并传递进位]
-------------------------
P7   P6   P5   P4   P3   P2   P1   P0
```

##### 优缺点
- 优点：速度比移位加法法快得多。因为它是一个纯组合逻辑电路，信号从输入到输出一波流，不需要时钟控制。延迟主要由关键路径上的加法器链决定，约为O(n)，但常数因子远小于移位加法法
- 缺点：需要大量的逻辑门（与门和全加器），硬件成本高。对于32位或64为乘法，电路规模会非常庞大

#### 现代高性能乘法器：沃里斯树
对于CPU中的高性能乘法器，单纯的行波进位阵列仍然不够快。于是引入了更先进的结构————沃里斯树

**核心思想：使用一种树形结构来快速压缩部分积的数量**
- 第一步：部分积生成-与传统阵列乘法器相同
- 第二步：部分积压缩-这是关键。WT使用一种名为”进位保留加法器“的单元（通常是3:2压缩器或4:2压缩器），以树形结构将多个部分积快速压缩为两个数（例如，`Sum`和`Carry`)
  - 3:2压缩器：输入3个二进制数，输出2个二进制数（一个和向量，一个进位向量），其数值综合等于三个输入数之和
  - 通过多层这样的压缩，可以迅速将16个、32个部分减少到最后的2个
- 第三步：最终相加-将树形结构输出的两个数（`Sum`和`Carry`），通过一个超前进位加法器进行最终相加，得到乘积结果


##### 工作流程比喻
要把一大堆（比如16堆）硬币数清楚
1. 阵列乘法器：像银行新手，两堆两堆地数，数完合一起再和下一堆数，效率低
2. 沃里斯树：像经验丰富的团队
  - 压缩阶段：先把16堆硬币，每3堆分给一个小组（3:2）压缩器。每个小组快速地数出”本地和“与”需要进位的整摞硬币“，输出为两堆。这样16堆就变成了～11堆
  - 重复这个过程，11堆-> 8堆-> 6堆 -> 4堆 -> 2堆
  - 最终相加：最后剩下的两堆，交给一个”神算手“（超前进位加法器）做最后一次精确计算，得出总数

##### 优缺点
- 优点：速度极快。部分积压缩的延迟是O(log n)，这是数量级的提升。是现代高性能CPU和DSP（数字信号处理器）的首选
- 缺点：电路结构非常复杂，布局布线困难，功耗和面积都很大

#### 总结

| 类型 | 核心原理 | 速度 | 硬件成本 | 应用场景 |
| - | - | - | - | - |
| 移位加法乘法器 | 串行、迭代、移位加 | 慢（O(n)）| 低 | 对面积和功耗及其敏感，速度要求不高的嵌入式系统 |
| 阵列乘法器 | 并行、组合逻辑、加法器阵列 | 中（O(n)）| 中 | 早期处理，对速度有一定要求但不需要极致的场景 |
| 沃里斯树 | 并行、树形结构、部分积压缩 | 快（O(log n)）| 高 | 现代高性能CPU、GPU、DSP |

> 从乘法器的发展可以看出，计算机工程始终在速度、面积（成本）、功耗这个”不可能三角“中进行权衡和优化

### 比较器
比较器是数字电路中用于比较两个数字大小的基本组件，其核心功能是判断两个二进制数A和B的大小关系，并输出三个可能的结果之一：`A > B`, `A < B`, 或`A = B` 

#### 1位比较器
比较两个1位的二进制数A和B

##### 真值表

| A | B | A > B | `A < B` | A = B |
| - | - | - | - | - |
| 0 | 0 | 0 | 0 | 1 |
| 0 | 1 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 0 |
| 1 | 1 | 0 | 0 | 1 |

根据真值表，可以直接写出逻辑表达式
- `A > B`: `A AND (NOT B)`
- `A < B`: `(NOT A) AND B` 
- `A = B`: `A XNOR B`（即`(A AND B) OR ((NOT A) AND (NOT B))`）

##### 电路图

```text 
A ──┐
    │ AND ────> A > B
B ──┘ NOT

A ──┐ NOT
    │ AND ────> A < B
B ──┘

A ──┐
    │ XNOR ───> A = B
B ──┘
```
这个1位比较器是构建更复杂比较器的基础模块 

#### 多位比较器：级联比较器
如何比较两个多位数（例如4位）`A3 A2 A1 A0`和`B3 B2 B1 B0`\
最直观的方法是从最高位开始逐位比较，就像比较两个十进制数一样\

##### 工作原理（以4位为例）
1. 比较最高位（A3, B3）
  - 如果`A3 > B3`，那么毫无疑问，`A > B` 
  - 如果`A3 < B3`，那么毫无疑问，`A < B`
  - 如果`A3 = B3`，那么还不能下结论，需要继续比较下一位
2. 比较次高位（A2, B2）：规则同上，但前提是更高位都相等
3. 这个过程一直持续到最低位。如果所有位都相等，则A = B 

这种设计需要一个级联或串联的结构

##### 结构示意图
```text 
        ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐
A3,B3 ─>│ 1位   │    │ 1位   │    │ 1位   │    │ 1位   │
        │比较器 │───>│比较器 │───>│比较器 │───>│比较器 │─> A = B
A2,B2 ─>│       │    │       │    │       │    │       │
        └───────┘    └───────┘    └───────┘    └───────┘
           │             │             │             │
           ▼             ▼             ▼             ▼
         A > B         A > B         A > B         A > B
         A < B         A < B         A < B         A < B
```
> 实际级联时，需要将高位的”相等“输出连接到低位的”使能“输入，表示”只有当我相等时，你下一位的比较结果才有效“

##### 优缺点
- 优点：结构清晰，易于理解，电路规模相对较小
- 缺点：速度慢。比较结果需要从最高位”传播“到最低位才能最终确定。最坏情况下（A == B），信号需要穿过所有位。延迟是O(n) 


#### 现代高速比较器：并行比较器/查找表式比较器
为了解决级联比较器的速度瓶颈，现代高性能电路通常采用并行方法\
**核心思想：利用一个庞大的”与-或“逻辑阵列，直接根据所有位的输入，同时（并行地）产生三个输出信号（`A>B`, `A < B`, `A = B`）**

##### 工作原理
它不进行逐位比较，而是直接”查找“最终结果。以2位比较器为例，其逻辑可以直接从真值表推导出来\
对于`A (A1 A0)`和`B (B1 B0)`
- `A = B`的条件是：`(A1 XNOR B1) AND (A0 XNOR B0)`
- `A > B`的条件是：
  - `(A1 > B1)` OR `(A1 == B1) AND (A0 > B0)`
  - 展开后就是`(A1 AND NOT B1) OR ( (A1 XNOR B1) AND (A0 AND NOT B0) )`
- `A < B`的条件是：
  - `(A1 < B1)` OR `(A1 == B1) AND (A0 < B0)`
  - 展开后就是`(NOT A1 AND B1) OR ( (A1 XNOR B1) AND (NOT A0 AND B0) )`

##### 电路实现
上述每一个输出（`A>B`, `A<B`, `A=B`）都可以用一个多输出的组合逻辑电路（与或门阵列）来实现。一旦输入`A1, A0, B1, B0`就位，这三个输出信号几乎同时产生

##### 优缺点
- 优点：速度极快。延迟基本固定，只经过少数几级门电路（通常是2-3级），与数值位数`n`关系不大，可以认为是`O(1)`的延迟
- 缺点：电路复杂度随位数指数级增长。对于n位比较器，其逻辑表达式的项数会非常多，需要大量的与门和或门。对于32位或64位的比较，这样的电路在面积和功耗上都是巨大的

##### 实践中的权衡
在实际的CPU设计中，对于超宽位（如64位）的比较，通常会采用分组并行的混合方法。例如，将一个64位比较器分成4个16位的并行比较器，然后再用一个快速的逻辑层来整合这4个16位的结果，从而在速度和电路复杂度之间取得一个良好的平衡

#### 总结

| 类型 | 核心原理 | 速度 | 硬件成本 | 应用场景 |
| - | - | - | - | - |
| 1位比较器| 基本逻辑门直接实现	| 快 | 极低	| 构建模块 |
| 级联比较器 | 从高位到低位串行比较 | 慢 (O(n))	| 低 | 对速度要求不高的简单控制逻辑 |
| 并行比较器 | 用组合逻辑阵列直接得出结果 | 极快 (~O(1)) | 高 | 现代高性能CPU、ALU中的比较操作 |


## 时序逻辑电路
时序逻辑电路的输出不仅取决于当前的输入，还与历史输入（即过去的状态）有关。时序逻辑电路中常常使用“触发器”来存储状态。常见的时序逻辑电路包括：
- 触发器（Flip-Flop）：用来存储一位二进制数据。常见的触发器有D触发器、T触发器、JK触发器等
- 寄存器：寄存器是多个触发器的组合，用来存储多位二进制数据
- 计数器：可以按顺序计数的电路，通常由触发器和逻辑门构成
- 移位寄存器：将寄存器中存储的数据逐位向左或向右移动
- 存储器（RAM）：大规模存储数据
- 有限状态机：这是时序逻辑电路中最核心、最抽象的概念。它描述了一个系统在不同“状态”之间转移的行为

### 触发器
时序逻辑电路能够“记忆”的关键，在与它包含了存储元件，最主要的就是触发器

触发器是一种具有两种稳定状态（0和1）的电路，可以长期保持其中一种状态，直到特定的输入信号（通常是始终信号）让它改变

#### D(Data)触发器
D触发器是一种具有记忆功能的时序逻辑单元，它能存储一位二进制数据（0或1）

##### 关键特性与工作原理
D触发器的核心工作机制可以概括为：在时钟信号的特定边沿，将输入端D的当前值捕获，并成为输出端Q的新值，并保持这个值直到下一个时钟边沿
1. 基本端口：
  - D（数据输入端）：这是你想要存储的数据
  - CLK（时钟输入端）：这是控制数据何时被存入的“指挥官”
  - Q（数据输出端）：这是存储的数据
  - Q'（反相输出端）：这是Q的相反信号（即Q=1时，Q'=0,反之亦然）。这个端口并非总是需要
2. 时钟边沿触发
这是D触发器的最关键的特性。它不是持续地响应D端的变化，而是只在时钟信号一个非常短暂的瞬间进行采样
  - 上升沿触发：在时钟信号CLK从0跳变到1的瞬间，D触发器动作。在电路图中，通常在CLK端用一个小三角形表示
  - 下降沿触发：在时钟信号CLK从1跳变到0的瞬间，D触发器动作。在电路图中，通常在CLK端用小三角形加一个气泡表示

在时钟沿之外的时间，无论D端输入如何变化，Q端的输出都始终保持不变。这个“保持不变”的特性，就是“锁存”或“记忆”功能的体现
3. 时序要求
为了让D触发器可靠地工作，数据输入D必须在时钟边沿附近满足一定的稳定性要求
  - 建立时间：在时钟边沿到来之前，输入信号D必须保持稳定的一小段时间
  - 保持时间：在时钟边沿过去之后，输入信号D必须继续保持稳定的一小段时间

如果违反了这两个时序要求，触发器可能会进入一个不稳定的“亚稳态”，导致输出无法预测

##### 真值表

| CLK | D | Q（下一刻）| 说明 |
| - | - | - | - |
| ^ | 0 | 0 | 时钟上升沿时，若D=0, 则Q变为0 |
| ^ | 1 | 1 | 时钟上升沿时，若D=1, 则Q变为1 |
| 0/1/v | X | Q（保持）| 非上升沿时，D的任何变化都不影响Q |

- ^表示时钟上升沿
- X表示“无关项”，可以是0或1 

##### 增强型D触发器
在实际应用中，基本的D触发器通常会增加一些控制输入端，使其功能更强大
- 复位端
  - 同步复位：只有在时钟边沿到来时，如果复位信号有效，才将Q强制清零。复位与时钟同步
  - 异步复位：只要复位信号有效，立即将Q强制清零，完全无视时钟信号。这是最高优先级的控制信号，在电路图中通常在R端加一个小气泡表示低电平有效
- 置位端
  - 与复位端相反，它用于将Q强制置1。同样分为同步置位和异步置位

###### 带有异步复位和置位的D触发器真值表（假设低电平有效）

| RST（复位）| SET（置位）| CLK | D | Q |
| - | - | - | - | - | - |
| 0 | 1 | X | X | 0 |（异步复位，最高优先级）|
| 1 | 0 | X | X | 1 |（异步置位，最高优先级）|
| 1 | 1 | ^ | 0 | 0 |（正常采样：D=0 -> Q=0 |
| 1 | 1 | ^ | 1 | 1 |（正常采样：D=1 -> Q=1 |
| 1 | 1 | 非^ | X | Q（保持）|（保持状态）|

##### 内部结构
一个主从D触发器通常由两个电平触发的D锁存器级联而成
1. 当CLK=0时：
  - 主锁存器打开，它跟随着输入D的变化
  - 从锁存器关闭，保持原来的值，将主锁存器刚锁存的值传递到最终输出Q 
2. 当CLK从0跳变为1时（上升沿）：
  - 主锁存器瞬间关闭，锁存住跳变前一刻的D值
  - 从锁存器瞬间打开，将主锁存器刚锁存的值传递到最终输出Q 
3. 当CLK=1时：
  - 主锁存器关闭，完全不受D端变化的影响
  - 从锁存器打开，但其输入来自一个稳定的值，因此Q端输出稳定

这种“主-从”结构，通过两个锁存器交替开关，实现了在边沿瞬间采样并锁存数据的功能

#### T(Toggle)触发器
核心功能：当T输入为1时，每个有效的时钟边缘都会使输出状态反转；当T输入为0时，输出状态保持不变\
简单来说，它是一个受控的反转开关

##### 关键特性与工作原理
1. 基本端口
  - T（反转控制器）：控制输出是否要反转
  - CLK（时钟输入端）：控制反转发生的时刻
  - Q（数据输出端）：当前的存储状态
  - Q'（反相输出端）：Q的反相

2. 工作模式
T触发器的功能可以用一个非常简单的规则来描述
- 如果T = 1：在时钟边沿到来时，输出Q反转（即`Q(next) = NOT Q(current)`）
- 如果T = 0：在时钟边沿到来时，输出Q保持（即`Q(next) = Q(current)`）

##### 真值表

| CLK | T | Q（当前）| Q（下一刻）| 说明 |
| - | - | - | - | - |
| ^ | 0 | 0 | 0 | T=0,保持状态 |
| ^ | 0 | 1 | 1 | T=0,保持状态 |
| ^ | 1 | 0 | 1 | T=1,翻转状态（0->1）|
| ^ | 1 | 1 | 0 | T=1,翻转状态（1->0）|
| 非^ | X | Q | Q | 无时钟边缘，永远保持 |

##### 一个重要的特例：T恒为1 
如果将T触发器的T输入端永久接高电平（逻辑1），那么它变成了一个二进制分频器或2分频计数器
- 每个时钟边沿到来时，因为`T=1`，输出Q都会翻转一次
- 这意味着Q变化的频率正好是时钟频率的一半

这就是“分频”概念的由来，它是构成计数器的基础

##### T触发器的实现
在标准的集成电路芯片中，并不存在一个名为“T触发器”的独立元件\
这是因为T触发器通常由D触发器转换而来。通过添加一个简单的组合逻辑电路，就可以让D触发器表现出T触发器的行为\
将D触发器的输出Q和输入D通过一个异或门连接起来，T信号作为异或门的另一个输入

**逻辑推导**
- 期望：`Q(next) = Q XOR T`
  - 当`T=0`时，`Q(next) = Q XOR 0 = Q`（保持）
  - 当`T=1`时，`Q(next) = Q XOR 1 = NOT Q`（翻转）
- 对于D触发器，在时钟边沿有`Q(next) = D`
- 因此，只需要让`D = Q XOR T`

这样，就用D触发器和一个异或门“搭建”出了一个T触发器


#### JK触发器
JK触发器是一种具有记忆功能的基本逻辑单元，它有一个时钟输入端（CLK）、两个数据输入端（J和K）、以及至少一个输出端（Q）。它的核心特性是
- 双稳态：可以稳定在“0”或“1”两种状态之一，用于存储1比特的信息
- 边沿触发（主流）：其状态变化通常发生在时钟信号（CLK）的上升沿或下降沿，而不是整个高电平或低电平期间。这使得电路在时序上更容易同步和控制

##### 符号与引脚
```text 
     ┌───┐
  J ─┤   │
     │   ├── Q
CLK ─┤>  │
     │   ├── /Q(Q非)
  K ─┤   │
     └───┘
```
- J.K：数据输入端。它们的状态组合决定了在下一个有效时钟边沿到来时，输出Q将如何变化
- CLK：时钟输入端。箭头">"通常表示边沿触发。如果没有圆圈，通常是上升沿触发；如果有圆圈（CLK），则表示下降沿触发
- Q：输出端。存储的数据
- /Q：反相输出端。总是与Q的电平相反
- 可选引脚：
  - Sd（Set，置位）：异步置位，低电平有效时，立即将Q置为1,不受时钟控制
  - Rd（Reset,复位）：异步复位，低电平有效时，立即将Q置为0,不受时钟控制

##### 真值表

| CLK | J | K | Qn+1（下一个状态）| 功能描述 |
| - | - | - | - | - |
| ^ | 0 | 0 | Qn | 保持：输出保持不变 |
| ^ | 0 | 1 | 0 | 复位：输出被置为0 |
| ^ | 1 | 0 | 1 | 置位：输出被置为1 |
| ^ | 1 | 1 | /Qn | 反转：输出取反 |

##### 四种工作模式
可以根据J、K的四种输入组合，将JK触发器的工作分为四种模式
1. 保持（Hold）- J=0,K=0 
  - 当时钟边沿到来时，触发器“无视”时钟信号，保持原来的状态不变。这是实现数据存储的基础
2. 复位（Reset）- J=0,K=1
  - 无论当前输出Q是什么，当时钟边沿到来时，输出Q都会被清零（Reset为0）
3. 置位（Set）- J=1,K=0 
  - 无论当前输出Q是什么，当时钟边沿到来时，输出Q都会被置一（Set为1）
4. 翻转（Toggle）- J=1,K=1 
  - 当时钟边沿到来时，输出Q会取反

### 寄存器

### 有限状态机
有限状态机（Final State Machine, FSM）是一种数学模型，用于描述具有有限个状态的系统以及状态之间的转移过程\
有限状态机在实际中用来建模系统的行为，可以用于表示一系列输入条件下系统的变化过程

#### FSM的基本组成
有限状态机由以下几部分组成
- 状态（State）：系统在某一个时刻所处的状态。每个状态代表系统的一种特定情况或模式
- 输入（Input）：外部输入信号，它会驱动系统状态的变化
- 转移（Transition）：状态之间的转换规则，定义了在何种输入下，系统从一个状态转移到另一个状态
- 初始状态（Initial State）：系统启动时的起始状态
- 终止状态（Final State）（可选）：某些FSM设计为在达到终止状态后停止

#### FSM的分类
有限状态机通常分为两种主要类型
- Moore型有限状态机：输出仅依赖于当前状态，与输入无关
  - 例如：某个系统可能有多个状态，但在每个状态下，输出是固定的
- Mealy型有限状态机：输出依赖于当前状态和当前输入
  - 例如：某个状态机的输出会根据当前的输入值变化

#### FSM的工作原理
FSM的工作过程可以概括为
1. 接收输入：FSM接收到一个外部输入信号
2. 状态转移：根据当前状态和输入信号，FSM决定是否发生状态转移
3. 产生输出：在Mealy型FSM中，输出受当前状态和输入状态的影响；在Moore型FSM中，输出仅受当前状态的影响

#### FSM的状态转移图
FSM通常用状态转移图（State Transition Diagram）来表示，其中
- 圆点表示状态
- 箭头表示状态之间的转移，箭头上标注的是输入条件
- 双圆点表示初始状态
- 在Mealy型FSM中，箭头上可能还会标注输出

#### FSM的状态转移表
状态转移表是FSM的另一种常见表示方法，它列出了所有状态以及在不同输入下的状态转移和输出

| 当前状态 | 输入 | 下一状态 | 输出 |
| - | - | - | - |
| 50 | 0 | 50 | 0 |
| 50 | 1 | 51 | 1 |
| 51 | 0 | 52 | 0 |
| 51 | 1 | 50 | 1 |

#### 设计一个FSM
设计FSM的步骤通常包括
1. 定义状态：确定系统的所有可能状态
2. 定义输入：确定会影响状态变化的输入
3. 定义状态转移规则：指定在不同输入下如何从一个状态转移到另一个状态
4. 确定输出规则：根据FSM的类型，定义输出与状态或输入的关系
5. 绘制状态转移图：用图形的方式表示所有状态及其转移关系

FSM可以通过编程语言进行实现，通常的实现方式有
- 状态机数组：通过二维数组表示状态转移
- switch-case语句：通过条件语句表示不同输入条件下的状态转移

## 数字系统
数字系统是由多个逻辑电路组合而成，能够执行更复杂的任务。数字系统通常包括以下几个部分
- 输入单元：将外部信息转化为适合数字系统处理的信号
- 处理单元：通常是算术逻辑单元（ALU），负责进行运算和逻辑操作
- 存储单元：存储数据和程序。常见的存储单元有RAM、ROM等
- 输出单元：将处理结果转化为可用的输出信息

## 数字电路设计方法
数字电路的设计可以采用两种主要方法
- 真值表法：根据输入输出的关系，列出所有可能的组合，并设计相应的逻辑电路
- 卡诺图法：通过绘制卡诺图来简化逻辑表达式，进而设计最简化的逻辑电路


## FSM在逻辑电路中的应用
### 计数器

### 序列检测

### 数字时钟













