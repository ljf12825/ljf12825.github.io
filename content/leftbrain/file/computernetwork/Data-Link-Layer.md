---
title: Data Link Layer
date: 2025-12-31
author: ljf12825
summary: data link layer
type: file
---

数据链路层处于OSI模型的第2层，负责在相邻节点之间可靠地传输数据帧（Frame），并进行差错检测、帧定界、流量控制等工作

## 它处理什么问题

| 问题                                          | 说明                                    |
| ------------------------------------------- | ------------------------------------- |
| **成帧（Framing）**                             | 把网络层的分组（Packet）封装成帧（Frame），方便底层传输。    |
| **差错检测与校正（Error Detection and Correction）** | 通过 CRC、奇偶校验等方式检查数据在传输过程中是否损坏。         |
| **流量控制（Flow Control）**                      | 控制发送速率，防止接收方来不及处理。                    |
| **介质访问控制（MAC）**                             | 多个设备共享物理媒介时，控制谁可以发数据（如以太网中的 CSMA/CD）。 |
| **物理地址寻址（MAC Address）**                     | 使用物理地址（MAC地址）来标识链路上的节点。               |

## 数据链路层的结构
数据链路层通常分为两个子层（尤其在IEEE 802中）

| 子层                | 功能                        |
| ----------------- | ------------------------- |
| **LLC（逻辑链路控制）子层** | 提供差错检测、帧同步等服务，定义帧格式。      |
| **MAC（介质访问控制）子层** | 控制设备如何访问共享物理媒介（决定谁能“说话”）。 |

## 层间关系
- 上接网络层：数据链路层接收来自网络层的分组（Packet），打包成帧
- 下接物理层：把帧转换为比特流，交给物理层传输

## 帧的组成（通用结构）
尽管不同链路层协议的帧结构会略有不同，但帧通常包含以下几个部分：
```diff
+---------+-----------+---------+------------+--------+
| 帧头    | 地址信息   | 控制字段 | 数据载荷    | 帧尾   |
+---------+-----------+---------+------------+--------+
```

| 区域       | 内容和作用                                      |
| -------- | ------------------------------------------ |
| **帧头**   | 表示帧的起始位置，一般用于帧定界，比如标识“一个帧从这里开始”            |
| **地址信息** | 包含发送方和接收方的 **MAC地址**（物理地址），用于局域网中标识设备      |
| **控制字段** | 表示帧类型、编号、确认、流量控制等（用于差错控制/顺序控制）             |
| **数据载荷** | 来自上层网络层（IP）的数据包，即真正要传送的“内容”                |
| **帧尾**   | 包含**差错检测码**，比如 CRC，用来检查帧在传输过程中是否出错（通常不能纠错） |

### 帧的界定
帧的界定，指的是接收方如何识别和划分一个个帧的起始和结束  
因为在链路上传输的是一串连续的比特流，接收端必须知道从哪开始读、读到哪结束，这就是帧的界定要解决的问题

#### 为什么需要帧的界定
链路层是点到点或点到多点之间的通信，如果不做帧的划分：
- 接收方不知道哪里是一条完整的信息
- 无法检测丢包、校验错误
- 多帧数据连在一起将造成“比特流混乱”

#### 常见的帧界定方式
##### 字节计数法（Byte Count）
- 在帧的开头写一个字段，表示后面帧的长度
- 例如：`[5][Data1][Data2][Data3][Data4][Data5]`

优点：结构简单，开销小  
缺点：如果长度字段出错，整个帧就错乱，恢复困难

##### 字符充填法（Character Stuffing）
- 使用特殊字符（如`FLAG=01111110`）作为帧起始和结束的标志
- 如果数据中出现`FLAG`，就插入一个转义字符（如`ESC`）进行转义

例如：  
发送帧：[FLAG][data1][ESC][FLAG][data2][FLAG]  
接收端通过`ESC`识别数据中的特殊字符不是标志位

优点：可靠，能处理控制字符冲突  
缺点：只适用于字符流，效率略低

##### 比特充填法（Bit Stuffing）以太网使用
- 也使用固定的比特标志（如`01111110`）作为帧的起始和结束
- 若数据中出现连续5个1，就在后面插入一个0（防止误判为结束标志）

例如：  
原始数据：`01111110`（冲突）  
比特充填后：`01111101`  
接收端发现连续5个1后自动删掉后面的0，还原原始数据

优点：适用于任意比特流  
缺点：需要位级处理，稍复杂

比特填充法的局限就在于：  
它假设连续5个1后跟的0一定是充填的，无法判断它是不是数据本身的0  
为了避免误判，协议的设计者必须保证：
- 数据编码不要主动制造出连续的`0111110`序列；
- 比如在HDLC、PPP等协议中，这种情况是通过充填机制主动生成的，不会自然出现
- 如果你是自己设计的通信协议，就要避免出现这样的字节，或者使用额外校验字段辅助识别边界



##### 基于物理层的编码规则（如曼彻斯特编码）
某些链路技术（如以太网物理层）使用编码规律来隐式地帮助同步帧界限，例如通过信号边缘检测等


## 差错检测
差错检测保证数据传输的正确性和可靠性

### 差错为什么发生
数据在物理媒介上传输时，可能因为干扰、噪声、电磁波、硬件故障等原因，导致传输的比特发生错误（比如0变成1，1变成0）  
这些错误如果不检测出来，接收方就会得到错误数据，造成系统错误

### 差错检测的目标
- 检测数据中的错误，保证接收到的数据和发送的数据一致
- 尽可能快速且有效，不能增加过多传输负担
- 差错检测 != 差错纠正，检测到错误后一般是丢弃或请求重传

### 常见差错检测的方法
#### 奇偶校验（Parity Check）
- 最简单的差错检测方法
- 在数据末尾加一个比特，保证整段数据中1的个数是偶数（偶校验）或奇数（奇校验）
- 缺点：只能检测单个比特错误，不能检测多比特错误

#### 循环冗余校验（CRC，Cyclic Redundancy Check）
- 最常用且强大的差错检测方法，广泛用于以太网、HDLC、USB等协议
- 原理：
  - 把数据看成一个二进制多项式（系数是0或1），用一个固定生成多项式（简称“生成多项式”）对数据进行模2除法
  - 除法的余数就是CRC校验码，附加到数据末尾一起发送
- 接收方用同样生成多项式除收到的数据，如果余数为0，说明没有检测到错误
- 优势：能检测大多数随机错误和突发错误，检测能力远胜奇偶校验
- 复杂度：算法可以用硬件实现，高速计算

#### 校验和（Checksum）
- 数据各部分数值相加（按字节或字），然后取反码或模某数
- 用于IP、TCP、UDP等协议
- 差错检测能力比CRC差，但计算更简单

#### 哈希函数
- 现代一些网络协议或存储设备中会用加密哈希算法（如MD5、SHA）校验完整性，但计算复杂，不常用于链路层

### 差错检测流程简述
1.发送端：
  - 原始数据经过CRC计算，得到CRC校验码
  - 将校验码附加在数据后面一起发送

2.接收端：
  - 收到数据 + 校验码
  - 对全部数据进行同样的CRC计算
  - 若结果为0，数据正确；否则，检测出错误

### 差错检测的局限性
> 如果数据和校验码都被篡改了，接收端的校验结果依然“正确”，怎么办

所有差错检测码（包括CRC）都是基于数学算法设计的，它们并不能保证100%发现所有错误

**为什么**
- 差错检验码本质上是给数据生成一个“指纹”
- 如果数据和校验码同时发生了“巧合性”的变化，导致指纹看起来没变（校验和依然正确），这种情况称为“未检测错误（Undetected Error）”

**发生这种情况的概率极低**
- CRC的设计目标就是让这种“巧合”概率极小，通常在十亿甚至万亿分之一的量级
- 在现实环境下，突发性的噪声通常不会“精确”改变数据和校验码，使得校验刚好通过

**但是仍然可能存在（理论上）**
- 这种错误一般只出现在极端恶劣的信道条件，或者数据遭遇恶意攻击（篡改）时
- 对于一般的网络通信，CRC足够强大，误检率非常低，通常可以忽略

**解决方案与防范措施**
- 更高级的完整性验证
  - 端到端校验（如TCP的校验和）
  - 应用层校验（如文件校验码、数字签名）
  - 加密哈希算法（SHA-256等）保证数据完整性和防篡改

- 可靠传输协议
  - 发现错误后由更高层协议负责重传（如TCP）
  - 如果校验码未检测到错误，可能会传递错误数据，但这在概率上很低

**结论**

差错检测码不是绝对完美的，但它是网络传输中非常高效且可靠的第一道防线。它把大部分错误都拦截了，高层协议和应用层再负责剩下的


## MAC地址
- MAC地址（Media Access Control Address），又称物理地址或硬件地址
- 是分配给网络接口卡（NIC）的唯一标识符
- 长度为48位（6字节），通常以十六进制表示
- 形如：`8C:85:90:2F:34:91`或`8C-85-90-2F-34-91`
- 高位 -> 低位

### MAC地址的结构
48位分成两个部分：

| 部分            | 长度       | 说明                       |
| ------------- | -------- | ------------------------ |
| **前24位**（OUI） | 3字节（24位） | 组织唯一标识符，分配给设备制造商（IEEE授权） |
| **后24位**      | 3字节（24位） | 设备序列号，由制造商自行分配           |

### MAC地址的作用
- 用于局域网内部设备的唯一识别
- 以太网帧头包含源MAC地址和目标MAC地址，帮助设备定位帧的发送者和接收者
- 与IP地址不同，MAC地址是硬编码在硬件里的（虽然可以软件修改，但一般不变）

### MAC地址的类型
1.单播地址（Unicast）
  - 唯一对应一个设备的地址，最高位（第一个字节的最低位）为0

2.组播地址（Multicast）
  - 用于一组设备，最高位为1

3.广播地址（Broadcast）
  - 特殊地址，所有位全为1（FF:FF:FF:FF:FF:FF），表示网络上所有设备

### MAC地址在通信中的流程
1.当一台设备要发送数据给另一台设备时，它会在帧头写上目标设备的MAC地址

2.以太网交换机会根据MAC地址转发帧

3.接收设备收到帧后，会检查目标MAC地址是否与自己匹配，匹配则处理数据，不匹配则丢弃

### 补充：ARP协议
- IP地址时网络层地址，需要通过地址解析协议（ARP）将IP映射为对应的MAC地址，才能在链路层发送数据
- ARP是IPv4环境下常见的协议，IPv6使用类似的邻居发现协议（NDP）

## 冲突检测
这是以太网中一个非常重要的机制，尤其是在传统共享介质环境下保证通信顺畅的关键技术

### 什么是冲突
在以太网的共享媒介（比如早期集线器环境）中，多个设备可能同时尝试发送数据
- 当两个或多个设备同时发送时，信号会在媒介上叠加，导致数据冲突
- 冲突会导致传输的帧出现错误，所有冲突的数据都无法正确接收

### 以太网中的冲突检测机制：CSMA/CD
CSMA/CD = Carrier Sense Multiple Access With Collision Detection  
载波监听多路访问/冲突检测

### CSMA/CD工作流程
1.载波监听（Carrier Sense）
- 设备在发送数据前先“听”信道，确认当前信道是否空闲

2.多路访问（Multiple Access）
- 如果信道空闲，设备开始发送数据

3.冲突检测（Collision Detection）
- 设备在发送数据时，同时监听媒介信号
- 如果检测信号异常（冲突信号），说明冲突发生

4.冲突处理
- 发送设备立即停止发送数据
- 发送一个称为“冲突信号”的特殊信号，通知其他设备冲突发生

5.退避算法（Backoff）
- 设备等待一个随机时间（用二进制指数退避算法计算）
- 等待时间到后重新尝试发送

### 为什么要冲突检测
- 避免冲突导致数据长时间冲突和丢失
- 快速终止冲突传输，减少信道浪费
- 协调多个设备公平访问共享信道

### 举例
假设设备A和设备B同时监听到信道空闲，都开始发送：
- 他们发送的信号在物理媒介上叠加，导致信号混乱
- 设备A和B检测到信号异常（冲突），立即停止发送
- 两个设备随机等待不同时间后，重新尝试发送

### 现代网络中的情况
- 交换机网络（Switched Ethernet）几乎没有冲突，因为每个端口都是独占链路，支持全双工通信
- 因此，现代以太网实际应用中，CSMA/CD主要是历史遗留机制

冲突检测主要存在于传统的以太网共享介质环境，但它不是所有网络技术都有的机制

## 介质控制访问
主要负责协调多个设备如何共享同一物理传输媒介，保证数据有序、有效地传输

### 什么是介质访问控制
- 介质访问控制是数据链路层的子层，解决多个设备如何共享公共传输介质的问题
- 它的核心任务是决定“谁什么时候能发送数据”，避免数据碰撞，提高网络效率

### 为什么需要介质访问控制
假设多个设备共用一根网线或无线信道
- 如果同时发送，信号就会碰撞，造成数据错误
- 需要一种机制协调设备访问权，避免冲突或减少冲突影响

### 常见的介质访问控制方法
#### 竞争式访问（Contention-based Access）
设备竞争使用信道，常见协议有：
- CSMA/CD：以太网使用，监听信道，发现冲突后退避重发
- CSMA/CA：无线网络Wi-Fi使用，通过监听信道和ACK确认避免冲突

#### 非竞争式访问（Contention-free Access）
采用集中管理，设备按顺序或规则访问信道：
- 令牌环（Token Ring）
  设备按顺序传递一个“令牌”，拥有令牌的设备才能发送

- 时分多址（TDMA，Time Division Multiple Access）
  把时间分成若干时隙，设备在分配的时隙内发送

- 频分多址（FDMA，Frequency Division Multiple Access）
  把频带划分成多个频道，每个设备用固定频道发送

- 码分多址（CDMA，Code Division Multiple Access）
  设备用不同码序列共享同一频带

优点：冲突少，适合高负载，实时要求高的场景

## 数据链路层的典型协议

| 协议                | 用途                         |
| ----------------- | -------------------------- |
| **Ethernet**（以太网） | 局域网中最常见的数据链路层协议。           |
| **PPP**（点对点协议）    | 常用于串口连接、电话拨号网络等。           |
| **HDLC**          | 思科设备之间通信常用，控制帧可靠传输。        |
| **802.11（Wi-Fi）** | 无线局域网数据链路层协议，包含复杂的MAC管理逻辑。 |

### Ethernet
Ethernet是计算机网络中最重要、最经典的链路层协议之一，是日常生活和工作中局域网通信的基础协议。它实现了数据链路层的大部分功能，尤其是在局域网（LAN）中广泛使用

> Ethernet是一种数据链路协议，用于在局域网中传输数据帧，由IEEE定义为IEEE 802.3标准

它解决了：
- 如何打包数据成帧（帧格式）
- 如何给设备分配地址（MAC地址）
- 如何管理共享媒介（CSMA/CD）
- 如何检测和处理错误（CRC）

| 特点     | 说明                       |
| ------ | ------------------------ |
| 传输介质   | 传统用双绞线、光纤，也支持同轴电缆        |
| 带宽速度   | 从10Mbps到10Gbps，甚至更高      |
| 访问控制方式 | 传统采用CSMA/CD，现代交换机全双工避免冲突 |
| 物理拓扑   | 早期是总线拓扑，现在多用星型拓扑         |
| 帧格式    | 固定帧结构，包含MAC地址、类型字段等      |
| 设备地址   | 使用唯一的48位MAC地址标识设备        |


#### 以太网帧结构（最常见的帧格式）

```pgsql
+------------+------------+--------------+-----------+---------------------+
| 目标 MAC地址 | 源 MAC地址  | 类型字段（Type） | 数据部分    | CRC校验码      |
| (6 Bytes)   | (6 Bytes)   | (2 Bytes)       | (46~1500B) | (4 Bytes)     |
+------------+------------+--------------+-----------+---------------------+
```

| 字段            | 大小          | 作用                              |
| ------------- | ----------- | ------------------------------- |
| 目的 MAC 地址     | 6 字节        | 接收方设备的 MAC 地址                   |
| 源 MAC 地址      | 6 字节        | 发送方设备的 MAC 地址                   |
| 类型字段          | 2 字节        | 指明数据部分携带的是哪种协议（如 IPv4 为 0x0800） |
| 数据部分（Payload） | 46\~1500 字节 | 传输的有效载荷（如IP数据包）                 |
| CRC 校验码       | 4 字节        | 检测数据是否在传输过程中出错                  |

> 以太网帧最小长度为64字节，数据部分不足时会自动充填，最大为1518字节（不包括VLAN等扩展）

#### 以太网帧界定
以太网使用如下方式实现帧界定：
- 前导码（Preamble）：`101010...10101011`（共8字节）
- 表示一个帧即将开始，帮助接收端时钟同步
- 后面紧跟着的是以太网帧的正式内容

这不是“标识符”分隔，而是通过信号模式和协议规范来界定帧的开始



### PPP
常用在点对点连接上，特别是拨号网络和某些宽带接入场景

#### 什么是PPP协议
- PPP协议是一种链路层协议，主要用于两个节点之间直接通信的点对点链路
- 它定义了链路的封装格式、链路建立、认证、协商以及错误检测等机制
- 适用范围：串口拨号连接（如早期的调制解调器拨号上网）、DSL宽带、VPN隧道等

#### PPP协议特点

| 特点      | 说明                           |
| ------- | ---------------------------- |
| 面向点对点链路 | 连接仅限两个端点，避免冲突和多路访问问题         |
| 封装灵活    | 支持多种网络层协议（IP、IPX、AppleTalk等） |
| 链路控制    | 支持链路建立、维护和拆除                 |
| 认证机制    | 支持PAP、CHAP等多种认证方式            |
| 差错检测    | 使用CRC16进行帧校验                 |

#### PPP帧格式
```diff
+--------+--------+---------+------------+----------+---------+
| 标志位 | 地址   | 控制    | 协议字段    | 信息字段 | FCS校验  |
| 1字节  | 1字节  | 1字节   | 2字节       | 变长     | 2字节    |
+--------+--------+---------+------------+----------+---------+
```

- 标志位（Flag）：固定为 `0x7E`，表示帧的开始和结束
- 地址（Address）：通常是广播地址 `0xFF`
- 控制（Control）：通常为 `0x03`，表示无编号信息帧
- 协议字段（Protocol）：标识上层封装的协议类型（如IP为0x0021）
- 信息字段（Information）：封装的网络层数据。
- 帧校验序列（FCS）：16位CRC，用于检测传输错误。

#### PPP协议的工作过程
1.链路建立：通过LCP（链路控制协议）协商链路参数（最大传输单元、认证方式等）

2.认证阶段（可选）：使用PAP或CHAP认证连接双方身份

3.网络层协议协商：通过NCP（网络控制协议）协商所使用的网络层协议参数（如IP地址）

4.数据传输：链路建立和认证完成后，开始传输封装好的网络层数据

5.链路终止：通信结束时拆除链路

#### PPP优点
- 灵活，支持多种网络协议
- 简单，适合点对点链路
- 支持身份认证，提高安全性
- 支持多种链路管理功能

#### 应用场景
- 早期拨号上网（通过电话线连接ISP）
- DSL宽带连接
- VPN隧道（例如PPTP就是用PPP封装的）
- 串口和同步链路通信

## 从帧转换成比特
### 基本概念
- 帧（Frame）：是数据链路层的基本传输单位，包含了“头部 + 数据 + 尾部”
- 比特（Bit）：是物理层的传输单位，0和1

帧 -> 比特流：本质上就是将一整帧的数据按照物理层的编码方式，转成一串二进制信号，在线上发送

### 转换过程
#### 1.构建帧
例如以太网帧结构如下：

| 字段          | 长度（字节）  | 说明      |
| ----------- | ------- | ------- |
| 前导码         | 7       | 帮助接收方同步 |
| 帧开始定界符（SFD） | 1       | 标记帧开始   |
| 目的 MAC 地址   | 6       |         |
| 源 MAC 地址    | 6       |         |
| 类型 / 长度     | 2       |         |
| 数据（Payload） | 46–1500 |         |
| CRC（循环冗余校验） | 4       |         |

举例：
```text
整个帧可能是：
[前导码][SFD][目的MAC][源MAC][类型][数据][CRC]
```
这是完整的帧结构，每一项都是字节或多个字节组成

#### 2.字节 → 比特（准备物理层发送）
每个字节 = 8个比特

例如：
```text
字节：0x4F = 01001111
```
整个帧会被逐字节转成二进制流

#### 3.比特 → 物理信号（在物理层）
比特转信号依赖于编码方式（如曼彻斯特编码、NRZ、NRZI等）和物理媒介（如双绞线、光纤、无线电波）

例子：曼彻斯特编码
- 0 -> 高 -> 低
- 1 -> 低 -> 高

这样可以通过电压变化表示一个个比特。网卡会把这些编码后信号发送到传输媒介上

### 发生位置
#### 发送端的网卡（NIC）
这是转换帧为比特流、发送信号的核心设备，发生以下过程

| 阶段       | 动作                       | 发生在        |
| -------- | ------------------------ | ---------- |
| 构造帧      | 操作系统内核/驱动将数据打包成帧（如以太网帧）  | CPU + 驱动软件 |
| 帧 ➝ 比特流  | 网卡把帧转成一串比特               | 网卡硬件       |
| 比特 ➝ 电信号 | 网卡将比特编码（如曼彻斯特）并转换为电压/光信号 | 网卡的物理层电路   |
| 物理信号传输   | 电信号通过网线、光纤或无线天线发送出去      | 网卡 + 媒介    |

#### 接收端的网卡
接收端网卡进行逆向过程

| 阶段        | 动作                    | 发生在    |
| --------- | --------------------- | ------ |
| 接收电信号     | 接收从线路来的信号（电压/光波）      | 网卡     |
| 电信号 ➝ 比特流 | 解码为 0/1 的比特流          | 网卡     |
| 比特流 ➝ 帧   | 按照协议组装出完整帧            | 网卡驱动   |
| 帧 ➝ 数据    | 交给操作系统协议栈（如 TCP/IP）处理 | 操作系统内核 |

#### 实际例子
在浏览器中访问一个网站
- 数据通过TCP/IP协议层层封装
- 系统调用网卡驱动，构造以太网帧
- 网卡将帧转换成比特流
- 比特流变成电信号，通过网线发送到路由器
- 路由器再转发这些帧，最后达到目标服务器
- 目标服务器的网卡解码比特流，解析帧，交给系统处理