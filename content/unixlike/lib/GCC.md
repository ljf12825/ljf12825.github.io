---
title: GCC
date: 2025-12-31
categories: [GNU]
tags: [coreutils]
author: "ljf12825"
type: blog
summary: introduction of gcc
---

GCC(GNU Compiler Collection)是一个开源的编译器系统，支持多种编程语言，包括C、C++、Fortran、Ada、Go、D、Object-C和其他一些语言\
它最初是由Richard Stallman在 1987年启动的，用于构建GNU操作系统的一部分，但现在已经发展成一个跨平台的工具，广泛应用于各类操作系统中\

GCC的主要特点是高效性、跨平台、开源，它支持多种体系结构，并且不断更新以支持新的编程语言和硬件架构

**GNU**\
GNU(GNU's Not Unix)是一个由Richard Stallman于1983年发起的自由软件项目，旨在开发一个完全自由、开放源代码的操作系统。GNU项目的目标是替代Unix操作系统，但与Unix不同的是，GNU的所有组件都是自由的软件，用户可以自由地运行、复制、修改和分发这些程序
GNU的核心理念是自由软件，这意味着：
1. 自由使用：自由运行，自用/商用
2. 自由学习和修改
3. 自由分发
4. 自由共享改进

为了确保这些自由，GNU项目创建了GNU通用公共许可证（GPL），这时一种广泛使用的开源许可证，保证软件的自由性并促进自由软件的传播

**GNU的组成部分**
1. GNU工具链
  - GNU项目提供了一套完整的工具，用于开发和管理软件。这些工具包括编译器、调试器、构建工具等
  - 最著名的工具包括
    - GCC（GNU Complier Collection）：一个支持多种编程语言的编译器
    - GDB（GNU Debugger）：一个强大的调试器，用于调试程序
    - Make：一个自动化构建工具，通常用于编译大型程序
    - Binutils：一组用于处理目标文件（如汇编、链接、反汇编等）的工具

2. GNU操作系统的核心组件
  - GNU C库（glibc）：一个实现了POSIX标准的C标准库，许多Linux系统和其他操作系统都依赖于它
  - GNU Bash：一个广泛使用的shell（命令行解释器），为用户提供命令行接口
  - GNU Core Utilities：包括文件操作、文本处理、文件权限管理等常见的命令，如`ls`、`cp`、`rm`等

3. GNU的图形环境
  - GNU 项目并未单独开发完整的图形界面系统，而是与其他项目合作，例如 X Window System，这为其用户提供图形界面环境
  - GNU Emacs：一个强大的文本编辑器，最初由 Richard Stallman 开发，是 GNU 项目中的一个标志性工具
  - GNOME：一个现代的桌面环境，虽然它最初是由 GNOME 项目开发，但它是基于 GNU 工具链和库的，广泛用于 Linux 桌面环境

**GNU于Linux的关系**\
GNU 项目本身并没有完成一个完整的操作系统内核。在 GNU 项目启动之初，Linux 内核并不存在。随着 Linux 内核（由 Linus Torvalds 于 1991 年发布）的出现，GNU 项目的一些工具与 Linux 内核结合，形成了今天我们所说的 Linux 操作系统。

实际上，许多人将 Linux 系统误称为 GNU/Linux，因为它是由 Linux 内核与 GNU 项目的工具链共同组成的。尽管如此，Linux 内核并非由 GNU 项目开发，因此，“GNU/Linux”更能准确反映系统的组成。

**主要的GNU许可证：GPL**\
GNU 项目的一个重要组成部分就是 GNU 通用公共许可证（GPL）。GPL 是一种强制开源的软件许可证，确保用户的自由使用、修改和分享软件。根据 GPL，任何修改或分发软件的行为都必须公开源代码，并且使用相同的许可证。
- GPL v2：第二版许可证，广泛应用于许多开源项目中（例如 Linux 内核）。
- GPL v3：更新版，增加了对软件专利和硬件限制的保护。

**GNU项目的影响和意义**\
1. 开源运动的奠基
  - GNU项目是现代开源软件运动的先驱之一。它的成功促使了大量的开源项目和社区的崛起

2. 自由软件基金会（FSF）
  - 由Richard Stallman创办的自由软件基金会（FSF）支持GNU项目，并推动自由软件的法律、教育和社会倡导

3. Linux和开源生态
  - GNU项目于Linux内核的结合，形成了世界上最广泛使用的操作系统之一，也就是GNU/Linux系统。基于这一系统，许多开源项目和企业得到了极大的发展

4. 科学和教育领域的推广
  - GNU项目不仅为个人用户提供了自由软件，还在科学研究和教育领域得到了广泛的应用。很多学术机构和实验室都使用GNU工具链和开源软件进行研究

**GCC的结构**\
GCC是一个由多个组件构成的编译器集合。其主要结构可以分为以下几个部分：
1. 前端（Front-End）
  - 前端负责处理源代码的语法和语义分析，将源代码转换为中间表示（IR）
  - GCC有不同的前端，支持多种编程语言
  - 每个前端都包括词法分析器、语法分析器、语义分析器

2. 中间层（Middle-End）
  - GCC的中间层主要处理中间表示（IR）的优化和转换
  - GCC使用GIMPLE和RTL（Register Transfer Language）两种中间表示
  - 这个阶段的主要目标是提高程序的执行效率，包括常见的优化，如常量传播、循环优化、死代码消除等

3. 后端（Back-End）
  - 后端将经过优化的中间表示（IR）转换成目标平台的机器代码
  - GCC支持多种硬件架构，后端会根据目标架构的指令集来生成对应的汇编代码
  - 后端还负责处理与具体平台相关的任务，如寄存器分配、指令选择等

4. 代码生成（Code Generation）
  - 最终，GCC的后端将优化后的IR转化为汇编预言家，然后通过汇编器（Assembler）生成机器代码

5. 链接（Linker）
  - GCC通常会调用链接器，将多个对象文件和库文件链接成一个最终可执行的程序

**GCC的主要功能**
1. 编译和优化
  - GCC不仅能够将源代码编译为机器代码，还能执行大量的优化以提高程序的执行效率
  - 支持的优化包括：循环优化、函数内联、代码移除、分支预测等

2. 跨平台支持
  - GCC支持多种操作系统和硬件平台，包括x86、x64、ARM、MIPS、PowerPC、RISC-V等
  - 通过调整目标架构，GCC可以生成不同平台上运行的可执行文件

3. 调试信息支持
  - GCC可以生成调试信息，支持GDB（GNU Dubugger）等调试工具，帮助开发者调试程序

4. 静态分析和诊断
  - GCC提供了强大的诊断信息，能够帮助开发者发现潜在的错误（如未初始化的变量、类型不匹配等）
  - 还支持静态分析工具，如`-Wall`（启用所有警告）和`-Wextra`（启用额外警告）

5. 多语言支持
  - GCC支持多种编程语言，并且可以在同一个项目中混合使用不同语言编写的代码

6. 生成可执行文件、库文件和目标文件
  - GCC支持生成可执行文件、静态库、动态库、目标文件等

**GCC的工作流程**
1. 编译阶段
  - GCC首先会对源代码进行预处理，处理宏定义、头文件引用等
  - 然后，源代码被转换成汇编代码

2. 汇编阶段
  - 汇编器将汇编代码转换为目标文件（`.o`文件）

3. 链接阶段
  - 链接器将目标文件和库文件链接在一起，生成最终的可执行文件

**GCC的扩展和插件**\
GCC还支持通过插件机制扩展编译器的功能。开发者可以编写自己的插件，添加新的分析、优化或代码生成特性。这个功能使得GCC在一些特定领域（如静态分析、代码检查等）非常灵活和强大

**GCC在现代编程中的地位**\
GCC是开源软件开发中的重要工具，尤其是在嵌入式开发、操作系统开发等领域有广泛应用。由于其高度优化、跨平台能力以及开源特性，它在编译器领域有着举足轻重的地位

GCC也是愈多其他项目的工具和基础，例如Linux内核就是用GCC编译的。同时，许多学术研究、编程语言的开发等也依赖GCC

### GCC工具链的安装
**通过版管理器安装**\
以Ubuntu为例
```bash
sudo apt update
sudo apt install build-essential gdb binutils
```
- `build-essential`：包含`gcc`、`g++`、`make`、`libc-dev`等基本工具
- `gdb`：GNU调试器
- `binutils`：包含`ld`（链接器）、`as`（汇编器）、`objdump`等工具

**验证安装**\
```bash
gcc --version
g++ --version
gdb --version
ld --version
```
如果这些命令输出版本信息，说明安装成功

**可选组件**\
安装特定版本的GCC\
如果系统自带的GCC版本比较旧，可以手动安装新版
```bash
sudo apt install gcc-15 g++-15 # 例如安装GCC 15
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc -15 100
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-15 100
```
然后使用`sudo update-alternatives --config gcc`切换版本

**手动编译安装**\
如果需要最新版或自定义配置，可以从源码编译
```bash
# 下载源码
wget https://ftp.gnu.org.gnu/gcc/gcc-15.1.0/gcc-15.1.0.tar.gz
tar -xzf gcc-15.1.0.tar.gz
cd gcc-15.1.0

# 安装依赖
./contrib/download_prerequisites

# 编译安装（较耗时）
mkdir build && cd build
../configure --prefix=/usr/local/gcc-15.1.0 --enable-languages=c, c++ --disable-multilib
make -j$(nproc) # 并行编译，加快速度
sudo make install

# 添加到PATH
echo 'export PATH=/usr/local/gcc-15.1.0/bin:$PATH' >> ~/.bashrc
source ~/.bashrc
```

GCC的全称是 GNU Compiler Collection（GNU 编译器集合），它是一套编译器集合，而不仅仅是单个编译器
- 历史：它最初名为 GNU C Compiler，只用于编译 C 语言。随着时间推移，它扩展支持了C++、Fortran、Ada、Go、D等多种语言，因此在 1999 年更名为现在的名字
- 核心地位：它是 GNU 工具链的核心组成部分，也是 Linux 生态的基石。几乎所有Linux发行版上的软件都是用 GCC 编译的
- 跨平台与开源：GCC 是自由软件，遵循 GPL 许可证。它支持几乎所有主流处理器架构（x86, ARM, RISC-V, MIPS等）和操作系统（Linux, Windows, macOS, BSD等）

**GCC 支持的语言**\
GCC是一个家族，包含多个前端编译器：
- `gcc`：用于编译 C 程序
- `g++`：C++
- `gfortran`：Fortran （取代了旧的`g77`）
- `gnat`：Ada
- `gccgo`：Go
- `gdc`：D

通常说“用 GCC 编译”，大多数指的是使用`gcc`或`g++`

## GCC的编译过程
GCC隐式地经历了四个主要阶段：
1. 预处理（Preprocessing）
  - 执行者：`cpp`（C Preprocessor）
  - 工作：
    - 展开所有的宏（`#define`）
    - 处理所有条件编译指令（`#if`, `ifdef`, `#endif`等）
    - 包含头文件（`include`）的内容
    - 删除所有注释和空行
  - 命令：`gcc -E main.c -o main.i`（输出`.i`文件）

2. 编译（Compilation）
  - 工作：将预处理后的代码（高级语言）翻译成汇编语言（特定于目标CPU的低级代码）
  - 命令：`gcc -S main.i -o main.s`（输出`.s`文件）
  - 注意：这里的“编译”是狭义上的，广义上的编译指整个从源码到二进制的过程

3. 汇编（Assembly）
  - 执行者：`as`（汇编器）
  - 工作：将汇编代码`.s`文件翻译成机器指令，生成目标文件（`.o`或`.obj`文件）。目标文件是二进制格式，但还不能直接运行
  - 命令：`gcc -c main.s -o main.o`（输出`.o`文件）

4. 链接（Linking）
  - 执行者：`ld`（链接器，GCC会调用它）
  - 工作：
    - 将多个目标文件（`.o`）合并成一个可执行文件
    - 解析库文件（如 C 标准库`libc.so`）中函数引用（例如`prinf`函数在哪）
    - 解决所有符号（函数、变量）的地址
  - 命令：`gcc main.o utils.o -o myapp`（输出为可执行文件）

`gcc main.c -o main`，GCC自动完成了以上所有四个步骤

## 常用GCC选项

| 类别 | 选项 | 说明 | 示例 |
| - | - | - | - |
| 常用选项 | `-o <file>` | 指定输出文件名 | `gcc main.c -o myapp` |
| | `-c` | 只编译不链接，生成`.o`文件 | `gcc -c main.c` -> `main.o` |
| | `-g` | 添加调试信息，便于使用GDB调试 | `gcc -g main.c -o main` |
| 警告选项 | `Wall` | 开启大部分常用警告（W all）| `gcc -Wall main.c` |
| | `-Wextra` | 开启额外的警告 | `gcc -Wall -Wextra main.c` |
| | `-Werror` | 将所有警告视为错误，强制要求代码0警告 | `gcc -Wall -Werror main.c` |
| 优化选项 | `-O0` | 不优化（默认），编译快，适合调试 | `gcc -O0 -g main.c` |
| | `-O1`, `-O2` | 不同级别的优化，`-O2`最常用 | `gcc -O2 main.c` |
| | `-O3` | 最高级别优化，可能激进地改变代码 | `gcc -O3 main.c` |
| | `-Os` | 优化代码大小（Optimize for size）| |
| 目录选项 | `-I<dir>` | 添加头文件搜索路径 | `gcc -I./include main.c` |
| | `-L<dir>` | 添加库文件搜索路径 | `gcc -L./lib main.o -lfoo` |
| 链接选项 | `-l<library>` | 链接指定的库 | `gcc main.o -lm`（链接数学库）|
| | `-static` | 静态链接，将库打包进最终程序 | `gcc -static main.c` |
| | `-shared` | 生成共享库（`.so`）而不是可执行文件 | `gcc -shared -o libfoo.so foo.c` |

## 示例
假设项目结构如下
```txt
my_project/
├── src/
│   ├── main.c
│   └── utils.c
├── include/
│   └── utils.h
└── lib/
    └── thirdparty.a
```
手动分步编译：
```bash
# 1. 编译源文件为目标文件，并指定头文件路径
gcc -c src/main.c -I./include -o build/main.o
gcc -c src/utils.c -I./include -o build/utils.o

# 2. 链接所有目标文件和第三方库，生成可执行程序
gcc build/main.o build/utils.o -L./lib -lthirdparty -o bin/myapp
```
一条指令完成（GCC自动处理中间步骤）
```bash
gcc src/main.c src/utils.c -I./include -L./lib -lthirdparty -o bin/myapp
```

## `gcc` and `g++`
`gcc`和`g++`都是GNU编译器套件里的前端驱动程序，不是单独的编译器，而是“驱动”不同后端编译工具链的入口。它们的主要区别体现在默认行为和语言支持上
1. `gcc`
  - 原名是GNU C Compiler，但后来扩展成了 GNU Compiler Collection
  - 主要职责：默认当作 C 编译器来使用
  - 行为特点：
    - 如果输入`.c`文件：当成C源文件处理
    - 如果输入`.cpp`/`.cc`/`.cxx`文件：也会尝试用C++编译器，但不会自动连接C++标准库（libstdc++）
    - 编译C++文件时，需要手动加上`-lstdc++`，否则使用C++标准库的程序（例如用`std::cout`）会报连接错误

示例
```bash
gcc test.cpp -o test # 可能会报错：未定义引用 std::cout
gcc test.cpp -o test -lstdc++ # 手动指定链接C++库，才能运行
```

2. `g++`
  - 是专门针对C++的编译驱动程序
  - 主要职责：把输入文件当作C++源代码来处理
  - 行为特点：
    - 输入`.c`或`.cpp`文件时，都会默认按C++语法处理
    - 编译和链接会自动加上C++标准库（libstdc++）
    - 适合C++项目编译，不用额外指定库

示例
```bash
g++ test.cpp -o test # 自动链接 stdc++，直接可以用 std::cout
```

### 实际建议
- 如果写纯C：用`gcc`
- 如果写C++：用`g++`，避免手动添加库的麻烦
- 如果写混合项目（C&C++）：通常使用`g++`做最终链接（因为要链上`libstdc++`），中间的`.o`文件可以用`gcc -c`或`g++ -c`来生成


## 文档与帮助
查阅GCC选项的详细内容，可以通过以下几种方式
### 方法一：使用`help`选项（最快捷）
这是最快、最直接的方式，用于在终端中快速查看所有选项的概览
```bash
gcc --help
```
这会输出一个很长的列表，按类别（如优化选项、警告选项等）列出所有可用的命令行选项以及其简要说明\
如果想查看某个特定类别的选项，可以使用
```bash
gcc --help=optimizers # 查看所有优化选项
gcc --help=warnings # 查看所有警告悬念
gcc --help=target # 查看目标平台相关选项
gcc --help=common # 查看通用选项
```
优点：极其快速，无需联网，随编译器自带\
缺点：说明非常简短，没有详细解释和示例

### 方法二：使用`man`手册页（最常用、最详细）
这是Linux/Unix系统下查询命令和工具详情的标准方法。`man`（manual）页面提供了非常详尽的文档
```bash
man gcc
```
这会打开一个完整的、结构化的手册。可以使用键盘进行导航
- 上下箭头：逐行滚动
- Page Up / Page Down：翻页
- `/`：搜索。例如，输入`/O2`然后按回车，可以跳转到`-O2`选项的解释
- `n`：跳转到下一个搜索匹配项
- `q`：退出手册页

**手册页结构：**
手册页通常包含以下部分，对于查找选项非常有用：
- NAME：名称和简要描述
- SYNOPSIS：语法概要
- DESCRIPTION：详细描述（重点阅读部分）
- OPTIONS：所有选项的详细解释
- SEE ALSO：相关参考

优点：信息非常详细，包含每个选项的行为、注意事项和与其他选项的交互。离线可用\
缺点：内容量大，需要一定的阅读和搜索技巧

### 方法三：使用`info`文档（最完整、最权威）
GNU项目的官方文档格式是`info`，它比`man`页面更结构化、更超文本化，内容也通常更新、更全
```bash
info gcc
```
这会启动一个基于文本的超文本浏览器。导航方式类似`man`，但更强大：
- 方向键：移动光标
- 回车：进入带有`*`标记的节点（超链接）
- `l`（小写L）：返回到上一个节点
- `u`：向上移动一层
- `q`：退出

在`info gcc`中，可以找到关于GCC的所有一切，包括完整的内部实现原理、每种支持语言的细节、以及每个选项的最终权威解释

优点：最完整、最权威的GCC文档，是GUN的官方手册\
缺点：结构复杂，信息量大

### 方法四：在线查询官方文档
GNU GCC官网提供了完整的[在线文档](https://gcc/gnu.org/onlinedocs)，阅读体验通常比终端更好\
其中包含：
- 当前稳定的版本
- 所有历史版本文档
- 多种格式（HTML, PDF等）

在线文档的结构和内容与`info`基本相同，但有了网页的便利性

### 方法五：询问编译器本身（`-Q --help=xxx`）
这是一个非常强大的技巧，可以让GCC告诉你它默认启用了哪些选项，或者不同优化级别具体包含了哪些子选项
1. 查看激活的优化选项：
`-O2`与`-O3`有什么区别
```bash
# 查看使用 -O2 时，哪些优化器被开启了
gcc -Q -O2 --help=optimizers

# 与 -O3 进行对比
gcc -Q -O3 --help=optimizers
```
输出会是一个很长的列表，显示每个优化选项是 `[enabled]` 还是 `[disabled]`。通过对比，你就可以清晰地看到 `-O3` 比 `-O2` 多开启了哪些具体的优化

2. 查看默认启用的警告
```bash
gcc -Q --help=warnings | grep enabled
```
这个命令可以查看哪些警告选项默认情况下是开启的（即使没有指定`-Wall`）

### 实战技巧
假设遇到了一个`-fPIC`选项，想知道它是干什么的
1. 快速瞥一眼（`--help`）
```bash
gcc --help | grep -i fpic
```
输出可能只有简单的一行：`-fPIC Generate position-independent code if possible`知道了它和“位置无关代码”有关

2. 查阅详细解释（`man`）
```bash
man gcc
```
在`man`页面中，按下`/`，输入`-fPIC`，按回车，反复按`n`键直到找到最匹配的解释。会看到更详细的描述

3. 查阅最权威的解释（`info`）

### 关于文档和帮助
可以把“掌握GCC”分为几个层次：

#### 层次一：掌握“使用”（文档可以基本覆盖）
这是**文档能帮你达到的主要目标**。通过 `man gcc`、`info gcc` 和在线文档，你可以：
*   **查找任何选项的含义**：比如 `-fstack-protector-strong` 是做什么的。
*   **了解正确的命令行语法**：如何组合选项来编译、链接一个项目。
*   **理解主要功能**：如何使用不同的优化级别（`-O0` vs `-O2`），如何生成调试信息（`-g`），如何链接静态库和动态库（`-l`, `-L`, `-static`）。
*   **解决大多数编译和链接错误**：通过文档理解错误背后的原因，并找到正确的选项来修复它（例如，链接失败时知道要加 `-lm`）。

**在这个层次上，文档是终极百科全书，反复查阅和实践可以让你变得非常熟练。**

#### 层次二：掌握“原理与洞察”（文档是基础，但需更多）
这是超越“用户手册”，进入“工程师思维”的层次。文档是起点，但远非终点。
*   **编译/链接模型**：文档告诉你 `-c` 和 `-o` 的用法，但要真正“掌握”，你需要理解**为什么需要分离编译和链接**？头文件（`.h`）和库文件（`.a`/`.so`）在编译和链接阶段各自扮演什么角色？符号表（Symbol Table）是什么？
*   **ABI（应用程序二进制接口）**：不同的优化选项（如 `-fPIC`）如何影响生成的代码？为什么用不同编译器或不同选项编译的库有时无法混用？这需要理解平台ABI。
*   **底层工具链**：GCC 只是一个驱动程序（driver），它背后调用了预处理器（`cpp`）、编译器本身（`cc1`）、汇编器（`as`）、链接器（`ld`）。要真正掌控它，你需要了解这个工具链的每个环节。文档会提及，但深度有限。
*   **与操作系统的交互**：程序如何启动（`_start` 入口点）？静态链接和动态链接在操作系统加载时有何不同？这超出了 GCC 文档的范围，涉及操作系统知识。

**在这个层次上，文档是你地图上的标注，但你需要自己去探索整个地形。**

#### 层次三：掌握“内部机制”（文档几乎无能为力）
这是 GCC 开发者的领域。
*   **编译器架构**：GCC 的前端、中端（优化）、后端是如何工作的？
*   **中间表示（GIMPLE, RTL）**：源代码是如何被转换成这些内部结构并进行优化的？
*   **机器描述（`.md`文件）**：如何为一种新的CPU架构添加GCC支持？

**对于这个层次，GCC 文档的作用很小，你需要去读源码、读专门的论文和书籍。**

---

### 那么，如何才能真正“掌握”GCC？（实践路线图）

文档是核心，但必须配合其他方式：

1.  **将文档作为案头必备工具，不会就查**。这是基础。
2.  **从实践中带来问题，带着问题去读文档**。这是最高效的方法。
    *   不要试图通读所有文档。而是当你遇到一个看不懂的警告、一个链接错误、一个性能问题时，**主动去 `man gcc` 里搜索相关的选项**。
    *   例如，遇到 `undefined reference` 错误，就去查 `-l` 和 `-L`；发现程序调试不了，就去深入研究 `-g`；想知道两个优化级别的区别，就用 `gcc -Q -O2 --help=optimizers` 对比。
3.  **拆解编译过程，加深理解**。
    *   使用 `-E`、`-S`、`-c` 选项**手动执行每一步**，并查看生成的 `.i`（预处理后）、`.s`（汇编）、`.o`（目标）文件内容。这是理解编译原理最直观的方式。
4.  **学习辅助工具**。
    *   **`objdump`**： 反汇编，看生成的实际代码。
    *   **`nm`**： 查看目标文件或库中的符号。
    *   **`readelf`**： 查看ELF格式文件的详细信息。
    *   **`strace`**： 跟踪GCC执行时调用了哪些系统调用和命令。
    *   这些工具能帮你验证文档里的知识，并看到背后的真相。
5.  **阅读相关经典书籍**。
    *   例如《深入理解计算机系统》（CS:APP）、《程序员的自我修养——链接、装载与库》等。它们会系统性地讲解GCC工具链背后的计算机原理。

GCC 只是一个“工具”，真正强大的是通过学习和使用它所建立的**对整个软件构建过程、系统底层知识的深刻理解**