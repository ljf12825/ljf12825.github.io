---
title: blame
date: 2025-12-31
categories: [Git]
tags: [Command, Porcelain]
author: "ljf12825"
type: blog
summary: usage of git blame
---

`git blame`是一个侦探工具，用来追溯文件中每一行代码的“身世”：是谁、在什么时候、因为什么提交（commit）而修改了这行代码\
这对于理解代码、排查问题（特别是发现引入了Bug的提交）以及（偶尔的）“甩锅”都非常有用

## 核心功能：逐行追溯
当对一个文件运行`git blame`时，Git会逐行分析该文件，并在每一行的前面加上一个注解，通常包含以下信息：
- 提交哈希值（Commit Hash）：修改这一行的那次提交的唯一ID（通常只显示前7位）
- 作者（Author）：修改这行代码的人
- 提交时间（Timestamp）：修改发生的时间
- 行号（Line Number）：当前行的行号

```text
PS F:\HowToGit> git blame Diff.md
5e91c15b (ljf12825Windows 2025-08-09 18:54:44 +0800   1) # Diff
5e91c15b (ljf12825Windows 2025-08-09 18:54:44 +0800   2) `git diff`用来比较两个版本之间的差异，以文本形式显示修改了哪些行
5e91c15b (ljf12825Windows 2025-08-09 18:54:44 +0800   3) 
5e91c15b (ljf12825Windows 2025-08-09 18:54:44 +0800   4) 它的本质是：
5e91c15b (ljf12825Windows 2025-08-09 18:54:44 +0800   5) - 计算两份文件的差异（patch）
5e91c15b (ljf12825Windows 2025-08-09 18:54:44 +0800   6) - 按行标记增加（`+`）、删除（`-`）
5e91c15b (ljf12825Windows 2025-08-09 18:54:44 +0800   7) - 使用颜色高亮（终端支持时）
5e91c15b (ljf12825Windows 2025-08-09 18:54:44 +0800   8) > 它不只是比较已提交的版本，还可以比较工作区、暂存区、历史提交等不同状态
5e91c15b (ljf12825Windows 2025-08-09 18:54:44 +0800   9) 
5e91c15b (ljf12825Windows 2025-08-09 18:54:44 +0800  10) **Git的三个状态**\
```
## 常用选项和技巧
- `-L <start>, <end>`或`-L <start>, +<number>`：只查看指定行的范围
  - `git blame -L 10,15 example.txt`：只看第10到第15行
  - `git blame -L 1-,+5 expample.txt`：从第10行开始，看5行（10-14行）
- `-C`/`-C -C`/`-C -C -C`：检测移动或复制的代码。默认情况下，`git blame`只跟踪在当前文件内的修改。如果有一段代码是从两一个文件里移动或复制过来的，这个选项可以追溯它的原始出处，而不是只显示移动它的那次提交，显示第一次出现这行的提交
  - `-C`：会在同一提交内查找移动的代码
  - `-C -C`或`-C -C -C`：愈发激进，从检查其他文件的复制，到跨文件、多级追踪来源。计算量很大，速度很慢（Git并不是语义分析，只是按文本相似度去猜测，所有有时结果并不完美）
- `-e`：显示作者的邮箱地址而不是用户名
- `-w`：忽略空白的修改。这样，如果某个提交只是调整了缩进或空格，不会影响真正的代码修改历史追溯
- `-M`：检测同一文件中移动或复制的代码

## 原理
`blame`是一个精巧的追溯算法，其核心目的是：在当前文件的行和产生这些行的提交之间建立准确的映射关系

### 核心数据结构：跟踪差异（Diff）与行起源
Git并不会在每次提交都存储每个文件的完整快照（尽管它感觉上是这样）。为了节省空间，它存储的是提交之间的差异（diff）。`git blame`的工作原理就是逆向演绎这个过程\
它需要回答一个问题：给定文件在提交`X`中的第`N`行，是由哪个提交引入或最后修改的

### 算法过程：反向追溯与二分查找
`git blame`的执行过程是一个从当前提交开始，逆向历史回溯的过程。它通常采用高效的算法（如二分查找）来快速定位引入更改的提交，而不是机械地逐个检查每一个历史提交\
其算法流程可以概括为：
1. 起点（Start Point）：从指定的提交（默认为`HEAD`，即当前状态）开始
2. 差异计算（Calculate Diff）：将当前正在检查的提交（例如`Commit C`）与其父提交（`Commit B`）进行比较，生成一个差异（diff）
3. 行号映射（Line Number Mapping）：分析这个diff。Diff会精确地描述那些行被增加、删除或修改
  - 新增的行（+lines）：这些行在当前提交（`C`）中是新的。因此，这些行的“责任人”就是当前提交`C`
  - 未变化的行（context line）：这些行从父提交（`B`）中原封不动地继承而来。对于这些行，`git blame`需要继续向历史追溯，去父提交(`B`)中寻找它们的起源
4. 递归/迭代（Recurse/Iterate）：对于所有需要追溯的行，算法将父提交（`B`）作为新的“当前提交”，并重复步骤2-3.这个过程一直持续到无法再追溯（达到初始提交）为止
5. 二分查找优化（Binary Search Optimization）：如果机械地从`HEAD`一直回溯到根提交，对于大项目来说会非常慢。Git使用了一种更聪明的方法：
  - 它首先会大致确定一个范围（比如从提交`A`到提交`Z`）
  - 然后它检查中间的提交`M`
  - 通过比较`M`和当前版本，它可以判断出引入某行代码的提交是再`M`之前哈市之后
  - 通过这种方式，它不断搜索范围对半缩小，从而极快地定位到目标提交。这就是二分查找，时间复杂度从O(N)降到了O(log N)

### 处理复杂情况：代码移动与复制
默认的追溯方式有一个局限：它只能检测到再当前文件内发生的修改。但如果一行代码是从另一个文件移动而来，简单的diff会认为这是“删除了旧文件的一行”和“添加了新文件的一行”，从而错误地将移动操作认定为新的添加\
这就是`-M`和`-C`选项发挥作用的地方，它们极大地增加了算法的“侦探”能力
- `-M`（检测同一文件内的移动）
  - 在比较提交`C`和其父提交`B`时，算法不仅看差异，还会检查本次提交中新增的代码块，是否与本次提交中删除的代码块相似
  - 如果相似度超过某个阈值（可配置），Git就认为这不是“新代码”，而是“移动了的代码”。因此，它会将这行的起源指向原始代码所在的提交，而不是移动它的这次提交
- `-C`（检测跨文件的移动/复制）
  - 算法会进一步扩大搜索范围。对于提交`C`中新增的代码，它不仅会在当前文件的父版本中查找，还会在同一提交内修改的其他所有文件中进行查找
  - 如果发现一个新增代码块与另一个文件中被删除或修改的代码块高度向司机，他就会认为代码是从那个文件复制或移动过来的，并将起源指向最初的提交
- `-C -C`或`-C -C -C`
  - 这是最严格的模式。它甚至会将当前提交的赋体骄傲与其他历史提交进行比较，以发现更久远之前发生的代码移动和复制。这能追溯出代码的“最初来源”，即使它已经在项目中被移动和复制了很多次

### 性能考量
`git blame`是一个非常高效的操作，这要归功于
1. 二分查找：快速定位更改
2. Git的对象库：所有提交、文件（blob）、目录（tree）都被哈希存储，读取速度极快
3. 差异算法的优化：Git的diff算法（如Myers diff algorithm）已经非常成熟和高效

然而，对一个非常庞大、历史悠久的文件（例如一个积累了十年的上万行配置文件）运行`blame`，尤其是加上`-C -C`选项时，仍然可能消耗较多计算资源，因为需要比较的代码块数量会呈指数级增长