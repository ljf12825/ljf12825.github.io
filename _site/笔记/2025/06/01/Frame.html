<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.1 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Frame - ljf12825’s Blog</title>
<meta name="description" content="在Unity中，Frame（帧）是游戏运行的基本时间单位">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="ljf12825's Blog">
<meta property="og:title" content="Frame">
<meta property="og:url" content="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Frame.html">


  <meta property="og:description" content="在Unity中，Frame（帧）是游戏运行的基本时间单位">







  <meta property="article:published_time" content="2025-06-01T00:00:00+08:00">






<link rel="canonical" href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Frame.html">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="ljf12825's Blog Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- favicon -->
<link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon">

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          ljf12825's Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Categories</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tags</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Frame">
    <meta itemprop="description" content="在Unity中，Frame（帧）是游戏运行的基本时间单位">
    <meta itemprop="datePublished" content="2025-06-01T00:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Frame.html" itemprop="url">Frame
</a>
          </h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>在Unity中，Frame（帧）是游戏运行的基本时间单位</p>

<h2 id="什么是frame">什么是Frame</h2>
<blockquote>
  <p>Frame：指游戏每渲染并更新一次画面所经历的完整周期
一个Frame包含了物理模拟、逻辑更新、渲染提交等多个阶段</p>
  <ul>
    <li>游戏每秒运行多个帧，成为FPS（Frame Per Second），帧率越高越流畅</li>
    <li>如果帧率是60FPS，表示每秒执行60次完整的Frame逻辑</li>
  </ul>
</blockquote>

<h2 id="frame的生命周期">Frame的生命周期</h2>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">Input</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">Physics</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">Update</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">AI</span><span class="o">/</span><span class="nt">Animator</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">LateUpdate</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">Rendering</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">Present</span><span class="o">]</span>
</code></pre></div></div>
<p>详见<a href="/posts/2025-06-02-Scripts/">Scripts</a></p>

<h2 id="不同帧的分类">不同帧的分类</h2>

<table>
  <thead>
    <tr>
      <th>帧类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>逻辑帧（Update 帧）</strong></td>
      <td>每帧都会执行的脚本逻辑</td>
    </tr>
    <tr>
      <td><strong>物理帧（FixedUpdate）</strong></td>
      <td>固定时间调用一次，与帧率无关</td>
    </tr>
    <tr>
      <td><strong>渲染帧</strong></td>
      <td>Unity 渲染一次画面</td>
    </tr>
  </tbody>
</table>

<h2 id="frame与多线程">Frame与多线程</h2>
<p>Unity中每一帧可以大致分为如下几个阶段：</p>
<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Frame</span><span class="w"> </span><span class="err">开始</span><span class="w">
</span><span class="err">│</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Script</span><span class="w"> </span><span class="nb">Update</span><span class="err">（</span><span class="nv">MonoBehaviour</span><span class="w"> </span><span class="nb">Update</span><span class="err">）</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">FixedUpdate</span><span class="err">（每</span><span class="w"> </span><span class="nb">N</span><span class="w"> </span><span class="err">帧触发）</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Animation</span><span class="w"> </span><span class="nb">Update</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Physics</span><span class="w"> </span><span class="nb">Update</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">AI</span><span class="w"> </span><span class="nv">Navigation</span><span class="w"> </span><span class="nb">Update</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Culling</span><span class="err">（剔除）</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Rendering</span><span class="w"> </span><span class="nv">Setup</span><span class="w">
</span><span class="err">│</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Rendering</span><span class="err">（提交</span><span class="w"> </span><span class="nv">DrawCalls</span><span class="w"> </span><span class="err">到</span><span class="w"> </span><span class="nv">GPU</span><span class="err">）</span><span class="w">
</span><span class="err">│</span><span class="w">
</span><span class="err">└─</span><span class="w"> </span><span class="nv">EndFrame</span><span class="w">
</span></code></pre></div></div>
<p>这些阶段会部分并行执行（也就是说，并非所有都是主线程执行的）</p>

<h3 id="多线程的参与">多线程的参与</h3>

<table>
  <thead>
    <tr>
      <th>线程</th>
      <th>作用</th>
      <th>举例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>主线程（Main Thread）</strong></td>
      <td>执行大部分脚本、生命周期函数、UI、调度渲染</td>
      <td>Update、LateUpdate、OnGUI、Animator</td>
    </tr>
    <tr>
      <td><strong>Job System 线程池</strong></td>
      <td>执行并行任务，如变换更新、骨骼动画、AI、路径查找</td>
      <td>DOTS Jobs、Transform System</td>
    </tr>
    <tr>
      <td><strong>渲染线程（Render Thread）</strong></td>
      <td>独立线程打包渲染命令给 GPU</td>
      <td>Draw Call 打包、CommandBuffer</td>
    </tr>
    <tr>
      <td><strong>Worker Threads（如音频）</strong></td>
      <td>异步加载资源、播放音频、网络等</td>
      <td>Audio Thread、Loading Thread</td>
    </tr>
    <tr>
      <td><strong>GPU（设备线程）</strong></td>
      <td>执行实际绘制、后处理、粒子等并行任务</td>
      <td>Shader、Compute Shader、VFX Graph</td>
    </tr>
  </tbody>
</table>

<h3 id="一帧中多线程协同的流程图">一帧中多线程协同的流程图</h3>
<pre><code class="language-less">             [一帧开始]
                   │
      ┌────────────┴─────────────┐
      │                          │
[Main Thread]              [Job System Threads]
      │                          │
 MonoBehaviour.Update()     DOTS Job: 动画、物理、AI计算等
      │                          │
 LateUpdate() ←───────────────┘（主线程同步 Job 结果）
      │
[开始渲染准备]
      │
      └─→ [Render Thread] → 提交 GPU 渲染命令
                          │
                          ↓
                   [GPU 渲染这一帧]
</code></pre>

<h3 id="线程同步与一帧的边界">线程同步与一帧的边界</h3>
<ul>
  <li>Job在当前帧内启动，也要在当前帧内完成，结果才能同步回主线程</li>
  <li>Unity不允许Job修改UnityEngine.Object</li>
  <li><code class="language-plaintext highlighter-rouge">JobHandle.Complete()</code>会阻塞等待Job完成，要合理使用</li>
</ul>

<h2 id="frame性能调优">Frame性能调优</h2>
<p>Frame Optimization是游戏性能优化的核心工作之一，目标是在每一帧内把CPU、GPU、内存、线程、渲染等资源使用最大化、冗余最小化，从而达到稳定的帧率</p>

<h3 id="一帧的性能结构大脑图">一帧的性能结构（大脑图）</h3>
<p>Unity中一帧的总耗时通常来自这几个方面：</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">一帧时间</span><span class="err">（</span><span class="nt">Frame</span> <span class="nt">Time</span><span class="err">）</span> <span class="err">≈</span>
  <span class="nt">CPU</span> <span class="nt">脚本逻辑开销</span> <span class="o">+</span>
  <span class="nt">Physics</span> <span class="nt">运算</span> <span class="o">+</span>
  <span class="nt">Animation</span> <span class="nt">采样</span><span class="o">/</span><span class="nt">骨骼</span> <span class="o">+</span>
  <span class="nt">Renderer</span> <span class="nt">准备</span><span class="o">/</span><span class="nt">剔除</span> <span class="o">+</span>
  <span class="nt">渲染线程开销</span><span class="err">（</span><span class="nt">Render</span> <span class="nt">Thread</span><span class="err">）</span><span class="o">+</span>
  <span class="nt">GPU</span> <span class="nt">渲染耗时</span>
</code></pre></div></div>
<p>目标是：让这些总和 小于 1 / FPS</p>

<h3 id="调优的目标谁卡就调谁">调优的目标：谁卡，就调谁</h3>

<table>
  <thead>
    <tr>
      <th>调优对象</th>
      <th>优化目的</th>
      <th>工具</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CPU 主线程</td>
      <td>减少逻辑卡顿</td>
      <td>Profiler、Timeline</td>
    </tr>
    <tr>
      <td>Job 多线程</td>
      <td>减少不必要的等待</td>
      <td>Profiler、JobDebugger</td>
    </tr>
    <tr>
      <td>Render Thread</td>
      <td>减少 DrawCall 和渲染命令量</td>
      <td>Frame Debugger、Stats</td>
    </tr>
    <tr>
      <td>GPU 渲染</td>
      <td>降低 Shader/像素复杂度</td>
      <td>GPU Profiler、RenderDoc</td>
    </tr>
    <tr>
      <td>内存使用</td>
      <td>减少 GC 和加载卡顿</td>
      <td>Memory Profiler、Deep Profiler</td>
    </tr>
  </tbody>
</table>

<h3 id="常见瓶颈与优化方法大致思路">常见瓶颈与优化方法（大致思路）</h3>
<h4 id="1脚本逻辑太重主线程占满">1.脚本逻辑太重（主线程占满）</h4>

<table>
  <thead>
    <tr>
      <th>症状</th>
      <th>优化手段</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Update() 每帧循环太多对象</td>
      <td>改为 Job 或事件驱动、UpdateGroup</td>
    </tr>
    <tr>
      <td>大量使用 <code class="language-plaintext highlighter-rouge">Find</code>, <code class="language-plaintext highlighter-rouge">GetComponent</code>, LINQ</td>
      <td>改成缓存引用、避免动态分配</td>
    </tr>
    <tr>
      <td>高频调用 GC</td>
      <td>使用对象池、Span、少用 string 拼接</td>
    </tr>
  </tbody>
</table>

<h4 id="2draw-call太多--batching失效">2.Draw Call太多 / Batching失效</h4>

<table>
  <thead>
    <tr>
      <th>症状</th>
      <th>优化方法</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>每帧几千次 DrawCall</td>
      <td>开启 SRP Batching 或 GPU Instancing</td>
    </tr>
    <tr>
      <td>动态物体频繁改变材质</td>
      <td>合并材质、使用 Texture Atlas</td>
    </tr>
    <tr>
      <td>UGUI 每个按钮都独立绘制</td>
      <td>使用 Canvas 分层、合批策略优化（静态 Canvas）</td>
    </tr>
  </tbody>
</table>

<h4 id="3渲染管线太重--gpu满载">3.渲染管线太重 / GPU满载</h4>

<table>
  <thead>
    <tr>
      <th>症状</th>
      <th>优化手段</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Shader 复杂 / 光照太多</td>
      <td>降低 Shader 复杂度，合并 Pass</td>
    </tr>
    <tr>
      <td>每像素灯光多 / 阴影开销大</td>
      <td>减少实时光源数量，Bake 灯光</td>
    </tr>
    <tr>
      <td>后处理堆叠太多</td>
      <td>合并效果、调低分辨率、关闭没必要的 PostFX</td>
    </tr>
  </tbody>
</table>

<h4 id="物理模拟耗时长">物理模拟耗时长</h4>

<table>
  <thead>
    <tr>
      <th>症状</th>
      <th>优化方法</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>大量 Collider / Rigidbody</td>
      <td>简化碰撞体、使用 Layer 避免不必要检测</td>
    </tr>
    <tr>
      <td>FixedUpdate 太频繁</td>
      <td>调整 Fixed Timestep（如 0.02 → 0.033）</td>
    </tr>
    <tr>
      <td>不必要的物理交互</td>
      <td>设置 isKinematic、启用睡眠</td>
    </tr>
  </tbody>
</table>

<h4 id="资源加载卡顿--gc卡顿">资源加载卡顿 / GC卡顿</h4>

<table>
  <thead>
    <tr>
      <th>症状</th>
      <th>优化方法</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>使用 <code class="language-plaintext highlighter-rouge">Resources.Load()</code> 或 <code class="language-plaintext highlighter-rouge">Instantiate()</code> 卡顿</td>
      <td>使用 Addressables 异步加载</td>
    </tr>
    <tr>
      <td>不断产生临时对象</td>
      <td>对象池、避免 foreach/ToList/Lambda</td>
    </tr>
    <tr>
      <td>大量 UI 弹窗频繁创建销毁</td>
      <td>UI 预加载 + 缓存 + 对象池化管理</td>
    </tr>
  </tbody>
</table>

<p><strong>详见 <a href="/posts/2025-06-13-Unity-Performance-Tuning/">Unity Performance Tuning</a></strong></p>

<h2 id="帧的底层原理">帧的底层原理</h2>
<p>从底层角度说：</p>
<blockquote>
  <p>一帧 = CPU逻辑执行 + 渲染命令提交 + GPU图像输出 + 系统显示刷新</p>
</blockquote>

<h3 id="一帧在底层的完整生命周期">一帧在底层的完整生命周期</h3>

<table>
  <thead>
    <tr>
      <th>阶段</th>
      <th>描述</th>
      <th>涉及模块</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>时间触发</td>
      <td>到了下一帧时间，Unity 开始执行 Update</td>
      <td>操作系统定时器 / 游戏主循环</td>
    </tr>
    <tr>
      <td>逻辑更新</td>
      <td>执行脚本逻辑（如移动、AI、物理）</td>
      <td>CPU，主线程，Mono</td>
    </tr>
    <tr>
      <td>资源准备</td>
      <td>加载纹理、动画数据、Mesh 等</td>
      <td>CPU + 内存 + IO</td>
    </tr>
    <tr>
      <td>渲染命令生成</td>
      <td>调用 Graphics API：DrawMesh、DrawCall</td>
      <td>Unity C++ 层、RenderThread</td>
    </tr>
    <tr>
      <td>渲染命令提交</td>
      <td>传给 GPU 渲染管线（如 Vulkan、OpenGL）</td>
      <td>RenderThread → GPU</td>
    </tr>
    <tr>
      <td>GPU 执行渲染管线</td>
      <td>顶点着色 → 光栅化 → 像素着色 → 输出到帧缓冲</td>
      <td>GPU Pipeline</td>
    </tr>
    <tr>
      <td>vsync 同步</td>
      <td>等待下一次显示器刷新（如 60Hz）</td>
      <td>SwapChain、VSync</td>
    </tr>
    <tr>
      <td>显示图像</td>
      <td>当前帧图像输出到屏幕</td>
      <td>显示设备、操作系统</td>
    </tr>
  </tbody>
</table>

<h3 id="图形api如何控制帧">图形API：如何控制帧</h3>
<p>Unity底层是通过图形API驱动的，这些API控制：</p>
<ul>
  <li>帧缓冲区 FrameBuffer</li>
  <li>渲染管线</li>
  <li>命令缓冲区 CommandBuffer</li>
  <li>交换链 SwapChain</li>
</ul>

<p><strong>Vulkan或DX中的一帧</strong></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BeginFrame</span><span class="p">();</span> <span class="c1">// 开始新的一帧（获取缓冲区）</span>
<span class="n">RecordRenderCommands</span><span class="p">();</span> <span class="c1">// 录制渲染命令</span>
<span class="n">SubmitToGPU</span><span class="p">();</span> <span class="c1">// 提交到GPU</span>
<span class="n">PresentFrame</span><span class="p">();</span> <span class="c1">// 显示渲染结果（同步vsync）</span>
</code></pre></div></div>
<p>Unity在底层封装了这些过程，开发者只看到<code class="language-plaintext highlighter-rouge">Update()</code>、<code class="language-plaintext highlighter-rouge">LateUpdate()</code>、<code class="language-plaintext highlighter-rouge">Render()</code></p>

<h3 id="帧率和显示器刷新率之间的关系">帧率和显示器刷新率之间的关系</h3>

<table>
  <thead>
    <tr>
      <th>显示器刷新率</th>
      <th>理想帧率</th>
      <th>VSync</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>60Hz 显示器</td>
      <td>60 FPS</td>
      <td>每 16.67ms 输出一帧</td>
    </tr>
    <tr>
      <td>120Hz 显示器</td>
      <td>120 FPS</td>
      <td>每 8.33ms 输出一帧</td>
    </tr>
    <tr>
      <td>帧生成慢</td>
      <td>掉帧、卡顿</td>
      <td>GPU 没赶上显示器刷新节奏</td>
    </tr>
    <tr>
      <td>帧生成太快</td>
      <td>撕裂（Tearing）</td>
      <td>若无 vsync</td>
    </tr>
  </tbody>
</table>

<h3 id="一帧中关键的底层数据引擎角度">一帧中关键的底层数据（引擎角度）</h3>

<table>
  <thead>
    <tr>
      <th>结构/模块</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GameLoop</td>
      <td>每帧驱动所有系统的核心循环</td>
    </tr>
    <tr>
      <td>MonoBehaviourSystem</td>
      <td>驱动 C# 脚本的系统</td>
    </tr>
    <tr>
      <td>RenderLoop</td>
      <td>构建和提交渲染指令</td>
    </tr>
    <tr>
      <td>CommandBuffer</td>
      <td>存储一帧的渲染命令</td>
    </tr>
    <tr>
      <td>SwapChain</td>
      <td>管理图像缓冲与 vsync 交换</td>
    </tr>
    <tr>
      <td>GfxDevice</td>
      <td>抽象的 GPU 设备接口</td>
    </tr>
    <tr>
      <td>NativeContainer</td>
      <td>管理底层数据容器（如 Transform）</td>
    </tr>
  </tbody>
</table>

<h3 id="每帧中资源怎么流转">每帧中资源怎么流转</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">C# 代码 -&gt; C++ 引擎 -&gt; GfxDevice -&gt; GPU Pipeline -&gt; 帧缓冲 -&gt; 显示器</code></li>
  <li>Unity做了大量C# &lt;-&gt; C++ &lt;-&gt; GPU间的数据传输</li>
</ul>

<h2 id="unity的高效框架优化">Unity的高效框架优化</h2>
<blockquote>
  <p>这些操作能在一帧时间内完成，是因为Unity通过了“并行化 + 最小化处理 + GPU卸载 + 帧缓冲机制”等一套高效框架优化，最大程度压缩了每一帧的工作流程</p>
</blockquote>

<h3 id="为什么一帧能做这么多事">为什么一帧能做这么多事</h3>

<table>
  <thead>
    <tr>
      <th>原因</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>并行处理</strong></td>
      <td>利用多个线程同时处理物理、动画、渲染准备等</td>
    </tr>
    <tr>
      <td><strong>GPU 异步渲染</strong></td>
      <td>渲染任务交给 GPU，CPU 继续处理逻辑，不等待</td>
    </tr>
    <tr>
      <td><strong>渲染缓存机制</strong></td>
      <td>当前帧 CPU 和上一帧 GPU 同时工作</td>
    </tr>
    <tr>
      <td><strong>分帧处理</strong></td>
      <td>大任务（如寻路、加载）分帧执行，避免卡帧</td>
    </tr>
    <tr>
      <td><strong>批处理 + 合批</strong></td>
      <td>合并多个渲染对象为一次提交，减少 GPU 压力</td>
    </tr>
    <tr>
      <td><strong>剔除（Culling）优化</strong></td>
      <td>只渲染玩家能看到的东西</td>
    </tr>
    <tr>
      <td><strong>时间预算模型</strong></td>
      <td>每帧只做预算时间内的任务，多余的等下一帧</td>
    </tr>
  </tbody>
</table>

<h3 id="多线程并行架构">多线程并行架构</h3>
<p>Unity实际上一帧涉及多个并行线程</p>

<table>
  <thead>
    <tr>
      <th>线程</th>
      <th>负责内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>主线程</td>
      <td>脚本、GameObject 生命周期、逻辑</td>
    </tr>
    <tr>
      <td>渲染线程</td>
      <td>提交 DrawCall，生成 GPU 命令</td>
    </tr>
    <tr>
      <td>Job System</td>
      <td>并发处理物理、动画、AI 等任务</td>
    </tr>
    <tr>
      <td>GPU 线程</td>
      <td>执行渲染（光栅化、着色器等）</td>
    </tr>
  </tbody>
</table>

<p><strong>多线程图示（简化）</strong></p>
<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">帧</span> <span class="nn">#N</span>
<span class="err">主线程：</span>   <span class="err">─────►</span> <span class="nt">Update</span><span class="o">()</span> <span class="err">──►</span> <span class="nt">PrepareRender</span> <span class="err">─►</span> <span class="nt">Present</span>
<span class="err">渲染线程：</span>           <span class="err">─────►</span> <span class="nt">Submit</span> <span class="nt">Commands</span>
<span class="nt">GPU</span> <span class="err">线程：</span>                     <span class="err">─────►</span> <span class="err">渲染执行</span>
</code></pre></div></div>
<p>每个线程在同时工作，不是等待某个线程跑完再开始</p>

<h3 id="最小化处理">最小化处理</h3>
<p>Unity在每一帧中，只处理真正必要、真正可见、真正变化的内容，而不是对所有对象、组件、资源都进行全量遍历和更新<br />
这是一种性能优化策略，目的是</p>
<ul>
  <li>减少CPU和内存的使用</li>
  <li>减少主线程压力</li>
  <li>减少渲染压力</li>
  <li>保证帧率稳定</li>
</ul>

<h4 id="最小化处理的核心原则">最小化处理的核心原则</h4>

<table>
  <thead>
    <tr>
      <th>原则</th>
      <th>举例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>只更新<strong>变化</strong>的对象</td>
      <td>静止物体不会触发动画或物理</td>
    </tr>
    <tr>
      <td>只渲染<strong>可见</strong>的物体</td>
      <td>被遮挡或不在视野内的对象被剔除（Culling）</td>
    </tr>
    <tr>
      <td>只处理<strong>在场景中激活</strong>的对象</td>
      <td>非激活 GameObject 不调用生命周期函数</td>
    </tr>
    <tr>
      <td>只计算<strong>必要精度</strong>的数据</td>
      <td>LOD 降级，简化远处模型</td>
    </tr>
    <tr>
      <td>按需执行<strong>系统模块</strong></td>
      <td>关闭未使用系统，如 NavMesh、布料、粒子</td>
    </tr>
  </tbody>
</table>

<h4 id="unity常见的最小化处理机制">Unity常见的“最小化处理”机制</h4>
<h5 id="1剔除culling">1.剔除（Culling）</h5>
<p>Unity会自动或手动剔除无用物体，跳过渲染或逻辑更新</p>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Frustum Culling</td>
      <td>相机视锥外的物体不渲染</td>
    </tr>
    <tr>
      <td>Occlusion Culling</td>
      <td>被遮挡的物体不渲染</td>
    </tr>
    <tr>
      <td>LOD Group</td>
      <td>距离远时使用低面数模型</td>
    </tr>
    <tr>
      <td>Static Batching</td>
      <td>静态物体合批减少绘制指令</td>
    </tr>
  </tbody>
</table>

<h5 id="2非激活物体不处理">2.非激活物体不处理</h5>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gameObject</span><span class="p">.</span><span class="nf">SetActive</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>不会执行<code class="language-plaintext highlighter-rouge">Update()</code></li>
  <li>不会被物理系统检测</li>
  <li>不参与渲染</li>
  <li>节省计算资源</li>
</ul>

<h5 id="3脚本生命周期函数的懒执行">3.脚本生命周期函数的懒执行</h5>
<p>Unity不会在每一帧中调用所有函数，只有对应条件满足才会触发<br />
比如：</p>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>条件</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Update()</code></td>
      <td>每帧调用（激活物体）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FixedUpdate()</code></td>
      <td>只在固定帧率更新（物理开启）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnBecameVisible()</code></td>
      <td>物体刚出现在相机里时</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LateUpdate()</code></td>
      <td>Update之后才调</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnTriggerEnter()</code></td>
      <td>只有碰撞才调</td>
    </tr>
  </tbody>
</table>

<h5 id="4jobsystem--burst的细粒度任务调度">4.JobSystem / Burst的细粒度任务调度</h5>
<ul>
  <li>Job System会把数据分片并发处理，并自动分配到空闲进程</li>
  <li>Burst编译器会将运算变成SIMD、无分支命令，极致压缩计算量</li>
</ul>

<p>目标：尽量避免主线程阻塞和不必要的处理</p>

<h5 id="5实例化和资源加载的最小化">5.实例化和资源加载的最小化</h5>

<table>
  <thead>
    <tr>
      <th>技术</th>
      <th>优化点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对象池（Object Pool）</td>
      <td>重用对象，避免频繁 Instantiate/Destroy</td>
    </tr>
    <tr>
      <td>Addressables 异步加载</td>
      <td>只在用到时加载资源</td>
    </tr>
    <tr>
      <td>场景流（Scene Streaming）</td>
      <td>只加载玩家附近区域的场景</td>
    </tr>
    <tr>
      <td>延迟加载（Lazy Init）</td>
      <td>某些组件在用到时再初始化</td>
    </tr>
  </tbody>
</table>

<h3 id="gpu卸载">GPU卸载</h3>
<p>GPU卸载，是指将计算密集、并行性强的工作从CPU转交给GPU来完成，以释放CPU的压力，从而提升整帧执行效率</p>

<h3 id="原因">原因</h3>
<ul>
  <li>GPU并行能力极强：GPU内部拥有成千上万个核心，能同时处理大量数据（如像素、顶点）</li>
  <li>CPU是瓶颈：Unity主线程常因逻辑繁忙，成为帧率瓶颈</li>
  <li>渲染任务天然适合GPU：像素计算、顶点变换、光照、后处理等可并行处理</li>
  <li>渲染和逻辑可并行执行</li>
</ul>

<h3 id="哪些任务会被卸载到gpu">哪些任务会被卸载到GPU</h3>

<table>
  <thead>
    <tr>
      <th>卸载内容</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>顶点变换</td>
      <td>模型的顶点坐标变换（MVP矩阵）</td>
    </tr>
    <tr>
      <td>光照计算</td>
      <td>每像素 / 顶点光照、反射、阴影等</td>
    </tr>
    <tr>
      <td>像素着色</td>
      <td>Color blending、贴图、Fog、后期特效等</td>
    </tr>
    <tr>
      <td>后处理</td>
      <td>Bloom、AO、DOF、MotionBlur 等</td>
    </tr>
    <tr>
      <td>GPU Instancing</td>
      <td>一次性绘制成千上万相同模型</td>
    </tr>
    <tr>
      <td>Compute Shader</td>
      <td>通用并行任务，如粒子模拟、布料、体积雾等</td>
    </tr>
  </tbody>
</table>

<h3 id="unity如何实现gpu卸载">Unity如何实现GPU卸载</h3>
<p>主线程构建渲染命令 -&gt; 渲染线程提交 -&gt; GPU异步执行</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Unity C#层伪流程</span>
<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">UpdateLogic</span><span class="p">();</span> <span class="c1">// 脚本逻辑运行（CPU）</span>
    <span class="nf">UpdateAnimaion</span><span class="p">();</span> <span class="c1">// 动画采样（CPU或Job）</span>
    <span class="nf">PrepareDrawCalls</span><span class="p">();</span> <span class="c1">// 构建绘制命令</span>
    <span class="c1">// 提交给GPU渲染线程 </span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">PrepareDrawCalls()</code>把数据交给GPU（通过command buffer）</li>
  <li>GPU异步处理，不阻塞主线程</li>
</ul>

<h3 id="gpu着色器">GPU着色器</h3>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Vertex Shader</td>
      <td>每个顶点执行一次，变换模型到裁剪空间</td>
    </tr>
    <tr>
      <td>Fragment (Pixel) Shader</td>
      <td>每像素执行一次，计算最终颜色</td>
    </tr>
    <tr>
      <td>Geometry / Tessellation Shader</td>
      <td>细分曲面或生成额外几何体</td>
    </tr>
    <tr>
      <td>Compute Shader</td>
      <td>并行通用计算，不限于渲染任务（如粒子模拟）</td>
    </tr>
  </tbody>
</table>

<p><strong>Unity Standard Shader如何借助GPU完成渲染</strong>
当你使用Unity内置Shader，如Standard Shader，它会自动在GPU上执行如下操作：</p>
<ul>
  <li>变换每个顶点位置（MVP）</li>
  <li>对每个像素计算光照、纹理贴图、法线贴图</li>
  <li>对半透明物体进行混合</li>
  <li>对反射、环境光遮蔽等做实时计算</li>
</ul>

<blockquote>
  <p>如果这些都在CPU上完成，一帧可能要跑1分钟</p>
</blockquote>

<p><strong>图示：Unity渲染流程（CPU -&gt; GPU）</strong></p>
<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">C</span><span class="nn">#</span> <span class="err">脚本逻辑</span> <span class="nt">Update</span><span class="o">()]</span>        <span class="err">┐</span>
<span class="o">[</span><span class="err">动画采样</span><span class="o">/</span><span class="err">物理运算</span><span class="o">]</span>          <span class="err">├─</span> <span class="nt">CPU</span> <span class="o">(</span><span class="err">主线程</span><span class="o">)</span>
<span class="o">[</span><span class="err">构建</span> <span class="nt">DrawCall</span> <span class="err">命令</span><span class="o">]</span>         <span class="err">┘</span>
         <span class="err">↓</span>
<span class="o">[</span><span class="err">渲染线程打包命令</span><span class="o">]</span> <span class="err">─→</span> <span class="nt">CommandBuffer</span>
         <span class="err">↓</span>
<span class="o">[</span><span class="nt">GFX</span> <span class="nt">Device</span> <span class="err">发给</span> <span class="nt">GPU</span><span class="o">]</span>
         <span class="err">↓</span>
<span class="o">[</span><span class="nt">GPU</span> <span class="err">执行：</span><span class="nt">Shader</span> <span class="err">➜</span> <span class="nt">Raster</span> <span class="err">➜</span> <span class="nt">PostFX</span><span class="o">]</span>
</code></pre></div></div>

<h3 id="cpu与gpu的帧缓冲双缓冲机制">CPU与GPU的帧缓冲双缓冲机制</h3>
<p>Unity会将“本帧CPU逻辑”和上一帧“GPU渲染”并行进行</p>
<ul>
  <li>当前帧：CPU构建渲染命令</li>
  <li>上一帧：GPU正在执行渲染</li>
</ul>

<p>这样就不会阻塞CPU，也不会GPU空转</p>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-06-01T00:00:00+08:00">June 1, 2025</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/posts/2025-06-09-Time-System/" class="pagination--pager" title="Time System">Previous</a>
    
    
      <a href="/2025-06-10-Serialization-and-Persistance/" class="pagination--pager" title="Serialization and Persistence">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/ljf12825" rel="nofollow noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">ljf12825's Blog</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
