<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.1 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Unity Component Communication - ljf12825’s Blog</title>
<meta name="description" content="在Unity中，组件之间的通信是非常重要的，因为它决定了不同模块如何相互交互和协作">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="ljf12825's Blog">
<meta property="og:title" content="Unity Component Communication">
<meta property="og:url" content="http://localhost:4000/posts/2025-07-15-Unity-Component-Communication/">


  <meta property="og:description" content="在Unity中，组件之间的通信是非常重要的，因为它决定了不同模块如何相互交互和协作">







  <meta property="article:published_time" content="2025-06-01T00:00:00+08:00">






<link rel="canonical" href="http://localhost:4000/posts/2025-07-15-Unity-Component-Communication/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="ljf12825's Blog Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- favicon -->
<link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon">

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          ljf12825's Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Categories</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tags</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Unity Component Communication">
    <meta itemprop="description" content="在Unity中，组件之间的通信是非常重要的，因为它决定了不同模块如何相互交互和协作">
    <meta itemprop="datePublished" content="2025-06-01T00:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/posts/2025-07-15-Unity-Component-Communication/" itemprop="url">Unity Component Communication
</a>
          </h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>在Unity中，组件之间的通信是非常重要的，因为它决定了不同模块如何相互交互和协作</p>

<p>正确的组件通信方式可以帮助实现松耦合、易于维护和扩展的架构</p>

<h2 id="getcomponentt直接调用显示调用"><code class="language-plaintext highlighter-rouge">GetComponent&lt;T&gt;()</code>直接调用（显示调用）</h2>
<p>这是Unity中最常见的方式之一，直接通过<code class="language-plaintext highlighter-rouge">GetComponent&lt;T&gt;()</code>获取组件实例，然后调用它的函数</p>

<p>它是显式的、直接的调用，没有任何抽象或间接层</p>

<p>由于它是强类型的，编译时可以检查类型错误，因此推荐使用</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Health</span> <span class="n">health</span> <span class="p">=</span> <span class="n">target</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Health</span><span class="p">&gt;();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">health</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="n">health</span><span class="p">.</span><span class="nf">TakeDamage</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
</code></pre></div></div>
<p>这个例子中，<code class="language-plaintext highlighter-rouge">GetComponent&lt;Health&gt;()</code>获取到目标GameObject上的<code class="language-plaintext highlighter-rouge">Health</code>组件，并调用其<code class="language-plaintext highlighter-rouge">TakeDamage()</code>方法</p>

<h3 id="使用方式">使用方式</h3>
<ul>
  <li>获取组件
<code class="language-plaintext highlighter-rouge">GetComponent&lt;T&gt;()</code>可以用于任何附加到GameObject上的组件。只要该组件存在，就可以通过该方法获取
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">palyer</span> <span class="p">=</span> <span class="n">gameObject</span><span class="p">.</span><span class="n">GetComponet</span><span class="p">&lt;</span><span class="n">Player</span><span class="p">&gt;();</span>
</code></pre></div>    </div>
  </li>
  <li>调用方法
获取到组件后，直接调用该组件暴露的方法
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">player</span><span class="p">.</span><span class="nf">TakeDamage</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
</code></pre></div>    </div>
    <p>示例
假设有一个<code class="language-plaintext highlighter-rouge">Player</code>组件和一个<code class="language-plaintext highlighter-rouge">Enemy</code>组件，<code class="language-plaintext highlighter-rouge">Enemy</code>需要让<code class="language-plaintext highlighter-rouge">Player</code>受到伤害
```cs
//在敌人脚本中
public class Enemy : MonoBehaviour
{
  public void AttackPlayer(GameObject palyer)
  {
      // 获取Player组件
      var palyerHealth = player.GetComponent<PlayerHealth>();
      if (pllayerHealth != null)
          // 直接调用PlayerHealth组件的TakeDamage方法
          playerHealth.TakeDamage(20);
  }
}</PlayerHealth></p>
  </li>
</ul>

<p>// 在PlayerHealth脚本中
public class PlayerHealth : MonoBehaviour
{
    public int health = 100;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void TakeDamage(int amount)
{
    health -= amount;
    Debug.Log($"Player took {amount} damage. Remaining health: {health}");
} } ```
</code></pre></div></div>

<p>优点</p>
<ul>
  <li>强类型，编译时检查</li>
  <li>清晰明了</li>
  <li>执行效率高</li>
</ul>

<p>缺点</p>
<ul>
  <li>
    <p>紧密耦合
直接调用会使组件之间的耦合变得非常紧密。<code class="language-plaintext highlighter-rouge">GetComponent&lt;T&gt;()</code> 强依赖于组件的具体类型，这意味着如果目标组件被更改或删除，代码将直接失败</p>
  </li>
  <li>
    <p>不适合频繁调用
如果频繁调用，尤其是在每帧调用中，会造成一定的性能损失。每次调用都会进行组件查找，增加了计算开销</p>
  </li>
</ul>

<p>解决办法：可以缓存组件，减少调用次数</p>

<ul>
  <li>代码扩展性差</li>
</ul>

<p>适用场景</p>
<ul>
  <li>适用于明确的组件之间的交互</li>
</ul>

<h3 id="最佳实践">最佳实践</h3>
<ul>
  <li>缓存组件引用：避免在<code class="language-plaintext highlighter-rouge">Update()</code>或频繁调用的地方使用<code class="language-plaintext highlighter-rouge">GetComponent&lt;T&gt;()</code>，应当在<code class="language-plaintext highlighter-rouge">Start()</code>或<code class="language-plaintext highlighter-rouge">Awake()</code>中缓存组件引用
```cs
private Health playerHealth;</li>
</ul>

<p>void Awake() =&gt; playerHealth = GetComponent<Health>();</Health></p>

<p>void TakeDamage() =&gt; playerHealth.TakeDamage(10);</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- 使用接口解耦：如果希望减少对具体组件的依赖，可以结合接口来解耦，使用接口来代替直接访问某个具体类型的组件
```cs
public interface IDamageable
{
    void TakeDamage(int amount);
}

void ApplyDamage(GameObject target)
{
    var damageable = target.GetComponent&lt;IDamageable&gt;();
    damageable?.TakeDamage(10);
}
</code></pre></div></div>
<ul>
  <li>适用于简单交互：直接调用适用于简单、短期的交互场景。在复杂或长期的系统中，应该考虑更为灵活的通信机制</li>
</ul>

<h3 id="总结">总结</h3>
<p>直接调用是最基础的组件通信方式，通过<code class="language-plaintext highlighter-rouge">GetComponent&lt;T&gt;()</code>获取组件并调用其方法。这种方式简单、直接、强类型，并且性能较好，但它会导致较强的耦合性，维护和扩展上可能会遇到问题。在实际项目中，如果不涉及频繁的组件访问，直接调用是一个非常有效且高效的选择，但需要小心耦合度过高带来的问题</p>

<h2 id="unityevent事件系统"><code class="language-plaintext highlighter-rouge">UnityEvent</code>事件系统</h2>
<p><code class="language-plaintext highlighter-rouge">UnityEvent</code>是Unity自带的事件系统，可以在Inspector中将方法直接绑定到事件</p>

<p><code class="language-plaintext highlighter-rouge">UnityEvent</code>是一个非常好的替代方案，尤其是希望在多个对象之间进行松耦合的通信时</p>

<p>它提供了一种可视化、无代码的方式来绑定事件</p>

<h3 id="基本概念">基本概念</h3>
<p><code class="language-plaintext highlighter-rouge">UnityEvent</code>是一个泛型类，继承自<code class="language-plaintext highlighter-rouge">UnityEventBase</code>，允许开发者创建可以在运行时调用的事件。与传统的C#委托不同，<code class="language-plaintext highlighter-rouge">UnityEvent</code>的优点在于它可以在Inspector面板中绑定方法</p>

<h3 id="声明与使用">声明与使用</h3>
<p>声明<br />
首先，可以在MonoBehaviour类中声明一个<code class="language-plaintext highlighter-rouge">UnityEvent</code>类型的成员变量，并且为它指定相应的泛型参数，表明事件需要传递哪些类型的参数</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.Events</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">EventExample</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">// 声明一个不带参数的UnityEvent</span>
    <span class="k">public</span> <span class="n">UnityEvent</span> <span class="n">onClick</span><span class="p">;</span>

    <span class="c1">// 声明一个带整数参数的UnityEvent</span>
    <span class="k">public</span> <span class="n">UnityEvent</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">onScoreUpdated</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 通过代码手动触发事件</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">onClick</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="n">onClick</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>

        <span class="c1">// 触发带参数的事件</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">onScoreUpdated</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="n">onScoreUpdated</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>绑定事件<br />
在Unity编辑器中，<code class="language-plaintext highlighter-rouge">UnityEvent</code>会自动出现在Inspector面板中。可以直接拖拽对象、选择方法进行绑定，方法签名要与事件的参数类型一致</p>

<h3 id="事件类型">事件类型</h3>
<p><code class="language-plaintext highlighter-rouge">UnityEvent</code>可以有不同的类型，具体由传入的泛型来定义。常见的类型包括</p>
<ul>
  <li>无参事件：<code class="language-plaintext highlighter-rouge">UnityEvent</code></li>
  <li>带参数事件：<code class="language-plaintext highlighter-rouge">UnityEvent&lt;int&gt;</code>,<code class="language-plaintext highlighter-rouge">UnityEvent&lt;float&gt;</code>,<code class="language-plaintext highlighter-rouge">UnityEvent&lt;string&gt;</code>等</li>
  <li>多参数事件：<code class="language-plaintext highlighter-rouge">UnityEvent&lt;int, string&gt;</code>,`UnityEvent&lt;Vector3, bool&gt;等</li>
</ul>

<h3 id="事件的调用与触发">事件的调用与触发</h3>
<p>事件的调用可以通过<code class="language-plaintext highlighter-rouge">Invoke()</code>方法来触发，也可以在方法中根据具体逻辑判断是否触发事件</p>

<p>例如，在物体碰撞时触发事件</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">OnTriggerEnter</span><span class="p">(</span><span class="n">Collider</span> <span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 只有在触发器碰到特定的物体时，才触发事件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="s">"Player"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">onClick</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="n">onClick</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="unityevent与c委托的区别">UnityEvent与C#委托的区别</h3>
<ul>
  <li>灵活性：<code class="language-plaintext highlighter-rouge">UnityEvent</code>可以通过Inspector绑定和设置，而C#委托需要在代码中显式地进行订阅和触发</li>
  <li>可视化支持：<code class="language-plaintext highlighter-rouge">UnityEvent</code>使得事件的订阅可以在编辑器中完成，不需要修改代码，而委托则需要写代码来添加和移除事件处理程序</li>
</ul>

<h3 id="unityevent性能">UnityEvent性能</h3>
<p>虽然<code class="language-plaintext highlighter-rouge">UnityEvent</code>非常方便，但它相比于传统的C#委托来说，存在一些性能开销，尤其是在大量事件触发和监听的场景下。因此，在需要高性能的情况下，可能更适合使用C#委托</p>

<h3 id="unity与序列化">Unity与序列化</h3>
<p><code class="language-plaintext highlighter-rouge">UnityEvent</code>是序列化的，因此它可以存储在ScriptableObject中，这使得可以在多个场景中重用事件逻辑，并且可以让事件的响应由数据驱动</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">System</span><span class="p">.</span><span class="n">Serializable</span><span class="p">]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MyGameEvent</span> <span class="p">:</span> <span class="n">UnityEvent</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="p">{}</span>
</code></pre></div></div>

<p>优点</p>
<ul>
  <li>易于设置和使用</li>
  <li>适用于编辑器，支持Inspector中的可视化部署</li>
  <li>松耦合</li>
</ul>

<p>缺点</p>
<ul>
  <li>性能较差，尤其是频繁触发事件时</li>
  <li>不支持返回值和参数类型检查</li>
</ul>

<p>适用场景</p>
<ul>
  <li>适合UI交互、动画、音效等场景</li>
</ul>

<h2 id="c委托事件">C#委托/事件</h2>
<p>C#原生的委托和事件是灵活且强大的通信方式，它提供了一种灵活、松耦合的方式来实现不同组件间的消息传递和响应<br />
使用委托和事件可以避免组件间的直接引用，减少耦合性，增强系统的可扩展性和可维护性</p>

<p><a href="/posts/2025-06-03-Event-Driven-Architecture/">Event Driven Architecture</a></p>

<p>优点</p>
<ul>
  <li>类型安全</li>
  <li>支持多播事件</li>
  <li>灵活，适用于大部分场景</li>
</ul>

<p>缺点</p>
<ul>
  <li>没有Inspector支持，需要编写代码进行管理</li>
  <li>可能会导致内存泄露，如果不正确取消订阅</li>
</ul>

<p>适用场景</p>
<ul>
  <li>跨对象和模块的通信，尤其适用于游戏内事件系统</li>
</ul>

<h2 id="接口调用">接口调用</h2>
<p>这种方式通过接口来解耦对象之间的依赖，在目标对象实现了接口后，可以在不关心具体实现的情况下调用接口中的方法。这种方法有效地减少了直接依赖，增加了代码的可扩展性和维护性</p>

<p>常见使用场景：</p>
<ol>
  <li>跨组件通信：不同组件之间需要交互时，接口提供了统一的通信方式</li>
  <li>插件式结构：实现可插拔的功能系统，接口定义通用行为，插件通过实现接口提供特定功能</li>
  <li>系统解耦：比如处理物理、音效、UI等模块时，每个接口通过接口进行交互，不需要依赖其他模块的具体实现</li>
</ol>

<p><a href="/posts/2025-07-15-Interface-Oriented-Design/">Interface Oriented Design</a></p>

<p>优点：</p>
<ul>
  <li>强烈建议用于解耦</li>
  <li>易于扩展和替换具体实现</li>
  <li>增强了代码的可维护性</li>
</ul>

<p>缺点：</p>
<ul>
  <li>比较难以理解，尤其是在复杂系统中</li>
  <li>使用不当可能导致过度设计</li>
</ul>

<p>适用场景</p>
<ul>
  <li>大型项目中，不同模块间的解耦通信</li>
</ul>

<h2 id="scriptableobject事件"><code class="language-plaintext highlighter-rouge">ScriptableObject</code>事件</h2>
<p><code class="language-plaintext highlighter-rouge">ScriptableObject</code>是一种用于在不同对象间传递数据和事件的高效方式</p>

<p>可以利用它作为一个全局事件总线，管理和调度事件</p>

<p>它不仅限于事件处理，还可以存储游戏数据，降低了系统的耦合度</p>

<p><a href="/posts/2025-07-11-ScriptableObject/">ScriptableObject</a></p>

<p>优点</p>
<ul>
  <li>非常适合跨场景或跨对象的数据共享</li>
  <li>支持多个监听器，易于扩展</li>
  <li>更加灵活和高效</li>
</ul>

<p>缺点</p>
<ul>
  <li>设置和管理相对复杂</li>
  <li>对新手来说可能不太直观</li>
</ul>

<p>适用场景</p>
<ul>
  <li>用于跨场景、跨对象的数据管理和事件处理</li>
</ul>

<h2 id="sendmessagebroadcastmessage反射调用"><code class="language-plaintext highlighter-rouge">SendMessage()</code>/<code class="language-plaintext highlighter-rouge">BroadcastMessage()</code>（反射调用）</h2>
<p><code class="language-plaintext highlighter-rouge">SendMessage()</code>和<code class="language-plaintext highlighter-rouge">BroadcastMessage()</code>是Unity中的反射调用机制，可以通过这些方法发送字符串消息到对象中对应的函数</p>

<p>这种方式并不要求目标对象实现特定的接口或类，比较灵活，但它是通过反射实现的，因此性能较差</p>

<h3 id="sendmessage"><code class="language-plaintext highlighter-rouge">SendMessage()</code></h3>
<p><code class="language-plaintext highlighter-rouge">SendMessage()</code>方法用于向对象上的所有组件发送消息，它会尝试调用指定名称的方法。消息通过字符串名称传递，因此在调用时不需要直接引用方法，允许动态调用方法。这种方式适用于不关心具体实现，只想告诉对象某个事件发生的情况</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gameObject</span><span class="p">.</span><span class="nf">SendMessage</span><span class="p">(</span><span class="s">"MethodName"</span><span class="p">,</span> <span class="n">parameter</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">MethodName</code>：目标方法的名称（字符串形式）</li>
  <li><code class="language-plaintext highlighter-rouge">parameter</code>：可选的参数，传递给目标方法。如果目标方法不需要参数，可以忽略</li>
</ul>

<p><strong>示例</strong><br />
假设有一个<code class="language-plaintext highlighter-rouge">Player</code>类和一个<code class="language-plaintext highlighter-rouge">Enemy</code>类，希望通过<code class="language-plaintext highlighter-rouge">SendMessage()</code>让<code class="language-plaintext highlighter-rouge">Enemy</code>知道<code class="language-plaintext highlighter-rouge">Player</code>受到伤害<br />
class <code class="language-plaintext highlighter-rouge">Player</code></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Palyer</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">health</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>

    <span class="c1">// 用于调用SendMessage()方法</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">TakeDamage</span><span class="p">(</span><span class="kt">int</span> <span class="n">damage</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">health</span> <span class="p">-=</span> <span class="n">damamge</span><span class="p">;</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"Player takes </span><span class="p">{</span><span class="n">damage</span><span class="p">}</span><span class="s"> damage, current health: </span><span class="p">{</span><span class="n">health</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>class <code class="language-plaintext highlighter-rouge">Enemy</code></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 使用SendMessage()发送消息</span>
        <span class="n">GameObject</span> <span class="n">player</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">"Player"</span><span class="p">);</span>
        <span class="n">player</span><span class="p">.</span><span class="nf">SendMessage</span><span class="p">(</span><span class="s">"TakeDamage"</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span> <span class="c1">// 向Player发送消息并传递伤害值</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在这个例子中，<code class="language-plaintext highlighter-rouge">Enemy</code>会在<code class="language-plaintext highlighter-rouge">Start()</code>方法中向<code class="language-plaintext highlighter-rouge">Player</code>发送<code class="language-plaintext highlighter-rouge">TakeDamage</code>消息，并传递一个伤害值。<code class="language-plaintext highlighter-rouge">Player</code>会在收到这个消息后执行相应逻辑</p>

<p>注意：</p>
<ul>
  <li>如果没有找到目标方法：<code class="language-plaintext highlighter-rouge">SendMessage()</code>会输出错误信息，因此在编写代码时需要确保目标方法的名称拼写正确</li>
  <li><code class="language-plaintext highlighter-rouge">SendMessage()</code>是基于反射的，调用过程相对较慢，所以不建议在高频次的地方更新方法（如<code class="language-plaintext highlighter-rouge">Update()</code>中使用）</li>
</ul>

<h3 id="broadcastmessage"><code class="language-plaintext highlighter-rouge">BroadcastMessage()</code></h3>
<p><code class="language-plaintext highlighter-rouge">BroadcastMessage()</code>方法类似于<code class="language-plaintext highlighter-rouge">SendMessage()</code>，但它会将消息发送到所有该对象上的组件，甚至包括所有子对象上的组件。这使得它特别适合在需要向一个对象的所有子组件广播事件时使用</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gameObject</span><span class="p">.</span><span class="nf">BroadcastMessage</span><span class="p">(</span><span class="s">"MethodName"</span><span class="p">,</span> <span class="n">parameter</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">MethodName</code>：目标方法的名称（字符串形式）</li>
  <li><code class="language-plaintext highlighter-rouge">parameter</code>：可选参数，传递给目标方法</li>
</ul>

<p><strong>示例</strong><br />
假设有一个<code class="language-plaintext highlighter-rouge">Player</code>对象和多个子物体（比如装备、武器等），希望通知所有子物体执行某个行为。例如，当<code class="language-plaintext highlighter-rouge">Player</code>受到伤害时，所有子物体的特效和音效应该播放<br />
class <code class="language-plaintext highlighter-rouge">Player</code></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Player</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">health</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>

    <span class="c1">// 用于调用BroadcastMessage()的方法</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">TakeDamage</span><span class="p">(</span><span class="kt">int</span> <span class="n">damage</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">health</span> <span class="p">-=</span> <span class="n">damage</span><span class="p">;</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"Player takes </span><span class="p">{</span><span class="n">damage</span><span class="p">}</span><span class="s"> damage, current health : </span><span class="p">{</span><span class="n">health</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

        <span class="nf">BroadcastMessage</span><span class="p">(</span><span class="s">"OnPlayerDamaged"</span><span class="p">,</span> <span class="n">health</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>class <code class="language-plaintext highlighter-rouge">Weapon</code>（子对象）</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Weapon</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">// 接收消息的方法</span>
    <span class="k">void</span> <span class="nf">OnPlayerDamage</span><span class="p">(</span><span class="kt">int</span> <span class="n">health</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"Weapon reacting to damage, Player's current health: </span><span class="p">{</span><span class="n">health</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>class <code class="language-plaintext highlighter-rouge">Shield</code>（子对象）</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Shield</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">// 接收消息的方法</span>
    <span class="k">void</span> <span class="nf">OnPlayerDamage</span><span class="p">(</span><span class="kt">int</span> <span class="n">health</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"Shield reacting to damage, Player's current health: </span><span class="p">{</span><span class="n">health</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>场景中的GameObject<br />
这个例子中，<code class="language-plaintext highlighter-rouge">Player</code>受到伤害时，会向它的所有子对象发送<code class="language-plaintext highlighter-rouge">OnPlayerDamaged</code>消息，并传递玩家当前生命值。所有子物体（例如<code class="language-plaintext highlighter-rouge">Weapon</code>和<code class="language-plaintext highlighter-rouge">Shield</code>）都可以根据这个信息作出反应</p>

<p>注意：\</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">BroadcastMessage()</code>会发送给所有子物体上的相同名称的方法，所以子物体必须实现该方法。如果某个子物体没有实现目标方法，它会收到一个错误信息</li>
  <li><code class="language-plaintext highlighter-rouge">BroadcastMessage()</code>也是基于反射的，因此性能开销大。需要避免在性能敏感的地方频繁调用</li>
</ul>

<h3 id="sendmessage-vs-broadcastmessage"><code class="language-plaintext highlighter-rouge">SendMessage()</code> vs <code class="language-plaintext highlighter-rouge">BroadcastMessage()</code></h3>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th><code class="language-plaintext highlighter-rouge">SendMessage()</code></th>
      <th><code class="language-plaintext highlighter-rouge">BroadcastMessage()</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>目标对象</strong></td>
      <td>只发送给目标对象本身</td>
      <td>发送给目标对象及其所有子对象</td>
    </tr>
    <tr>
      <td><strong>使用场景</strong></td>
      <td>适用于单一对象的消息传递</td>
      <td>适用于向所有子对象发送消息</td>
    </tr>
    <tr>
      <td><strong>消息发送方式</strong></td>
      <td>发送给指定对象的指定方法</td>
      <td>发送给对象及其所有子对象的相同方法</td>
    </tr>
    <tr>
      <td><strong>性能开销</strong></td>
      <td>相对较高，基于反射</td>
      <td>性能开销更大，因为需要遍历所有子对象</td>
    </tr>
    <tr>
      <td><strong>方法要求</strong></td>
      <td>目标方法需要匹配名称和参数</td>
      <td>子物体的所有方法都需要匹配名称和参数</td>
    </tr>
  </tbody>
</table>

<p>优点</p>
<ul>
  <li>很灵活，可以动态调用</li>
  <li>不需要目标对象实现特定接口或类</li>
</ul>

<p>缺点</p>
<ul>
  <li>性能差，使用反射会增加运行时开销</li>
  <li>易出错，因为字符串消息没有类型检查</li>
  <li>不利于调试和维护</li>
</ul>

<p>适用场景</p>
<ul>
  <li>仅在特殊情况下，避免使用</li>
</ul>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-06-01T00:00:00+08:00">June 1, 2025</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/posts/2025-07-11-Object/" class="pagination--pager" title="Object">Previous</a>
    
    
      <a href="/posts/2025-07-18-Assets-Import-and-Load/" class="pagination--pager" title="Assets Import and Load">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/ljf12825" rel="nofollow noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">ljf12825's Blog</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
