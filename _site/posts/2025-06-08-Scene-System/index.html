<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.1 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Scene System - ljf12825’s Blog</title>
<meta name="description" content="Unity Scene System是Unity中用于组织和管理游戏世界的基础结构，Unity支持多个Scene的加载与卸载，允许构建出大型、分块化的世界">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="ljf12825's Blog">
<meta property="og:title" content="Scene System">
<meta property="og:url" content="http://localhost:4000/posts/2025-06-08-Scene-System/">


  <meta property="og:description" content="Unity Scene System是Unity中用于组织和管理游戏世界的基础结构，Unity支持多个Scene的加载与卸载，允许构建出大型、分块化的世界">







  <meta property="article:published_time" content="2025-06-01T00:00:00+08:00">






<link rel="canonical" href="http://localhost:4000/posts/2025-06-08-Scene-System/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="ljf12825's Blog Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- favicon -->
<link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon">

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          ljf12825's Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Categories</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tags</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Scene System">
    <meta itemprop="description" content="Unity Scene System是Unity中用于组织和管理游戏世界的基础结构，Unity支持多个Scene的加载与卸载，允许构建出大型、分块化的世界">
    <meta itemprop="datePublished" content="2025-06-01T00:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/posts/2025-06-08-Scene-System/" itemprop="url">Scene System
</a>
          </h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>Unity Scene System是Unity中用于组织和管理游戏世界的基础结构，Unity支持多个Scene的加载与卸载，允许构建出大型、分块化的世界</p>

<h2 id="scene">Scene</h2>
<p>Scene是Unity游戏项目中的一个基础构建单元，它就像游戏世界中的一个“地图”或“关卡”，一个Scene就是一个逻辑/物理空间的容器，包含了：</p>
<ul>
  <li>GameObject</li>
  <li>地形、UI、声音</li>
  <li>脚本、组件</li>
  <li>光照信息、烘焙数据等</li>
</ul>

<p>在Unity中，一个Scene对应一个<code class="language-plaintext highlighter-rouge">.unity</code>文件</p>

<h3 id="scene-生命周期">Scene 生命周期</h3>
<p>1.创建或打开场景（<code class="language-plaintext highlighter-rouge">.unity</code>文件）</p>

<p>2.布置场景内容</p>

<p>3.保存场景</p>

<p>4.构建和加载场景（Build Settings里添加场景）</p>

<p>5.运行时加载和卸载场景</p>

<h3 id="场景最佳实践">场景最佳实践</h3>
<ul>
  <li>保持每个场景的职责单一（比如UI与游戏逻辑分离）</li>
  <li>使用Prefab来管理重复对象</li>
  <li>使用场景加载器或管理器来控制场景切换和数据传递</li>
  <li>合理使用DontDestroyOnLoad来跨场景保存数据或对象</li>
</ul>

<h2 id="multi-scene">Multi Scene</h2>
<p>多场景允许你同时加载和管理多个场景，不同场景可以同时存在并且运行在游戏中，允许你灵活地处理加载、切换和卸载场景的需求</p>

<ol>
  <li>加载和卸载场景
    <ul>
      <li>Additive加载：可以在现有场景的基础上加载新的场景，这种方式不会卸载当前场景，而是将多个场景叠加在一起</li>
      <li>Single加载：可以将一个场景替换当前场景，这种方式会卸载当前场景并加载新的场景</li>
    </ul>
  </li>
  <li>常见的多场景应用场景
    <ul>
      <li>主菜单 + 游戏场景：主菜单和游戏场景可以同时加载，用户操作菜单时，游戏场景依然在后台运行</li>
      <li>动态加载关卡：可以根据游戏的进度或玩家行为动态加载或卸载不同的场景，比如一个大世界分为多个小场景，按需加载</li>
      <li>UI和游戏场景分离：UI可以独立于游戏场景加载，确保UI始终可用，而不受游戏场景加载状态的影响</li>
    </ul>
  </li>
</ol>

<h3 id="加载场景additive-和-single">加载场景（Additive 和 Single）</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Additive</code>加载：将新场景加载到现有场景中，保持当前场景不变</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Additive</code>加载意味着将一个新场景加载到现有场景的基础上，当前场景不会被卸载，而是与新场景一起共存。使用这种方式可以让多个场景并行运行，从而实现一些复杂的场景管理，例如分割大型场景，或者在后台加载新的场景内容</p>

<p>使用场景：</p>

<ul>
  <li>动态加载关卡：例如一个开放世界游戏，场景可以按需加载。加载一个新的区域时，现有区域不会被卸载</li>
  <li>UI 和游戏分离：UI 可以作为一个单独的场景加载并保持活跃，而游戏逻辑场景则可以独立运行</li>
  <li>多人游戏：在多人游戏中，玩家可能在多个子场景中互动，Additive 加载可以实现多个玩家在多个区域间的无缝切换</li>
</ul>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Additive</span>
<span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadScene</span><span class="p">(</span><span class="s">"NewScene"</span><span class="p">,</span> <span class="n">LoadSceneMode</span><span class="p">.</span><span class="n">Additive</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Single</code>加载：加载一个新场景并卸载当前场景</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Single</code>加载模式表示加载一个新场景并卸载当前的场景。这是传统的场景切换方式，通常用于当你需要完全切换到另一个场景时</p>

<p>使用场景：</p>
<ul>
  <li>关卡切换：当玩家从一个关卡进入另一个关卡时，Single 加载通常是最常用的方式</li>
  <li>游戏状态管理：如果你的游戏有明确的关卡结构或状态，切换到新场景时，可以使用 Single 模式来清空当前场景，加载一个全新的游戏状态</li>
</ul>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 加载场景（Single）</span>
<span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadScene</span><span class="p">(</span><span class="s">"NewScene"</span><span class="p">,</span> <span class="n">LoadSceneMode</span><span class="p">.</span><span class="n">Single</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="卸载场景">卸载场景</h3>
<p>如果你使用了<code class="language-plaintext highlighter-rouge">Additive</code>加载多个场景，可以选择卸载某个场景</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 卸载场景</span>
<span class="n">SceneManager</span><span class="p">.</span><span class="nf">UnloadSceneAsync</span><span class="p">(</span><span class="s">"OldScene"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="多场景加载的复杂性和管理">多场景加载的复杂性和管理</h3>
<p>在使用<code class="language-plaintext highlighter-rouge">Additive</code>加载时，场景之间的资源管理尤为重要。不同场景之间共享资源，可能会导致以下问题：</p>
<ul>
  <li>资源冲突：多个场景中可能会使用相同的资源（如材质、纹理、音效等），如果没有适当的管理，可能会发生资源覆盖或重复加载</li>
  <li>性能瓶颈：加载多个场景会增加内存使用量，尤其是在大型场景中。如果不及时卸载不需要的场景，可能会导致性能下降</li>
</ul>

<p><strong>避免场景间资源冲突</strong></p>
<ol>
  <li>
    <p>资源打包：利用Unity的资源打包系统（例如Asset Bundles或Addressables），可以让每个场景只加载所需的资源，避免多个场景之间的资源冲突</p>
  </li>
  <li>
    <p>场景划分与依赖管理：避免场景间有过强的依赖关系。例如，将游戏逻辑与UI、背景和音效分开，确保每个场景只包含特定职责的内容</p>
  </li>
  <li>
    <p>共享资源：通过<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>来管理那些需要跨场景的共享资源（如音频管理器、玩家数据管理器等）</p>
  </li>
</ol>

<h3 id="切换场景并保持场景之间的交互">切换场景并保持场景之间的交互</h3>
<p>使用多场景时，有时候你希望不同的场景之间可以交互。比如，可以在一个场景中控制另一个场景中的对象。<br />
可以通过<code class="language-plaintext highlighter-rouge">SceneManager.GetSceneByName</code>或<code class="language-plaintext highlighter-rouge">SceneManager.GetSceneAt</code>获取其他加载的场景，然后通过<code class="language-plaintext highlighter-rouge">Scene.GetRootGameObjects()</code>获取该场景中的所有根级对象，进一步操作它们</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取其他场景的根物体</span>
<span class="n">Scene</span> <span class="n">otherScene</span> <span class="p">=</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">GetSceneByName</span><span class="p">(</span><span class="s">"OtherScene"</span><span class="p">);</span>
<span class="n">GameObject</span><span class="p">[]</span> <span class="n">rootObjects</span> <span class="p">=</span> <span class="n">otherScene</span><span class="p">.</span><span class="nf">GetRootGameObjects</span><span class="p">();</span>

<span class="c1">// 操作场景中的物体</span>
<span class="k">foreach</span> <span class="p">(</span><span class="n">GameObject</span> <span class="n">obj</span> <span class="k">in</span> <span class="n">rootObjects</span><span class="p">)</span> <span class="n">obj</span><span class="p">.</span><span class="nf">SetActive</span><span class="p">(</span><span class="k">false</span><span class="p">);</span> <span class="c1">// 隐藏物体</span>
</code></pre></div></div>

<ul>
  <li>场景切换动画：为了避免切换场景时的黑屏，你可以在场景切换之前播放一个加载动画或者过渡动画</li>
</ul>

<h3 id="异步加载场景">异步加载场景</h3>
<h4 id="为什么使用异步加载">为什么使用异步加载</h4>
<p>异步加载允许你在场景加载的过程中保持游戏的流畅运行。异步加载时，Unity会在后台加载场景，不会阻塞主线程，因此可以避免游戏界面卡顿或掉帧<br />
异步加载常用于：</p>
<ul>
  <li>避免卡顿：在加载大型场景或资源时，异步加载可以有效减少游戏界面卡顿的现象</li>
  <li>展示加载进度：可以展示进度条或者加载动画，提升用户体验</li>
</ul>

<h4 id="异步加载基础">异步加载基础</h4>
<p>通过<code class="language-plaintext highlighter-rouge">SceneManager.LoadSceneAsync</code>可以异步加载场景，可以使用<code class="language-plaintext highlighter-rouge">AsyncOperation</code>对象来监控加载进度</p>

<p><strong>示例：</strong></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IEnumerator</span> <span class="nf">LoadSceneAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">sceneName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 异步加载场景</span>
    <span class="n">AsyncOperation</span> <span class="n">asyncLoad</span> <span class="p">=</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadSceneAsync</span><span class="p">(</span><span class="n">sceneName</span><span class="p">);</span>

    <span class="c1">// 等待场景加载完成</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">asyncLoad</span><span class="p">.</span><span class="n">isDone</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 显示加载进度</span>
        <span class="kt">float</span> <span class="n">progress</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Clamp01</span><span class="p">(</span><span class="n">asyncLoad</span><span class="p">.</span><span class="n">progress</span> <span class="p">/</span> <span class="m">0.9f</span><span class="p">);</span> <span class="c1">// 进度值[0, 1]</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Loading progress: "</span> <span class="p">+</span> <span class="n">progress</span><span class="p">);</span>

        <span class="c1">// 可以在这里更新进度条UI</span>

        <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// 每帧执行</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="async和await异步加载"><code class="language-plaintext highlighter-rouge">async</code>和<code class="language-plaintext highlighter-rouge">await</code>异步加载</h4>
<p>Unity在2017之后对C#的异步功能支持更好，支持使用<code class="language-plaintext highlighter-rouge">async</code>和<code class="language-plaintext highlighter-rouge">await</code>来简化异步操作。你可以将异步加载过程包装成一个异步方法，从而避免繁琐的协程逻辑</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">saync</span> <span class="n">Task</span> <span class="nf">LoadSceneAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">sceneName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AsyncOperation</span> <span class="n">asyncLoad</span> <span class="p">=</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadSceneAsync</span><span class="p">(</span><span class="n">sceneName</span><span class="p">);</span>

    <span class="c1">// 等待加载完成</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">asyncLoad</span><span class="p">.</span><span class="n">isDone</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">progress</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Clamp01</span><span class="p">(</span><span class="n">asyncLoad</span><span class="p">.</span><span class="n">progress</span> <span class="p">/</span> <span class="m">0.9f</span><span class="p">);</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Loading progress: "</span> <span class="p">+</span> <span class="n">progress</span><span class="p">);</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Yield</span><span class="p">();</span> <span class="c1">// 等待下一帧</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="资源顺序加载">资源顺序加载</h4>
<p>有时候，我们希望保证某些资源或场景按特定顺序加载，或者在某些资源完全加载后才能加载其他资源。使用异步加载时，<code class="language-plaintext highlighter-rouge">async</code>和<code class="language-plaintext highlighter-rouge">await</code>可以让你控制加载的顺序</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="n">Task</span> <span class="nf">LoadSceneInOrider</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 加载第一个场景</span>
    <span class="k">await</span> <span class="nf">LoadSceneAsync</span><span class="p">(</span><span class="s">"Scene1"</span><span class="p">);</span>

    <span class="c1">// 加载第二个场景</span>
    <span class="k">await</span> <span class="nf">LoadSceneAsync</span><span class="p">(</span><span class="s">"Scene2"</span><span class="p">);</span>

    <span class="c1">// 继续加载其他资源</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="避免资源加载顺序问题">避免资源加载顺序问题</h4>
<p>确保在加载多个场景时，场景中的资源顺序正确。对于大型场景或者有依赖关系的资源，可以使用<code class="language-plaintext highlighter-rouge">Addressables</code>系统来更细粒度地控制资源的加载顺序</p>

<h4 id="资源优化">资源优化</h4>
<p>异步加载场景和资源时，性能优化是非常重要的。可以使用以下方法：</p>
<ul>
  <li>使用<code class="language-plaintext highlighter-rouge">async</code>和<code class="language-plaintext highlighter-rouge">await</code>配合加载不同类型的资源：例如先加载场景，然后在后台加载音频、纹理等资源</li>
  <li>场景切换前缓冲资源：提前加载必要的资源，避免在切换场景时发生卡顿</li>
  <li>分步加载资源：不必一次性加载所有资源，可以分批次地进行加载，确保用户界面的流畅性</li>
</ul>

<h3 id="多场景注意事项">多场景注意事项</h3>
<ul>
  <li>场景间的依赖：确保每个场景的独立性。如果一个场景依赖于另一个场景中的对象，加载时可能会出现问题，特别是在异步加载时</li>
  <li>内存管理：加载多个场景会消耗更多内存，尤其是大型场景。确保合理管理内存，及时卸载不再需要的场景</li>
</ul>

<h3 id="实例多场景管理器">实例：多场景管理器</h3>
<p>可以创建一个管理多个场景加载的系统</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.SceneManagement</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MultiSceneManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">mainScene</span> <span class="p">=</span> <span class="s">"MainScene"</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">uiScene</span> <span class="p">=</span> <span class="s">"UIScene"</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 加载主场景和UI场景</span>
        <span class="nf">LoadMainScene</span><span class="p">();</span>
        <span class="nf">LoadUIScene</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">LoadMainScene</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadScene</span><span class="p">(</span><span class="n">mainScene</span><span class="p">,</span> <span class="n">LoadSceneMode</span><span class="p">.</span><span class="n">Additive</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">LoadUIScene</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadScene</span><span class="p">(</span><span class="n">uiScene</span><span class="p">,</span> <span class="n">LoadSceneMode</span><span class="p">.</span><span class="n">Additive</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">UnloadMainScene</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">UnloadSceneAsync</span><span class="p">(</span><span class="n">mainScene</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">UnloadUIScene</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">UnloadSceneAsync</span><span class="p">(</span><span class="n">uiScene</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="scenemanager">SceneManager</h3>
<p><code class="language-plaintext highlighter-rouge">SceneManager</code>是Unity中用来管理场景加载、卸载和切换的一个类。它提供了许多用于操作场景的方法，比如异步加载场景、场景之间切换、场景的同步加载、查询场景信息等。</p>

<p><code class="language-plaintext highlighter-rouge">SceneManager</code>是<code class="language-plaintext highlighter-rouge">UnityEngine.SceneManagement</code>命名空间的一部分</p>

<h4 id="常用api">常用API</h4>
<h5 id="加载场景">加载场景</h5>
<ul>
  <li>加载单一场景</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">SceneManager.LoadScene</code>用于加载指定的场景</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadScene</span><span class="p">(</span><span class="s">"SceneName"</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>异步加载场景</li>
</ul>

<p>异步加载场景是为了避免在加载时阻塞主线程，可以提高游戏体验</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AsyncOperation</span> <span class="n">asyncOp</span> <span class="p">=</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadSceneAsync</span><span class="p">(</span><span class="s">"SceneName"</span><span class="p">);</span>
</code></pre></div></div>

<p>异步加载场景时，可以通过<code class="language-plaintext highlighter-rouge">AsyncOperation</code>对象来获取加载进度，甚至可以控制场景是否在加载完成后自动激活</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">asyncOp</span><span class="p">.</span><span class="n">allowSceneActivation</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> <span class="c1">// 控制场景是否自动激活</span>
</code></pre></div></div>

<h5 id="卸载场景-1">卸载场景</h5>
<ul>
  <li>卸载当前场景</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">SceneManager.UnloadSceneAsync</code>用于卸载一个场景，通常用于切换场景时</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SceneManager</span><span class="p">.</span><span class="nf">UnloadSceneAsync</span><span class="p">(</span><span class="s">"SceneName"</span><span class="p">);</span>
</code></pre></div></div>

<p>这个方法是异步的，因此可以在后台卸载场景，不会影响游戏的运行</p>

<h5 id="获取当前场景">获取当前场景</h5>
<ul>
  <li>获取当前激活的场景</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">SceneManager.GetActiveScene</code>用于获取当前激活的场景，返回的是一个<code class="language-plaintext highlighter-rouge">Scene</code>对象</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Scene</span> <span class="n">currentScene</span> <span class="p">=</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">GetActiveScene</span><span class="p">();</span>
</code></pre></div></div>

<p>可以通过<code class="language-plaintext highlighter-rouge">Scene</code>对象获取场景的名称、路径、索引等信息</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span> <span class="n">sceneName</span> <span class="p">=</span> <span class="n">currentScene</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</code></pre></div></div>

<h5 id="场景切换">场景切换</h5>
<ul>
  <li>加载多个场景</li>
</ul>

<p>可以使用<code class="language-plaintext highlighter-rouge">SceneManager.LoadScene</code>来加载多个场景，这对于一些需要同时存在多个场景的情况（如多人联机或大场景加载）非常有用</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadScene</span><span class="p">(</span><span class="s">"Scene1"</span><span class="p">,</span> <span class="n">LoadSceneMode</span><span class="p">.</span><span class="n">Additive</span><span class="p">);</span> <span class="c1">// 加载一个附加场景</span>
</code></pre></div></div>
<p>通过<code class="language-plaintext highlighter-rouge">LoadSceneMode.Additive</code>，新的场景会叠加到现有场景上</p>

<ul>
  <li>切换场景</li>
</ul>

<p>如果你要切换到一个新的场景并卸载当前场景，可以在加载新场景时使用<code class="language-plaintext highlighter-rouge">LoadSceneMode.Single</code>，它会在加载新场景的同时卸载当前场景</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadScene</span><span class="p">(</span><span class="s">"NewScene"</span><span class="p">,</span> <span class="n">LoadSceneMode</span><span class="p">.</span><span class="n">Single</span><span class="p">);</span>
</code></pre></div></div>
<h5 id="场景索引">场景索引</h5>
<p>可以通过<code class="language-plaintext highlighter-rouge">Scene</code>对象来查询更多关于场景的信息：</p>
<ul>
  <li>获取场景的名称
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span> <span class="n">sceneName</span> <span class="p">=</span> <span class="n">currentScene</span><span class="p">.</span><span class="n">name</span>
</code></pre></div>    </div>
  </li>
  <li>获取场景的索引
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sceneIndex</span> <span class="p">=</span> <span class="n">currentScene</span><span class="p">.</span><span class="n">buildIndex</span>
</code></pre></div>    </div>
  </li>
  <li>获取场景的根游戏对象
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span><span class="p">[]</span> <span class="n">rootObjects</span> <span class="p">=</span> <span class="n">currentScene</span><span class="p">.</span><span class="nf">GetRootGameObjects</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="事件和回调">事件和回调</h5>
<p>Unity提供了一些事件和回调来监听场景加载的状态</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SceneManager.sceneLoaded</code>事件</li>
</ul>

<p>这个事件会在场景加载完成时触发，你可以通过订阅这个事件来执行场景加载后的操作</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SceneManger</span><span class="p">.</span><span class="n">sceneLoaded</span> <span class="p">+=</span> <span class="n">OnSceneLoaded</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">OnSceneLoaded</span><span class="p">(</span><span class="n">Scene</span> <span class="n">scene</span><span class="p">,</span> <span class="n">LoadSceneMode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Scene "</span> <span class="p">+</span> <span class="n">scene</span><span class="p">.</span><span class="n">name</span> <span class="p">+</span> <span class="s">" loaded."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SceneManager.sceneUnloaded</code>事件</li>
</ul>

<p>这个事件会在场景卸载时触发</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SceneManager</span><span class="p">.</span><span class="n">sceneUnloaded</span> <span class="p">+=</span> <span class="n">OnSceneUnloaded</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">OnSceneUnloaded</span><span class="p">(</span><span class="n">Scene</span> <span class="n">scene</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Scene "</span> <span class="p">+</span> <span class="n">scene</span><span class="p">.</span><span class="n">name</span> <span class="p">+</span> <span class="s">" unloaded."</span><span class="p">);</span>
</code></pre></div></div>

<p><a href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html">UnityScripting SceneManager</a></p>

<h3 id="dontdestroyonload">DontDestroyOnLoad</h3>
<p><code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>是Unity中一个非常使用的函数，它可以将某个对象在加载新场景时保持不被销毁。这对于需要在多个场景间共享的对象（如音频管理器、玩家数据等）非常有用</p>

<p>1.基本使用</p>

<p>通过<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>，你可以使一个游戏对象在场景切换时不被销毁。当你加载一个新场景时，默认情况下，当前场景中所有对象都会被卸载。但如果某个对象调用了<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>，它就会被保留，直到手动销毁它</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="nf">DontDestroyOnLoad</span><span class="p">(</span><span class="n">gameObject</span><span class="p">);</span> <span class="c1">// 保持这个对象不被销毁</span>
</code></pre></div></div>

<p>2.适用场景</p>

<p><code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>通常适用于以下情况：</p>
<ul>
  <li>音频管理器：游戏中有一个音频管理器对象，需要在不同场景之间共享音乐和音效设置。通过<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>，你可以确保音频管理器在场景切换时不被销毁</li>
  <li>玩家数据：例如，玩家的得分、背包内容、任务进度等需要在多个场景之间保持一致。在这种情况下，你可以将数据存储在一个不销毁的对象中</li>
  <li>全局控制器：如果你有一个控制器或管理器（例如游戏状态控制器、广告管理器等），这些也可以通过<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>保持跨场景存在</li>
</ul>

<p>3.注意事项</p>

<p><strong>可能引起的问题</strong></p>
<ul>
  <li>对象重复创建：<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>会让对象保持在所有场景之间。但是，如果在多个场景中分别创建了同样的对象，这可能会导致重复的对象。例如，如果你在一个场景中已经有一个音频管理器，并且在加载另一个场景时有创建了一个新的音频管理器，结果可能时两个音频管理器同时存在。为了避免这种情况，需要确保只有一个对象调用了<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code></li>
</ul>

<p>解决办法：通常做法是在脚本中加上一个检查，确保只有第一个创建的对象调用<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>，而其他对象则销毁自己</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nf">FindObjectsOfType</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">MyManager</span><span class="p">)).</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="m">1</span><span class="p">)</span>
        <span class="nf">Destroy</span><span class="p">(</span><span class="n">gameObject</span><span class="p">);</span> <span class="c1">// 如果场景中已经有一个该类型的对象，销毁当前对象</span>
    
    <span class="k">else</span> <span class="nf">DontDestroyOnLoad</span><span class="p">(</span><span class="n">gameObject</span><span class="p">);</span> <span class="c1">// 否则保留该对象</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>使用<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>时的对象管理</strong></p>
<ul>
  <li>生命周期管理：虽然<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>防止对象在场景切换时销毁，但它并不会阻止对象在运行时被销毁，如果想在特定时刻销毁该对象，需要手动调用<code class="language-plaintext highlighter-rouge">Destroy()</code></li>
</ul>

<p><strong>跨场景对象命名问题</strong>
<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>对象仍然存在于内存中，因此你需要特别注意它们的名字。为了避免在多个场景中有相同名称的对象，通常可以将<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>对象的名称修改为唯一的标识符</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FindObjectOfType</span><span class="p">&lt;</span><span class="n">MyManager</span><span class="p">&gt;()</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">gameObject</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="s">"UniqueManager"</span><span class="p">;</span>
        <span class="nf">DontDestroyOnLoad</span><span class="p">(</span><span class="n">gameObject</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nf">Destroy</span><span class="p">(</span><span class="n">gameObject</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="底层实现推测">底层实现（推测）</h4>
<p>Unity的底层实现并没有公开<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>的具体源码，但我们可以推测它的工作原理基于以下几个步骤：</p>
<ul>
  <li>场景对象管理器：当Unity进行场景切换时，它会遍历场景中的所有对象，并将标记为<code class="language-plaintext highlighter-rouge">DontDestroyOnLoad</code>的对象移除场景的管理队列</li>
  <li>全局管理容器：这些标记为不销毁的对象会被一如一个全局的容器中，保持在内存中，直到程序结束或手动销毁这些对象</li>
  <li>不被卸载：这些对象的生命周期与当前场景无关，它们会在Unity的内部管理中维持直到销毁</li>
</ul>

<h3 id="场景打包与构建设置">场景打包与构建设置</h3>
<h4 id="构建设置">构建设置</h4>
<h5 id="访问构建设置">访问构建设置</h5>
<p>构建设置可以通过Unity编辑器的菜单访问：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">File</code> -&gt; <code class="language-plaintext highlighter-rouge">Build Settings</code></li>
</ul>

<p>构建设置窗口列出了所有可用的场景、平台选项、打包模式、构建设置等。你可以通过它来管理场景、选择构建平台、设置构建选项</p>

<p><img src="/assets/images/BuildSettings.jpg" alt="Build Settings" /></p>

<h5 id="场景的添加与移除">场景的添加与移除</h5>
<p>在构建设置中，所有需要包含在游戏构建中的场景都必须被添加到场景列表中</p>
<ul>
  <li>添加场景：点击<code class="language-plaintext highlighter-rouge">Add Open Scenes</code>按钮，Unity会将当前打开的场景添加到场景列表中</li>
  <li>移除场景：点击场景旁边的<code class="language-plaintext highlighter-rouge">-</code>按钮，移除该场景</li>
</ul>

<p>场景顺序：场景在构建设置中的顺序很重要。Unity会按顺序加载这些场景，并且默认加载列表中的第一个场景作为游戏启动场景</p>

<h5 id="构建平台选择">构建平台选择</h5>
<p>Unity支持多个平台的构建，包括PC、Mac、Linux、WebGL、iOS、Android、Console等，可以选择目标平台并进行构建。不同平台可能会有不同的构建要求</p>
<ul>
  <li>选择平台：在构建设置窗口中，点击平台名称（例如PC，Mac &amp; Linux Standalone）来选择目标平台</li>
  <li>平台切换：点击<code class="language-plaintext highlighter-rouge">Switch Platform</code>按钮来切换目标平台，Unity会根据选择的平台进行相应的调整</li>
</ul>

<h5 id="场景打包模式">场景打包模式</h5>
<p>在构建设置中，场景的加载方式分为两种模式：</p>
<ul>
  <li>Additive</li>
  <li>Single</li>
</ul>

<p>通常情况下，需要选择不同的加载模式来优化内存管理和加载时间</p>

<h4 id="场景构建与打包优化">场景构建与打包优化</h4>
<h5 id="资源优化-1">资源优化</h5>
<p>优化游戏的场景和资源打包时提升游戏性能的重要步骤，以下是常见的优化方法：</p>
<ul>
  <li>精简资源：确保每个场景中只包含必要的资源，避免冗余的材质、纹理、音频等</li>
  <li>静态合批：将场景中的静态物体合并成一个大网格，减少draw call，提升渲染效率</li>
  <li>光照与阴影：减少场景中动态光源数量，合理使用光照贴图（Lightmaps）来优化性能</li>
</ul>

<h5 id="场景打包设置">场景打包设置</h5>
<p>Unity提供了对场景打包的一些设置，帮助你控制场景打包的方式：</p>
<ul>
  <li>压缩选项：可以选择是否对场景中的资源进行压缩，通常选择压缩可以减少打包文件的大小</li>
  <li>场景的内存管理：在构建设置中，你可以选择是否将场景资源分离到不同的资源包中（例如Asset Bundles或Addressables），这样可以减少初始加载时间，并按需加载资源</li>
</ul>

<h5 id="多平台支持">多平台支持</h5>
<p>Unity支持在不同平台上进行构建。你可以针对每个平台选择不同的场景优化策略：</p>
<ul>
  <li>PC和Mac：通常场景中的资源较大，可以通过压缩和剔除不必要的内容来减小文件体积</li>
  <li>移动平台：对于移动平台，通常需要更严格的内存管理和性能优化，避免过大的场景和冗余资源</li>
  <li>WebGL：Web平台通常有更严格的内存和资源限制，因此需要优化场景资源，减少加载时间</li>
</ul>

<h5 id="构建设置中的其他选项">构建设置中的其他选项</h5>
<ul>
  <li>Player Settings：可以对每个平台的构建进行详细配置，例如分辨率、图形设置、资源加载策略等</li>
  <li>Development Build：启用此选项可以使构建版本包含调试信息，用于开发和调试</li>
  <li>Script Debugging：启用后，可以进行脚本调试，适用于开发阶段</li>
</ul>

<h3 id="场景分块加载">场景分块加载</h3>
<p>对于大型游戏，特别是开放世界类型的游戏，将场景分割成小的块（Chunk）是非常重要的，这样可以按需加载场景，从而减小内存消耗并提高游戏性能</p>

<p>分块加载场景的优势：</p>
<ul>
  <li>按需加载：根据玩家的位置或游戏进度，动态加载和卸载场景</li>
  <li>减少内存占用：只加载当前玩家需要的场景，减少不必要的内存消耗</li>
</ul>

<h4 id="如何实现场景分块加载">如何实现场景分块加载：</h4>
<ol>
  <li>将一个大场景拆分成多个小场景（例如，分成多个区域）</li>
  <li>使用<code class="language-plaintext highlighter-rouge">SceneManager.LoadScene</code>或<code class="language-plaintext highlighter-rouge">SceneManger.LoadSceneAsync</code>按需加载这些小场景</li>
  <li>使用<code class="language-plaintext highlighter-rouge">LoadSceneMode.Additive</code>加载多个场景，而不卸载当前场景</li>
</ol>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 异步加载多个场景</span>
<span class="n">IEnumerator</span> <span class="nf">LoadChunksAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">AsyncOperation</span> <span class="n">asyncLoad</span> <span class="p">=</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadSceneAsync</span><span class="p">(</span><span class="s">"Chunk1"</span><span class="p">,</span> <span class="n">LoadSceneMode</span><span class="p">.</span><span class="n">Additive</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(!</span><span class="n">asyncLoad</span><span class="p">.</span><span class="n">isDone</span><span class="p">)</span> <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>

    <span class="n">asyncLoad</span> <span class="p">=</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadSceneAsync</span><span class="p">(</span><span class="s">"Chunk2"</span><span class="p">,</span> <span class="n">LoadSceneMode</span><span class="p">.</span><span class="n">Additive</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(!</span><span class="n">asyncLoad</span><span class="p">.</span><span class="n">isDone</span><span class="p">)</span> <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="场景分层管理">场景分层管理</h4>
<p>通过分层管理来控制场景的加载，主要将游戏内容和UI、背景音乐等资源分离，可以提高场景的加载效率，例如：</p>
<ul>
  <li>游戏场景：包含主游戏逻辑、任务、敌人、地形等</li>
  <li>UI场景：包含主菜单、设置、游戏暂停界面等</li>
  <li>音频场景：音频资源可以独立成一个场景，保证游戏时音效不会受到场景切换的影响</li>
</ul>

<h3 id="触发器加载机制">触发器加载机制</h3>

<h3 id="addressable与场景加载">Addressable与场景加载</h3>
<h4 id="addressable-asset-system">Addressable Asset System</h4>
<p>Unity的Addressable Asset System是一个非常强大的资源管理和加载系统，可以让你更精确地控制资源的加载、卸载、分发和优化。它可以用于按需加载资源，特别适合大规模场景的动态加载</p>

<p>主要特点：</p>
<ul>
  <li>按需加载：通过地址引用来加载资源，而不需要将所有资源打包在场景中</li>
  <li>优化加载：支持异步加载和缓存优化，减少内存消耗</li>
</ul>

<p>在构建场景时，可以通过Addressable资源来管理和加载场景文件及资源。例如，可以将场景预先打包为Addressable，并在运行时加载它</p>

<p>示例：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine.AddressableAssets</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.ResourceManagement.AsyncOperations</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">LoadSceneWithAddressable</span><span class="p">(</span><span class="kt">string</span> <span class="n">sceneName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 使用Addressable加载场景</span>
    <span class="n">AsyncOperationHandle</span><span class="p">&lt;</span><span class="n">SceneInstance</span><span class="p">&gt;</span> <span class="n">handle</span> <span class="p">=</span> <span class="n">Addressables</span><span class="p">.</span><span class="nf">LoadSceneAsync</span><span class="p">(</span><span class="n">sceneName</span><span class="p">,</span> <span class="n">LoadSceneMode</span><span class="p">.</span><span class="n">Additive</span><span class="p">);</span>

    <span class="c1">// 可以监听加载过程</span>
    <span class="n">handle</span><span class="p">.</span><span class="n">Completed</span> <span class="p">+=</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Scene Loaded: "</span> <span class="p">+</span> <span class="n">sceneName</span><span class="p">);};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="场景打包为addressable">场景打包为Addressable</h4>
<p>将场景打包为Addressable可以极大地优化场景的加载过程，特别是在资源分发和网络加载时，Unity提供了专门的工具来标记场景为Addressable，并管理它们的加载</p>
<ol>
  <li>在Addressable中创建一个项目条目</li>
  <li>通过Asset Bundle管理器，将场景资源标记为<code class="language-plaintext highlighter-rouge">Addressable</code></li>
  <li>使用异步加载方法来加载场景并优化内存使用</li>
</ol>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-06-01T00:00:00+08:00">June 1, 2025</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/posts/2025-06-07-UI-System/" class="pagination--pager" title="UI System">Previous</a>
    
    
      <a href="/posts/2025-06-09-Time-System/" class="pagination--pager" title="Time System">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/ljf12825" rel="nofollow noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">ljf12825's Blog</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
