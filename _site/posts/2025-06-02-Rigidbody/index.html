<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.1 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Rigibody - ljf12825’s Blog</title>
<meta name="description" content="在Unity中，Rigidbody是一个用于实现物理行为的组件，它允许你的游戏对象受力、重力、碰撞等真实世界的物理规则影响">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="ljf12825's Blog">
<meta property="og:title" content="Rigibody">
<meta property="og:url" content="http://localhost:4000/posts/2025-06-02-Rigidbody/">


  <meta property="og:description" content="在Unity中，Rigidbody是一个用于实现物理行为的组件，它允许你的游戏对象受力、重力、碰撞等真实世界的物理规则影响">







  <meta property="article:published_time" content="2025-06-01T00:00:00+08:00">






<link rel="canonical" href="http://localhost:4000/posts/2025-06-02-Rigidbody/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="ljf12825's Blog Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/J.ico" alt="ljf12825's Blog"></a>
        
        <a class="site-title" href="/">
          ljf12825's Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Categories</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tags</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Rigibody">
    <meta itemprop="description" content="在Unity中，Rigidbody是一个用于实现物理行为的组件，它允许你的游戏对象受力、重力、碰撞等真实世界的物理规则影响">
    <meta itemprop="datePublished" content="2025-06-01T00:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/posts/2025-06-02-Rigidbody/" itemprop="url">Rigibody
</a>
          </h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>在Unity中，<code class="language-plaintext highlighter-rouge">Rigidbody</code>是一个用于实现物理行为的组件，它允许你的游戏对象受力、重力、碰撞等真实世界的物理规则影响</p>

<h2 id="rigidbody的基本功能">Rigidbody的基本功能</h2>
<p>当你给一个<code class="language-plaintext highlighter-rouge">GameObject</code>添加Rigibody后，它具备以下能力：</p>

<table>
  <thead>
    <tr>
      <th>功能</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>重力</td>
      <td>会受到 Unity 世界的重力影响。</td>
    </tr>
    <tr>
      <td>力作用</td>
      <td>可通过 <code class="language-plaintext highlighter-rouge">AddForce()</code> 施加力。</td>
    </tr>
    <tr>
      <td>碰撞</td>
      <td>可与带有 <code class="language-plaintext highlighter-rouge">Collider</code> 的物体发生物理碰撞。</td>
    </tr>
    <tr>
      <td>移动</td>
      <td>可通过物理方式（而不是直接修改 transform）移动。</td>
    </tr>
  </tbody>
</table>

<h3 id="rigidbodypanel">RigidbodyPanel</h3>

<p><img src="/assets/images/RigidbodyPanel.jpg" alt="RigidbodyPanel" /></p>

<p><strong>基础物理参数</strong></p>

<table>
  <thead>
    <tr>
      <th>参数名</th>
      <th>作用</th>
      <th>默认值</th>
      <th>建议用法</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Mass</strong>（质量）</td>
      <td>控制惯性、碰撞反应</td>
      <td><code class="language-plaintext highlighter-rouge">1</code></td>
      <td>设为真实世界比例（如车 1000、人 70）</td>
    </tr>
    <tr>
      <td><strong>Drag</strong>（线性阻力）</td>
      <td>模拟空气/水的阻力（减速）</td>
      <td><code class="language-plaintext highlighter-rouge">0</code></td>
      <td>移动物体逐渐停止，可设为 <code class="language-plaintext highlighter-rouge">1~5</code></td>
    </tr>
    <tr>
      <td><strong>Angular Drag</strong>（角阻力）</td>
      <td>减缓旋转速度</td>
      <td><code class="language-plaintext highlighter-rouge">0.05</code></td>
      <td>防止物体无限旋转，常设为 <code class="language-plaintext highlighter-rouge">0.1~0.5</code></td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>Automatic Center Of Mass</strong>（自动质心，默认为true）
    <ul>
      <li>Unity会根据物体的形状（Collider）和质量分布，自动计算Rigidbody的中心点</li>
      <li>通常质心在物体的几何中心，但加多个Collider后可能偏移</li>
      <li>这是大多数情况下推荐的方式，因为它物理上是合理的</li>
    </ul>
  </li>
</ul>

<p><strong>手动设置质心</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rb</span><span class="p">.</span><span class="n">centerOfMass</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">1f</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span> <span class="c1">//手动设一个偏移量</span>
</code></pre></div></div>
<blockquote>
  <p>设置后将覆盖自动计算值，适用于如车辆、飞船平衡优化、ragdoll调整等高级用途</p>
</blockquote>

<p>可视化质心方法：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">OnDrawGizmo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rb</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Gizmos</span><span class="p">.</span><span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">red</span><span class="p">;</span>
        <span class="n">Gizmos</span><span class="p">.</span><span class="nf">DrawSphere</span><span class="p">(</span><span class="n">rb</span><span class="p">.</span><span class="n">worldCenterOfMess</span><span class="p">,</span> <span class="m">0.1f</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>为什么质心重要</strong></p>

<table>
  <thead>
    <tr>
      <th>应用场景</th>
      <th>影响</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>飞船 / 载具</td>
      <td>若质心偏上，容易翻车或晃动</td>
    </tr>
    <tr>
      <td>摆锤 / 吊挂物体</td>
      <td>旋转效果中心点取决于质心</td>
    </tr>
    <tr>
      <td>多 Collider 组合物体</td>
      <td>自动质心可能不在视觉中心</td>
    </tr>
    <tr>
      <td>被力击打（AddForce）</td>
      <td>力不作用在质心会引起旋转（力矩）</td>
    </tr>
  </tbody>
</table>

<p><strong>Automatic Tensor</strong>（自动惯性张量，默认为true）</p>

<p><strong>什么是Tensor</strong></p>
<ul>
  <li>在物理学中，惯性张量是描述刚体如何响应旋转力（力矩）的数学结构</li>
  <li>它是质量分布的一个三维矩阵，决定了刚体绕每个轴的旋转惯性</li>
  <li>简单理解：惯性张量 = “旋转版的质量”</li>
</ul>

<p><strong>默认自动计算惯性张量</strong></p>
<ul>
  <li>Unity默认根据物体的<code class="language-plaintext highlighter-rouge">Collider</code>形状和<code class="language-plaintext highlighter-rouge">Mass</code>自动计算惯性张量</li>
  <li>这就是<code class="language-plaintext highlighter-rouge">Rigidbody.inertiaTensor</code>和<code class="language-plaintext highlighter-rouge">inertiaTensorRotation</code>的来源</li>
  <li>所以刚体自然会表现出“越大越难转”“形状影响旋转惯性”等真实行为</li>
</ul>

<p><strong>手动设置惯性张量（自动覆盖）</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rb</span><span class="p">.</span><span class="n">inertiaTensor</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span> <span class="c1">//自定义旋转惯性</span>
<span class="n">rb</span><span class="p">.</span><span class="n">inertiaTensorRotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="n">identity</span><span class="p">;</span> <span class="c1">//张量方向</span>
</code></pre></div></div>
<p>但这样做有前提条件：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rb</span><span class="p">.</span><span class="nf">ResetInertiaTensor</span><span class="p">();</span> <span class="c1">//可重置为自动计算值</span>
</code></pre></div></div>
<blockquote>
  <p>设置之前你要禁用自动张量</p>
</blockquote>

<p><strong>什么情况需要自定义惯性张量</strong></p>

<table>
  <thead>
    <tr>
      <th>应用</th>
      <th>目的</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>物理模拟器 / 实验工具</td>
      <td>精确控制旋转行为</td>
    </tr>
    <tr>
      <td>异形刚体（如飞船、复杂机器人）</td>
      <td>人为调整旋转惯性，防止旋转太快或不稳定</td>
    </tr>
    <tr>
      <td>某些游戏设计</td>
      <td>让角色或物体转得更“重”或更“灵活”</td>
    </tr>
    <tr>
      <td>制作旋转玩具 / 陀螺仪</td>
      <td>可控惯性带来物理可玩性</td>
    </tr>
  </tbody>
</table>

<p><strong>运动状态设置</strong></p>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>作用</th>
      <th>默认</th>
      <th>使用场景</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Use Gravity</strong></td>
      <td>是否受重力影响</td>
      <td>true</td>
      <td>用于自由下落、角色跳跃等</td>
    </tr>
    <tr>
      <td><strong>Is Kinematic</strong></td>
      <td>是否由代码控制，不参与物理</td>
      <td>false</td>
      <td>静态平台、动画控制角色等</td>
    </tr>
  </tbody>
</table>

<p><strong>Interpolate（插值）</strong></p>

<table>
  <thead>
    <tr>
      <th>选项</th>
      <th>说明</th>
      <th>使用场景</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>None</strong></td>
      <td>不插值，可能抖动</td>
      <td>一般默认</td>
    </tr>
    <tr>
      <td><strong>Interpolate</strong></td>
      <td>使用上一帧数据进行平滑</td>
      <td>摄像机跟随刚体时防抖动</td>
    </tr>
    <tr>
      <td><strong>Extrapolate</strong></td>
      <td>使用下一帧数据预测位置</td>
      <td>一般不推荐，容易导致位置错误</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>插值仅影响视觉表现，不影响物理逻辑，适合处理低帧率时的视觉平滑</p>
</blockquote>

<p><strong>Collision Detection（碰撞检测模式）</strong></p>

<table>
  <thead>
    <tr>
      <th>模式</th>
      <th>描述</th>
      <th>使用场景</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Discrete</strong></td>
      <td>默认，普通对象</td>
      <td>慢速运动、低精度要求</td>
    </tr>
    <tr>
      <td><strong>Continuous</strong></td>
      <td>防穿透</td>
      <td>快速移动物体（如子弹）</td>
    </tr>
    <tr>
      <td><strong>Continuous Dynamic</strong></td>
      <td>防止快速刚体穿过静态物体</td>
      <td>用于导弹、飞行物</td>
    </tr>
    <tr>
      <td><strong>Continuous Speculative</strong></td>
      <td>预测未来路径是否碰撞</td>
      <td>用于需要超高稳定性的对象</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>连续检测会增加计算量，不建议用于大量物体</p>
</blockquote>

<p><strong>Constraints（冻结轴向）</strong>
用于锁定物体的移动或旋转，防止不受控的漂移或翻滚</p>

<table>
  <thead>
    <tr>
      <th>选项</th>
      <th>说明</th>
      <th>常用组合</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Freeze Position X/Y/Z</td>
      <td>锁定对应轴上的移动</td>
      <td>冻住平台等静态物体</td>
    </tr>
    <tr>
      <td>Freeze Rotation X/Y/Z</td>
      <td>锁定对应轴上的旋转</td>
      <td>防止角色倒地、车轮翻转</td>
    </tr>
    <tr>
      <td>Freeze All</td>
      <td>锁定所有轴</td>
      <td>彻底不动，用于静态物体</td>
    </tr>
  </tbody>
</table>

<p><strong>Layer Overrides（图层覆盖）</strong><br />
允许刚体在物理世界中临时使用不同的Layer设置进行碰撞和检测计算，不会影响物体本身的Layer<br />
影响范围：物理模拟（碰撞、Raycast、Force、Overlap等），不会影响渲染、标签识别、脚本逻辑</p>
<ul>
  <li>Include Layers
    <ul>
      <li>表示允许此刚体与哪些Layer的对象发生物理交互</li>
      <li>这实质上是一个LayerMask</li>
    </ul>
  </li>
  <li>Exclude Layers
    <ul>
      <li>表示在物理交互中忽略的Layer
        <blockquote>
          <p>Exclude Layers优先于Include Layers</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h2 id="rigidbody常见用法">Rigidbody常见用法：</h2>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Rigidbody</span> <span class="n">rb</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Rigidbody</span><span class="p">&gt;();</span>

<span class="n">rb</span><span class="p">.</span><span class="nf">AddForce</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="m">10f</span><span class="p">);</span> <span class="c1">//施加一个向前的力</span>
<span class="n">rb</span><span class="p">.</span><span class="nf">AddTorque</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="m">5f</span><span class="p">);</span> <span class="c1">//添加一个旋转力</span>
<span class="n">rb</span><span class="p">.</span><span class="nf">MovePosition</span><span class="p">(</span><span class="n">newPos</span><span class="p">);</span> <span class="c1">//平滑低移动Rigidbody</span>
<span class="n">rb</span><span class="p">.</span><span class="n">velocity</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span> <span class="c1">//设置线速度</span>
</code></pre></div></div>

<h3 id="iskinematic-和-非-kinematic">isKinematic 和 非 Kinematic</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">isKinematic = false</code>（默认）：受物理引擎控制（例如重力、碰撞、AddForce）</li>
  <li><code class="language-plaintext highlighter-rouge">isKinematic = true</code>：完全由你控制<code class="language-plaintext highlighter-rouge">transform</code>或<code class="language-plaintext highlighter-rouge">MovePosition()</code>，不会被物理引擎影响</li>
</ul>

<p>用途：</p>
<ul>
  <li>Kinematic常用于移动平台、动画角色骨骼、摄像机跟随等</li>
</ul>

<h3 id="rigidbody-vs-transform控制">Rigidbody vs Transform控制</h3>
<p><strong>不要在有Rigidbody的物体上直接用<code class="language-plaintext highlighter-rouge">transform.position += ...</code>来移动，这会跳过物理系统，导致碰撞问题</strong></p>

<p>正确做法：</p>
<ul>
  <li>用<code class="language-plaintext highlighter-rouge">Rigidbody.MovePosition()</code>移动</li>
  <li>或使用<code class="language-plaintext highlighter-rouge">AddForce()</code>、<code class="language-plaintext highlighter-rouge">velocity</code>等物理方式</li>
</ul>

<p>问题本质：
在Unity中，Rigidbody是由物理系统控制的，一旦你给GameObject添加了Rigidbody，它的位置和旋转应该只通过物理系统来控制。</p>

<p>使用<code class="language-plaintext highlighter-rouge">transform.position += ...</code>会出现的问题</p>

<table>
  <thead>
    <tr>
      <th>问题</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>绕过物理引擎</strong></td>
      <td><code class="language-plaintext highlighter-rouge">transform.position += ...</code> 是<strong>立即改变 Transform 的位置</strong>，Unity 物理系统（PhysX）对此毫不知情</td>
    </tr>
    <tr>
      <td><strong>不会产生碰撞检测</strong></td>
      <td>物体“穿越”其他碰撞体而不产生物理响应（穿模）</td>
    </tr>
    <tr>
      <td><strong>不会产生力或速度变化</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Rigidbody.velocity</code> 不会更新，你也不能检测运动趋势</td>
    </tr>
    <tr>
      <td><strong>打乱内部物理状态</strong></td>
      <td>会破坏 Rigidbody 的睡眠状态、插值、运动预测等机制，造成 jitter（抖动）或奇怪弹跳</td>
    </tr>
    <tr>
      <td><strong>失去重力/摩擦等作用</strong></td>
      <td>物体移动但没有物理感，导致操作不自然</td>
    </tr>
  </tbody>
</table>

<p>只有在以下三种情况中可以使用<code class="language-plaintext highlighter-rouge">transform.position</code>:<br />
1.没有<code class="language-plaintext highlighter-rouge">Rigidbody</code>的对象（纯UI/特效/场景物体）</p>

<p>2.临时调整位置，如传送、重置</p>

<p>3.<code class="language-plaintext highlighter-rouge">isKinematic = true</code></p>

<h3 id="示例角色控制器使用rigidbody">示例：角色控制器使用Rigidbody</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">PlayerMovement</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">speed</span> <span class="p">=</span> <span class="m">5f</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">Rigidbody</span> <span class="n">rb</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">rb</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Rigidbody</span><span class="p">&gt;();</span>

    <span class="k">void</span> <span class="nf">FixedUpdate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">h</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">v</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>

        <span class="n">Vector3</span> <span class="n">move</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="n">rb</span><span class="p">.</span><span class="nf">MovePosition</span><span class="p">(</span><span class="n">rb</span><span class="p">.</span><span class="n">position</span> <span class="p">+</span> <span class="n">move</span> <span class="p">*</span> <span class="n">speed</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">fixedDeltaTime</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="物理力应用的类型">物理力应用的类型</h2>
<p>Unity提供了多种物理力应用方式，你可以根据物理效果需求选择合适的模式</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rb</span><span class="p">.</span><span class="nf">AddForce</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">force</span><span class="p">,</span> <span class="n">ForceMode</span><span class="p">.</span><span class="n">Force</span><span class="p">);</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>ForceMode</th>
      <th>作用</th>
      <th>适用场景</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Force</code></td>
      <td>持续施加力（受质量影响）</td>
      <td>模拟发动机、风力等持续力</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Impulse</code></td>
      <td>瞬时冲量（受质量影响）</td>
      <td>子弹击中、跳跃、爆炸推动</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">VelocityChange</code></td>
      <td>改变速度（忽略质量）</td>
      <td>快速位移、瞬间反弹</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Acceleration</code></td>
      <td>施加加速度（不受质量影响）</td>
      <td>飞行器推进、不考虑质量时</td>
    </tr>
  </tbody>
</table>

<h2 id="爆炸力addexplosionforce">爆炸力：<code class="language-plaintext highlighter-rouge">AddExplosionForce</code></h2>
<p>模拟爆炸冲击力，自动考虑距离衰减和力方向</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rb</span><span class="p">.</span><span class="nf">AddExplosionForce</span><span class="p">(</span><span class="n">force</span><span class="p">,</span> <span class="n">explosionPosition</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">upwardsModifier</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">force</code>:爆炸的最大力</li>
  <li><code class="language-plaintext highlighter-rouge">explosionPosition</code>:爆炸中心</li>
  <li><code class="language-plaintext highlighter-rouge">radius</code>:爆炸影响范围</li>
  <li><code class="language-plaintext highlighter-rouge">upwardsModifier</code>:向上的推力（可增强爆炸效果）</li>
</ul>

<h2 id="rigidbody-constraints锁定轴向">Rigidbody Constraints（锁定轴向）</h2>
<p>锁定位置或旋转，常用于平台类游戏角色防止翻滚</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rb</span><span class="p">.</span><span class="n">constraints</span> <span class="p">=</span> <span class="n">RigidbodyConstraints</span><span class="p">.</span><span class="n">FreezeRotationX</span> <span class="p">|</span> <span class="n">RigidbodyConstraints</span><span class="p">.</span><span class="n">FreezeRotationZ</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">FreezePositionX/Y/Z</code></li>
  <li><code class="language-plaintext highlighter-rouge">FreezeRotationX/Y/Z</code></li>
  <li><code class="language-plaintext highlighter-rouge">FreezeAll</code></li>
</ul>

<h2 id="rigidbody-interpolation插值">Rigidbody Interpolation（插值）</h2>
<p>用于缓解物体抖动或物理更新频率和渲染帧率不一致的问题<br />
插值实在渲染帧之间平滑显示刚体位置或旋转，防止因物理更新滞后造成的抖动或卡顿</p>

<blockquote>
  <p>渲染帧和物理帧
在Unity游戏循环中，渲染帧（Update）和物理帧（Fixed Update）是分开的
渲染帧率和物理帧率可能不同，这样一来，在两次物理更新之间可能要渲染一次或多次画面，此时刚体的位置还没更新，就会导致物体“跳跃”，摄像机跟随刚体时抖动</p>
</blockquote>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rb</span><span class="p">.</span><span class="n">interpolation</span> <span class="p">=</span> <span class="n">RigidbodyInterpolation</span><span class="p">.</span><span class="n">Interpolate</span><span class="p">;</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>插值类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>None</td>
      <td>不插值，最性能优先</td>
    </tr>
    <tr>
      <td>Interpolate</td>
      <td>插值上一次位置</td>
    </tr>
    <tr>
      <td>Extrapolate</td>
      <td>预测下一帧位置</td>
    </tr>
  </tbody>
</table>

<p>适用于：摄像机跟随物体 + Rigidbody，平滑动画等</p>

<p><strong>插值不是同步手段</strong><br />
插值只影响视觉显示，不影响实际物理行为或碰撞检测</p>

<h2 id="rigidbody连接joint系统">Rigidbody连接（Joint系统）</h2>
<p>Unity提供了多个<code class="language-plaintext highlighter-rouge">Joint</code>来连接两个Rigidbody，来实现机械、吊挂、弹簧等效果</p>

<p>常用Joint类型</p>

<table>
  <thead>
    <tr>
      <th>Joint 类型</th>
      <th>功能</th>
      <th>应用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FixedJoint</code></td>
      <td>完全绑定两个刚体</td>
      <td>构建刚性结构</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HingeJoint</code></td>
      <td>像门铰链一样旋转</td>
      <td>车轮、门</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SpringJoint</code></td>
      <td>模拟弹簧连接</td>
      <td>弹簧、绳索末端</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ConfigurableJoint</code></td>
      <td>自定义约束自由度</td>
      <td>高级物理装置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CharacterJoint</code></td>
      <td>模拟人体骨骼</td>
      <td>人物 ragdoll</td>
    </tr>
  </tbody>
</table>

<p><strong>示例：固定一个物体</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">joint</span> <span class="p">=</span> <span class="n">gameObject</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">FixedJoint</span><span class="p">&gt;();</span>
<span class="n">joint</span><span class="p">.</span><span class="n">connectedBody</span> <span class="p">=</span> <span class="n">otherRigidbody</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="刚体时间管理">刚体时间管理</h2>
<p>你可以临时控制刚体行为。例如冻结、暂停、缓动</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rb</span><span class="p">.</span><span class="n">isKinematic</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span> <span class="c1">// 暂停物理影响</span>
<span class="n">rb</span><span class="p">.</span><span class="n">detectCollisions</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> <span class="c1">//禁用碰撞响应</span>
<span class="n">rb</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">();</span> <span class="c1">//进入“休眠”状态，除非外力唤醒</span>
<span class="n">rb</span><span class="p">.</span><span class="nf">WakeUp</span><span class="p">();</span> <span class="c1">//强制唤醒</span>
</code></pre></div></div>
<h2 id="手动模拟物理少见但强大">手动模拟物理（少见但强大）</h2>
<p>Unity默认每帧自动调用<code class="language-plaintext highlighter-rouge">Physics.Simulate()</code>，你可以关闭自动模拟并手动调用它</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Physics</span><span class="p">.</span><span class="n">autoSimulation</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
<span class="n">Physics</span><span class="p">.</span><span class="nf">Simulate</span><span class="p">(</span><span class="n">Time</span><span class="p">.</span><span class="n">fixedDeltaTime</span><span class="p">);</span>
</code></pre></div></div>
<p>用于录制、回放、预测系统、AI训练等</p>

<h2 id="实践建议">实践建议</h2>
<h3 id="1性能优化">1.性能优化</h3>
<ul>
  <li>尽量使用<code class="language-plaintext highlighter-rouge">MovePosition</code>和<code class="language-plaintext highlighter-rouge">MoveRotation</code>代替直接设置<code class="language-plaintext highlighter-rouge">transform</code></li>
  <li>使用<code class="language-plaintext highlighter-rouge">Rigidbody.Sleep()</code>来节省性能，尤其是大量静态物体</li>
</ul>

<h3 id="2碰撞过滤">2.碰撞过滤</h3>
<ul>
  <li>使用<code class="language-plaintext highlighter-rouge">Layer</code> + <code class="language-plaintext highlighter-rouge">Physics.IngoreCollision()</code>或<code class="language-plaintext highlighter-rouge">Physics.IgnoreLayerCollision()</code>控制碰撞逻辑</li>
</ul>

<h3 id="3组合joint">3.组合Joint</h3>
<ul>
  <li>复杂角色物理（如ragdoll）可通过多个Joint配合约束自由度实现真实物理表现</li>
</ul>

<h3 id="4多刚体组合">4.多刚体组合</h3>
<ul>
  <li>使用空物体为父物体挂多个子物体加不同Rigidbody，用<code class="language-plaintext highlighter-rouge">Joint</code>连接</li>
</ul>

<h2 id="刚体不能直接禁用">刚体不能直接禁用</h2>
<h3 id="1刚体不是一个标准行为组件">1.刚体不是一个标准行为组件</h3>
<ul>
  <li>Unity中大多数组件都继承自<code class="language-plaintext highlighter-rouge">Behaviour</code>类，这类组件有一个通用的enable属性</li>
  <li>但Rigidbody继承自<code class="language-plaintext highlighter-rouge">Component</code>，因此没有<code class="language-plaintext highlighter-rouge">enable</code>属性4
    <h3 id="2rigidbody是物理系统的一部分关闭它的逻辑很复杂">2.Rigidbody是物理系统的一部分，关闭它的逻辑很复杂</h3>
    <p>Unity的Rigidbody是底层物理引擎（NVIDIA PhysX）注册的一个刚体对象，它包含大量复杂的状态（如质量、速度、力、碰撞状态等），不能简单“关掉”</p>
  </li>
</ul>

<p>如果允许直接<code class="language-plaintext highlighter-rouge">enabled = false</code>，Unity就得把它从物理世界中注销，可能会导致：</p>
<ul>
  <li>打乱碰撞检测状态</li>
  <li>丢失动力学状态</li>
  <li>导致其他与之交互的刚体行为出错</li>
</ul>

<p>替代方法：</p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>效果</th>
      <th>场景</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rb.isKinematic = true</code></td>
      <td>不再受物理引擎驱动</td>
      <td>暂停物理交互，但可以通过 transform 控制</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rb.detectCollisions = false</code></td>
      <td>不再检测碰撞</td>
      <td>让它“穿透”其他物体</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rb.Sleep()</code></td>
      <td>让刚体进入休眠</td>
      <td>减少物理计算开销</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Destroy(rb)</code></td>
      <td>彻底移除刚体</td>
      <td>完全不再参与物理</td>
    </tr>
  </tbody>
</table>

<h2 id="rigidbody-api"><code class="language-plaintext highlighter-rouge">Rigidbody</code> API</h2>

<h3 id="常用字段属性">常用字段/属性</h3>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">mass</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>质量（默认 1）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">drag</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>线性阻力</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">angularDrag</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>角阻力</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">useGravity</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否启用重力</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isKinematic</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否受物理引擎影响</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">velocity</code></td>
      <td><code class="language-plaintext highlighter-rouge">Vector3</code></td>
      <td>当前线速度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">angularVelocity</code></td>
      <td><code class="language-plaintext highlighter-rouge">Vector3</code></td>
      <td>当前角速度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">position</code></td>
      <td><code class="language-plaintext highlighter-rouge">Vector3</code></td>
      <td>世界空间位置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rotation</code></td>
      <td><code class="language-plaintext highlighter-rouge">Quaternion</code></td>
      <td>世界旋转</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">centerOfMass</code></td>
      <td><code class="language-plaintext highlighter-rouge">Vector3</code></td>
      <td>质心位置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">inertiaTensor</code></td>
      <td><code class="language-plaintext highlighter-rouge">Vector3</code></td>
      <td>惯性张量</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">constraints</code></td>
      <td><code class="language-plaintext highlighter-rouge">RigidbodyConstraints</code></td>
      <td>锁定移动或旋转轴</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">interpolation</code></td>
      <td><code class="language-plaintext highlighter-rouge">RigidbodyInterpolation</code></td>
      <td>插值方式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">collisionDetectionMode</code></td>
      <td><code class="language-plaintext highlighter-rouge">CollisionDetectionMode</code></td>
      <td>碰撞检测模式</td>
    </tr>
  </tbody>
</table>

<h3 id="常用方法控制移动施加力">常用方法（控制移动、施加力）</h3>
<h4 id="施加力的方法力学模拟">施加力的方法（力学模拟）</h4>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
      <th>常用参数说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AddForce(Vector3 force, ForceMode mode = ForceMode.Force)</code></td>
      <td>向刚体施加一个世界空间的力</td>
      <td>- <code class="language-plaintext highlighter-rouge">ForceMode</code> 可选：<code class="language-plaintext highlighter-rouge">Force</code>, <code class="language-plaintext highlighter-rouge">Impulse</code>, <code class="language-plaintext highlighter-rouge">Acceleration</code>, <code class="language-plaintext highlighter-rouge">VelocityChange</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AddRelativeForce(Vector3 force, ForceMode mode = ForceMode.Force)</code></td>
      <td>向刚体施加一个<strong>相对于自身方向</strong>的力</td>
      <td>用于局部方向推进，如飞船、角色局部移动</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AddTorque(Vector3 torque, ForceMode mode = ForceMode.Force)</code></td>
      <td>添加一个旋转力（转矩）</td>
      <td>控制刚体的旋转，比如陀螺仪效果</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AddRelativeTorque(Vector3 torque, ForceMode mode = ForceMode.Force)</code></td>
      <td>添加一个<strong>相对坐标</strong>的转矩</td>
      <td>以自身坐标轴方向旋转</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AddExplosionForce(float force, Vector3 position, float radius, float upwardsModifier = 0.0f, ForceMode mode = ForceMode.Force)</code></td>
      <td>模拟爆炸力</td>
      <td>常用于爆炸、炸飞物体等效果</td>
    </tr>
  </tbody>
</table>

<h4 id="移动与旋转物理友好方式">移动与旋转（物理友好方式）</h4>
<p>这些方法在<code class="language-plaintext highlighter-rouge">FixedUpdate()</code>中调用，以物理方式平滑移动对象</p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MovePosition(Vector3 position)</code></td>
      <td>让刚体以物理方式移动到某位置（会产生碰撞）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MoveRotation(Quaternion rot)</code></td>
      <td>让刚体以物理方式旋转到目标旋转角度</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>不要使用transform.position = … 替代移动刚体，会破坏物理系统</p>
</blockquote>

<h4 id="状态控制">状态控制</h4>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Sleep()</code></td>
      <td>让刚体休眠（不再进行物理更新，除非唤醒）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">WakeUp()</code></td>
      <td>唤醒休眠的刚体</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IsSleeping()</code></td>
      <td>检查当前是否处于休眠状态</td>
    </tr>
  </tbody>
</table>

<h4 id="速度与点速度获取">速度与点速度获取</h4>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetPointVelocity(Vector3 worldPoint)</code></td>
      <td>获取世界空间中某一点的实际速度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetRelativePointVelocity(Vector3 relativePoint)</code></td>
      <td>获取某个相对位置的速度（少用）</td>
    </tr>
  </tbody>
</table>

<h3 id="状态检测与设置">状态检测与设置</h3>

<table>
  <thead>
    <tr>
      <th>方法 / 属性</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IsSleeping()</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>当前是否休眠</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">detectCollisions</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否响应碰撞</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">maxDepenetrationVelocity</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>最大穿透修正速度（用于防止卡住）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">solverIterations</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>物理求解器迭代次数（越高越精准）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sleepThreshold</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>控制何时休眠</td>
    </tr>
  </tbody>
</table>

<h3 id="高级设置">高级设置</h3>

<table>
  <thead>
    <tr>
      <th>属性 / 方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">inertiaTensorRotation</code></td>
      <td>惯性张量旋转</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">maxAngularVelocity</code></td>
      <td>最大角速度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">centerOfMass</code></td>
      <td>自定义质心位置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ResetCenterOfMass()</code></td>
      <td>重置为默认质心</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ResetInertiaTensor()</code></td>
      <td>重置惯性张量</td>
    </tr>
  </tbody>
</table>

<h3 id="与collider配合相关">与Collider配合相关</h3>
<p>Rigidbody本身不处理碰撞细节，但需配合<code class="language-plaintext highlighter-rouge">Collider</code>组件才能参与物理交互</p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ClosestPointOnBounds(Vector3 position)</code></td>
      <td>获取边界上最接近某点的位置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SweepTest(Vector3 direction, out RaycastHit hit, float maxDistance)</code></td>
      <td>模拟刚体沿方向运动是否会撞到东西</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SweepTestAll(...)</code></td>
      <td>返回所有碰撞信息</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetRelativePointVelocity(Vector3 relativePoint)</code></td>
      <td>获取某点相对速度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetPointVelocity(Vector3 worldPoint)</code></td>
      <td>获取世界空间下某点速度</td>
    </tr>
  </tbody>
</table>

<p><strong><a href="https://docs.unity3d.com/ScriptReference/Rigidbody.html">Unity官方文档（Rigidbody）</a></strong></p>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-06-01T00:00:00+08:00">June 1, 2025</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/%E7%AC%94%E8%AE%B0/2025/06/01/Component.html" class="pagination--pager" title="Component">Previous</a>
    
    
      <a href="/%E7%AC%94%E8%AE%B0/2025/06/01/Scripts.html" class="pagination--pager" title="Scripts">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/ljf12825" rel="nofollow noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">ljf12825's Blog</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
