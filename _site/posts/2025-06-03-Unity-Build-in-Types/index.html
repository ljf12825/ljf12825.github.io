<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.1 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Unity Build-in Types - ljf12825’s Blog</title>
<meta name="description" content="Unity内建类型">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="ljf12825's Blog">
<meta property="og:title" content="Unity Build-in Types">
<meta property="og:url" content="http://localhost:4000/posts/2025-06-03-Unity-Build-in-Types/">


  <meta property="og:description" content="Unity内建类型">







  <meta property="article:published_time" content="2025-06-01T00:00:00+08:00">






<link rel="canonical" href="http://localhost:4000/posts/2025-06-03-Unity-Build-in-Types/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="ljf12825's Blog Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- favicon -->
<link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon">

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          ljf12825's Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Categories</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tags</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Unity Build-in Types">
    <meta itemprop="description" content="Unity内建类型">
    <meta itemprop="datePublished" content="2025-06-01T00:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/posts/2025-06-03-Unity-Build-in-Types/" itemprop="url">Unity Build-in Types
</a>
          </h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>Unity内建类型</p>

<h2 id="1空间几何类型transform相关">1.空间/几何类型（Transform相关）</h2>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Vector2</code>, <code class="language-plaintext highlighter-rouge">Vector3</code>, <code class="language-plaintext highlighter-rouge">Vector4</code></td>
      <td>表示二维/三维/四维向量</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Quaternion</code></td>
      <td>四元数，表示旋转</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Matrix4x4</code></td>
      <td>4×4 矩阵，常用于转换</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Bounds</code></td>
      <td>包围盒（中心+尺寸）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Ray</code>, <code class="language-plaintext highlighter-rouge">RaycastHit</code></td>
      <td>射线检测相关类型</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Plane</code></td>
      <td>表示一个无限平面</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Rect</code></td>
      <td>二维矩形区域</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Color</code>, <code class="language-plaintext highlighter-rouge">Color32</code></td>
      <td>表示颜色（线性空间和 sRGB）</td>
    </tr>
  </tbody>
</table>

<h3 id="vector">Vector</h3>
<p><code class="language-plaintext highlighter-rouge">Vector2</code>、<code class="language-plaintext highlighter-rouge">Vector3</code>、<code class="language-plaintext highlighter-rouge">Vector4</code></p>

<p>它们是Unity提供的三个核心向量类型，广泛用于位置、方向、速度、缩放、颜色等各种场景</p>

<table>
  <thead>
    <tr>
      <th>向量类型</th>
      <th>维度</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Vector2</code></td>
      <td>2D 向量，包含 <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code></td>
      <td>用于 2D 空间中的位置、速度等</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Vector3</code></td>
      <td>3D 向量，包含 <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, <code class="language-plaintext highlighter-rouge">z</code></td>
      <td>用于 3D 空间中的大多数情况</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Vector4</code></td>
      <td>4D 向量，包含 <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, <code class="language-plaintext highlighter-rouge">z</code>, <code class="language-plaintext highlighter-rouge">w</code></td>
      <td>用于更高级的计算，如齐次坐标、shader 编程</td>
    </tr>
  </tbody>
</table>

<h4 id="vector2二维向量">Vector2（二维向量）</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector2</span> <span class="n">position</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">1.5f</span><span class="p">,</span> <span class="m">3.0f</span><span class="p">);</span>
</code></pre></div></div>
<p>常见用途：</p>
<ul>
  <li>2D游戏中的对象位置、速度、加速度等</li>
  <li>屏幕空间坐标（如UI坐标）</li>
  <li>纹理坐标（UV mapping）</li>
</ul>

<h4 id="vector3三维向量">Vector3（三维向量）</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector3</span> <span class="n">direction</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span> <span class="c1">//向上</span>
<span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+=</span> <span class="n">direction</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
</code></pre></div></div>
<p>常见用途：</p>
<ul>
  <li>3D对象的位置、方向、缩放</li>
  <li>物理运动（速度、加速度）</li>
  <li>相机方向、光照方向</li>
</ul>

<h5 id="api">API</h5>
<p><strong>Static Properties</strong><br />
这些属性是<code class="language-plaintext highlighter-rouge">Vector3</code>结构体的常用快捷方式，简化了常见的方向或特殊值的表示，使得代码更简洁易读</p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">back</code></td>
      <td>等价于 <code class="language-plaintext highlighter-rouge">Vector3(0, 0, -1)</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">down</code></td>
      <td>等价于 <code class="language-plaintext highlighter-rouge">Vector3(0, -1, 0)</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">forward</code></td>
      <td>等价于 <code class="language-plaintext highlighter-rouge">Vector3(0, 0, 1)</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">left</code></td>
      <td>等价于 <code class="language-plaintext highlighter-rouge">Vector3(-1, 0, 0)</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">negativeInfinity</code></td>
      <td>等价于 <code class="language-plaintext highlighter-rouge">Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity)</code>，表示<code class="language-plaintext highlighter-rouge">-∞</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">one</code></td>
      <td>等价于 <code class="language-plaintext highlighter-rouge">Vector3(1, 1, 1)</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">positiveInfinity</code></td>
      <td>等价于 <code class="language-plaintext highlighter-rouge">Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity)</code>，表示<code class="language-plaintext highlighter-rouge">+∞</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">right</code></td>
      <td>等价于 <code class="language-plaintext highlighter-rouge">Vector3(1, 0, 0)</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">up</code></td>
      <td>等价于 <code class="language-plaintext highlighter-rouge">Vector3(0, 1, 0)</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">zero</code></td>
      <td>等价于 <code class="language-plaintext highlighter-rouge">Vector3(0, 0, 0)</code>。</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="language-plaintext highlighter-rouge">negativeInfinity</code>（负无穷）
    <ul>
      <li>定义：表示负无穷大的值</li>
      <li>类型：<code class="language-plaintext highlighter-rouge">float.NegativeInfinity</code></li>
      <li>常见用途
        <ul>
          <li>初始化最小值：可以用<code class="language-plaintext highlighter-rouge">negativeInfinity</code>来初始化一个变量，使其值总是比任何数值都小。例如，在计算最小值时，可以用它来确保首次比较时能正确地更新最小值</li>
          <li>比较：用于处理在算法中可能遇到的负无穷大值，比如图形计算中的不可达距离</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">positiveInfinity</code>（正无穷）
    <ul>
      <li>定义：表示正无穷大的值</li>
      <li>类型：<code class="language-plaintext highlighter-rouge">float.PositiveInfinity</code></li>
      <li>常见用途：
        <ul>
          <li>初始化最大值：用 <code class="language-plaintext highlighter-rouge">positiveInfinity</code> 来初始化一个变量，使其值总是比任何数值都大。例如，在计算最大值时，可以用它来确保首次比较时能正确地更新最大值。</li>
          <li>比较：用于处理可能出现的正无穷大值，例如在图形学中表示无法到达的最大距离或算法中的最大值。</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">magnitude</code></td>
      <td>返回此向量的长度（只读）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">normalized</code></td>
      <td>返回基于当前向量的标准化向量。标准化后的向量长度为 1，并与当前向量方向相同。如果当前向量太小，返回零向量。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sqrMagnitude</code></td>
      <td>返回此向量的平方长度（只读）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">this[int]</code></td>
      <td>通过 <code class="language-plaintext highlighter-rouge">[0]</code>、<code class="language-plaintext highlighter-rouge">[1]</code>、<code class="language-plaintext highlighter-rouge">[2]</code> 分别访问向量的 x、y、z 分量。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">x</code></td>
      <td>向量的 x 分量。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">y</code></td>
      <td>向量的 y 分量。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">z</code></td>
      <td>向量的 z 分量。</td>
    </tr>
  </tbody>
</table>

<p><strong>Constructors</strong></p>

<table>
  <thead>
    <tr>
      <th>COnstructor</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Vector3</code></td>
      <td>创建一个三维向量或点</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Equals</code></td>
      <td>如果给定的向量与当前向量完全相等，返回 <code class="language-plaintext highlighter-rouge">true</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Set</code></td>
      <td>设置现有 <code class="language-plaintext highlighter-rouge">Vector3</code> 的 x、y 和 z 分量。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ToString</code></td>
      <td>返回该向量的格式化字符串表示。”(x, y, z)”</td>
    </tr>
  </tbody>
</table>

<p><strong>Static Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Angle</code></td>
      <td>计算两个向量之间的夹角。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ClampMagnitude</code></td>
      <td>返回一个新的向量，最大长度被限制为 <code class="language-plaintext highlighter-rouge">maxLength</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Cross</code></td>
      <td>计算两个三维向量的叉积。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Distance</code></td>
      <td>计算两个三维点之间的距离。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Dot</code></td>
      <td>计算两个三维向量的点积，定义在相同坐标空间中。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Lerp</code></td>
      <td>在两个点之间进行线性插值。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LerpUnclamped</code></td>
      <td>在两个向量之间进行线性插值，不限制插值范围。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Max</code></td>
      <td>返回一个由两个向量中最大分量组成的向量。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Min</code></td>
      <td>返回一个由两个向量中最小分量组成的向量。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MoveTowards</code></td>
      <td>计算一个位置，当前位置到目标位置的最大移动距离不超过 <code class="language-plaintext highlighter-rouge">maxDistanceDelta</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Normalize</code></td>
      <td>将向量标准化，使其长度为 1。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OrthoNormalize</code></td>
      <td>使两个向量都标准化并且相互正交。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Project</code></td>
      <td>将一个向量投影到另一个向量上。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ProjectOnPlane</code></td>
      <td>将一个向量投影到一个平面上。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Reflect</code></td>
      <td>将向量反射到由法线定义的平面上。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">RotateTowards</code></td>
      <td>将一个向量 <code class="language-plaintext highlighter-rouge">current</code> 旋转到目标向量 <code class="language-plaintext highlighter-rouge">target</code>，并计算旋转。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Scale</code></td>
      <td>逐分量地将两个向量相乘。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SignedAngle</code></td>
      <td>计算两个向量之间相对于某一轴的带符号夹角。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Slerp</code></td>
      <td>在两个三维向量之间进行球面线性插值。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SlerpUnclamped</code></td>
      <td>在两个向量之间进行球面线性插值，不限制插值范围。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SmoothDamp</code></td>
      <td>逐渐地将向量朝着目标位置变化，随着时间变化。</td>
    </tr>
  </tbody>
</table>

<p><strong>Operators</strong></p>

<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator -</code></td>
      <td>将一个向量从另一个向量中减去。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator !=</code></td>
      <td>如果两个向量不同，则返回 <code class="language-plaintext highlighter-rouge">true</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator *</code></td>
      <td>将一个向量与一个数值相乘（逐分量相乘）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator /</code></td>
      <td>将一个向量与一个数值相除（逐分量相除）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator +</code></td>
      <td>两个三维向量进行逐分量加法。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator ==</code></td>
      <td>如果两个向量大致相等，则返回 <code class="language-plaintext highlighter-rouge">true</code>。</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.unity3d.com/ScriptReference/Vector3.html">Unity官方文档（Vector3）</a></p>

<h4 id="vector4四维向量">Vector4（四维向量）</h4>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector4</span> <span class="n">v</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">);</span>
</code></pre></div></div>
<p>常见用途：</p>
<ul>
  <li>齐次坐标（矩阵变换常用）</li>
  <li>传递颜色（Color在底层可能是Vector4(r,g,b,a)）</li>
  <li>shader开发中用于高级数学运算（如平面方程、切线空间等）</li>
</ul>

<h3 id="quaternion--euler-angles">Quaternion &amp; Euler Angles</h3>
<p>在Unity中，Quaternion是用来表示旋转的核心数学结构，它避免了Euler Angles的万向节死锁问题，并且适用于平滑插值和复杂3D计算</p>

<h4 id="quaternion">Quaternion</h4>
<p>Quaternion表示绕某一条单位轴旋转一个角度的这个过程，简单来说：表示一个旋转</p>

<p><strong>数学本质</strong>
四元数是一种复数扩展：</p>
<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">Q</span> <span class="p">=</span> <span class="s">w + xi + yj + zk</span>
</code></pre></div></div>
<p>在Unity中被表示为：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">struct</span> <span class="nc">Quaternion</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">z</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">x, y, z</code>表示旋转轴的向量部分（方向）<br />
<code class="language-plaintext highlighter-rouge">w</code>表示旋转的角度部分(cos(θ/2))</p>

<p>四元数不是角度 + 轴直接拼成的，是通过以下方式构造：</p>
<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">x</span><span class="p">=</span><span class="s">axis.x⋅sin(θ/2)</span>
<span class="py">y</span><span class="p">=</span><span class="s">axis.y⋅sin(θ/2)</span>
<span class="py">z</span><span class="p">=</span><span class="s">axis.z⋅sin(θ/2)</span>
<span class="py">w</span><span class="p">=</span><span class="s">cos(θ/2)</span>
</code></pre></div></div>
<p>其中<code class="language-plaintext highlighter-rouge">axis</code>是归一化的旋转轴向量<br />
<code class="language-plaintext highlighter-rouge">θ</code>是旋转角度（弧度）</p>

<p>你可以把四元数想象成一个旋转操作，它编码了两个信息：</p>
<ul>
  <li>1.绕哪个轴旋转</li>
  <li>2.旋转多少角度</li>
</ul>

<p><strong>Quaternion用途</strong></p>

<table>
  <thead>
    <tr>
      <th>用途场景</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>表示物体旋转</td>
      <td>替代 <code class="language-plaintext highlighter-rouge">transform.rotation = new Vector3(...)</code>，更稳定</td>
    </tr>
    <tr>
      <td>做平滑旋转（Slerp/Lerp）</td>
      <td>保持插值平滑、不跳跃、不变形</td>
    </tr>
    <tr>
      <td>实现摄像机跟随</td>
      <td>平滑跟随目标的朝向</td>
    </tr>
    <tr>
      <td>构建旋转动画</td>
      <td>可结合 Timeline、Animator 使用</td>
    </tr>
    <tr>
      <td>控制角色面向</td>
      <td>看向目标、追踪方向等</td>
    </tr>
  </tbody>
</table>

<p><strong>Quaternion API</strong></p>

<table>
  <thead>
    <tr>
      <th>方法/属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Quaternion.identity</code></td>
      <td>零旋转（即不旋转）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Quaternion.Euler(x, y, z)</code></td>
      <td>从欧拉角创建旋转</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Quaternion.LookRotation(dir)</code></td>
      <td>让对象朝向某个方向</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Quaternion.Angle(a, b)</code></td>
      <td>计算两个旋转之间的角度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Quaternion.AngleAxis(float angle, Vector3 axis)</code></td>
      <td>围绕axis旋转angle度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Quaternion.Slerp(a, b, t)</code></td>
      <td>在两个旋转之间平滑插值（匀速）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Quaternion.Lerp(a, b, t)</code></td>
      <td>线性插值旋转（不推荐用于大角度）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Quaternion.RotateTowards(a, b, maxDegreesDelta)</code></td>
      <td>限制最大旋转角度的平滑旋转</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">* 运算符</code>（例如 <code class="language-plaintext highlighter-rouge">rot * vector</code>）</td>
      <td>将旋转应用于向量，旋转该方向向量</td>
    </tr>
  </tbody>
</table>

<p><strong>构建方式</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Quaternion</span> <span class="n">q</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">AngleAxis</span><span class="p">(</span><span class="m">90</span><span class="p">,</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">up</span><span class="p">);</span> <span class="c1">//绕Y轴旋转90°</span>
</code></pre></div></div>
<p>使用欧拉角构建：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Quaternion</span> <span class="n">q</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">90</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span> <span class="c1">//XYZ分别是绕X Y Z轴的角度</span>
</code></pre></div></div>
<h4 id="euler-angles">Euler Angles</h4>

<p><strong>欧拉角的定义</strong><br />
欧拉角是用三个角度来描述3D空间中的一个旋转变换，每个角度表示围绕一个坐标轴的旋转量。<br />
在Unity中，欧拉角就是一个<code class="language-plaintext highlighter-rouge">Vector3</code></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">transform</span><span class="p">.</span><span class="n">eulerAngles</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">30</span><span class="p">,</span> <span class="m">45</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</code></pre></div></div>
<p>这表示：</p>
<ul>
  <li>绕X轴旋转30°</li>
  <li>然后绕Y轴旋转45°</li>
  <li>然后绕Z轴旋转0°
    <blockquote>
      <p>欧拉角的本质是「分轴顺序旋转」，三个角度 + 一个旋转顺序（X -&gt; Y -&gt; Z），顺序不能出现问题，否则结果不同</p>
    </blockquote>
  </li>
</ul>

<p><strong>欧拉角的特点</strong></p>

<table>
  <thead>
    <tr>
      <th>特点</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>直观</td>
      <td>直接写角度，容易理解和调试</td>
    </tr>
    <tr>
      <td>顺序敏感</td>
      <td>顺序不同，结果不同（ZYX ≠ XYZ）</td>
    </tr>
    <tr>
      <td>有死锁</td>
      <td>当某个轴旋转到特定位置时，另一个轴“失效”——<strong>万向节死锁（Gimbal Lock）</strong></td>
    </tr>
    <tr>
      <td>插值难</td>
      <td>在两个角度之间插值时可能会突然“跳动”或绕远路</td>
    </tr>
  </tbody>
</table>

<p><strong>欧拉角适用于：</strong></p>
<ul>
  <li>手动设置角度</li>
  <li>UI显示</li>
  <li>编辑器中拖拽角度时</li>
  <li>简单旋转动画、摄像机控制</li>
</ul>

<p><strong>实际旋转逻辑中，建议使用Quaternion</strong></p>

<p><strong>Euler Angels和Quaternion的关系</strong><br />
Unity内部几乎不直接用欧拉角进行旋转运算，它会自动把你设置的欧拉角转换为四元数</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">transform</span><span class="p">.</span><span class="n">eulerAngles</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">90</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
<span class="c1">// 实际上自动转换为：</span>
<span class="n">transform</span><span class="p">.</span><span class="n">rotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">90</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>欧拉角插值出现的问题</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector3</span> <span class="k">from</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
<span class="n">Vector3</span> <span class="n">to</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">360</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>

<span class="n">Vector3</span> <span class="n">result</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="nf">Lerp</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">);</span> <span class="c1">//会插值到180°</span>
</code></pre></div></div>
<p>实际上，从0°到360°最短路径时0°，这就是欧拉角插值跳变的问题<br />
使用四元数可以避免</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Quaternion</span> <span class="n">q1</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="k">from</span><span class="p">);</span>
<span class="n">Quaternion</span> <span class="n">q2</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>

<span class="n">Quaternion</span> <span class="n">qResult</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Slerp</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>Euler Angles和Quaternion的转换</strong><br />
欧拉角 -&gt; 四元数</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Quaternion</span> <span class="n">q</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">30</span><span class="p">,</span> <span class="m">45</span><span class="p">,</span> <span class="m">60</span><span class="p">);</span>
</code></pre></div></div>
<p>四元数 -&gt; 欧拉角</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector3</span> <span class="n">euler</span> <span class="p">=</span> <span class="n">q</span><span class="p">.</span><span class="n">eulerAngles</span><span class="p">;</span>
</code></pre></div></div>
<blockquote>
  <p>四元数本身不会存储旋转顺序和原始角度，这个反转换可能会出现不寻常的角度，比如-180°、350°等</p>
</blockquote>

<p>欧拉角和四元数的关系：三次独立的XYZ轴旋转（Euler Angle）相当于对于某个特定轴旋转特定角度（Quaternion）<br />
<strong>深入原理</strong>
给定欧拉角 (𝛼, 𝛽, 𝛾)，表示绕 X、Y、Z 旋转，四元数变换公式如下（XYZ顺序）：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Quaternion</span> <span class="n">q</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">);</span>
</code></pre></div></div>
<p>等价于</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Quaternion</span> <span class="n">qx</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">AngleAxis</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
<span class="n">Quaternion</span> <span class="n">qy</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">AngleAxis</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">up</span><span class="p">);</span>
<span class="n">Quaternion</span> <span class="n">qz</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">AngleAxis</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span><span class="p">);</span>
<span class="n">Quaternion</span> <span class="n">q</span> <span class="p">=</span> <span class="n">qy</span> <span class="p">*</span> <span class="n">qx</span> <span class="p">*</span> <span class="n">qz</span><span class="p">;</span> <span class="c1">//组合旋转，顺序重要；Unity为左乘</span>
</code></pre></div></div>

<p><strong>万向节死锁（Gimbal Lock）</strong><br />
Gimbal Lock是指使用欧拉角进行三维旋转时，当两个旋转轴重合，导致自由度从3变成2，某个方向的旋转无法表达的情况<br />
产生Gimbal Lock的核心原因是欧拉角的特性:<br />
一组欧拉角描述一个旋转过程：即，围绕每个轴的旋转角度和围绕每个轴旋转的顺序，顺序很重要，不同的顺序会带来不同的结果
Gimbal Lock产生的核心是：先执行旋转的轴会带动后执行旋转的轴转动，即产生新轴；但后执行旋转的轴不会带动先执行旋转的轴转动，即一个轴旋转过后就不会出现新轴了，这就会出现轴重合问题，即导致万向节死锁的产生<br />
<strong>数学本质是矩阵乘法的非交换性</strong><br />
旋转在数学上是用矩阵表示的：</p>
<ul>
  <li>旋转操作使用矩阵乘法实现的</li>
  <li>矩阵乘法不满足交换律，也就是说：Rx × Ry != Ry × Rx</li>
</ul>

<p><strong>核心关键是为什么后旋转的轴不能带动先旋转的轴？</strong><br />
这个问题涉及到旋转的执行顺序本质上是“嵌套变换”，而不是“同步协商”的。这就像流水线的工序，是不可逆和不可交错的<br />
核心结论：<br />
每一步旋转都是在“当前局部坐标系”下完成的，而不是回头修改前面坐标系的历史状态<br />
后面的旋转只是在前面旋转结果基础上叠加，它并不会“回头影响”之前已经旋转过的坐标系<br />
举个例子：
假设做一个蛋糕：<br />
第一步：打鸡蛋  <br />
第二步：加牛奶<br />
第三步：搅拌<br />
现在你问：为什么我搅拌的时候不能回头改变我打鸡蛋这个过程？<br />
因为：打鸡蛋已经做完了，是个不可逆的状态变换，你在搅拌的时候，只能处理“鸡蛋 + 牛奶”的混合物，不能改变已经打完的蛋</p>

<p><strong>数学视角：矩阵乘法是方向性的</strong>
旋转是通过矩阵来表示的，顺序matters： <code class="language-plaintext highlighter-rouge">FinalRotation = Rz · Ry · Rx</code><br />
你先执行Rx，然后再执行Ry,再执行Rz<br />
每个旋转操作都是将当前状态乘上一个旋转矩阵<br />
一旦Rx被应用，坐标系就已经变了<br />
之后的Ry是在这个变了的坐标系下进行的<br />
Ry不会也无法回头修改Rx的效果<br />
因为矩阵乘法不是可交换的，所以这个顺序是“单向嵌套”，不是“双向影响”</p>

<p><strong>欧拉角是旋转变换，每次旋转变换都是叠加了上次旋转的状态后再进行的，也就是说，虽然每次变换都是独立的，但都要经历从初始状态按顺序旋转，绕轴旋转角度达到目标状态这一系列流程，这就把时序包含在其中了</strong><br />
<strong>初始状态是（0，0，0）</strong></p>

<p><strong>为什么看到的变换是连续的</strong><br />
欧拉角变换虽然顺序嵌套，但它们构成的是一个连续函数映射<br />
欧拉角 → 四元数 → 变换矩阵 → 渲染出模型的姿态
整个链条中：</p>

<p>欧拉角：你手动输入的 (X, Y, Z) 是连续的（例如你拖动滑块）</p>

<p>四元数：Unity 把欧拉角转换成一个四元数，这是一个连续光滑的旋转表示</p>

<p>矩阵：四元数再转成 3×3 旋转矩阵，依然是平滑的</p>

<p>模型：在世界中展示的姿态是自然旋转、连贯变化的</p>

<p>所以你看到的旋转是连续的、平滑的。</p>

<p><strong>哪些地方是不连续的</strong><br />
1.万向节死锁，当某个周旋转到90°，两个轴重合，自由度减少，Unity为了保持“姿态”，可能会自动调整其他轴的值，此时Rotation的值再Inspector中跳变，但物体并没有跳<br />
2.四元数存在加减号不唯一（180°对称）问题，一个方向可以由两个四元数表示：q和-q，它们作用在物体上是一样的，Unity在背后自动选择最短路径，所以视觉上依旧是连续旋转路径上的最短旋转</p>

<h3 id="matrix44">Matrix4×4</h3>
<p>在 Unity 中，Matrix4x4 是一个 4x4 的矩阵，通常用于表示和处理 3D 图形变换（例如：平移、旋转、缩放）以及投影变换。它是 Unity 中进行图形学计算时不可或缺的工具之一，特别是在操作坐标系变换和投影时，矩阵起到了重要作用。</p>

<h4 id="结构和基本概念">结构和基本概念</h4>
<p>一个 4x4 的矩阵包含 16 个元素，用来存储 3D 空间中的变换信息。矩阵通常表示为：</p>

\[\begin{bmatrix}
m_00 &amp; m_01 &amp; m_02 &amp; m_03\\
m_10 &amp; m_11 &amp; m_12 &amp; m_13\\
m_20 &amp; m_21 &amp; m_22 &amp; m_23\\
m_30 &amp; m_31 &amp; m_32 &amp; m_33
\end{bmatrix}\]

<ul>
  <li>前三列（前三个3D向量）：表示选择、缩放和剪切变换</li>
  <li>最后一列：通常表示平移</li>
  <li>最后一行：在Unity中一般被设置为<code class="language-plaintext highlighter-rouge">[0, 0, 0, 1]</code>，它不参与位置和方向的变换，但在某些情况下（如透视投影）可能会发生变化</li>
</ul>

<h4 id="matrix44的常见用途">Matrix4×4的常见用途</h4>
<p>1) 变换（Transformations）
在3D图形中，变换通常包含平移（Translation）、旋转（Rotation）和缩放（Scaling），这些都可以通过矩阵来表示。矩阵变换是通过矩阵与向量的乘法实现的</p>
<ul>
  <li>
    <p>平移矩阵：
通过矩阵中的第四列来实现物体的平移</p>

    <p>$ Translation\;Matrix = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; tx\ 0 &amp; 1 &amp; 0 &amp; ty\ 0 &amp; 0 &amp; 1 &amp; tz\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} $</p>

    <p>其中，<code class="language-plaintext highlighter-rouge">tx</code>,<code class="language-plaintext highlighter-rouge">ty</code>,<code class="language-plaintext highlighter-rouge">tz</code>是在X,Y,Z轴上的平移距离</p>
  </li>
  <li>旋转矩阵：
旋转矩阵用于旋转物体在不同轴上的旋转。旋转矩阵有不同的表示方式，常见的是绕X,Y,Z轴旋转的矩阵：
    <ul>
      <li>绕X轴旋转：
        <pre><code class="language-math">Rotation\;Matrix(X)=\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; cos(θ) &amp; -sin(θ) &amp; 0\\ 0 &amp; sin(θ) &amp; cos(θ) &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}
</code></pre>
      </li>
      <li>绕Y轴旋转
        <pre><code class="language-math">   Rotation\;Matrix(Y)=\begin{bmatrix} cos(θ) &amp; 0 &amp; sin(θ) &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ -sin(θ) &amp; 0 &amp; cos(θ) &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} 
</code></pre>
      </li>
      <li>绕Z轴旋转：
        <pre><code class="language-math">Rotation\;Matrix(Z)=\begin{bmatrix} cos(θ) &amp; 0 &amp; sin(θ) &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ -sin(θ) &amp; 0 &amp; cos(θ) &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} 
</code></pre>
        <p>其中<code class="language-plaintext highlighter-rouge">θ</code>代表旋转角度</p>
      </li>
    </ul>
  </li>
  <li>缩放矩阵：
缩放矩阵控制物体在各个轴上的缩放：
    <pre><code class="language-math">Scale\;Matrix=\begin{bmatrix} sx &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; sy &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; sz &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} 
</code></pre>

    <p>其中，<code class="language-plaintext highlighter-rouge">sx</code>,<code class="language-plaintext highlighter-rouge">sy</code>,<code class="language-plaintext highlighter-rouge">sz</code>代表X,Y,Z轴上的缩放因子</p>
  </li>
</ul>

<p>2) 矩阵乘法
多个变换（如平移、旋转、缩放）可以通过矩阵乘法结合起来。例如，将旋转和缩放变换合并到一个矩阵中，执行复合变换。</p>
<ul>
  <li>如果你有两个矩阵<code class="language-plaintext highlighter-rouge">M1</code>和<code class="language-plaintext highlighter-rouge">M2</code>，则复合变换矩阵是通过矩阵乘法得到的：<code class="language-plaintext highlighter-rouge">M = M1 * M2</code></li>
  <li>在Unity中，矩阵乘法通过<code class="language-plaintext highlighter-rouge">Matrix4×4</code>的<code class="language-plaintext highlighter-rouge">*</code>操作符完成
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Matrix4x4</span> <span class="n">rotationMatrix</span> <span class="p">=</span> <span class="n">Matrix4x4</span><span class="p">.</span><span class="nf">Rotate</span><span class="p">(</span><span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">45</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
<span class="n">Matrix4x4</span> <span class="n">scaleMatrix</span> <span class="p">=</span> <span class="n">Matrix4x4</span><span class="p">.</span><span class="nf">Scale</span><span class="p">(</span><span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">));</span>
<span class="n">Matrix4x4</span> <span class="n">combinedMatrix</span> <span class="p">=</span> <span class="n">rotationMatrix</span> <span class="p">*</span> <span class="n">scaleMatrix</span><span class="p">;</span> <span class="c1">// 复合变换</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>3) 投影矩阵
投影矩阵用于将 3D 场景投影到 2D 屏幕上。常见的投影有 正射投影 和 透视投影。</p>

<ul>
  <li>透视投影矩阵：
透视投影矩阵会产生“透视效果”，即远处的物体看起来更小。透视矩阵的公式通常比较复杂，Unity 提供了 <code class="language-plaintext highlighter-rouge">Matrix4x4.Perspective</code> 方法来生成透视投影矩阵。
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Matrix4x4</span> <span class="n">perspectiveMatrix</span> <span class="p">=</span> <span class="n">Matrix4x4</span><span class="p">.</span><span class="nf">Perspective</span><span class="p">(</span><span class="m">60f</span><span class="p">,</span> <span class="m">16f</span><span class="p">/</span><span class="m">9f</span><span class="p">,</span> <span class="m">0.1f</span><span class="p">,</span> <span class="m">100f</span><span class="p">);</span>
</code></pre></div>    </div>
    <p>其中，<code class="language-plaintext highlighter-rouge">60f</code>是垂直视野角度，<code class="language-plaintext highlighter-rouge">16/9f</code>是宽高比，<code class="language-plaintext highlighter-rouge">0.1f</code>和<code class="language-plaintext highlighter-rouge">100f</code>是近平面和远平面的距离</p>
  </li>
  <li>正射投影矩阵
正射投影没有透视效果，所有物体的大小都是相同的，不随远近变化。可以通过 Matrix4x4.Ortho 来创建
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Matrix4x4</span> <span class="n">orthoMatrix</span> <span class="p">=</span> <span class="n">Matrix4x4</span><span class="p">.</span><span class="nf">Ortho</span><span class="p">(-</span><span class="m">5f</span><span class="p">,</span> <span class="m">5f</span><span class="p">,</span> <span class="p">-</span><span class="m">5f</span><span class="p">,</span> <span class="m">5f</span><span class="p">,</span> <span class="m">0.1f</span><span class="p">,</span> <span class="m">100f</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>4) 视图矩阵（View Matrix）
视图矩阵用于描述相机在场景中的位置和朝向。它把世界空间中的物体转换到相机的视图空间</p>
<ul>
  <li>Unity中可以通过<code class="language-plaintext highlighter-rouge">Camera.worldToCameraMatrix</code>获取视图矩阵</li>
</ul>

<h4 id="api-1">API</h4>
<p><strong>Static Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">identity</code></td>
      <td>返回单位矩阵（只读）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">zero</code></td>
      <td>返回零矩阵（只读）</td>
    </tr>
  </tbody>
</table>

<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">decomposeProjection</code></td>
      <td>该属性接受一个投影矩阵并返回定义投影视锥体的六个平面坐标。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">determinant</code></td>
      <td>返回矩阵的行列式（只读）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">inverse</code></td>
      <td>返回该矩阵的逆矩阵（只读）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isIdentity</code></td>
      <td>检查此矩阵是否为单位矩阵（只读）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">lossyScale</code></td>
      <td>尝试从矩阵中获取一个缩放值（只读）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rotation</code></td>
      <td>尝试从矩阵中获取一个旋转四元数。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">this[int, int]</code></td>
      <td>访问矩阵中的元素，使用 <code class="language-plaintext highlighter-rouge">[row, column]</code> 索引。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">transpose</code></td>
      <td>返回矩阵的转置矩阵（只读）。</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetColumn</code></td>
      <td>获取矩阵的某一列。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetPosition</code></td>
      <td>从矩阵中获取位置向量。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetRow</code></td>
      <td>返回矩阵的某一行。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MultiplyPoint</code></td>
      <td>使用此矩阵对一个位置进行变换（通用）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MultiplyPoint3x4</code></td>
      <td>使用此矩阵对一个位置进行快速变换（适用于 3x4 矩阵）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MultiplyVector</code></td>
      <td>使用此矩阵对一个方向进行变换。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetColumn</code></td>
      <td>设置矩阵的某一列。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetRow</code></td>
      <td>设置矩阵的某一行。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetTRS</code></td>
      <td>将此矩阵设置为一个平移、旋转和缩放矩阵。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ToString</code></td>
      <td>返回此矩阵的格式化字符串表示。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">TransformPlane</code></td>
      <td>返回一个在空间中经过变换的平面。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ValidTRS</code></td>
      <td>检查此矩阵是否是一个有效的变换矩阵（平移、旋转、缩放组合矩阵）。</td>
    </tr>
  </tbody>
</table>

<p><strong>Static Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Frustum</code></td>
      <td>返回一个具有视景体（viewing frustum）的投影矩阵，近平面由传入的坐标定义。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Inverse3DAffine</code></td>
      <td>计算一个 3D 仿射矩阵的逆矩阵。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LookAt</code></td>
      <td>创建一个“Look At”矩阵，使物体朝向指定的目标点。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Ortho</code></td>
      <td>创建一个正交投影矩阵。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Perspective</code></td>
      <td>创建一个透视投影矩阵。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Rotate</code></td>
      <td>创建一个旋转矩阵。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Scale</code></td>
      <td>创建一个缩放矩阵。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Translate</code></td>
      <td>创建一个平移矩阵。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">TRS</code></td>
      <td>创建一个平移、旋转和缩放的组合矩阵。</td>
    </tr>
  </tbody>
</table>

<p><strong>Operators</strong></p>

<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator*</code></td>
      <td>两个矩阵相乘</td>
    </tr>
  </tbody>
</table>

<h2 id="application">Application</h2>
<p><code class="language-plaintext highlighter-rouge">Application</code>是Unity提供的一个全局静态类，用来获取或控制应用程序的整体运行状态，比如游戏生命周期、平台信息、版本号、退出应用、持久化路径、事件系统等<br />
可以理解为：<code class="language-plaintext highlighter-rouge">Application</code> = 游戏运行时的全局控制台</p>

<h3 id="api-2">API</h3>
<p><strong>Static Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>分组</th>
      <th>属性</th>
      <th>用途简述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>应用信息</strong></td>
      <td><code class="language-plaintext highlighter-rouge">productName</code></td>
      <td>应用产品名</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">companyName</code></td>
      <td>公司名</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">version</code></td>
      <td>应用版本号</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">unityVersion</code></td>
      <td>Unity 运行时版本</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">buildGUID</code></td>
      <td>构建唯一标识</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">cloudProjectId</code></td>
      <td>云项目 ID</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">identifier</code></td>
      <td>包名 / Bundle ID</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">installerName</code></td>
      <td>安装来源（商店）</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">installMode</code></td>
      <td>安装模式</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">sandboxType</code></td>
      <td>沙盒环境类型</td>
    </tr>
    <tr>
      <td><strong>平台与运行环境</strong></td>
      <td><code class="language-plaintext highlighter-rouge">platform</code></td>
      <td>当前运行平台</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">isMobilePlatform</code></td>
      <td>是否移动平台</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">isConsolePlatform</code></td>
      <td>是否主机平台</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">isEditor</code></td>
      <td>是否在编辑器运行</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">isBatchMode</code></td>
      <td>是否批处理模式</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">absoluteURL</code></td>
      <td>当前 URL / 深度链接</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">systemLanguage</code></td>
      <td>系统语言</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">internetReachability</code></td>
      <td>网络可达性</td>
    </tr>
    <tr>
      <td><strong>数据路径</strong></td>
      <td><code class="language-plaintext highlighter-rouge">dataPath</code></td>
      <td>游戏数据路径（只读）</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">persistentDataPath</code></td>
      <td>持久化数据路径（可写）</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">streamingAssetsPath</code></td>
      <td>StreamingAssets 路径</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">temporaryCachePath</code></td>
      <td>临时缓存路径</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">consoleLogPath</code></td>
      <td>日志文件路径</td>
    </tr>
    <tr>
      <td><strong>运行状态</strong></td>
      <td><code class="language-plaintext highlighter-rouge">isPlaying</code></td>
      <td>是否正在运行</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">isFocused</code></td>
      <td>是否获得焦点</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">runInBackground</code></td>
      <td>后台运行开关</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">backgroundLoadingPriority</code></td>
      <td>后台加载优先级</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">targetFrameRate</code></td>
      <td>目标帧率</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">exitCancellationToken</code></td>
      <td>退出时取消令牌</td>
    </tr>
    <tr>
      <td><strong>安全与验证</strong></td>
      <td><code class="language-plaintext highlighter-rouge">genuine</code></td>
      <td>应用是否被篡改</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">genuineCheckAvailable</code></td>
      <td>是否可用完整性检查</td>
    </tr>
  </tbody>
</table>

<p><strong>Static Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>分组</th>
      <th>方法</th>
      <th>描述</th>
      <th>典型用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>场景与运行控制</strong></td>
      <td><code class="language-plaintext highlighter-rouge">CanStreamedLevelBeLoaded(string levelName)</code></td>
      <td>检查指定场景是否可以加载（适用于流式加载）</td>
      <td>场景预检测，避免加载不存在的场景</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">Unload()</code></td>
      <td>卸载 Unity Player</td>
      <td>WebGL、嵌入式 Unity 内容的卸载</td>
    </tr>
    <tr>
      <td><strong>日志与调试</strong></td>
      <td><code class="language-plaintext highlighter-rouge">GetStackTraceLogType(LogType logType)</code></td>
      <td>获取指定日志类型的堆栈跟踪模式</td>
      <td>日志调试策略</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">SetStackTraceLogType(LogType logType, StackTraceLogType stackTraceType)</code></td>
      <td>设置指定日志类型的堆栈跟踪模式</td>
      <td>减少无关堆栈信息，提高性能</td>
    </tr>
    <tr>
      <td><strong>权限与授权</strong></td>
      <td><code class="language-plaintext highlighter-rouge">HasUserAuthorization(UserAuthorization mode)</code></td>
      <td>检查用户是否授权使用麦克风或摄像头（iOS/WebGL）</td>
      <td>设备访问控制</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">RequestUserAuthorization(UserAuthorization mode)</code></td>
      <td>请求用户授权麦克风/摄像头（iOS/WebGL）</td>
      <td>首次访问硬件设备时使用</td>
    </tr>
    <tr>
      <td><strong>许可证与广告</strong></td>
      <td><code class="language-plaintext highlighter-rouge">HasProLicense()</code></td>
      <td>检查当前 Unity 是否为 Pro 许可证</td>
      <td>编辑器功能限制判断</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">RequestAdvertisingIdentifierAsync(Action&lt;string, bool, string&gt; callback)</code></td>
      <td>请求广告标识符（iOS/UWP）</td>
      <td>广告分析、用户追踪（需遵守隐私法规）</td>
    </tr>
    <tr>
      <td><strong>运行状态</strong></td>
      <td><code class="language-plaintext highlighter-rouge">IsPlaying(Object obj)</code></td>
      <td>检查对象是否在运行环境中（Play 模式或构建版本）</td>
      <td>运行时逻辑分支判断</td>
    </tr>
    <tr>
      <td><strong>系统交互</strong></td>
      <td><code class="language-plaintext highlighter-rouge">OpenURL(string url)</code></td>
      <td>打开外部链接或资源</td>
      <td>跳转到网页、商店、帮助文档</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">Quit()</code></td>
      <td>退出应用程序</td>
      <td>游戏退出按钮</td>
    </tr>
  </tbody>
</table>

<p>注意事项</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Quit()</code>在编辑器中无效，只在构建版本中退出</li>
  <li>权限方法仅在特定平台有效（iOS、WebGL），Android需要用原生接口</li>
  <li>广告ID受隐私政策限制（iOS 14+ 必须先获得用户同意）</li>
  <li><code class="language-plaintext highlighter-rouge">Unload()</code>主要用于WebGL等嵌入环境，不适用于独立应用</li>
  <li>日志堆栈设置可以优化性能，但会影响调试信息完整性</li>
</ol>

<p><strong>Events</strong></p>

<table>
  <thead>
    <tr>
      <th>事件名</th>
      <th>触发时机</th>
      <th>常见用途</th>
      <th>注意事项</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>deepLinkActivated</strong></td>
      <td>当 App 通过 <strong>Deep Link URL</strong> 被激活时（Android / iOS / UWP）</td>
      <td>处理外部 URL 跳转，例如从浏览器点击链接直接打开游戏并跳转到特定场景</td>
      <td>仅在移动端/UWP生效，需要在系统设置好 Deep Link</td>
    </tr>
    <tr>
      <td><strong>focusChanged</strong></td>
      <td>当应用程序获得或失去焦点时</td>
      <td>暂停/恢复游戏逻辑、音乐播放、计时器等</td>
      <td>与 <code class="language-plaintext highlighter-rouge">Application.runInBackground</code> 配合使用</td>
    </tr>
    <tr>
      <td><strong>logMessageReceived</strong></td>
      <td>在主线程收到 <code class="language-plaintext highlighter-rouge">Debug.Log</code>/<code class="language-plaintext highlighter-rouge">Debug.LogError</code>/<code class="language-plaintext highlighter-rouge">Debug.LogWarning</code> 时触发</td>
      <td>收集运行时日志、保存到文件、上传服务器</td>
      <td>仅主线程调用，性能安全</td>
    </tr>
    <tr>
      <td><strong>logMessageReceivedThreaded</strong></td>
      <td>在<strong>任意线程</strong>收到日志信息时触发</td>
      <td>捕获多线程环境下的日志（Job System、线程池等）</td>
      <td>回调不在主线程，访问 Unity API 会报错</td>
    </tr>
    <tr>
      <td><strong>lowMemory</strong></td>
      <td>当设备内存不足时触发</td>
      <td>释放不必要的资源、清理缓存</td>
      <td>常见于移动设备，尤其是低端机</td>
    </tr>
    <tr>
      <td><strong>memoryUsageChanged</strong></td>
      <td>当内存使用量显著变化时触发</td>
      <td>做内存优化监控，比如动态调节贴图分辨率</td>
      <td>Unity 2021.2+ 新增功能</td>
    </tr>
    <tr>
      <td><strong>onBeforeRender</strong></td>
      <td>在渲染前调用（尤其是 VR 输入更新）</td>
      <td>VR/AR 场景中，在渲染前同步姿态数据</td>
      <td>用途很小众，主要面向 XR</td>
    </tr>
    <tr>
      <td><strong>quitting</strong></td>
      <td>应用退出时触发</td>
      <td>保存存档、上传数据、关闭网络连接</td>
      <td>有时不一定能保证执行完，比如强杀进程</td>
    </tr>
    <tr>
      <td><strong>unloading</strong></td>
      <td>Player 卸载时触发</td>
      <td>卸载前释放资源（场景卸载、资源清理）</td>
      <td>常与 Addressables 资源卸载配合</td>
    </tr>
    <tr>
      <td><strong>wantsToQuit</strong></td>
      <td>应用<strong>想要</strong>退出时触发，可拦截</td>
      <td>弹出“是否退出”确认框</td>
      <td>通过返回 <code class="language-plaintext highlighter-rouge">false</code> 阻止退出</td>
    </tr>
  </tbody>
</table>

<p><strong>Delegates</strong></p>

<table>
  <thead>
    <tr>
      <th>委托</th>
      <th>作用</th>
      <th>常用场景</th>
      <th>签名</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>AdvertisingIdentifierCallback</strong></td>
      <td>获取设备广告 ID（Ad ID / IDFA）</td>
      <td>广告投放、用户追踪</td>
      <td><code class="language-plaintext highlighter-rouge">void(string advertisingId, bool trackingEnabled, string error)</code></td>
    </tr>
    <tr>
      <td><strong>LogCallback</strong></td>
      <td>自定义日志处理</td>
      <td>日志系统、异常上传</td>
      <td><code class="language-plaintext highlighter-rouge">void(string condition, string stackTrace, LogType type)</code></td>
    </tr>
    <tr>
      <td><strong>LowMemoryCallback</strong></td>
      <td>低内存回调</td>
      <td>清缓存、卸载贴图</td>
      <td><code class="language-plaintext highlighter-rouge">void()</code></td>
    </tr>
    <tr>
      <td><strong>MemoryUsageChangedCallback</strong></td>
      <td>内存使用变化回调</td>
      <td>实时内存监控、自适应性能</td>
      <td><code class="language-plaintext highlighter-rouge">void(long memoryUsage)</code></td>
    </tr>
  </tbody>
</table>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-06-01T00:00:00+08:00">June 1, 2025</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/posts/2025-06-03-Unity-Asynchronous-and-Coroutine/" class="pagination--pager" title="Unity Asynchronous and Coroutine">Previous</a>
    
    
      <a href="/posts/2025-06-04-Collider-and-Trigger/" class="pagination--pager" title="Collider &amp; Trigger">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/ljf12825" rel="nofollow noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">ljf12825's Blog</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
