<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.1 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>UI System - ljf12825’s Blog</title>
<meta name="description" content="Unity UI系统是Unity引擎内置的用于构建用户界面的工具集。它基于Canvas（画布）架构，支持制作按钮、文本、图片、滑动条、输入框等各种交互元素">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="ljf12825's Blog">
<meta property="og:title" content="UI System">
<meta property="og:url" content="http://localhost:4000/posts/2025-06-07-UI-System/">


  <meta property="og:description" content="Unity UI系统是Unity引擎内置的用于构建用户界面的工具集。它基于Canvas（画布）架构，支持制作按钮、文本、图片、滑动条、输入框等各种交互元素">







  <meta property="article:published_time" content="2025-06-01T00:00:00+08:00">






<link rel="canonical" href="http://localhost:4000/posts/2025-06-07-UI-System/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="ljf12825's Blog Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- favicon -->
<link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon">

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          ljf12825's Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Categories</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tags</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="UI System">
    <meta itemprop="description" content="Unity UI系统是Unity引擎内置的用于构建用户界面的工具集。它基于Canvas（画布）架构，支持制作按钮、文本、图片、滑动条、输入框等各种交互元素">
    <meta itemprop="datePublished" content="2025-06-01T00:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/posts/2025-06-07-UI-System/" itemprop="url">UI System
</a>
          </h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>Unity UI系统是Unity引擎内置的用于构建用户界面的工具集。它基于Canvas（画布）架构，支持制作按钮、文本、图片、滑动条、输入框等各种交互元素</p>

<h2 id="ugui和ngui">UGUI和NGUI</h2>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>UGUI（Unity GUI）</th>
      <th>NGUI（Next-Gen UI）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>开发方</td>
      <td>Unity 官方</td>
      <td>第三方（Tasharen Entertainment）</td>
    </tr>
    <tr>
      <td>引入版本</td>
      <td>Unity 4.6+ 内置</td>
      <td>Unity 3.x 时期的主流 UI 插件</td>
    </tr>
    <tr>
      <td>集成性</td>
      <td>原生集成，支持 Canvas、EventSystem、Animation 等</td>
      <td>插件形式，较早期版本需手动集成</td>
    </tr>
    <tr>
      <td>渲染系统</td>
      <td>使用 Unity 内部渲染系统（Canvas）</td>
      <td>自定义渲染系统，Draw Call 优化依赖面板拆分</td>
    </tr>
    <tr>
      <td>编辑器支持</td>
      <td>所见即所得，Scene View 拖拽 UI</td>
      <td>早期需要反复预览，后期版本改善较多</td>
    </tr>
    <tr>
      <td>多分辨率适配</td>
      <td>有自动布局系统、Anchor、RectTransform</td>
      <td>依赖自定义 Anchor 系统</td>
    </tr>
    <tr>
      <td>动画支持</td>
      <td>支持 Unity Animation 和 Animator</td>
      <td>原生支持有限，需自定义组件</td>
    </tr>
    <tr>
      <td>事件系统</td>
      <td>支持原生 EventSystem（点击、拖拽等）</td>
      <td>使用自己的事件系统</td>
    </tr>
    <tr>
      <td>社区和文档</td>
      <td>官方支持，Unity 文档齐全</td>
      <td>社区活跃度下降，文档依赖作者和社区</td>
    </tr>
    <tr>
      <td>性能</td>
      <td>对大型复杂 UI 会产生较多 Draw Call，需要合批优化</td>
      <td>更早期对 Draw Call 优化做得较极致，但维护成本高</td>
    </tr>
    <tr>
      <td>是否推荐使用</td>
      <td>推荐（Unity 官方支持）</td>
      <td>不推荐新项目使用（已过时）</td>
    </tr>
  </tbody>
</table>

<p>NGUI是在Unity官方UI系统还不成熟时的“事实标准”，很多Unity3.x和4.x的项目大量使用<br />
UGUI时Unity官方退出的新UI系统，功能更强大，易于扩展，且原生支持多平台和工具链</p>

<p><img src="/assets/images/CreateUI.jpg/" alt="CreateUI" /></p>

<p><a href="https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/index.html">UnityUI2.0.0</a></p>

<h2 id="canvas">Canvas</h2>
<p>Canvas是Unity中所有UI元素的容器，所有UI控件都必须是Canvas的子对象，否则它们不会被渲染成UI</p>

<p><img src="/assets/images/CanvasInspector.jpg/" alt="CanvasInspector" /></p>

<h3 id="canvas的渲染模式">Canvas的渲染模式</h3>
<p>Canvas有三种渲染模式，不同模式影响UI的显示方式、渲染顺序以及与摄像机的关系</p>

<h4 id="1screen-space---overlay屏幕空间覆盖">1.Screen Space - Overlay（屏幕空间覆盖）</h4>
<ul>
  <li>这是默认模式</li>
  <li>UI直接渲染在屏幕上，始终覆盖在游戏视图的最上层</li>
  <li>不受任何摄像机影响，不需要摄像机参与渲染</li>
  <li>适合制作固定在屏幕上的HUD、血条、菜单等</li>
  <li>优点：渲染简单，效率高</li>
  <li>缺点：无法与3D世界产生深度关系，UI始终在前面</li>
</ul>

<h4 id="2screen-space---camera屏幕空间摄像机">2.Screen Space - Camera（屏幕空间摄像机）</h4>
<ul>
  <li>UI挂载在指定的摄像机前面</li>
  <li>通过摄像机来渲染UI，UI会与摄像机的视锥和深度产生关系</li>
  <li>允许UI元素首摄像机影响（缩放、视角变化）</li>
  <li>常用于需要与摄像机视角联动的UI，例如放大镜效果、视角内提示等</li>
  <li>可以控制UI的排序顺序（Sorting Layer和Order in Layer）</li>
</ul>

<h4 id="3world-space世界空间">3.World Space（世界空间）</h4>
<ul>
  <li>UI作为3D场景中的普通物体存在</li>
  <li>有自己的位置、旋转、缩放，可以放在场景中任意位置</li>
  <li>通过普通摄像机渲染，能与3D模型、光照等交互</li>
  <li>适合制作3D菜单、游戏内面板、悬浮信息</li>
  <li>需要调整Canvas的大小和UI元素的尺寸，比较复杂</li>
</ul>

<h3 id="canvas组件的重要属性">Canvas组件的重要属性</h3>
<h4 id="screen-space---overlay">Screen Space - Overlay</h4>
<p><img src="/assets/images/Canvas-ScreenSpace-Overlay.jpg/" alt="CanvasScreenSpace-Overlay" /></p>

<p>默认模式</p>

<ul>
  <li>Render Mode：渲染模式，见上文</li>
  <li>Pixel Perfect：像素完美，开启后UI元素会对齐到像素点，减少模糊，适合2D像素风UI</li>
  <li>Sort Order：控制UI元素渲染顺序，决定了多个Canvas之间的渲染优先级，数值越大，渲染层级越靠前，会覆盖数值较小的Canvas；数值相同，会根据它们在Hierarchy中的位置决定前后</li>
  <li>Target Display：该Canvas渲染到哪一个物理显示器上，这个功能主要用在多显示器应用中，默认Unity只是用主显示器（Display1），有八个可选项，必须在代码中手动启动多个显示器 <code class="language-plaintext highlighter-rouge">if (Dispaly.display.Length &gt; 1) Display.display[1].Activate();</code>（启用Display 2）</li>
  <li>Additional Shader Channels：用于指定UI顶点需要传递给Shader的额外数据通道
当你使用自定义UI Shader（比如为按钮添加特效、动画、描边等）时，可能需要从UI元素的每个顶点传递一些额外数据（如颜色、UV1、法线、Tangent等）到Shader中。而默认Canvas并不会传递这些数据，只有你在<code class="language-plaintext highlighter-rouge">Additional Shader Channels</code>中显式勾选，Unity才会将这些数据从CPU传给GPU
可选项说明：
    <ul>
      <li>TexCoord1：第二套UV坐标，一些Shader特效可能使用</li>
      <li>TexCoord2：第三套UV坐标</li>
      <li>TexCoord3：第四套UV坐标</li>
      <li>Normal：法线信息（常用于光照Shader）</li>
      <li>Tangent：切线信息（常与法线贴图配合）</li>
      <li>Color：颜色通道（通常UI默认传递的是主颜色）</li>
    </ul>

    <p>Unity的UI是通过<code class="language-plaintext highlighter-rouge">CanvasRenderer</code>生成的顶点数据送入GPU，默认只传position、uv0、color；若Shader需要额外通道，必须通过<code class="language-plaintext highlighter-rouge">Additional Shader Channels</code>显式开启，让<code class="language-plaintext highlighter-rouge">Canvas</code>包装完整数据；但需要注意，勾选越多，传输数据越大，性能开销越大（尤其是在移动端）</p>
  </li>
  <li>Vertex Color Always In Gamma Color Space：控制UI顶点颜色是否始终使用Gamma空间进行处理，无论当前项目是否使用Linear或Gamma颜色空间</li>
</ul>

<h4 id="screen-space---camera">Screen Space - Camera</h4>
<p><img src="/assets/images/Canvas-ScreenSpace-Camera.jpg/" alt="CanvasScreenSpace-Camera" /></p>

<ul>
  <li>Render Camera：The Camera whitch will render the canvas. This is also the camera used to send events
A Screen Space Canvas with no specified camera acts like an Overlay Canvas</li>
</ul>

<h4 id="world-space">World Space</h4>
<p><img src="/assets/images/Canvas-WorldSpace.jpg/" alt="CanvasWorldSpace" /></p>

<ul>
  <li>Event Camera：用于处理射线点击UI的相机（通常是主摄像机），必须设置，否则点击无效</li>
</ul>

<h3 id="canvasscaler">CanvasScaler</h3>
<p>Canvas通常会搭配CanvasScaler使用，控制UI的缩放和适配，CanvasScaler用于根据不同分辨率、屏幕尺寸，动态调整UI大小，保证UI在不同设备上的一致性</p>

<h4 id="三种缩放模式">三种缩放模式</h4>
<p>1.Constant Pixel Size（固定像素大小）</p>

<p><img src="/assets/images/CanvasScaler-ConstantPixelSize.jpg/" alt="Constant Pixel Size" /></p>

<ul>
  <li>UI元素大小固定为设计时的像素值，不会随屏幕尺寸变化缩放</li>
  <li>适合UI对像素精度要求高，不想变形的场景</li>
  <li>缺点：不同分辨率下UI大小不一致，低分辨率屏幕上UI显得很大，高分辨率上显得很小</li>
</ul>

<p>参数：</p>
<ul>
  <li>Scale Factor：控制Canvas上所有UI元素的整体缩放倍数</li>
  <li>Reference Pixels Per Unit：单位像素参考值，决定1个世界单位中包含多少个像素</li>
</ul>

<p>2.Scale With Screen Size（随屏幕尺寸缩放）</p>

<p><img src="/assets/images/CanvasScaler-ScaleWithScreenSize.jpg/" alt="Scale With Screen Size" /></p>

<ul>
  <li>根据屏幕分辨率，按比例缩放UI，使得UI在不同分辨率下保持视觉一致</li>
  <li>通过<code class="language-plaintext highlighter-rouge">Reference Resolution</code>设置参考设计分辨率</li>
  <li>通过<code class="language-plaintext highlighter-rouge">Screen Match Mode</code>决定缩放如何适配宽高比
    <ul>
      <li>Match Width Or Height：在宽和高之间插值，<code class="language-plaintext highlighter-rouge">Match</code>属性控制偏重那一边（0为宽，1为高）</li>
      <li>Expand：适配屏幕，保证UI不会裁剪，但可能留空白</li>
      <li>Shrink：保证UI填满屏幕，可能裁剪一部分</li>
    </ul>
  </li>
  <li>这是最常用的模式，推荐用于大多数UI适配</li>
</ul>

<p>3.Constant Physical Size（固定物理大小）</p>

<p><img src="/assets/images/CanvasScaler-ConstantPhysicalSize.jpg/" alt="Constant Physical Size" /></p>

<ul>
  <li>UI元素在物理尺寸上保持不变（以英寸、毫米为单位），无论屏幕分辨率如何变化</li>
  <li>依赖设备DPI（屏幕像素密度），适用于对物理尺寸有要求的UI</li>
</ul>

<p>参数：</p>
<ul>
  <li>Physical Unit：物理单位，告诉Unity希望使用哪种单位作为UI元素的尺寸基准
可选项：
    <ul>
      <li>Points</li>
      <li>Pixels</li>
      <li>Millimeters</li>
      <li>Centimeters</li>
      <li>Inches</li>
    </ul>
  </li>
  <li>Fallback Screen DPI：当Unity无法获取当前设备的DPI时，就会使用这个值来代替实际DPI</li>
  <li>Default Sprite DPI：控制UI中Sprite贴图的物理尺寸缩放基准</li>
</ul>

<h3 id="graphic-raycaster">Graphic Raycaster</h3>
<p>在屏幕空间内把点击（Pointer）或触摸事件，转换成UI元素的响应事件</p>

<p>面板属性：</p>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Ignore Reversed Graphics</strong></td>
      <td>是否忽略背面 UI 图形（比如被旋转了 180° 的 UI 元素）</td>
    </tr>
    <tr>
      <td><strong>Blocking Objects</strong></td>
      <td>控制是否允许 3D/2D 物体阻挡 UI 点击（比如 3D 模型挡住了按钮）</td>
    </tr>
    <tr>
      <td><strong>Blocking Mask</strong></td>
      <td>用于限制哪些 Layer 的物体会阻挡 UI 射线</td>
    </tr>
  </tbody>
</table>

<h4 id="工作原理ui射线检测">工作原理：UI射线检测</h4>
<p>当你点击屏幕时，Unity的Event System会：</p>
<ul>
  <li>发出一条射线（Ray）</li>
  <li>交给<code class="language-plaintext highlighter-rouge">Grphic Raycaster</code></li>
  <li><code class="language-plaintext highlighter-rouge">Graphic Raycaster</code>会检测这条射线是否与某些UI元素相交</li>
  <li>若相交，就触发这些元素的<code class="language-plaintext highlighter-rouge">OnPointerClick()</code>、<code class="language-plaintext highlighter-rouge">OnPointerDown()</code>、<code class="language-plaintext highlighter-rouge">OnDrag()</code>等事件</li>
</ul>

<p>要让Graphic Paycaster正常工作，必须保证：</p>
<ul>
  <li>Canvas上挂了<code class="language-plaintext highlighter-rouge">Graphic Raycaster</code></li>
  <li>场景中有一个<code class="language-plaintext highlighter-rouge">Event System</code></li>
  <li>UI元素上有<code class="language-plaintext highlighter-rouge">Graphic</code>组件（如<code class="language-plaintext highlighter-rouge">Image</code>、<code class="language-plaintext highlighter-rouge">Text</code>，才能被Raycaster检测到）</li>
  <li>UI元素有<code class="language-plaintext highlighter-rouge">Raycast Target</code>为勾选状态</li>
  <li>没有被<code class="language-plaintext highlighter-rouge">Canvas Group</code>阻挡（其<code class="language-plaintext highlighter-rouge">Blocks Raycasts</code>属性必须为true）</li>
</ul>

<h3 id="canvas-group">Canvas Group</h3>

<p><img src="/assets/images/CanvasGroupPanel.jpg/" alt="CanvasGroupPanel" /></p>

<p>控制一组UI元素的整体透明度、交互性和射线响应<br />
用它可以实现：</p>
<ul>
  <li>一整个面板淡入淡出</li>
  <li>临时禁用一组按钮</li>
  <li>某些UI遮罩区域不响应点击</li>
</ul>

<h4 id="属性">属性</h4>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Alpha</strong></td>
      <td><code class="language-plaintext highlighter-rouge">float</code> (0 ~ 1)</td>
      <td>控制透明度，0 = 全透明，1 = 不透明。会影响 <strong>UI 的视觉透明</strong> 和 <strong>交互性（如果 Block Raycasts = true）</strong></td>
    </tr>
    <tr>
      <td><strong>Interactable</strong></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否允许子元素响应交互事件（如点击 Button）</td>
    </tr>
    <tr>
      <td><strong>Blocks Raycasts</strong></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否拦截 UI 射线，决定子元素是否能被点击、拖动等</td>
    </tr>
    <tr>
      <td><strong>Ignore Parent Groups</strong></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否忽略父级 Canvas Group 的控制（<strong>重要属性</strong>）</td>
    </tr>
  </tbody>
</table>

<h3 id="canvas的层级关系">Canvas的层级关系</h3>
<p>Unity允许UI层级中存在多个Canvas组件，这时，Canvas本身就能作为字节点存在，形成嵌套结构</p>

<ul>
  <li>子Canvas布置主Canvas的一部分，它是一个“独立渲染单元”</li>
  <li>每个Canvas都是一个独立的渲染批次（Draw Call）</li>
  <li>子Canvas不会因为父Canvas中其他UI元素变化而重绘，反之亦然</li>
</ul>

<h4 id="为什么要用子canvas">为什么要用子Canvas</h4>
<p>子Canvas主要用于优化性能和分离逻辑</p>

<h5 id="性能优化">性能优化</h5>
<blockquote>
  <p>如果你有一个排行榜界面，只有当排行榜打开时才需要刷新内容，其他UI不变，这可以这样：</p>
  <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">Canvas</span><span class="o">(</span><span class="nt">主UI</span><span class="o">)</span>
<span class="o">|</span><span class="err">——</span><span class="nt">背景UI</span><span class="o">(</span><span class="nt">静态</span><span class="o">)</span>
<span class="o">|</span><span class="err">——</span><span class="nt">Canvas</span><span class="o">(</span><span class="nt">排行榜</span><span class="o">)</span> <span class="o">&lt;</span><span class="nt">-</span> <span class="nt">单独Canvas</span><span class="err">，</span><span class="nt">打开时才激活和更新</span>
</code></pre></div>  </div>
  <p>这样排行榜刷新不会引起整个主UI Canvas的重建批次</p>
</blockquote>

<h5 id="ui分区逻辑清晰">UI分区逻辑清晰</h5>
<blockquote>
  <p>把HUD、弹窗、系统提示各放到子Canvas中，方便管理和控制层级、显隐、动画等</p>
</blockquote>

<h4 id="父子canvas的排序--显示顺序">父子Canvas的排序 &amp; 显示顺序</h4>
<h5 id="排序层控制sorting-layer--order-in-layer">排序层控制（Sorting Layer + Order in Layer）</h5>
<p>每个Canvas都有：</p>
<ul>
  <li>Sorting Layer（图层）</li>
  <li>Order in Layer（在该图层的顺序）
这两个参数决定Canvas之间的渲染先后顺序，数值越高越在前，越晚渲染
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">Canvas HUD(Sorting Layer</span><span class="pi">:</span> <span class="s">UI, Order</span><span class="err">:</span> <span class="s">0)</span>
<span class="na">Canvas Popup(Sorting Layer</span><span class="pi">:</span> <span class="s">UI, Order</span><span class="err">:</span> <span class="s">10)</span>
</code></pre></div>    </div>
    <p>Popup会在HUD上方显示，即使它是子物体也一样</p>
  </li>
</ul>

<h4 id="recttransform父子关系的影响">RectTransform父子关系的影响</h4>
<ul>
  <li>子UI元素会继承父节点的位置、旋转、缩放等变换</li>
  <li>子UI的位置是相对于父节点的（本地坐标）</li>
  <li>适用于做面板嵌套、按钮列表、滑动区域等结构</li>
</ul>

<h3 id="canvas性能">Canvas性能</h3>
<ul>
  <li>尽量减少Canvas数量，因为每个Canvas都是单独的渲染批次</li>
  <li>将频繁变动的UI元素放到单独的Canvas，避免整个UI重绘</li>
  <li>使用Canvas Group控制UI整体显示和透明度，可以减少重绘</li>
  <li>关闭不需要显示的UI，避免额外渲染</li>
</ul>

<h3 id="canvas-api">Canvas API</h3>
<h4 id="properties">Properties</h4>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>说明</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">renderMode</code></td>
      <td><code class="language-plaintext highlighter-rouge">RenderMode</code></td>
      <td>渲染模式（Overlay、ScreenSpaceCamera、WorldSpace）</td>
      <td>决定Canvas如何渲染和视图方式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">worldCamera</code></td>
      <td><code class="language-plaintext highlighter-rouge">Camera</code></td>
      <td>渲染用摄像机（适用于 Camera、World 模式）</td>
      <td>控制UI投射方向、接收事件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pixelPerfect</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否启用像素完美对齐（仅限Screen Space）</td>
      <td>像素风格游戏的UI清晰对齐</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">planeDistance</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>距摄像机的距离（仅Screen Space - Camera）</td>
      <td>控制Canvas深度层级</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">scaleFactor</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>缩放因子（通常由 CanvasScaler 控制）</td>
      <td>适配不同分辨率</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">referencePixelsPerUnit</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>每单位像素数，决定图像缩放清晰度</td>
      <td>确保 UI 图像缩放一致</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sortingLayerID</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>渲染图层 ID</td>
      <td>控制 Canvas 渲染层</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sortingLayerName</code></td>
      <td><code class="language-plaintext highlighter-rouge">string</code></td>
      <td>渲染图层名称</td>
      <td>可读性更强的层级控制</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sortingOrder</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>同图层中的渲染顺序，越大越前面</td>
      <td>控制 UI 显示前后关系</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">overrideSorting</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否覆盖父 Canvas 的排序逻辑</td>
      <td>弹窗、特效UI 的独立排序</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">targetDisplay</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>目标显示屏幕编号（用于多显示器）</td>
      <td>多屏幕UI部署</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isRootCanvas</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code> (只读)</td>
      <td>是否为根 Canvas</td>
      <td>判断是否主 Canvas（用于布局判断）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rootCanvas</code></td>
      <td><code class="language-plaintext highlighter-rouge">Canvas</code> (只读)</td>
      <td>所属的顶级 Canvas</td>
      <td>获取当前 Canvas 的上级主容器</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">renderOrder</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code> (只读)</td>
      <td>实际渲染顺序（自动计算）</td>
      <td>调试 Canvas 渲染先后</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pixelRect</code></td>
      <td><code class="language-plaintext highlighter-rouge">Rect</code> (只读)</td>
      <td>当前 Canvas 实际的像素渲染区域</td>
      <td>渲染区域调试</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">renderingDisplaySize</code></td>
      <td><code class="language-plaintext highlighter-rouge">Vector2</code> (只读)</td>
      <td>渲染显示区域的像素尺寸</td>
      <td>获取目标显示区域尺寸</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">overridePixelPerfect</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否允许覆盖父Canvas的像素对齐设置</td>
      <td>子 Canvas 不启用像素对齐时用</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">additionalShaderChannels</code></td>
      <td><code class="language-plaintext highlighter-rouge">AdditionalShaderChannels</code></td>
      <td>指定额外的 shader 顶点数据传输通道</td>
      <td>用于自定义UI Shader</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cachedSortingLayerValue</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code> (只读)</td>
      <td>当前排序图层的底层缓存值，用于排序计算</td>
      <td>系统内部优化（一般不手动使用）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">normalizedSortingGridSize</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>Canvas 分割的排序网格单元大小</td>
      <td>高阶排序控制，与 SRP 结合使用</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">updateRectTransformForStandalone</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>在手动 <code class="language-plaintext highlighter-rouge">Camera.Render()</code> 时是否自动更新 RectTransform</td>
      <td>手动渲染UI场景</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">vertexColorAlwaysGammaSpace</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>在使用线性空间渲染时是否强制顶点颜色使用 Gamma 空间传递</td>
      <td>确保 UI 颜色一致性（线性渲染）</td>
    </tr>
  </tbody>
</table>

<h4 id="static-method">Static Method</h4>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>返回类型</th>
      <th>描述</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Canvas.ForceUpdateCanvases()</code></td>
      <td><code class="language-plaintext highlighter-rouge">void</code></td>
      <td><strong>强制更新所有 Canvas</strong> 的布局和绘制内容</td>
      <td>用于在下一帧前立即刷新 UI 状态（比如修改布局元素后）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Canvas.GetDefaultCanvasMaterial()</code></td>
      <td><code class="language-plaintext highlighter-rouge">Material</code></td>
      <td>返回一个<strong>默认 Canvas 材质</strong>，用于普通 UI 元素的渲染</td>
      <td>如果需要自定义绘制或替换默认材质时使用</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Canvas.GetETC1SupportedCanvasMaterial()</code></td>
      <td><code class="language-plaintext highlighter-rouge">Material</code></td>
      <td>获取或生成支持 <strong>ETC1 格式贴图的 UI 材质</strong>（主要用于 Android）</td>
      <td>在使用 ETC1 压缩纹理时提供透明通道支持（Alpha 拆分）</td>
    </tr>
  </tbody>
</table>

<h4 id="events">Events</h4>

<table>
  <thead>
    <tr>
      <th>事件名</th>
      <th>调用时机</th>
      <th>描述</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">preWillRenderCanvases</code></td>
      <td><strong>Canvas 渲染前，最先调用</strong></td>
      <td>在 Canvas 渲染流程开始前立即触发（早于布局和绘制）</td>
      <td>在渲染前动态调整 UI 布局、刷新数据</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">willRenderCanvases</code></td>
      <td><strong>Canvas 渲染前，紧接上一步</strong></td>
      <td>在 Canvas 渲染流程开始前触发，但晚于 <code class="language-plaintext highlighter-rouge">preWillRenderCanvases</code></td>
      <td>绑定动画播放、状态更新逻辑、依赖布局结果的修改操作</td>
    </tr>
  </tbody>
</table>

<h5 id="事件区别和调用顺序">事件区别和调用顺序</h5>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Canvas</span><span class="p">.</span><span class="n">preWillRederCanvases</span> <span class="p">-&gt;</span> <span class="n">Canvas</span><span class="p">.</span><span class="n">willRenderCanvases</span> <span class="p">-&gt;</span> <span class="n">Canvas</span> <span class="err">渲染</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">preWilldRenderCanvases</code>：在所有布局系统更新之前调用，用于准备UI状态、尺寸、数据等</li>
  <li><code class="language-plaintext highlighter-rouge">willRenderCanvases</code>：在布局完成后、渲染开始前调用，适合根据最终布局做动画、视觉状态处理</li>
</ul>

<p><a href="https://docs.unity3d.com/ScriptReference/Canvas.html">UnityScripting Canvas</a></p>

<h2 id="ui-componenet">UI Componenet</h2>
<h3 id="通用组件">通用组件</h3>
<p><img src="/assets/images/UI-CommonComponent.jpg" alt="UICommonComponent" /></p>
<h4 id="rect-transform">Rect Transform</h4>
<p><code class="language-plaintext highlighter-rouge">RectTransform</code>继承自<code class="language-plaintext highlighter-rouge">Transform</code>，专门用于2D UI布局。<br />
所有UI元素都依赖<code class="language-plaintext highlighter-rouge">RectTransform</code>来定位和缩放</p>

<h5 id="核心属性">核心属性</h5>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchorMin</code></td>
      <td>Vector2</td>
      <td>锚点区域左下角（归一化坐标，0~1）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchorMax</code></td>
      <td>Vector2</td>
      <td>锚点区域右上角</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchoredPosition</code></td>
      <td>Vector2</td>
      <td>相对于锚点区域中心的偏移量</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pivot</code></td>
      <td>Vector2</td>
      <td>本地坐标的参考中心（范围 0~1）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sizeDelta</code></td>
      <td>Vector2</td>
      <td>元素宽高，或拉伸模式下的偏移</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rect</code></td>
      <td>Rect (只读)</td>
      <td>实际的矩形框（位置、宽高）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">localPosition</code></td>
      <td>Vector3</td>
      <td>相对于父节点的本地坐标（不推荐直接用于 UI）</td>
    </tr>
  </tbody>
</table>

<h5 id="anchor">Anchor</h5>
<p>Anchor（锚点）是<code class="language-plaintext highlighter-rouge">RectTransform</code>的关键组成部分，决定了UI元素相对于父物体的位置和尺寸的参考点</p>

<p>Anchor实际上是一对二维坐标：<code class="language-plaintext highlighter-rouge">anchorMin</code>和<code class="language-plaintext highlighter-rouge">anchorMax</code>，每个值都是<code class="language-plaintext highlighter-rouge">[0, 1]</code>范围内归一化坐标，表示在父元素矩形中的相对位置</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">anchorMin = (0, 0)</code>表示父物体的左下角</li>
  <li><code class="language-plaintext highlighter-rouge">anchorMax = (1, 1)</code>表示父物体的右上角</li>
</ul>

<p><strong>锚点的几种模式</strong>
1.固定位置（不拉伸）<br />
当：<code class="language-plaintext highlighter-rouge">anchorMin</code> = <code class="language-plaintext highlighter-rouge">anchorMax</code></p>
<ul>
  <li>元素位置相对于这个锚点点位</li>
  <li>用<code class="language-plaintext highlighter-rouge">anchoredPosition</code>来控制偏移</li>
  <li>常用于角落按钮、图标等</li>
</ul>

<p>2.拉伸尺寸（适应父物体）
当：<code class="language-plaintext highlighter-rouge">anchorMin</code> != <code class="language-plaintext highlighter-rouge">anchorMax</code></p>
<ul>
  <li>元素会随着父容器的尺寸变化而拉伸</li>
  <li><code class="language-plaintext highlighter-rouge">sizeDelta</code>不是绝对宽高，而是拉伸结果的偏移</li>
</ul>

<h5 id="pivot">Pivot</h5>
<p>pivot（枢轴点）定义的是UI元素自身的参考点（中心点），它决定了：</p>
<ul>
  <li>元素的位置是以自身哪个位置为参考（锚点对齐）</li>
  <li>元素在旋转时围绕哪里旋转</li>
  <li>元素在缩放时以哪个点为中心缩放</li>
</ul>

<p>它的值是一个二维向量，范围在<code class="language-plaintext highlighter-rouge">[0, 1]</code>之间，表示相对于自身矩形的位置：</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">pivot</code> 值</th>
      <th>位置说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>(0, 0)</td>
      <td>左下角</td>
    </tr>
    <tr>
      <td>(0.5, 0.5)</td>
      <td>中心（默认）</td>
    </tr>
    <tr>
      <td>(1, 1)</td>
      <td>右上角</td>
    </tr>
    <tr>
      <td>(0, 1)</td>
      <td>左上角</td>
    </tr>
    <tr>
      <td>(1, 0)</td>
      <td>右下角</td>
    </tr>
  </tbody>
</table>

<h4 id="布局">布局</h4>
<p><strong>布局演示</strong>
假设Canvas是1920*1080的全屏UI</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RectTransform</span> <span class="n">rt</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">RectTransform</span><span class="p">&gt;();</span>

<span class="n">rt</span><span class="p">.</span><span class="n">anchorMin</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0.5f</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">);</span>
<span class="n">rt</span><span class="p">.</span><span class="n">anchorMax</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0.5f</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">);</span>
<span class="n">rt</span><span class="p">.</span><span class="n">pivot</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0.5f</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">);</span>
<span class="n">rt</span><span class="p">.</span><span class="n">anchoredPosition</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
<span class="n">rt</span><span class="p">.</span><span class="n">sizeDelta</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">200</span><span class="p">,</span> <span class="m">100</span><span class="p">);</span>
</code></pre></div></div>
<p>这个UI元素将被放置在屏幕正中央，宽度为200，高度为100</p>

<h5 id="坐标系层级关系">坐标系层级关系</h5>
<p>1.<code class="language-plaintext highlighter-rouge">anchorMin</code> / <code class="language-plaintext highlighter-rouge">anchorMax</code>决定锚点区域</p>

<p>2.<code class="language-plaintext highlighter-rouge">anchoredPosition</code>是相对于锚点区域的中心</p>

<p>3.<code class="language-plaintext highlighter-rouge">pivot</code>是UI元素自身的中心点</p>

<p>4.最终位置由这些共同计算得到</p>

<p><strong>实际计算公式（简化版）</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>最终位置 = 锚点区域中心 + anchoredPosition - pivot * sizeDelta
</code></pre></div></div>
<p>这个公式说明了设置的位置不是直接坐标，而是围绕锚点和pivot共同计算的结果</p>

<p><img src="/assets/images/AnchorPresets.jpg" alt="AnchorPreSets" /></p>

<ul>
  <li>按住Alt + Shift拖动可以同时设置pivot和anchor</li>
  <li>Unity提供Anchor Preset快速布局</li>
  <li>蓝线表示Anchors，红点表示Pivot，灰框表示实际UI区域</li>
</ul>

<h5 id="recttransform-api">RectTransform API</h5>
<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchoredPosition</code></td>
      <td>相对于锚点参考位置的<strong>二维坐标</strong>，表示此 <code class="language-plaintext highlighter-rouge">RectTransform</code> 的<strong>pivot（枢轴点）</strong>的位置。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchoredPosition3D</code></td>
      <td>相对于锚点参考位置的<strong>三维坐标</strong>，主要用于支持 Z 轴（例如 3D UI 或特殊布局需求）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchorMax</code></td>
      <td>右上角锚点在父 <code class="language-plaintext highlighter-rouge">RectTransform</code> 中的<strong>归一化坐标</strong>（范围 0~1），例如 (1,1) 表示父物体的右上角。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchorMin</code></td>
      <td>左下角锚点在父 <code class="language-plaintext highlighter-rouge">RectTransform</code> 中的<strong>归一化坐标</strong>，例如 (0,0) 表示父物体的左下角。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">drivenByObject</code></td>
      <td>如果该 <code class="language-plaintext highlighter-rouge">RectTransform</code> 的属性被其他对象驱动（如 Layout 组件），会显示驱动它的对象；否则为 <code class="language-plaintext highlighter-rouge">null</code>。常用于调试自动布局。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">offsetMax</code></td>
      <td>当前矩形右上角相对于右上锚点的偏移值（本地坐标）。可以理解为 <code class="language-plaintext highlighter-rouge">Top</code> 和 <code class="language-plaintext highlighter-rouge">Right</code> 的偏移。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">offsetMin</code></td>
      <td>当前矩形左下角相对于左下锚点的偏移值。可以理解为 <code class="language-plaintext highlighter-rouge">Left</code> 和 <code class="language-plaintext highlighter-rouge">Bottom</code> 的偏移。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pivot</code></td>
      <td>当前 <code class="language-plaintext highlighter-rouge">RectTransform</code> 的<strong>枢轴点</strong>，用归一化坐标表示 (0~1)，如 (0.5, 0.5) 表示中心点，(0, 0) 表示左下角。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rect</code></td>
      <td>在本地坐标系下计算出的实际矩形区域，是一个 <code class="language-plaintext highlighter-rouge">Rect</code> 结构体（包含 x, y, width, height）。只读属性。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sizeDelta</code></td>
      <td>表示当前矩形的宽高 <strong>相对于 anchor 之间距离的增量值</strong>。如果 anchorMin 和 anchorMax 相同，则这个值就是最终尺寸。</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Method</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ForceUpdateRectTransforms()</code></td>
      <td>强制重新计算 <code class="language-plaintext highlighter-rouge">RectTransform</code> 的内部数据（通常在布局改变后使用，用来立即更新布局）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetLocalCorners(Vector3[] fourCornersArray)</code></td>
      <td>获取该 <code class="language-plaintext highlighter-rouge">RectTransform</code> 在本地空间中的四个角的坐标，按顺序为：左下、左上、右上、右下。结果会填充到传入的 <code class="language-plaintext highlighter-rouge">Vector3[4]</code> 数组中。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetWorldCorners(Vector3[] fourCornersArray)</code></td>
      <td>获取该 <code class="language-plaintext highlighter-rouge">RectTransform</code> 在<strong>世界空间</strong>中的四个角的坐标（顺序同上）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetInsetAndSizeFromParentEdge(RectTransform.Edge edge, float inset, float size)</code></td>
      <td>以父物体的某条边为参考，设置当前 <code class="language-plaintext highlighter-rouge">RectTransform</code> 距离该边的<strong>偏移值（inset）</strong>和自身的<strong>尺寸（size）</strong>。适用于锚点固定在某一边的场景。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetSizeWithCurrentAnchors(RectTransform.Axis axis, float size)</code></td>
      <td>在指定轴（水平或垂直）上，按照当前锚点设置矩形大小。它会考虑锚点之间的拉伸距离，<strong>相对于锚点调整 sizeDelta</strong>。</td>
    </tr>
  </tbody>
</table>

<p><strong>Event</strong></p>

<table>
  <thead>
    <tr>
      <th>事件</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">reapplyDrivenProperties</code></td>
      <td>当一个 <code class="language-plaintext highlighter-rouge">RectTransform</code> 的某些属性（由外部系统如 Layout、Animation 或代码控制）需要被重新应用时触发的事件。开发者可以订阅这个事件来自定义处理逻辑。</td>
    </tr>
  </tbody>
</table>

<p><strong>Delegate</strong></p>

<table>
  <thead>
    <tr>
      <th>委托</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReapplyDrivenProperties</code></td>
      <td>用于 <code class="language-plaintext highlighter-rouge">RectTransform.reapplyDrivenProperties</code> 事件的委托类型，定义了事件回调的签名。</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.unity3d.com/ScriptReference/RectTransform.html">UnityScripting RectTransform</a></p>

<h4 id="canvas-renderer">Canvas Renderer</h4>
<p><code class="language-plaintext highlighter-rouge">CanvasRenderer</code>是Unity UI系统中挂在每个可见UI上的一个底层组件，负责UI的绘制提交，它是Graphic类的渲染后台</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">CanvasRenderer</code>是连接UI元素和底层渲染管线的桥梁</p>
</blockquote>

<h5 id="canvasrenderer的作用">CanvasRenderer的作用</h5>

<table>
  <thead>
    <tr>
      <th>功能方向</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>渲染控制</td>
      <td>负责把 UI 元素的顶点数据、颜色、材质提交给 Canvas 系统渲染</td>
    </tr>
    <tr>
      <td>可见性控制</td>
      <td>控制是否显示（通过 <code class="language-plaintext highlighter-rouge">cull</code>, <code class="language-plaintext highlighter-rouge">SetAlpha</code>, <code class="language-plaintext highlighter-rouge">SetColor</code> 等）</td>
    </tr>
    <tr>
      <td>材质支持</td>
      <td>支持单个或多个材质绘制（比如 <code class="language-plaintext highlighter-rouge">SetMaterial</code>, <code class="language-plaintext highlighter-rouge">SetPopMaterial</code>）</td>
    </tr>
    <tr>
      <td>顶点缓存</td>
      <td>维护每个 UI 元素的 Mesh 数据</td>
    </tr>
    <tr>
      <td>Mask 支持</td>
      <td>与 UI Mask 系统配合使用进行遮罩裁剪处理</td>
    </tr>
  </tbody>
</table>

<h5 id="canvasrenderer和ui的绘制流程">CanvasRenderer和UI的绘制流程</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UI组件（Image/Text 等）
    ↓
生成顶点、UV、颜色等数据
    ↓
传给 CanvasRenderer
    ↓
CanvasRenderer 将数据提交给 Canvas 系统
    ↓
Canvas 系统统一批处理渲染
</code></pre></div></div>

<h5 id="canvasrenderer-api">CanvasRenderer API</h5>

<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>含义</th>
      <th>用途/说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">absoluteDepth</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>相对于<strong>根 Canvas 的深度值</strong></td>
      <td>用于判断当前 UI 元素在整个 UI 渲染中的层级。数值越大，越“靠上”渲染。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">relativeDepth</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>相对于<strong>父 Canvas 的深度值</strong></td>
      <td>可用于局部 Canvas 中排序。配合 <code class="language-plaintext highlighter-rouge">absoluteDepth</code> 理解 UI 层级渲染顺序。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">materialCount</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>当前可用于渲染的<strong>材质数量</strong></td>
      <td>用于分配和管理 UI 材质。你可以通过 <code class="language-plaintext highlighter-rouge">SetMaterial()</code> 为每个 index 设置材质。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">popMaterialCount</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>内部用于 Mask（遮罩）的材质数量</td>
      <td>这个通常配合 UI Masking 使用（如 <code class="language-plaintext highlighter-rouge">Image.maskable = true</code>）。设置 <code class="language-plaintext highlighter-rouge">PopMaterial</code> 用于控制遮罩剥离行为。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hasPopInstruction</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否启用了 “渲染堆栈 pop draw call”</td>
      <td>和 <code class="language-plaintext highlighter-rouge">PopMaterial</code> 有关。你可以开启它来显式控制何时 pop 遮罩渲染状态。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hasMoved</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>如果 UI 位置发生变更，则为 <code class="language-plaintext highlighter-rouge">true</code></td>
      <td>用于判断当前帧是否需要重新生成 UI 顶点几何。优化 UI 刷新频率用。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cull</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否<strong>剔除</strong>当前元素</td>
      <td>设置为 <code class="language-plaintext highlighter-rouge">true</code> 时，这个元素不再渲染（即使它可见）。用于节省性能。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cullTransparentMesh</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>如果顶点颜色 alpha 接近 0，是否剔除渲染</td>
      <td>用于透明 UI 元素的剔除优化。默认为 <code class="language-plaintext highlighter-rouge">true</code>，避免无意义绘制。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hasRectClipping</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否启用了矩形剪裁区域</td>
      <td>是否启用了 <code class="language-plaintext highlighter-rouge">EnableRectClipping(Rect)</code>。常用于 <code class="language-plaintext highlighter-rouge">ScrollRect</code> 中的裁剪效果。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">clippingSoftness</code></td>
      <td><code class="language-plaintext highlighter-rouge">Vector2</code></td>
      <td>设置裁剪的“软边缘”范围</td>
      <td>使裁剪边缘变得平滑渐变，不是硬切。单位像素值，适合美术优化。</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Method</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>中文解释</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">Clear()</code></strong></td>
      <td>清除所有缓存的顶点数据</td>
      <td>自定义 UI 元素重绘前清空数据</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">DisableRectClipping()</code></strong></td>
      <td>关闭矩形裁剪区域</td>
      <td>让 UI 元素可以渲染到全屏（常见于浮动 UI）</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">EnableRectClipping(Rect rect)</code></strong></td>
      <td>启用矩形裁剪区域，只显示 <code class="language-plaintext highlighter-rouge">rect</code> 内内容</td>
      <td>用于 <code class="language-plaintext highlighter-rouge">ScrollRect</code> 滚动列表裁剪或自定义遮罩逻辑</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetAlpha()</code></strong></td>
      <td>获取当前的透明度值</td>
      <td>判断当前透明度状态，常用于动画/过渡控制</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetColor()</code></strong></td>
      <td>获取当前设置的颜色</td>
      <td>一般配合 <code class="language-plaintext highlighter-rouge">SetColor</code> 使用，读取当前 UI 颜色</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetInheritedAlpha()</code></strong></td>
      <td>获取包括所有父级 CanvasGroup 的总 alpha 值</td>
      <td>透明度层级继承计算，适合判断是否实际可见</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetMaterial(int index)</code></strong></td>
      <td>获取某个索引的材质</td>
      <td>适合高级渲染管理，如多 Pass 材质</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetPopMaterial(int index)</code></strong></td>
      <td>获取 Pop 材质（用于 UI 遮罩的反向操作）</td>
      <td>用于 UI Mask / Stencil Buffer 中的剪裁恢复逻辑</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetMesh()</code></strong></td>
      <td>获取当前用于渲染的 Mesh</td>
      <td>常用于自定义绘制调试和顶点处理</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetSecondaryTexture(int index)</code></strong></td>
      <td>获取指定索引的第二纹理</td>
      <td>用于多纹理 UI Shader，例如溶解图、遮罩图</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetSecondaryTextureCount()</code></strong></td>
      <td>获取当前可用第二纹理数量</td>
      <td>用于管理复杂 Shader UI 结构</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetSecondaryTextureName(int index)</code></strong></td>
      <td>获取指定索引的 Shader 属性名</td>
      <td>获取传入的纹理对应的 <code class="language-plaintext highlighter-rouge">_SomeTexName</code></td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetAlpha(float alpha)</code></strong></td>
      <td>设置透明度，会与 <code class="language-plaintext highlighter-rouge">UIVertex alpha</code> 和 <code class="language-plaintext highlighter-rouge">Canvas alpha</code> 相乘</td>
      <td>快速设置 UI 淡入淡出、不透明状态等</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetAlphaTexture(Texture tex)</code></strong></td>
      <td>将 <code class="language-plaintext highlighter-rouge">_AlphaTex</code> 指定为某个纹理，传给 Shader</td>
      <td>适用于字体抗锯齿、自定义透明纹理渲染</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetColor(Color color)</code></strong></td>
      <td>设置颜色，会与 <code class="language-plaintext highlighter-rouge">UIVertex.color</code> 和 <code class="language-plaintext highlighter-rouge">Canvas.color</code> 混合</td>
      <td>比如红色血条：<code class="language-plaintext highlighter-rouge">SetColor(Color.red)</code></td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetMaterial(Material mat, int index)</code></strong></td>
      <td>为指定索引设置材质</td>
      <td>UI Shader 控制，如多 pass 渲染、特效图层等</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetPopMaterial(Material mat, int index)</code></strong></td>
      <td>设置 Pop 材质（内部用于 Mask 反剪裁）</td>
      <td>控制遮罩关闭后的恢复材质</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetMesh(Mesh mesh)</code></strong></td>
      <td>设置渲染用的 Mesh，Mesh 必须启用读写</td>
      <td>你可以自定义顶点图形绘制复杂 UI</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetSecondaryTextureCount(int count)</code></strong></td>
      <td>设置可用第二纹理数量</td>
      <td>Shader 中有多个纹理输入时要提前设置</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetSecondaryTexture(int index, string shaderProp, Texture tex)</code></strong></td>
      <td>设置指定索引的纹理及其 Shader 属性名</td>
      <td>给 UI Shader 传多个纹理，如 <code class="language-plaintext highlighter-rouge">_MaskTex</code>, <code class="language-plaintext highlighter-rouge">_NoiseTex</code></td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetTexture(Texture tex)</code></strong></td>
      <td>设置用于 UI 材质中的主纹理</td>
      <td>相当于设定 Shader 的 <code class="language-plaintext highlighter-rouge">_MainTex</code>，适用于 <code class="language-plaintext highlighter-rouge">Image</code> 或 <code class="language-plaintext highlighter-rouge">RawImage</code> 渲染</td>
    </tr>
  </tbody>
</table>

<p><strong>Static Method</strong></p>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>作用</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SplitUIVertexStreams</code></strong></td>
      <td>将 <code class="language-plaintext highlighter-rouge">UIVertex</code> 列表拆分成各个属性数组（位置、颜色、UV、法线、切线）</td>
      <td>修改顶点颜色、UV、法线等时使用</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">AddUIVertexStream</code></strong></td>
      <td>将 <code class="language-plaintext highlighter-rouge">UIVertex</code> 中的数据<strong>添加</strong>到现有的顶点属性列表</td>
      <td>组合多个顶点来源数据，叠加处理</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">CreateUIVertexStream</code></strong></td>
      <td>将单独的顶点属性数组（位置、颜色、UV等）<strong>合成为一个 <code class="language-plaintext highlighter-rouge">UIVertex</code> 流</strong></td>
      <td>自定义 UI 图形顶点数据，如渐变、闪光、圆形 UI 等</td>
    </tr>
  </tbody>
</table>

<p>静态方法参数说明</p>

<table>
  <thead>
    <tr>
      <th>参数名</th>
      <th>类型</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">verts</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;UIVertex&gt;</code></td>
      <td>完整顶点数据流</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">positions</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;Vector3&gt;</code></td>
      <td>每个顶点的位置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">colors</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;Color32&gt;</code></td>
      <td>每个顶点的颜色</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">uv0S</code> / <code class="language-plaintext highlighter-rouge">uv1S</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;Vector4&gt;</code></td>
      <td>UV 坐标（第0、1通道）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">normals</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;Vector3&gt;</code></td>
      <td>法线</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tangents</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;Vector4&gt;</code></td>
      <td>切线，用于光照方向等</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">stream</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;UIVertex&gt;</code></td>
      <td>用于最终生成的合并数据</td>
    </tr>
  </tbody>
</table>

<p><strong>Event</strong></p>

<table>
  <thead>
    <tr>
      <th>事件名</th>
      <th>作用</th>
      <th>使用场景</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">onRequestRebuild</code></strong></td>
      <td><strong>（仅在 Editor 模式下）</strong>当 CanvasRenderer 中的数据无效、需要重建时触发</td>
      <td>编辑器下自定义 UI 编辑、自动刷新组件、响应布局更新等</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.unity3d.com/ScriptReference/CanvasRenderer.html">CanvasRenderer</a></p>

<h4 id="image">Image</h4>
<p>Image用于在<code class="language-plaintext highlighter-rouge">Canvas</code>上渲染2D图像</p>

<h5 id="属性-1">属性</h5>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Source Image</strong></td>
      <td>要显示的图片（Sprite）</td>
    </tr>
    <tr>
      <td><strong>Color</strong></td>
      <td>渲染颜色，会乘上图片原色，可用于变色、淡入淡出</td>
    </tr>
    <tr>
      <td><strong>Material</strong></td>
      <td>自定义渲染材质（通常用于特殊效果，如描边、渐变）</td>
    </tr>
    <tr>
      <td><strong>Raycast Target</strong></td>
      <td>是否响应点击事件（勾选表示能被 <code class="language-plaintext highlighter-rouge">GraphicRaycaster</code> 检测）</td>
    </tr>
    <tr>
      <td><strong>Maskable</strong></td>
      <td>是否允许被遮罩裁剪（勾选表示允许）</td>
    </tr>
  </tbody>
</table>

<p><strong>Image Type</strong></p>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>描述</th>
      <th>用途示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Simple</strong></td>
      <td>直接绘制整张图片</td>
      <td>图标、贴图、UI背景</td>
    </tr>
    <tr>
      <td><strong>Sliced</strong></td>
      <td>使用 9 宫格方式拉伸</td>
      <td>按钮、对话框、面板背景</td>
    </tr>
    <tr>
      <td><strong>Tiled</strong></td>
      <td>将图像平铺（不拉伸）填满区域</td>
      <td>网格背景、重复纹理</td>
    </tr>
    <tr>
      <td><strong>Filled</strong></td>
      <td>根据百分比填充图像</td>
      <td>血条、技能冷却、进度圈</td>
    </tr>
  </tbody>
</table>

<h5 id="image-type-simple">Image Type: Simple</h5>
<ul>
  <li>Use Sprite Mesh
是否使用Sprite导入时生成的精细网格来渲染这张图片
    <ul>
      <li>勾选：使用Sprite的自定义网格（Polygon Mesh）</li>
      <li>取消：使用默认的矩形网格（Quad）</li>
    </ul>
  </li>
  <li>Preserve Aspect
图片在拉伸时是否保持原始宽高比</li>
</ul>

<h5 id="image-type-sliced">Image Type: Sliced</h5>
<ul>
  <li>Fill Center
是否绘制九宫格中间的中心区域（中心填充）
    <ul>
      <li>勾选：中间区域会被绘制，整个九宫格都会显示</li>
      <li>取消：中间区域不会绘制，只绘制九宫格的四个边和四个角， 这样中心部分会变透明，常用于制作空心边框、框线效果</li>
    </ul>
  </li>
  <li>Pixels Per Unit Multiplier
像素与Unity单位之间的转换比例，以调整图片显示的大小，从而不必修改RectTransform大小</li>
</ul>

<h5 id="image-type-tiled">Image Type: Tiled</h5>
<p>同上</p>

<h5 id="image-type-filled">Image Type: Filled</h5>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Fill Method</strong></td>
      <td>填充方式（Horizontal、Vertical、Radial360、Radial180 等）</td>
    </tr>
    <tr>
      <td><strong>Fill Origin</strong></td>
      <td>填充起点（左/右/上/下/中心）</td>
    </tr>
    <tr>
      <td><strong>Fill Amount</strong></td>
      <td>填充比例（0 到 1）</td>
    </tr>
    <tr>
      <td><strong>Clockwise</strong></td>
      <td>是否顺时针填充</td>
    </tr>
  </tbody>
</table>

<h5 id="性能建议">性能建议</h5>

<table>
  <thead>
    <tr>
      <th>建议</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>尽量合批</td>
      <td>使用相同材质和图片可减少 draw call</td>
    </tr>
    <tr>
      <td>禁用 <code class="language-plaintext highlighter-rouge">Raycast Target</code></td>
      <td>如果不需要点击事件，记得取消勾选提高效率</td>
    </tr>
    <tr>
      <td>使用 <code class="language-plaintext highlighter-rouge">Sliced</code></td>
      <td>比 <code class="language-plaintext highlighter-rouge">Simple</code> 更适合可拉伸的 UI 元素，避免失真</td>
    </tr>
    <tr>
      <td>用 <code class="language-plaintext highlighter-rouge">Mask</code> 做裁剪</td>
      <td>可配合小地图/头像/UI 视窗裁剪区域</td>
    </tr>
  </tbody>
</table>

<h5 id="image-api">Image API</h5>

<p><strong>Static Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ussClassName</code></td>
      <td>该类型元素默认的 <strong>USS（Unity Style Sheets）类名</strong>。用于样式表（USS 文件）中选择和定义该类型元素的默认样式。</td>
    </tr>
  </tbody>
</table>

<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">image</code></td>
      <td>要显示的贴图（<code class="language-plaintext highlighter-rouge">Texture</code> 或 <code class="language-plaintext highlighter-rouge">Texture2D</code>）。设置后，<code class="language-plaintext highlighter-rouge">Image</code> 会使用此纹理渲染，控件大小可能自动适应纹理尺寸。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">scaleMode</code></td>
      <td>图片的缩放模式，使用 <code class="language-plaintext highlighter-rouge">ScaleMode</code> 枚举值（如 <code class="language-plaintext highlighter-rouge">StretchToFill</code>, <code class="language-plaintext highlighter-rouge">ScaleAndCrop</code>, <code class="language-plaintext highlighter-rouge">ScaleToFit</code>）控制图片如何适应控件大小。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sourceRect</code></td>
      <td>指定贴图中哪一部分作为源区域显示，使用左上角为参考点的坐标和尺寸（单位为像素）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sprite</code></td>
      <td>显示的精灵（<code class="language-plaintext highlighter-rouge">Sprite</code> 类型）。这是 UI Toolkit 中推荐的图像显示方式，比原始 <code class="language-plaintext highlighter-rouge">Texture</code> 更灵活。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tintColor</code></td>
      <td>渲染图片时使用的着色颜色（默认为白色，设置为其他颜色可以改变图片颜色）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">uv</code></td>
      <td>图片的 UV 坐标范围，基于左下角为原点（通常用于手动设置 UV 区域，控制显示纹理的哪一部分）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">vectorImage</code></td>
      <td>用于显示的矢量图（<code class="language-plaintext highlighter-rouge">VectorImage</code> 类型，SVG 样式的图像）。适合需要分辨率无损缩放的图标或 UI 图案。</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.unity3d.com/ScriptReference/UIElements.Image.html">UnityScrpting Image</a></p>

<h2 id="ui-element">UI Element</h2>
<h3 id="panel">Panel</h3>
<p>Panel是用来组织、分组、控制一组UI元素的容器，是UI架构中最基本的结构单位</p>

<p>本质上是一个普通的<code class="language-plaintext highlighter-rouge">GameObject</code></p>

<blockquote>
  <p>Panel = GameObject + RectTransform + Other Optional Component</p>
</blockquote>

<h4 id="常见用途">常见用途</h4>

<table>
  <thead>
    <tr>
      <th>用途</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>UI 分组容器</strong></td>
      <td>将一组相关的 UI 元素包在一起（如背包、商店、设置等）</td>
    </tr>
    <tr>
      <td><strong>背景视觉层</strong></td>
      <td>给 UI 添加一个背景板（通常使用半透明黑色）</td>
    </tr>
    <tr>
      <td><strong>控制显示/隐藏</strong></td>
      <td>通过 <code class="language-plaintext highlighter-rouge">SetActive()</code> 控制整组 UI 显示与否</td>
    </tr>
    <tr>
      <td><strong>蒙版裁剪</strong></td>
      <td>配合 <code class="language-plaintext highlighter-rouge">Mask</code> 或 <code class="language-plaintext highlighter-rouge">RectMask2D</code> 使用，裁剪子内容</td>
    </tr>
    <tr>
      <td><strong>动画过渡</strong></td>
      <td>面板之间切换时做位移、渐变等 UI 动画</td>
    </tr>
    <tr>
      <td><strong>局部布局控制</strong></td>
      <td>配合 <code class="language-plaintext highlighter-rouge">LayoutGroup</code> 使用，控制子元素的自动排列</td>
    </tr>
  </tbody>
</table>

<h3 id="image-1">Image</h3>
<p>Image = RectTransform + Image<br />
组件Image不能脱离RectTransform和CanvasRenderer<br />
Image组件见上</p>

<h3 id="raw-image">Raw Image</h3>
<p>Raw Image = RectTransform + Canvas Renderer + Raw Image</p>

<p><img src="/assets/images/RawImagePanel.jpg" alt="RawImagePanel" /></p>

<p><code class="language-plaintext highlighter-rouge">Raw Image</code>是Unity UI中用于直接显示<code class="language-plaintext highlighter-rouge">Texture</code>的组件，区别于<code class="language-plaintext highlighter-rouge">Image</code>显示<code class="language-plaintext highlighter-rouge">Sprite</code>，<code class="language-plaintext highlighter-rouge">RawImage</code>更灵活，适合直接显示非Sprite类型的纹理</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RawImage</code>继承自<code class="language-plaintext highlighter-rouge">MaskableGraphic</code>，是一个UI可视化组件</li>
  <li>它直接使用一个<code class="language-plaintext highlighter-rouge">Texture</code>对象进行绘制，而不需要把纹理先转换成<code class="language-plaintext highlighter-rouge">Sprite</code></li>
  <li>适合展示视频帧、RenderTexture、摄像头画面或自定义生成的纹理</li>
</ul>

<h4 id="image-vs-rawimage">Image vs RawImage</h4>

<table>
  <thead>
    <tr>
      <th>方面</th>
      <th>RawImage</th>
      <th>Image</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>显示资源类型</td>
      <td><code class="language-plaintext highlighter-rouge">Texture</code></td>
      <td><code class="language-plaintext highlighter-rouge">Sprite</code></td>
    </tr>
    <tr>
      <td>是否支持 9 切片</td>
      <td>不支持</td>
      <td>支持</td>
    </tr>
    <tr>
      <td>适合用途</td>
      <td>视频播放、动态纹理显示、非 Sprite 纹理</td>
      <td>UI 图标、按钮、九宫格背景</td>
    </tr>
    <tr>
      <td>是否自动处理边缘</td>
      <td>不支持</td>
      <td>支持切片自动拉伸</td>
    </tr>
  </tbody>
</table>

<h3 id="text-legacy">Text-Legacy</h3>
<p>UGUI中最早期的文本显示方式之一，Legacy代表它已经被新的系统所取代，但它依然存在于Unity中，作为一种兼容性方案</p>

<p><img src="/assets/images/TextPanel.jpg" alt="TextPanel" /></p>

<p><code class="language-plaintext highlighter-rouge">Text</code>是Unity UGUI系统（UnityEngine.UI.Text）中的标准UI组件，用来在Canvas上显示简单的2D文本</p>

<h4 id="基本属性">基本属性</h4>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Text</strong></td>
      <td>要显示的字符串</td>
    </tr>
    <tr>
      <td><strong>Font</strong></td>
      <td>使用的字体（<code class="language-plaintext highlighter-rouge">.ttf</code>）资源</td>
    </tr>
    <tr>
      <td><strong>Font Style</strong></td>
      <td>字体样式（Normal / Bold / Italic）</td>
    </tr>
    <tr>
      <td><strong>Font Size</strong></td>
      <td>字号大小（整数）</td>
    </tr>
    <tr>
      <td><strong>Line Spacing</strong></td>
      <td>行间距倍数</td>
    </tr>
    <tr>
      <td><strong>Rich Text</strong></td>
      <td>是否启用 <code class="language-plaintext highlighter-rouge">&lt;b&gt;</code>,<code class="language-plaintext highlighter-rouge">&lt;i&gt;</code> 等富文本语法</td>
    </tr>
    <tr>
      <td><strong>Alignment</strong></td>
      <td>对齐方式（左中右 / 上中下）</td>
    </tr>
    <tr>
      <td><strong>Align By Geometry</strong></td>
      <td>按几何对齐</td>
    </tr>
    <tr>
      <td><strong>Horizontal Overflow</strong></td>
      <td>超出边框时的处理方式（Wrap（换行）/Overflow（溢出）</td>
    </tr>
    <tr>
      <td><strong>Vertical Overflow</strong></td>
      <td>同上，垂直方向 (Truncate/Overflow)</td>
    </tr>
    <tr>
      <td><strong>Best Fit</strong></td>
      <td>是否自动缩放字体以适应文本框大小</td>
    </tr>
    <tr>
      <td><strong>Color</strong></td>
      <td>文本颜色</td>
    </tr>
    <tr>
      <td><strong>Material</strong></td>
      <td>可替换字体材质（如实现描边/阴影）</td>
    </tr>
    <tr>
      <td><strong>Raycast Target</strong></td>
      <td>是否参与事件响应（一般设为 false 提升性能）</td>
    </tr>
    <tr>
      <td><strong>Raycast Padding</strong></td>
      <td>用于扩大或缩小UI元素对射线检测（点击、触摸等交互）的响应区域</td>
    </tr>
    <tr>
      <td><strong>Maskable</strong></td>
      <td>可被遮罩剔除</td>
    </tr>
  </tbody>
</table>

<h4 id="工作流程">工作流程</h4>
<p>Text-Legacy的渲染流程大致如下：</p>
<ul>
  <li>将文本用指定字体转换为字符图形</li>
  <li>用字体的字符图集（Font Atlas）作为纹理采样源</li>
  <li>把这些字母绘制为UI顶点</li>
  <li>通过Canvas Renderer渲染出来</li>
</ul>

<h4 id="text-legacy的缺点">Text-Legacy的缺点</h4>

<table>
  <thead>
    <tr>
      <th>问题</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>清晰度差</td>
      <td>字体在不同分辨率下可能模糊（Bitmap-based）</td>
    </tr>
    <tr>
      <td>无动态字形支持</td>
      <td>不支持多语言自动扩展字体图集</td>
    </tr>
    <tr>
      <td>没有高级排版功能</td>
      <td>不支持富排版、嵌入图标、文本裁剪等高级功能</td>
    </tr>
    <tr>
      <td>不支持富样式</td>
      <td>难以实现多颜色、高级描边、背景等需求</td>
    </tr>
    <tr>
      <td>性能低</td>
      <td>每次修改文本都会重新生成 UI 顶点，占 GC 和 CPU</td>
    </tr>
  </tbody>
</table>

<h4 id="性能提升">性能提升</h4>
<ul>
  <li>使用高质量<code class="language-plaintext highlighter-rouge">.tff</code>字体（防止边缘锯齿）</li>
  <li>打开Best Fit或设置合理的Font Size</li>
  <li>配合Shadow/Outline效果增强可读性</li>
  <li>避免频繁更新文本，防止GC</li>
</ul>

<h2 id="effect">Effect</h2>

<h2 id="layout-system">Layout System</h2>
<h3 id="layout-group">Layout Group</h3>

<h3 id="contentsizefitter">ContentSizeFitter</h3>

<h3 id="aspectratiofitter">AspectRatioFitter</h3>

<h3 id="mask--rectmask2d">Mask / RectMask2D</h3>

<h2 id="draw-call">Draw Call</h2>

<h2 id="unity-ui-tookit">Unity UI Tookit</h2>

<h2 id="event-system">Event System</h2>

<h2 id="ui动画">UI动画</h2>

<h2 id="ui资源管理">UI资源管理</h2>

<h2 id="ui动态生成">UI动态生成</h2>

<h2 id="ui-manager-system">UI Manager System</h2>

<h2 id="ui性能优化">UI性能优化</h2>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-06-01T00:00:00+08:00">June 1, 2025</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/posts/2025-06-07-Joint/" class="pagination--pager" title="Joint">Previous</a>
    
    
      <a href="/posts/2025-06-08-Scene-System/" class="pagination--pager" title="Scene System">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/ljf12825" rel="nofollow noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">ljf12825's Blog</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
