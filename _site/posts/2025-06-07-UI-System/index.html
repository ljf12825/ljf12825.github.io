<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.1 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>UI System - ljf12825’s Blog</title>
<meta name="description" content="Unity UI系统是Unity引擎内置的用于构建用户界面的工具集。它基于Canvas（画布）架构，支持制作按钮、文本、图片、滑动条、输入框等各种交互元素">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="ljf12825's Blog">
<meta property="og:title" content="UI System">
<meta property="og:url" content="http://localhost:4000/posts/2025-06-07-UI-System/">


  <meta property="og:description" content="Unity UI系统是Unity引擎内置的用于构建用户界面的工具集。它基于Canvas（画布）架构，支持制作按钮、文本、图片、滑动条、输入框等各种交互元素">







  <meta property="article:published_time" content="2025-06-01T00:00:00+08:00">






<link rel="canonical" href="http://localhost:4000/posts/2025-06-07-UI-System/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="ljf12825's Blog Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- favicon -->
<link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon">

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          ljf12825's Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Categories</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tags</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="UI System">
    <meta itemprop="description" content="Unity UI系统是Unity引擎内置的用于构建用户界面的工具集。它基于Canvas（画布）架构，支持制作按钮、文本、图片、滑动条、输入框等各种交互元素">
    <meta itemprop="datePublished" content="2025-06-01T00:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/posts/2025-06-07-UI-System/" itemprop="url">UI System
</a>
          </h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>Unity UI系统是Unity引擎内置的用于构建用户界面的工具集。它基于Canvas（画布）架构，支持制作按钮、文本、图片、滑动条、输入框等各种交互元素</p>

<h2 id="ugui和ngui">UGUI和NGUI</h2>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>UGUI（Unity GUI）</th>
      <th>NGUI（Next-Gen UI）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>开发方</td>
      <td>Unity 官方</td>
      <td>第三方（Tasharen Entertainment）</td>
    </tr>
    <tr>
      <td>引入版本</td>
      <td>Unity 4.6+ 内置</td>
      <td>Unity 3.x 时期的主流 UI 插件</td>
    </tr>
    <tr>
      <td>集成性</td>
      <td>原生集成，支持 Canvas、EventSystem、Animation 等</td>
      <td>插件形式，较早期版本需手动集成</td>
    </tr>
    <tr>
      <td>渲染系统</td>
      <td>使用 Unity 内部渲染系统（Canvas）</td>
      <td>自定义渲染系统，Draw Call 优化依赖面板拆分</td>
    </tr>
    <tr>
      <td>编辑器支持</td>
      <td>所见即所得，Scene View 拖拽 UI</td>
      <td>早期需要反复预览，后期版本改善较多</td>
    </tr>
    <tr>
      <td>多分辨率适配</td>
      <td>有自动布局系统、Anchor、RectTransform</td>
      <td>依赖自定义 Anchor 系统</td>
    </tr>
    <tr>
      <td>动画支持</td>
      <td>支持 Unity Animation 和 Animator</td>
      <td>原生支持有限，需自定义组件</td>
    </tr>
    <tr>
      <td>事件系统</td>
      <td>支持原生 EventSystem（点击、拖拽等）</td>
      <td>使用自己的事件系统</td>
    </tr>
    <tr>
      <td>社区和文档</td>
      <td>官方支持，Unity 文档齐全</td>
      <td>社区活跃度下降，文档依赖作者和社区</td>
    </tr>
    <tr>
      <td>性能</td>
      <td>对大型复杂 UI 会产生较多 Draw Call，需要合批优化</td>
      <td>更早期对 Draw Call 优化做得较极致，但维护成本高</td>
    </tr>
    <tr>
      <td>是否推荐使用</td>
      <td>推荐（Unity 官方支持）</td>
      <td>不推荐新项目使用（已过时）</td>
    </tr>
  </tbody>
</table>

<p>NGUI是在Unity官方UI系统还不成熟时的“事实标准”，很多Unity3.x和4.x的项目大量使用<br />
UGUI时Unity官方退出的新UI系统，功能更强大，易于扩展，且原生支持多平台和工具链</p>

<p><img src="/assets/images/CreateUI.jpg" alt="CreateUI" /></p>

<p><a href="https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/index.html">UnityUI2.0.0</a></p>

<h2 id="canvas">Canvas</h2>
<p>Canvas是Unity中所有UI元素的容器，所有UI控件都必须是Canvas的子对象，否则它们不会被渲染成UI</p>

<p><img src="/assets/images/CanvasInspector.jpg" alt="CanvasInspector" /></p>

<h3 id="canvas的渲染模式">Canvas的渲染模式</h3>
<p>Canvas有三种渲染模式，不同模式影响UI的显示方式、渲染顺序以及与摄像机的关系</p>

<h4 id="1screen-space---overlay屏幕空间覆盖">1.Screen Space - Overlay（屏幕空间覆盖）</h4>
<ul>
  <li>这是默认模式</li>
  <li>UI直接渲染在屏幕上，始终覆盖在游戏视图的最上层</li>
  <li>不受任何摄像机影响，不需要摄像机参与渲染</li>
  <li>适合制作固定在屏幕上的HUD、血条、菜单等</li>
  <li>优点：渲染简单，效率高</li>
  <li>缺点：无法与3D世界产生深度关系，UI始终在前面</li>
</ul>

<h4 id="2screen-space---camera屏幕空间摄像机">2.Screen Space - Camera（屏幕空间摄像机）</h4>
<ul>
  <li>UI挂载在指定的摄像机前面</li>
  <li>通过摄像机来渲染UI，UI会与摄像机的视锥和深度产生关系</li>
  <li>允许UI元素首摄像机影响（缩放、视角变化）</li>
  <li>常用于需要与摄像机视角联动的UI，例如放大镜效果、视角内提示等</li>
  <li>可以控制UI的排序顺序（Sorting Layer和Order in Layer）</li>
</ul>

<h4 id="3world-space世界空间">3.World Space（世界空间）</h4>
<ul>
  <li>UI作为3D场景中的普通物体存在</li>
  <li>有自己的位置、旋转、缩放，可以放在场景中任意位置</li>
  <li>通过普通摄像机渲染，能与3D模型、光照等交互</li>
  <li>适合制作3D菜单、游戏内面板、悬浮信息</li>
  <li>需要调整Canvas的大小和UI元素的尺寸，比较复杂</li>
</ul>

<h3 id="canvas组件的重要属性">Canvas组件的重要属性</h3>
<h4 id="screen-space---overlay">Screen Space - Overlay</h4>
<p><img src="/assets/images/Canvas-ScreenSpace-Overlay.jpg" alt="CanvasScreenSpace-Overlay" /></p>

<p>默认模式</p>

<ul>
  <li>Render Mode：渲染模式，见上文</li>
  <li>Pixel Perfect：像素完美，开启后UI元素会对齐到像素点，减少模糊，适合2D像素风UI</li>
  <li>Sort Order：控制UI元素渲染顺序，决定了多个Canvas之间的渲染优先级，数值越大，渲染层级越靠前，会覆盖数值较小的Canvas；数值相同，会根据它们在Hierarchy中的位置决定前后</li>
  <li>Target Display：该Canvas渲染到哪一个物理显示器上，这个功能主要用在多显示器应用中，默认Unity只是用主显示器（Display1），有八个可选项，必须在代码中手动启动多个显示器 <code class="language-plaintext highlighter-rouge">if (Dispaly.display.Length &gt; 1) Display.display[1].Activate();</code>（启用Display 2）</li>
  <li>Additional Shader Channels：用于指定UI顶点需要传递给Shader的额外数据通道
当你使用自定义UI Shader（比如为按钮添加特效、动画、描边等）时，可能需要从UI元素的每个顶点传递一些额外数据（如颜色、UV1、法线、Tangent等）到Shader中。而默认Canvas并不会传递这些数据，只有你在<code class="language-plaintext highlighter-rouge">Additional Shader Channels</code>中显式勾选，Unity才会将这些数据从CPU传给GPU
可选项说明：
    <ul>
      <li>TexCoord1：第二套UV坐标，一些Shader特效可能使用</li>
      <li>TexCoord2：第三套UV坐标</li>
      <li>TexCoord3：第四套UV坐标</li>
      <li>Normal：法线信息（常用于光照Shader）</li>
      <li>Tangent：切线信息（常与法线贴图配合）</li>
      <li>Color：颜色通道（通常UI默认传递的是主颜色）</li>
    </ul>

    <p>Unity的UI是通过<code class="language-plaintext highlighter-rouge">CanvasRenderer</code>生成的顶点数据送入GPU，默认只传position、uv0、color；若Shader需要额外通道，必须通过<code class="language-plaintext highlighter-rouge">Additional Shader Channels</code>显式开启，让<code class="language-plaintext highlighter-rouge">Canvas</code>包装完整数据；但需要注意，勾选越多，传输数据越大，性能开销越大（尤其是在移动端）</p>
  </li>
  <li>Vertex Color Always In Gamma Color Space：控制UI顶点颜色是否始终使用Gamma空间进行处理，无论当前项目是否使用Linear或Gamma颜色空间</li>
</ul>

<h4 id="screen-space---camera">Screen Space - Camera</h4>
<p><img src="/assets/images/Canvas-ScreenSpace-Camera.jpg" alt="CanvasScreenSpace-Camera" /></p>

<ul>
  <li>Render Camera：The Camera whitch will render the canvas. This is also the camera used to send events
A Screen Space Canvas with no specified camera acts like an Overlay Canvas</li>
</ul>

<h4 id="world-space">World Space</h4>
<p><img src="/assets/images/Canvas-WorldSpace.jpg" alt="CanvasWorldSpace" /></p>

<ul>
  <li>Event Camera：用于处理射线点击UI的相机（通常是主摄像机），必须设置，否则点击无效</li>
</ul>

<h3 id="canvasscaler">CanvasScaler</h3>
<p>Canvas通常会搭配CanvasScaler使用，控制UI的缩放和适配，CanvasScaler用于根据不同分辨率、屏幕尺寸，动态调整UI大小，保证UI在不同设备上的一致性</p>

<h4 id="三种缩放模式">三种缩放模式</h4>
<p>1.Constant Pixel Size（固定像素大小）</p>

<p><img src="/assets/images/CanvasScaler-ConstantPixelSize.jpg" alt="Constant Pixel Size" /></p>

<ul>
  <li>UI元素大小固定为设计时的像素值，不会随屏幕尺寸变化缩放</li>
  <li>适合UI对像素精度要求高，不想变形的场景</li>
  <li>缺点：不同分辨率下UI大小不一致，低分辨率屏幕上UI显得很大，高分辨率上显得很小</li>
</ul>

<p>参数：</p>
<ul>
  <li>Scale Factor：控制Canvas上所有UI元素的整体缩放倍数</li>
  <li>Reference Pixels Per Unit：单位像素参考值，决定1个世界单位中包含多少个像素</li>
</ul>

<p>2.Scale With Screen Size（随屏幕尺寸缩放）</p>

<p><img src="/assets/images/CanvasScaler-ScaleWithScreenSize.jpg" alt="Scale With Screen Size" /></p>

<ul>
  <li>根据屏幕分辨率，按比例缩放UI，使得UI在不同分辨率下保持视觉一致</li>
  <li>通过<code class="language-plaintext highlighter-rouge">Reference Resolution</code>设置参考设计分辨率</li>
  <li>通过<code class="language-plaintext highlighter-rouge">Screen Match Mode</code>决定缩放如何适配宽高比
    <ul>
      <li>Match Width Or Height：在宽和高之间插值，<code class="language-plaintext highlighter-rouge">Match</code>属性控制偏重那一边（0为宽，1为高）</li>
      <li>Expand：适配屏幕，保证UI不会裁剪，但可能留空白</li>
      <li>Shrink：保证UI填满屏幕，可能裁剪一部分</li>
    </ul>
  </li>
  <li>这是最常用的模式，推荐用于大多数UI适配</li>
</ul>

<p>3.Constant Physical Size（固定物理大小）</p>

<p><img src="/assets/images/CanvasScaler-ConstantPhysicalSize.jpg" alt="Constant Physical Size" /></p>

<ul>
  <li>UI元素在物理尺寸上保持不变（以英寸、毫米为单位），无论屏幕分辨率如何变化</li>
  <li>依赖设备DPI（屏幕像素密度），适用于对物理尺寸有要求的UI</li>
</ul>

<p>参数：</p>
<ul>
  <li>Physical Unit：物理单位，告诉Unity希望使用哪种单位作为UI元素的尺寸基准
可选项：
    <ul>
      <li>Points</li>
      <li>Pixels</li>
      <li>Millimeters</li>
      <li>Centimeters</li>
      <li>Inches</li>
    </ul>
  </li>
  <li>Fallback Screen DPI：当Unity无法获取当前设备的DPI时，就会使用这个值来代替实际DPI</li>
  <li>Default Sprite DPI：控制UI中Sprite贴图的物理尺寸缩放基准</li>
</ul>

<h3 id="graphic-raycaster">Graphic Raycaster</h3>
<p>在屏幕空间内把点击（Pointer）或触摸事件，转换成UI元素的响应事件</p>

<p>面板属性：</p>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Ignore Reversed Graphics</strong></td>
      <td>是否忽略背面 UI 图形（比如被旋转了 180° 的 UI 元素）</td>
    </tr>
    <tr>
      <td><strong>Blocking Objects</strong></td>
      <td>控制是否允许 3D/2D 物体阻挡 UI 点击（比如 3D 模型挡住了按钮）</td>
    </tr>
    <tr>
      <td><strong>Blocking Mask</strong></td>
      <td>用于限制哪些 Layer 的物体会阻挡 UI 射线</td>
    </tr>
  </tbody>
</table>

<h4 id="工作原理ui射线检测">工作原理：UI射线检测</h4>
<p>当你点击屏幕时，Unity的Event System会：</p>
<ul>
  <li>发出一条射线（Ray）</li>
  <li>交给<code class="language-plaintext highlighter-rouge">Grphic Raycaster</code></li>
  <li><code class="language-plaintext highlighter-rouge">Graphic Raycaster</code>会检测这条射线是否与某些UI元素相交</li>
  <li>若相交，就触发这些元素的<code class="language-plaintext highlighter-rouge">OnPointerClick()</code>、<code class="language-plaintext highlighter-rouge">OnPointerDown()</code>、<code class="language-plaintext highlighter-rouge">OnDrag()</code>等事件</li>
</ul>

<p>要让Graphic Paycaster正常工作，必须保证：</p>
<ul>
  <li>Canvas上挂了<code class="language-plaintext highlighter-rouge">Graphic Raycaster</code></li>
  <li>场景中有一个<code class="language-plaintext highlighter-rouge">Event System</code></li>
  <li>UI元素上有<code class="language-plaintext highlighter-rouge">Graphic</code>组件（如<code class="language-plaintext highlighter-rouge">Image</code>、<code class="language-plaintext highlighter-rouge">Text</code>，才能被Raycaster检测到）</li>
  <li>UI元素有<code class="language-plaintext highlighter-rouge">Raycast Target</code>为勾选状态</li>
  <li>没有被<code class="language-plaintext highlighter-rouge">Canvas Group</code>阻挡（其<code class="language-plaintext highlighter-rouge">Blocks Raycasts</code>属性必须为true）</li>
</ul>

<h3 id="canvas-group">Canvas Group</h3>

<p><img src="/assets/images/CanvasGroupPanel.jpg" alt="CanvasGroupPanel" /></p>

<p>控制一组UI元素的整体透明度、交互性和射线响应<br />
用它可以实现：</p>
<ul>
  <li>一整个面板淡入淡出</li>
  <li>临时禁用一组按钮</li>
  <li>某些UI遮罩区域不响应点击</li>
</ul>

<h4 id="属性">属性</h4>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Alpha</strong></td>
      <td><code class="language-plaintext highlighter-rouge">float</code> (0 ~ 1)</td>
      <td>控制透明度，0 = 全透明，1 = 不透明。会影响 <strong>UI 的视觉透明</strong> 和 <strong>交互性（如果 Block Raycasts = true）</strong></td>
    </tr>
    <tr>
      <td><strong>Interactable</strong></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否允许子元素响应交互事件（如点击 Button）</td>
    </tr>
    <tr>
      <td><strong>Blocks Raycasts</strong></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否拦截 UI 射线，决定子元素是否能被点击、拖动等</td>
    </tr>
    <tr>
      <td><strong>Ignore Parent Groups</strong></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否忽略父级 Canvas Group 的控制（<strong>重要属性</strong>）</td>
    </tr>
  </tbody>
</table>

<h3 id="canvas的层级关系">Canvas的层级关系</h3>
<p>Unity允许UI层级中存在多个Canvas组件，这时，Canvas本身就能作为字节点存在，形成嵌套结构</p>

<ul>
  <li>子Canvas布置主Canvas的一部分，它是一个“独立渲染单元”</li>
  <li>每个Canvas都是一个独立的渲染批次（Draw Call）</li>
  <li>子Canvas不会因为父Canvas中其他UI元素变化而重绘，反之亦然</li>
</ul>

<h4 id="为什么要用子canvas">为什么要用子Canvas</h4>
<p>子Canvas主要用于优化性能和分离逻辑</p>

<h5 id="性能优化">性能优化</h5>
<blockquote>
  <p>如果你有一个排行榜界面，只有当排行榜打开时才需要刷新内容，其他UI不变，这可以这样：</p>
  <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">Canvas</span><span class="o">(</span><span class="nt">主UI</span><span class="o">)</span>
<span class="o">|</span><span class="err">——</span><span class="nt">背景UI</span><span class="o">(</span><span class="nt">静态</span><span class="o">)</span>
<span class="o">|</span><span class="err">——</span><span class="nt">Canvas</span><span class="o">(</span><span class="nt">排行榜</span><span class="o">)</span> <span class="o">&lt;</span><span class="nt">-</span> <span class="nt">单独Canvas</span><span class="err">，</span><span class="nt">打开时才激活和更新</span>
</code></pre></div>  </div>
  <p>这样排行榜刷新不会引起整个主UI Canvas的重建批次</p>
</blockquote>

<h5 id="ui分区逻辑清晰">UI分区逻辑清晰</h5>
<blockquote>
  <p>把HUD、弹窗、系统提示各放到子Canvas中，方便管理和控制层级、显隐、动画等</p>
</blockquote>

<h4 id="父子canvas的排序--显示顺序">父子Canvas的排序 &amp; 显示顺序</h4>
<h5 id="排序层控制sorting-layer--order-in-layer">排序层控制（Sorting Layer + Order in Layer）</h5>
<p>每个Canvas都有：</p>
<ul>
  <li>Sorting Layer（图层）</li>
  <li>Order in Layer（在该图层的顺序）
这两个参数决定Canvas之间的渲染先后顺序，数值越高越在前，越晚渲染
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">Canvas HUD(Sorting Layer</span><span class="pi">:</span> <span class="s">UI, Order</span><span class="err">:</span> <span class="s">0)</span>
<span class="na">Canvas Popup(Sorting Layer</span><span class="pi">:</span> <span class="s">UI, Order</span><span class="err">:</span> <span class="s">10)</span>
</code></pre></div>    </div>
    <p>Popup会在HUD上方显示，即使它是子物体也一样</p>
  </li>
</ul>

<h4 id="recttransform父子关系的影响">RectTransform父子关系的影响</h4>
<ul>
  <li>子UI元素会继承父节点的位置、旋转、缩放等变换</li>
  <li>子UI的位置是相对于父节点的（本地坐标）</li>
  <li>适用于做面板嵌套、按钮列表、滑动区域等结构</li>
</ul>

<h3 id="canvas性能">Canvas性能</h3>
<ul>
  <li>尽量减少Canvas数量，因为每个Canvas都是单独的渲染批次</li>
  <li>将频繁变动的UI元素放到单独的Canvas，避免整个UI重绘</li>
  <li>使用Canvas Group控制UI整体显示和透明度，可以减少重绘</li>
  <li>关闭不需要显示的UI，避免额外渲染</li>
</ul>

<h3 id="canvas-api">Canvas API</h3>
<h4 id="properties">Properties</h4>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>说明</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">renderMode</code></td>
      <td><code class="language-plaintext highlighter-rouge">RenderMode</code></td>
      <td>渲染模式（Overlay、ScreenSpaceCamera、WorldSpace）</td>
      <td>决定Canvas如何渲染和视图方式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">worldCamera</code></td>
      <td><code class="language-plaintext highlighter-rouge">Camera</code></td>
      <td>渲染用摄像机（适用于 Camera、World 模式）</td>
      <td>控制UI投射方向、接收事件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pixelPerfect</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否启用像素完美对齐（仅限Screen Space）</td>
      <td>像素风格游戏的UI清晰对齐</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">planeDistance</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>距摄像机的距离（仅Screen Space - Camera）</td>
      <td>控制Canvas深度层级</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">scaleFactor</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>缩放因子（通常由 CanvasScaler 控制）</td>
      <td>适配不同分辨率</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">referencePixelsPerUnit</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>每单位像素数，决定图像缩放清晰度</td>
      <td>确保 UI 图像缩放一致</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sortingLayerID</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>渲染图层 ID</td>
      <td>控制 Canvas 渲染层</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sortingLayerName</code></td>
      <td><code class="language-plaintext highlighter-rouge">string</code></td>
      <td>渲染图层名称</td>
      <td>可读性更强的层级控制</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sortingOrder</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>同图层中的渲染顺序，越大越前面</td>
      <td>控制 UI 显示前后关系</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">overrideSorting</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否覆盖父 Canvas 的排序逻辑</td>
      <td>弹窗、特效UI 的独立排序</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">targetDisplay</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>目标显示屏幕编号（用于多显示器）</td>
      <td>多屏幕UI部署</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isRootCanvas</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code> (只读)</td>
      <td>是否为根 Canvas</td>
      <td>判断是否主 Canvas（用于布局判断）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rootCanvas</code></td>
      <td><code class="language-plaintext highlighter-rouge">Canvas</code> (只读)</td>
      <td>所属的顶级 Canvas</td>
      <td>获取当前 Canvas 的上级主容器</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">renderOrder</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code> (只读)</td>
      <td>实际渲染顺序（自动计算）</td>
      <td>调试 Canvas 渲染先后</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pixelRect</code></td>
      <td><code class="language-plaintext highlighter-rouge">Rect</code> (只读)</td>
      <td>当前 Canvas 实际的像素渲染区域</td>
      <td>渲染区域调试</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">renderingDisplaySize</code></td>
      <td><code class="language-plaintext highlighter-rouge">Vector2</code> (只读)</td>
      <td>渲染显示区域的像素尺寸</td>
      <td>获取目标显示区域尺寸</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">overridePixelPerfect</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否允许覆盖父Canvas的像素对齐设置</td>
      <td>子 Canvas 不启用像素对齐时用</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">additionalShaderChannels</code></td>
      <td><code class="language-plaintext highlighter-rouge">AdditionalShaderChannels</code></td>
      <td>指定额外的 shader 顶点数据传输通道</td>
      <td>用于自定义UI Shader</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cachedSortingLayerValue</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code> (只读)</td>
      <td>当前排序图层的底层缓存值，用于排序计算</td>
      <td>系统内部优化（一般不手动使用）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">normalizedSortingGridSize</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>Canvas 分割的排序网格单元大小</td>
      <td>高阶排序控制，与 SRP 结合使用</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">updateRectTransformForStandalone</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>在手动 <code class="language-plaintext highlighter-rouge">Camera.Render()</code> 时是否自动更新 RectTransform</td>
      <td>手动渲染UI场景</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">vertexColorAlwaysGammaSpace</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>在使用线性空间渲染时是否强制顶点颜色使用 Gamma 空间传递</td>
      <td>确保 UI 颜色一致性（线性渲染）</td>
    </tr>
  </tbody>
</table>

<h4 id="static-method">Static Method</h4>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>返回类型</th>
      <th>描述</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Canvas.ForceUpdateCanvases()</code></td>
      <td><code class="language-plaintext highlighter-rouge">void</code></td>
      <td><strong>强制更新所有 Canvas</strong> 的布局和绘制内容</td>
      <td>用于在下一帧前立即刷新 UI 状态（比如修改布局元素后）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Canvas.GetDefaultCanvasMaterial()</code></td>
      <td><code class="language-plaintext highlighter-rouge">Material</code></td>
      <td>返回一个<strong>默认 Canvas 材质</strong>，用于普通 UI 元素的渲染</td>
      <td>如果需要自定义绘制或替换默认材质时使用</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Canvas.GetETC1SupportedCanvasMaterial()</code></td>
      <td><code class="language-plaintext highlighter-rouge">Material</code></td>
      <td>获取或生成支持 <strong>ETC1 格式贴图的 UI 材质</strong>（主要用于 Android）</td>
      <td>在使用 ETC1 压缩纹理时提供透明通道支持（Alpha 拆分）</td>
    </tr>
  </tbody>
</table>

<h4 id="events">Events</h4>

<table>
  <thead>
    <tr>
      <th>事件名</th>
      <th>调用时机</th>
      <th>描述</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">preWillRenderCanvases</code></td>
      <td><strong>Canvas 渲染前，最先调用</strong></td>
      <td>在 Canvas 渲染流程开始前立即触发（早于布局和绘制）</td>
      <td>在渲染前动态调整 UI 布局、刷新数据</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">willRenderCanvases</code></td>
      <td><strong>Canvas 渲染前，紧接上一步</strong></td>
      <td>在 Canvas 渲染流程开始前触发，但晚于 <code class="language-plaintext highlighter-rouge">preWillRenderCanvases</code></td>
      <td>绑定动画播放、状态更新逻辑、依赖布局结果的修改操作</td>
    </tr>
  </tbody>
</table>

<h5 id="事件区别和调用顺序">事件区别和调用顺序</h5>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Canvas</span><span class="p">.</span><span class="n">preWillRederCanvases</span> <span class="p">-&gt;</span> <span class="n">Canvas</span><span class="p">.</span><span class="n">willRenderCanvases</span> <span class="p">-&gt;</span> <span class="n">Canvas</span> <span class="err">渲染</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">preWilldRenderCanvases</code>：在所有布局系统更新之前调用，用于准备UI状态、尺寸、数据等</li>
  <li><code class="language-plaintext highlighter-rouge">willRenderCanvases</code>：在布局完成后、渲染开始前调用，适合根据最终布局做动画、视觉状态处理</li>
</ul>

<p><a href="https://docs.unity3d.com/ScriptReference/Canvas.html">UnityScripting Canvas</a></p>

<h2 id="ui-componenet">UI Componenet</h2>
<h3 id="通用组件">通用组件</h3>
<p><img src="/assets/images/UI-CommonComponent.jpg" alt="UICommonComponent" /></p>
<h4 id="rect-transform">Rect Transform</h4>
<p><code class="language-plaintext highlighter-rouge">RectTransform</code>继承自<code class="language-plaintext highlighter-rouge">Transform</code>，专门用于2D UI布局。<br />
所有UI元素都依赖<code class="language-plaintext highlighter-rouge">RectTransform</code>来定位和缩放</p>

<h5 id="核心属性">核心属性</h5>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchorMin</code></td>
      <td>Vector2</td>
      <td>锚点区域左下角（归一化坐标，0~1）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchorMax</code></td>
      <td>Vector2</td>
      <td>锚点区域右上角</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchoredPosition</code></td>
      <td>Vector2</td>
      <td>相对于锚点区域中心的偏移量</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pivot</code></td>
      <td>Vector2</td>
      <td>本地坐标的参考中心（范围 0~1）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sizeDelta</code></td>
      <td>Vector2</td>
      <td>元素宽高，或拉伸模式下的偏移</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rect</code></td>
      <td>Rect (只读)</td>
      <td>实际的矩形框（位置、宽高）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">localPosition</code></td>
      <td>Vector3</td>
      <td>相对于父节点的本地坐标（不推荐直接用于 UI）</td>
    </tr>
  </tbody>
</table>

<h5 id="anchor">Anchor</h5>
<p>Anchor（锚点）是<code class="language-plaintext highlighter-rouge">RectTransform</code>的关键组成部分，决定了UI元素相对于父物体的位置和尺寸的参考点</p>

<p>Anchor实际上是一对二维坐标：<code class="language-plaintext highlighter-rouge">anchorMin</code>和<code class="language-plaintext highlighter-rouge">anchorMax</code>，每个值都是<code class="language-plaintext highlighter-rouge">[0, 1]</code>范围内归一化坐标，表示在父元素矩形中的相对位置</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">anchorMin = (0, 0)</code>表示父物体的左下角</li>
  <li><code class="language-plaintext highlighter-rouge">anchorMax = (1, 1)</code>表示父物体的右上角</li>
</ul>

<p><strong>锚点的几种模式</strong>
1.固定位置（不拉伸）<br />
当：<code class="language-plaintext highlighter-rouge">anchorMin</code> = <code class="language-plaintext highlighter-rouge">anchorMax</code></p>
<ul>
  <li>元素位置相对于这个锚点点位</li>
  <li>用<code class="language-plaintext highlighter-rouge">anchoredPosition</code>来控制偏移</li>
  <li>常用于角落按钮、图标等</li>
</ul>

<p>2.拉伸尺寸（适应父物体）
当：<code class="language-plaintext highlighter-rouge">anchorMin</code> != <code class="language-plaintext highlighter-rouge">anchorMax</code></p>
<ul>
  <li>元素会随着父容器的尺寸变化而拉伸</li>
  <li><code class="language-plaintext highlighter-rouge">sizeDelta</code>不是绝对宽高，而是拉伸结果的偏移</li>
</ul>

<h5 id="pivot">Pivot</h5>
<p>pivot（枢轴点）定义的是UI元素自身的参考点（中心点），它决定了：</p>
<ul>
  <li>元素的位置是以自身哪个位置为参考（锚点对齐）</li>
  <li>元素在旋转时围绕哪里旋转</li>
  <li>元素在缩放时以哪个点为中心缩放</li>
</ul>

<p>它的值是一个二维向量，范围在<code class="language-plaintext highlighter-rouge">[0, 1]</code>之间，表示相对于自身矩形的位置：</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">pivot</code> 值</th>
      <th>位置说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>(0, 0)</td>
      <td>左下角</td>
    </tr>
    <tr>
      <td>(0.5, 0.5)</td>
      <td>中心（默认）</td>
    </tr>
    <tr>
      <td>(1, 1)</td>
      <td>右上角</td>
    </tr>
    <tr>
      <td>(0, 1)</td>
      <td>左上角</td>
    </tr>
    <tr>
      <td>(1, 0)</td>
      <td>右下角</td>
    </tr>
  </tbody>
</table>

<h4 id="布局">布局</h4>
<p><strong>布局演示</strong>
假设Canvas是1920*1080的全屏UI</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RectTransform</span> <span class="n">rt</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">RectTransform</span><span class="p">&gt;();</span>

<span class="n">rt</span><span class="p">.</span><span class="n">anchorMin</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0.5f</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">);</span>
<span class="n">rt</span><span class="p">.</span><span class="n">anchorMax</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0.5f</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">);</span>
<span class="n">rt</span><span class="p">.</span><span class="n">pivot</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0.5f</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">);</span>
<span class="n">rt</span><span class="p">.</span><span class="n">anchoredPosition</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
<span class="n">rt</span><span class="p">.</span><span class="n">sizeDelta</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">200</span><span class="p">,</span> <span class="m">100</span><span class="p">);</span>
</code></pre></div></div>
<p>这个UI元素将被放置在屏幕正中央，宽度为200，高度为100</p>

<h5 id="坐标系层级关系">坐标系层级关系</h5>
<p>1.<code class="language-plaintext highlighter-rouge">anchorMin</code> / <code class="language-plaintext highlighter-rouge">anchorMax</code>决定锚点区域</p>

<p>2.<code class="language-plaintext highlighter-rouge">anchoredPosition</code>是相对于锚点区域的中心</p>

<p>3.<code class="language-plaintext highlighter-rouge">pivot</code>是UI元素自身的中心点</p>

<p>4.最终位置由这些共同计算得到</p>

<p><strong>实际计算公式（简化版）</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>最终位置 = 锚点区域中心 + anchoredPosition - pivot * sizeDelta
</code></pre></div></div>
<p>这个公式说明了设置的位置不是直接坐标，而是围绕锚点和pivot共同计算的结果</p>

<p><img src="/assets/images/AnchorPresets.jpg" alt="AnchorPreSets" /></p>

<ul>
  <li>按住Alt + Shift拖动可以同时设置pivot和anchor</li>
  <li>Unity提供Anchor Preset快速布局</li>
  <li>蓝线表示Anchors，红点表示Pivot，灰框表示实际UI区域</li>
</ul>

<h5 id="recttransform-api">RectTransform API</h5>
<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchoredPosition</code></td>
      <td>相对于锚点参考位置的<strong>二维坐标</strong>，表示此 <code class="language-plaintext highlighter-rouge">RectTransform</code> 的<strong>pivot（枢轴点）</strong>的位置。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchoredPosition3D</code></td>
      <td>相对于锚点参考位置的<strong>三维坐标</strong>，主要用于支持 Z 轴（例如 3D UI 或特殊布局需求）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchorMax</code></td>
      <td>右上角锚点在父 <code class="language-plaintext highlighter-rouge">RectTransform</code> 中的<strong>归一化坐标</strong>（范围 0~1），例如 (1,1) 表示父物体的右上角。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">anchorMin</code></td>
      <td>左下角锚点在父 <code class="language-plaintext highlighter-rouge">RectTransform</code> 中的<strong>归一化坐标</strong>，例如 (0,0) 表示父物体的左下角。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">drivenByObject</code></td>
      <td>如果该 <code class="language-plaintext highlighter-rouge">RectTransform</code> 的属性被其他对象驱动（如 Layout 组件），会显示驱动它的对象；否则为 <code class="language-plaintext highlighter-rouge">null</code>。常用于调试自动布局。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">offsetMax</code></td>
      <td>当前矩形右上角相对于右上锚点的偏移值（本地坐标）。可以理解为 <code class="language-plaintext highlighter-rouge">Top</code> 和 <code class="language-plaintext highlighter-rouge">Right</code> 的偏移。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">offsetMin</code></td>
      <td>当前矩形左下角相对于左下锚点的偏移值。可以理解为 <code class="language-plaintext highlighter-rouge">Left</code> 和 <code class="language-plaintext highlighter-rouge">Bottom</code> 的偏移。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pivot</code></td>
      <td>当前 <code class="language-plaintext highlighter-rouge">RectTransform</code> 的<strong>枢轴点</strong>，用归一化坐标表示 (0~1)，如 (0.5, 0.5) 表示中心点，(0, 0) 表示左下角。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rect</code></td>
      <td>在本地坐标系下计算出的实际矩形区域，是一个 <code class="language-plaintext highlighter-rouge">Rect</code> 结构体（包含 x, y, width, height）。只读属性。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sizeDelta</code></td>
      <td>表示当前矩形的宽高 <strong>相对于 anchor 之间距离的增量值</strong>。如果 anchorMin 和 anchorMax 相同，则这个值就是最终尺寸。</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Method</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ForceUpdateRectTransforms()</code></td>
      <td>强制重新计算 <code class="language-plaintext highlighter-rouge">RectTransform</code> 的内部数据（通常在布局改变后使用，用来立即更新布局）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetLocalCorners(Vector3[] fourCornersArray)</code></td>
      <td>获取该 <code class="language-plaintext highlighter-rouge">RectTransform</code> 在本地空间中的四个角的坐标，按顺序为：左下、左上、右上、右下。结果会填充到传入的 <code class="language-plaintext highlighter-rouge">Vector3[4]</code> 数组中。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetWorldCorners(Vector3[] fourCornersArray)</code></td>
      <td>获取该 <code class="language-plaintext highlighter-rouge">RectTransform</code> 在<strong>世界空间</strong>中的四个角的坐标（顺序同上）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetInsetAndSizeFromParentEdge(RectTransform.Edge edge, float inset, float size)</code></td>
      <td>以父物体的某条边为参考，设置当前 <code class="language-plaintext highlighter-rouge">RectTransform</code> 距离该边的<strong>偏移值（inset）</strong>和自身的<strong>尺寸（size）</strong>。适用于锚点固定在某一边的场景。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetSizeWithCurrentAnchors(RectTransform.Axis axis, float size)</code></td>
      <td>在指定轴（水平或垂直）上，按照当前锚点设置矩形大小。它会考虑锚点之间的拉伸距离，<strong>相对于锚点调整 sizeDelta</strong>。</td>
    </tr>
  </tbody>
</table>

<p><strong>Event</strong></p>

<table>
  <thead>
    <tr>
      <th>事件</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">reapplyDrivenProperties</code></td>
      <td>当一个 <code class="language-plaintext highlighter-rouge">RectTransform</code> 的某些属性（由外部系统如 Layout、Animation 或代码控制）需要被重新应用时触发的事件。开发者可以订阅这个事件来自定义处理逻辑。</td>
    </tr>
  </tbody>
</table>

<p><strong>Delegate</strong></p>

<table>
  <thead>
    <tr>
      <th>委托</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReapplyDrivenProperties</code></td>
      <td>用于 <code class="language-plaintext highlighter-rouge">RectTransform.reapplyDrivenProperties</code> 事件的委托类型，定义了事件回调的签名。</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.unity3d.com/ScriptReference/RectTransform.html">UnityScripting RectTransform</a></p>

<h4 id="canvas-renderer">Canvas Renderer</h4>
<p><code class="language-plaintext highlighter-rouge">CanvasRenderer</code>是Unity UI系统中挂在每个可见UI上的一个底层组件，负责UI的绘制提交，它是Graphic类的渲染后台</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">CanvasRenderer</code>是连接UI元素和底层渲染管线的桥梁</p>
</blockquote>

<h5 id="canvasrenderer的作用">CanvasRenderer的作用</h5>

<table>
  <thead>
    <tr>
      <th>功能方向</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>渲染控制</td>
      <td>负责把 UI 元素的顶点数据、颜色、材质提交给 Canvas 系统渲染</td>
    </tr>
    <tr>
      <td>可见性控制</td>
      <td>控制是否显示（通过 <code class="language-plaintext highlighter-rouge">cull</code>, <code class="language-plaintext highlighter-rouge">SetAlpha</code>, <code class="language-plaintext highlighter-rouge">SetColor</code> 等）</td>
    </tr>
    <tr>
      <td>材质支持</td>
      <td>支持单个或多个材质绘制（比如 <code class="language-plaintext highlighter-rouge">SetMaterial</code>, <code class="language-plaintext highlighter-rouge">SetPopMaterial</code>）</td>
    </tr>
    <tr>
      <td>顶点缓存</td>
      <td>维护每个 UI 元素的 Mesh 数据</td>
    </tr>
    <tr>
      <td>Mask 支持</td>
      <td>与 UI Mask 系统配合使用进行遮罩裁剪处理</td>
    </tr>
  </tbody>
</table>

<h5 id="canvasrenderer和ui的绘制流程">CanvasRenderer和UI的绘制流程</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UI组件（Image/Text 等）
    ↓
生成顶点、UV、颜色等数据
    ↓
传给 CanvasRenderer
    ↓
CanvasRenderer 将数据提交给 Canvas 系统
    ↓
Canvas 系统统一批处理渲染
</code></pre></div></div>

<h5 id="canvasrenderer-api">CanvasRenderer API</h5>

<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>含义</th>
      <th>用途/说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">absoluteDepth</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>相对于<strong>根 Canvas 的深度值</strong></td>
      <td>用于判断当前 UI 元素在整个 UI 渲染中的层级。数值越大，越“靠上”渲染。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">relativeDepth</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>相对于<strong>父 Canvas 的深度值</strong></td>
      <td>可用于局部 Canvas 中排序。配合 <code class="language-plaintext highlighter-rouge">absoluteDepth</code> 理解 UI 层级渲染顺序。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">materialCount</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>当前可用于渲染的<strong>材质数量</strong></td>
      <td>用于分配和管理 UI 材质。你可以通过 <code class="language-plaintext highlighter-rouge">SetMaterial()</code> 为每个 index 设置材质。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">popMaterialCount</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>内部用于 Mask（遮罩）的材质数量</td>
      <td>这个通常配合 UI Masking 使用（如 <code class="language-plaintext highlighter-rouge">Image.maskable = true</code>）。设置 <code class="language-plaintext highlighter-rouge">PopMaterial</code> 用于控制遮罩剥离行为。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hasPopInstruction</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否启用了 “渲染堆栈 pop draw call”</td>
      <td>和 <code class="language-plaintext highlighter-rouge">PopMaterial</code> 有关。你可以开启它来显式控制何时 pop 遮罩渲染状态。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hasMoved</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>如果 UI 位置发生变更，则为 <code class="language-plaintext highlighter-rouge">true</code></td>
      <td>用于判断当前帧是否需要重新生成 UI 顶点几何。优化 UI 刷新频率用。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cull</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否<strong>剔除</strong>当前元素</td>
      <td>设置为 <code class="language-plaintext highlighter-rouge">true</code> 时，这个元素不再渲染（即使它可见）。用于节省性能。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cullTransparentMesh</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>如果顶点颜色 alpha 接近 0，是否剔除渲染</td>
      <td>用于透明 UI 元素的剔除优化。默认为 <code class="language-plaintext highlighter-rouge">true</code>，避免无意义绘制。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hasRectClipping</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否启用了矩形剪裁区域</td>
      <td>是否启用了 <code class="language-plaintext highlighter-rouge">EnableRectClipping(Rect)</code>。常用于 <code class="language-plaintext highlighter-rouge">ScrollRect</code> 中的裁剪效果。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">clippingSoftness</code></td>
      <td><code class="language-plaintext highlighter-rouge">Vector2</code></td>
      <td>设置裁剪的“软边缘”范围</td>
      <td>使裁剪边缘变得平滑渐变，不是硬切。单位像素值，适合美术优化。</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Method</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>中文解释</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">Clear()</code></strong></td>
      <td>清除所有缓存的顶点数据</td>
      <td>自定义 UI 元素重绘前清空数据</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">DisableRectClipping()</code></strong></td>
      <td>关闭矩形裁剪区域</td>
      <td>让 UI 元素可以渲染到全屏（常见于浮动 UI）</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">EnableRectClipping(Rect rect)</code></strong></td>
      <td>启用矩形裁剪区域，只显示 <code class="language-plaintext highlighter-rouge">rect</code> 内内容</td>
      <td>用于 <code class="language-plaintext highlighter-rouge">ScrollRect</code> 滚动列表裁剪或自定义遮罩逻辑</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetAlpha()</code></strong></td>
      <td>获取当前的透明度值</td>
      <td>判断当前透明度状态，常用于动画/过渡控制</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetColor()</code></strong></td>
      <td>获取当前设置的颜色</td>
      <td>一般配合 <code class="language-plaintext highlighter-rouge">SetColor</code> 使用，读取当前 UI 颜色</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetInheritedAlpha()</code></strong></td>
      <td>获取包括所有父级 CanvasGroup 的总 alpha 值</td>
      <td>透明度层级继承计算，适合判断是否实际可见</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetMaterial(int index)</code></strong></td>
      <td>获取某个索引的材质</td>
      <td>适合高级渲染管理，如多 Pass 材质</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetPopMaterial(int index)</code></strong></td>
      <td>获取 Pop 材质（用于 UI 遮罩的反向操作）</td>
      <td>用于 UI Mask / Stencil Buffer 中的剪裁恢复逻辑</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetMesh()</code></strong></td>
      <td>获取当前用于渲染的 Mesh</td>
      <td>常用于自定义绘制调试和顶点处理</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetSecondaryTexture(int index)</code></strong></td>
      <td>获取指定索引的第二纹理</td>
      <td>用于多纹理 UI Shader，例如溶解图、遮罩图</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetSecondaryTextureCount()</code></strong></td>
      <td>获取当前可用第二纹理数量</td>
      <td>用于管理复杂 Shader UI 结构</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">GetSecondaryTextureName(int index)</code></strong></td>
      <td>获取指定索引的 Shader 属性名</td>
      <td>获取传入的纹理对应的 <code class="language-plaintext highlighter-rouge">_SomeTexName</code></td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetAlpha(float alpha)</code></strong></td>
      <td>设置透明度，会与 <code class="language-plaintext highlighter-rouge">UIVertex alpha</code> 和 <code class="language-plaintext highlighter-rouge">Canvas alpha</code> 相乘</td>
      <td>快速设置 UI 淡入淡出、不透明状态等</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetAlphaTexture(Texture tex)</code></strong></td>
      <td>将 <code class="language-plaintext highlighter-rouge">_AlphaTex</code> 指定为某个纹理，传给 Shader</td>
      <td>适用于字体抗锯齿、自定义透明纹理渲染</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetColor(Color color)</code></strong></td>
      <td>设置颜色，会与 <code class="language-plaintext highlighter-rouge">UIVertex.color</code> 和 <code class="language-plaintext highlighter-rouge">Canvas.color</code> 混合</td>
      <td>比如红色血条：<code class="language-plaintext highlighter-rouge">SetColor(Color.red)</code></td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetMaterial(Material mat, int index)</code></strong></td>
      <td>为指定索引设置材质</td>
      <td>UI Shader 控制，如多 pass 渲染、特效图层等</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetPopMaterial(Material mat, int index)</code></strong></td>
      <td>设置 Pop 材质（内部用于 Mask 反剪裁）</td>
      <td>控制遮罩关闭后的恢复材质</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetMesh(Mesh mesh)</code></strong></td>
      <td>设置渲染用的 Mesh，Mesh 必须启用读写</td>
      <td>你可以自定义顶点图形绘制复杂 UI</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetSecondaryTextureCount(int count)</code></strong></td>
      <td>设置可用第二纹理数量</td>
      <td>Shader 中有多个纹理输入时要提前设置</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetSecondaryTexture(int index, string shaderProp, Texture tex)</code></strong></td>
      <td>设置指定索引的纹理及其 Shader 属性名</td>
      <td>给 UI Shader 传多个纹理，如 <code class="language-plaintext highlighter-rouge">_MaskTex</code>, <code class="language-plaintext highlighter-rouge">_NoiseTex</code></td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SetTexture(Texture tex)</code></strong></td>
      <td>设置用于 UI 材质中的主纹理</td>
      <td>相当于设定 Shader 的 <code class="language-plaintext highlighter-rouge">_MainTex</code>，适用于 <code class="language-plaintext highlighter-rouge">Image</code> 或 <code class="language-plaintext highlighter-rouge">RawImage</code> 渲染</td>
    </tr>
  </tbody>
</table>

<p><strong>Static Method</strong></p>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>作用</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SplitUIVertexStreams</code></strong></td>
      <td>将 <code class="language-plaintext highlighter-rouge">UIVertex</code> 列表拆分成各个属性数组（位置、颜色、UV、法线、切线）</td>
      <td>修改顶点颜色、UV、法线等时使用</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">AddUIVertexStream</code></strong></td>
      <td>将 <code class="language-plaintext highlighter-rouge">UIVertex</code> 中的数据<strong>添加</strong>到现有的顶点属性列表</td>
      <td>组合多个顶点来源数据，叠加处理</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">CreateUIVertexStream</code></strong></td>
      <td>将单独的顶点属性数组（位置、颜色、UV等）<strong>合成为一个 <code class="language-plaintext highlighter-rouge">UIVertex</code> 流</strong></td>
      <td>自定义 UI 图形顶点数据，如渐变、闪光、圆形 UI 等</td>
    </tr>
  </tbody>
</table>

<p>静态方法参数说明</p>

<table>
  <thead>
    <tr>
      <th>参数名</th>
      <th>类型</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">verts</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;UIVertex&gt;</code></td>
      <td>完整顶点数据流</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">positions</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;Vector3&gt;</code></td>
      <td>每个顶点的位置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">colors</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;Color32&gt;</code></td>
      <td>每个顶点的颜色</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">uv0S</code> / <code class="language-plaintext highlighter-rouge">uv1S</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;Vector4&gt;</code></td>
      <td>UV 坐标（第0、1通道）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">normals</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;Vector3&gt;</code></td>
      <td>法线</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tangents</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;Vector4&gt;</code></td>
      <td>切线，用于光照方向等</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">stream</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;UIVertex&gt;</code></td>
      <td>用于最终生成的合并数据</td>
    </tr>
  </tbody>
</table>

<p><strong>Event</strong></p>

<table>
  <thead>
    <tr>
      <th>事件名</th>
      <th>作用</th>
      <th>使用场景</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">onRequestRebuild</code></strong></td>
      <td><strong>（仅在 Editor 模式下）</strong>当 CanvasRenderer 中的数据无效、需要重建时触发</td>
      <td>编辑器下自定义 UI 编辑、自动刷新组件、响应布局更新等</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.unity3d.com/ScriptReference/CanvasRenderer.html">CanvasRenderer</a></p>

<h4 id="image">Image</h4>
<p>Image用于在<code class="language-plaintext highlighter-rouge">Canvas</code>上渲染2D图像</p>

<h5 id="属性-1">属性</h5>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Source Image</strong></td>
      <td>要显示的图片（Sprite）</td>
    </tr>
    <tr>
      <td><strong>Color</strong></td>
      <td>渲染颜色，会乘上图片原色，可用于变色、淡入淡出</td>
    </tr>
    <tr>
      <td><strong>Material</strong></td>
      <td>自定义渲染材质（通常用于特殊效果，如描边、渐变）</td>
    </tr>
    <tr>
      <td><strong>Raycast Target</strong></td>
      <td>是否响应点击事件（勾选表示能被 <code class="language-plaintext highlighter-rouge">GraphicRaycaster</code> 检测）</td>
    </tr>
    <tr>
      <td><strong>Maskable</strong></td>
      <td>是否允许被遮罩裁剪（勾选表示允许）</td>
    </tr>
  </tbody>
</table>

<p><strong>Image Type</strong></p>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>描述</th>
      <th>用途示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Simple</strong></td>
      <td>直接绘制整张图片</td>
      <td>图标、贴图、UI背景</td>
    </tr>
    <tr>
      <td><strong>Sliced</strong></td>
      <td>使用 9 宫格方式拉伸</td>
      <td>按钮、对话框、面板背景</td>
    </tr>
    <tr>
      <td><strong>Tiled</strong></td>
      <td>将图像平铺（不拉伸）填满区域</td>
      <td>网格背景、重复纹理</td>
    </tr>
    <tr>
      <td><strong>Filled</strong></td>
      <td>根据百分比填充图像</td>
      <td>血条、技能冷却、进度圈</td>
    </tr>
  </tbody>
</table>

<h5 id="image-type-simple">Image Type: Simple</h5>
<ul>
  <li>Use Sprite Mesh
是否使用Sprite导入时生成的精细网格来渲染这张图片
    <ul>
      <li>勾选：使用Sprite的自定义网格（Polygon Mesh）</li>
      <li>取消：使用默认的矩形网格（Quad）</li>
    </ul>
  </li>
  <li>Preserve Aspect
图片在拉伸时是否保持原始宽高比</li>
</ul>

<h5 id="image-type-sliced">Image Type: Sliced</h5>
<ul>
  <li>Fill Center
是否绘制九宫格中间的中心区域（中心填充）
    <ul>
      <li>勾选：中间区域会被绘制，整个九宫格都会显示</li>
      <li>取消：中间区域不会绘制，只绘制九宫格的四个边和四个角， 这样中心部分会变透明，常用于制作空心边框、框线效果</li>
    </ul>
  </li>
  <li>Pixels Per Unit Multiplier
像素与Unity单位之间的转换比例，以调整图片显示的大小，从而不必修改RectTransform大小</li>
</ul>

<h5 id="image-type-tiled">Image Type: Tiled</h5>
<p>同上</p>

<h5 id="image-type-filled">Image Type: Filled</h5>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Fill Method</strong></td>
      <td>填充方式（Horizontal、Vertical、Radial360、Radial180 等）</td>
    </tr>
    <tr>
      <td><strong>Fill Origin</strong></td>
      <td>填充起点（左/右/上/下/中心）</td>
    </tr>
    <tr>
      <td><strong>Fill Amount</strong></td>
      <td>填充比例（0 到 1）</td>
    </tr>
    <tr>
      <td><strong>Clockwise</strong></td>
      <td>是否顺时针填充</td>
    </tr>
  </tbody>
</table>

<h5 id="性能建议">性能建议</h5>

<table>
  <thead>
    <tr>
      <th>建议</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>尽量合批</td>
      <td>使用相同材质和图片可减少 draw call</td>
    </tr>
    <tr>
      <td>禁用 <code class="language-plaintext highlighter-rouge">Raycast Target</code></td>
      <td>如果不需要点击事件，记得取消勾选提高效率</td>
    </tr>
    <tr>
      <td>使用 <code class="language-plaintext highlighter-rouge">Sliced</code></td>
      <td>比 <code class="language-plaintext highlighter-rouge">Simple</code> 更适合可拉伸的 UI 元素，避免失真</td>
    </tr>
    <tr>
      <td>用 <code class="language-plaintext highlighter-rouge">Mask</code> 做裁剪</td>
      <td>可配合小地图/头像/UI 视窗裁剪区域</td>
    </tr>
  </tbody>
</table>

<h5 id="image-api">Image API</h5>

<p><strong>Static Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ussClassName</code></td>
      <td>该类型元素默认的 <strong>USS（Unity Style Sheets）类名</strong>。用于样式表（USS 文件）中选择和定义该类型元素的默认样式。</td>
    </tr>
  </tbody>
</table>

<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">image</code></td>
      <td>要显示的贴图（<code class="language-plaintext highlighter-rouge">Texture</code> 或 <code class="language-plaintext highlighter-rouge">Texture2D</code>）。设置后，<code class="language-plaintext highlighter-rouge">Image</code> 会使用此纹理渲染，控件大小可能自动适应纹理尺寸。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">scaleMode</code></td>
      <td>图片的缩放模式，使用 <code class="language-plaintext highlighter-rouge">ScaleMode</code> 枚举值（如 <code class="language-plaintext highlighter-rouge">StretchToFill</code>, <code class="language-plaintext highlighter-rouge">ScaleAndCrop</code>, <code class="language-plaintext highlighter-rouge">ScaleToFit</code>）控制图片如何适应控件大小。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sourceRect</code></td>
      <td>指定贴图中哪一部分作为源区域显示，使用左上角为参考点的坐标和尺寸（单位为像素）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sprite</code></td>
      <td>显示的精灵（<code class="language-plaintext highlighter-rouge">Sprite</code> 类型）。这是 UI Toolkit 中推荐的图像显示方式，比原始 <code class="language-plaintext highlighter-rouge">Texture</code> 更灵活。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tintColor</code></td>
      <td>渲染图片时使用的着色颜色（默认为白色，设置为其他颜色可以改变图片颜色）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">uv</code></td>
      <td>图片的 UV 坐标范围，基于左下角为原点（通常用于手动设置 UV 区域，控制显示纹理的哪一部分）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">vectorImage</code></td>
      <td>用于显示的矢量图（<code class="language-plaintext highlighter-rouge">VectorImage</code> 类型，SVG 样式的图像）。适合需要分辨率无损缩放的图标或 UI 图案。</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.unity3d.com/ScriptReference/UIElements.Image.html">UnityScrpting Image</a></p>

<h2 id="ui-element">UI Element</h2>
<h3 id="panel">Panel</h3>
<p>Panel是用来组织、分组、控制一组UI元素的容器，是UI架构中最基本的结构单位</p>

<p>本质上是一个普通的<code class="language-plaintext highlighter-rouge">GameObject</code></p>

<blockquote>
  <p>Panel = GameObject + RectTransform + Other Optional Component</p>
</blockquote>

<h4 id="常见用途">常见用途</h4>

<table>
  <thead>
    <tr>
      <th>用途</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>UI 分组容器</strong></td>
      <td>将一组相关的 UI 元素包在一起（如背包、商店、设置等）</td>
    </tr>
    <tr>
      <td><strong>背景视觉层</strong></td>
      <td>给 UI 添加一个背景板（通常使用半透明黑色）</td>
    </tr>
    <tr>
      <td><strong>控制显示/隐藏</strong></td>
      <td>通过 <code class="language-plaintext highlighter-rouge">SetActive()</code> 控制整组 UI 显示与否</td>
    </tr>
    <tr>
      <td><strong>蒙版裁剪</strong></td>
      <td>配合 <code class="language-plaintext highlighter-rouge">Mask</code> 或 <code class="language-plaintext highlighter-rouge">RectMask2D</code> 使用，裁剪子内容</td>
    </tr>
    <tr>
      <td><strong>动画过渡</strong></td>
      <td>面板之间切换时做位移、渐变等 UI 动画</td>
    </tr>
    <tr>
      <td><strong>局部布局控制</strong></td>
      <td>配合 <code class="language-plaintext highlighter-rouge">LayoutGroup</code> 使用，控制子元素的自动排列</td>
    </tr>
  </tbody>
</table>

<h3 id="image-1">Image</h3>
<p>Image = RectTransform + Image<br />
组件Image不能脱离RectTransform和CanvasRenderer<br />
Image组件见上</p>

<h3 id="raw-image">Raw Image</h3>
<p>Raw Image = RectTransform + Canvas Renderer + Raw Image</p>

<p><img src="/assets/images/RawImagePanel.jpg" alt="RawImagePanel" /></p>

<p><code class="language-plaintext highlighter-rouge">Raw Image</code>是Unity UI中用于直接显示<code class="language-plaintext highlighter-rouge">Texture</code>的组件，区别于<code class="language-plaintext highlighter-rouge">Image</code>显示<code class="language-plaintext highlighter-rouge">Sprite</code>，<code class="language-plaintext highlighter-rouge">RawImage</code>更灵活，适合直接显示非Sprite类型的纹理</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RawImage</code>继承自<code class="language-plaintext highlighter-rouge">MaskableGraphic</code>，是一个UI可视化组件</li>
  <li>它直接使用一个<code class="language-plaintext highlighter-rouge">Texture</code>对象进行绘制，而不需要把纹理先转换成<code class="language-plaintext highlighter-rouge">Sprite</code></li>
  <li>适合展示视频帧、RenderTexture、摄像头画面或自定义生成的纹理</li>
</ul>

<h4 id="image-vs-rawimage">Image vs RawImage</h4>

<table>
  <thead>
    <tr>
      <th>方面</th>
      <th>RawImage</th>
      <th>Image</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>显示资源类型</td>
      <td><code class="language-plaintext highlighter-rouge">Texture</code></td>
      <td><code class="language-plaintext highlighter-rouge">Sprite</code></td>
    </tr>
    <tr>
      <td>是否支持 9 切片</td>
      <td>不支持</td>
      <td>支持</td>
    </tr>
    <tr>
      <td>适合用途</td>
      <td>视频播放、动态纹理显示、非 Sprite 纹理</td>
      <td>UI 图标、按钮、九宫格背景</td>
    </tr>
    <tr>
      <td>是否自动处理边缘</td>
      <td>不支持</td>
      <td>支持切片自动拉伸</td>
    </tr>
  </tbody>
</table>

<h3 id="textlegacy">Text(Legacy)</h3>
<p>UGUI中最早期的文本显示方式之一，Legacy代表它已经被新的系统所取代，但它依然存在于Unity中，作为一种兼容性方案</p>

<p><img src="/assets/images/TextPanel.jpg" alt="TextPanel" /></p>

<p><code class="language-plaintext highlighter-rouge">Text</code>是Unity UGUI系统（UnityEngine.UI.Text）中的标准UI组件，用来在Canvas上显示简单的2D文本</p>

<h4 id="基本属性">基本属性</h4>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Text</strong></td>
      <td>要显示的字符串</td>
    </tr>
    <tr>
      <td><strong>Font</strong></td>
      <td>使用的字体（<code class="language-plaintext highlighter-rouge">.ttf</code>）资源</td>
    </tr>
    <tr>
      <td><strong>Font Style</strong></td>
      <td>字体样式（Normal / Bold / Italic）</td>
    </tr>
    <tr>
      <td><strong>Font Size</strong></td>
      <td>字号大小（整数）</td>
    </tr>
    <tr>
      <td><strong>Line Spacing</strong></td>
      <td>行间距倍数</td>
    </tr>
    <tr>
      <td><strong>Rich Text</strong></td>
      <td>是否启用 <code class="language-plaintext highlighter-rouge">&lt;b&gt;</code>,<code class="language-plaintext highlighter-rouge">&lt;i&gt;</code> 等富文本语法</td>
    </tr>
    <tr>
      <td><strong>Alignment</strong></td>
      <td>对齐方式（左中右 / 上中下）</td>
    </tr>
    <tr>
      <td><strong>Align By Geometry</strong></td>
      <td>按几何对齐</td>
    </tr>
    <tr>
      <td><strong>Horizontal Overflow</strong></td>
      <td>超出边框时的处理方式（Wrap（换行）/Overflow（溢出）</td>
    </tr>
    <tr>
      <td><strong>Vertical Overflow</strong></td>
      <td>同上，垂直方向 (Truncate/Overflow)</td>
    </tr>
    <tr>
      <td><strong>Best Fit</strong></td>
      <td>是否自动缩放字体以适应文本框大小</td>
    </tr>
    <tr>
      <td><strong>Color</strong></td>
      <td>文本颜色</td>
    </tr>
    <tr>
      <td><strong>Material</strong></td>
      <td>可替换字体材质（如实现描边/阴影）</td>
    </tr>
    <tr>
      <td><strong>Raycast Target</strong></td>
      <td>是否参与事件响应（一般设为 false 提升性能）</td>
    </tr>
    <tr>
      <td><strong>Raycast Padding</strong></td>
      <td>用于扩大或缩小UI元素对射线检测（点击、触摸等交互）的响应区域</td>
    </tr>
    <tr>
      <td><strong>Maskable</strong></td>
      <td>可被遮罩剔除</td>
    </tr>
  </tbody>
</table>

<h4 id="工作流程">工作流程</h4>
<p>Text(Legacy)的渲染流程大致如下：</p>
<ul>
  <li>将文本用指定字体转换为字符图形</li>
  <li>用字体的字符图集（Font Atlas）作为纹理采样源</li>
  <li>把这些字母绘制为UI顶点</li>
  <li>通过Canvas Renderer渲染出来</li>
</ul>

<h4 id="textlegacy的缺点">Text(Legacy)的缺点</h4>

<table>
  <thead>
    <tr>
      <th>问题</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>清晰度差</td>
      <td>字体在不同分辨率下可能模糊（Bitmap-based）</td>
    </tr>
    <tr>
      <td>无动态字形支持</td>
      <td>不支持多语言自动扩展字体图集</td>
    </tr>
    <tr>
      <td>没有高级排版功能</td>
      <td>不支持富排版、嵌入图标、文本裁剪等高级功能</td>
    </tr>
    <tr>
      <td>不支持富样式</td>
      <td>难以实现多颜色、高级描边、背景等需求</td>
    </tr>
    <tr>
      <td>性能低</td>
      <td>每次修改文本都会重新生成 UI 顶点，占 GC 和 CPU</td>
    </tr>
  </tbody>
</table>

<h4 id="性能提升">性能提升</h4>
<ul>
  <li>使用高质量<code class="language-plaintext highlighter-rouge">.tff</code>字体（防止边缘锯齿）</li>
  <li>打开Best Fit或设置合理的Font Size</li>
  <li>配合Shadow/Outline效果增强可读性</li>
  <li>避免频繁更新文本，防止GC</li>
</ul>

<h4 id="textlegacy-api">Text(Legacy) API</h4>
<h5 id="properties-1">Properties</h5>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>alignByGeometry</strong></td>
      <td>bool</td>
      <td>是否根据字形几何范围对齐，而非字形度量（更精确的水平对齐）。</td>
    </tr>
    <tr>
      <td><strong>alignment</strong></td>
      <td>TextAnchor</td>
      <td>文本相对于 RectTransform 的对齐方式（左中右，上中下等）。</td>
    </tr>
    <tr>
      <td><strong>cachedTextGenerator</strong></td>
      <td>TextGenerator</td>
      <td>缓存的文本生成器，用于渲染当前可见文本。</td>
    </tr>
    <tr>
      <td><strong>cachedTextGeneratorForLayout</strong></td>
      <td>TextGenerator</td>
      <td>缓存的文本生成器，用于布局计算。</td>
    </tr>
    <tr>
      <td><strong>flexibleHeight</strong></td>
      <td>float</td>
      <td>布局系统调用，表示布局弹性高度。</td>
    </tr>
    <tr>
      <td><strong>flexibleWidth</strong></td>
      <td>float</td>
      <td>布局系统调用，表示布局弹性宽度。</td>
    </tr>
    <tr>
      <td><strong>font</strong></td>
      <td>Font</td>
      <td>使用的字体资源。</td>
    </tr>
    <tr>
      <td><strong>fontSize</strong></td>
      <td>int</td>
      <td>字体渲染大小（像素）。</td>
    </tr>
    <tr>
      <td><strong>fontStyle</strong></td>
      <td>FontStyle</td>
      <td>字体样式，如正常、斜体、粗体等。</td>
    </tr>
    <tr>
      <td><strong>horizontalOverflow</strong></td>
      <td>HorizontalWrapMode</td>
      <td>水平溢出模式（Wrap 或 Overflow），控制文本是否换行。</td>
    </tr>
    <tr>
      <td><strong>layoutPriority</strong></td>
      <td>int</td>
      <td>布局系统调用，布局优先级。</td>
    </tr>
    <tr>
      <td><strong>lineSpacing</strong></td>
      <td>float</td>
      <td>行间距，相对于字体行高的比例，1为正常。</td>
    </tr>
    <tr>
      <td><strong>mainTexture</strong></td>
      <td>Texture</td>
      <td>字体纹理，用于渲染字体。</td>
    </tr>
    <tr>
      <td><strong>minHeight</strong></td>
      <td>float</td>
      <td>布局系统调用，最小高度。</td>
    </tr>
    <tr>
      <td><strong>minWidth</strong></td>
      <td>float</td>
      <td>布局系统调用，最小宽度。</td>
    </tr>
    <tr>
      <td><strong>pixelsPerUnit</strong></td>
      <td>float (只读)</td>
      <td>字体缩放的像素单位，描述字体渲染的像素密度。</td>
    </tr>
    <tr>
      <td><strong>preferredHeight</strong></td>
      <td>float</td>
      <td>由文本生成器计算的理想高度。</td>
    </tr>
    <tr>
      <td><strong>preferredWidth</strong></td>
      <td>float</td>
      <td>由文本生成器计算的理想宽度。</td>
    </tr>
    <tr>
      <td><strong>resizeTextForBestFit</strong></td>
      <td>bool</td>
      <td>是否允许文本自动调整大小以适应容器。</td>
    </tr>
    <tr>
      <td><strong>resizeTextMaxSize</strong></td>
      <td>int</td>
      <td>自动调整时允许的最大字体大小。</td>
    </tr>
    <tr>
      <td><strong>resizeTextMinSize</strong></td>
      <td>int</td>
      <td>自动调整时允许的最小字体大小。</td>
    </tr>
    <tr>
      <td><strong>supportRichText</strong></td>
      <td>bool</td>
      <td>是否支持富文本格式（例如 <code class="language-plaintext highlighter-rouge">&lt;b&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;i&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;color&gt;</code> 标签）。</td>
    </tr>
    <tr>
      <td><strong>text</strong></td>
      <td>string</td>
      <td>当前显示的文本内容。</td>
    </tr>
    <tr>
      <td><strong>verticalOverflow</strong></td>
      <td>VerticalWrapMode</td>
      <td>垂直溢出模式，控制文本超出垂直边界时的处理方式（裁剪或溢出）。</td>
    </tr>
  </tbody>
</table>

<h5 id="public-method">Public Method</h5>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>CalculateLayoutInputHorizontal</strong></td>
      <td>由布局系统调用，用于计算水平布局输入（如宽度需求）。</td>
    </tr>
    <tr>
      <td><strong>CalculateLayoutInputVertical</strong></td>
      <td>由布局系统调用，用于计算垂直布局输入（如高度需求）。</td>
    </tr>
    <tr>
      <td><strong>FontTextureChanged</strong></td>
      <td>由 <code class="language-plaintext highlighter-rouge">FontUpdateTracker</code> 调用，当字体纹理更新时触发的回调。</td>
    </tr>
    <tr>
      <td><strong>GetGenerationSettings</strong></td>
      <td>便捷函数，用于生成并填充文本生成器（TextGenerator）的设置参数。</td>
    </tr>
  </tbody>
</table>

<h5 id="protected-method">Protected Method</h5>

<p><strong>OnDisable</strong></p>

<h5 id="static-method-1">Static Method</h5>

<p><strong>GetTextAnchorPivot</strong> 提供一个便捷方法计算锚点向量偏移量</p>

<p><a href="https://docs.unity3d.com/2019.1/Documentation/ScriptReference/UI.Text.html">UnityScrpting Text(2019.1)</a></p>

<h3 id="buttonlegacy">Button(Legacy)</h3>
<p>Unity早期标准控件（UnityEngine.UI.Button）</p>
<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Button(Legacy)</span> <span class="err">=</span> <span class="err">`Rect</span> <span class="err">Transform`</span> <span class="err">+</span> <span class="err">`Canvas</span> <span class="err">Renderer`</span> <span class="err">+</span> <span class="err">`Image`</span> <span class="err">+</span> <span class="err">`Button`</span>
  <span class="err">|__</span> <span class="err">Text(Legacy)</span>
</code></pre></div></div>
<p><img src="/assets/images/ButtonCantAddTextComponent.jpg" alt="ButtonCantAddTextComponent" /></p>

<p>Button组件只能绑定一个<code class="language-plaintext highlighter-rouge">Graphic</code>来做交互反馈，比如颜色变化、高亮、禁用状态<br />
这个<code class="language-plaintext highlighter-rouge">Graphic</code>是通过<code class="language-plaintext highlighter-rouge">Button.targetGraphic</code>这个字段指定的，通常是绑定在同一个GameObject上的<code class="language-plaintext highlighter-rouge">Image</code>或<code class="language-plaintext highlighter-rouge">RawImage</code><br />
Unity的默认交互逻辑只能作用于一个</p>

<p><img src="/assets/images/Button(Legacy)Panel.jpg" alt="Button(Legacy)Panel" /></p>

<h4 id="panel-properties">Panel Properties</h4>

<ul>
  <li>
    <p>Interactable
bool 是否允许按钮响应点击，取消勾选按钮将进入禁用状态（由Transition决定视觉反馈）</p>
  </li>
  <li>Transition（状态切换方式）
决定按钮在不同状态下的视觉反馈<br />
可选项：
    <ul>
      <li>None 没有任何状态变化</li>
      <li>Color Tint（默认）
        <ul>
          <li>改变<code class="language-plaintext highlighter-rouge">targetGraphic</code>的颜色</li>
          <li>会出现以下设置：
            <ul>
              <li>Target Graphic：颜色变化作用的目标</li>
              <li>Normal Color：正常状态</li>
              <li>Highlighted Color：鼠标悬停</li>
              <li>Press Color：点击中</li>
              <li>Selected Color：被选中状态（用于导航）</li>
              <li>Disabled Color：禁用状态</li>
              <li>Color Multiplier：颜色强度乘数，<code class="language-plaintext highlighter-rouge">最终颜色 = 原始颜色 * Color Multiplier</code></li>
              <li>Fade Duration：颜色渐变持续时间（秒）</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Sprite Swap
        <ul>
          <li>会切换不同的图片</li>
          <li>会出现以下设置：
            <ul>
              <li>Target Graphic</li>
              <li>Highlighted Sprite</li>
              <li>Pressed Sprite</li>
              <li>Disabled Sprite</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Animation
        <ul>
          <li>触发Animator控制器中的动画状态</li>
          <li>要求你设置一个带有动画状态机的Animator Controller</li>
          <li>字段：
            <ul>
              <li>Normal Trigger</li>
              <li>Highlighted Trigger</li>
              <li>Pressed Trigger</li>
              <li>Disabled Trigger</li>
            </ul>
          </li>
          <li>配合Animator参数使用</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Target Graphic
    <ul>
      <li>设置受Transition控制的<code class="language-plaintext highlighter-rouge">Graphic</code>组件</li>
      <li>通常是按钮本体上的<code class="language-plaintext highlighter-rouge">Image</code></li>
    </ul>
  </li>
  <li>Navigation
    <ul>
      <li>控制键盘或手柄方向键操作时，焦点如何移动</li>
      <li>有四种模式：
        <ul>
          <li>None：不使用导航</li>
          <li>Horizontal / Vertical：自动查找上下左右按钮</li>
          <li>Explicit：手动指定上下左右的按钮</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>OnClick()事件
    <ul>
      <li>设置点击按钮时调用的函数</li>
      <li>类型：UnityEvent（可以托脚本组件 + 指定公开方法）</li>
      <li>多个函数可以同时绑定，按顺序依次调用</li>
    </ul>
  </li>
</ul>

<h4 id="button的继承结构">Button的继承结构</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UIBehaviour
|___ Selectable
          |___Button
</code></pre></div></div>

<p><strong>Selectable</strong>提供了核心交互逻辑：</p>
<ul>
  <li>状态切换</li>
  <li>导航</li>
  <li>是否可交互等逻辑</li>
</ul>

<p><strong>Button</strong>在此基础上扩展了：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">onClick</code>事件触发机制</li>
  <li>响应鼠标点击和键盘操作</li>
</ul>

<h4 id="button的点击事件流程底层">Button的点击事件流程（底层）</h4>
<p>1.场景中有<code class="language-plaintext highlighter-rouge">EventSystem</code> + <code class="language-plaintext highlighter-rouge">GraphicRaycaster</code>
2.鼠标点击UI Canvas上的对象
3.<code class="language-plaintext highlighter-rouge">GraphicRaycaster</code>计算哪个UI元素被点击
4.被点到的UI触发<code class="language-plaintext highlighter-rouge">IPointerClickHandler</code>接口
5.Button继承这个接口，调用<code class="language-plaintext highlighter-rouge">.onClick.Invoke()</code></p>

<h4 id="button示例">Button示例</h4>
<h5 id="基础绑定--点击回调">基础绑定 + 点击回调</h5>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.UI</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ButtonExample</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">Button</span> <span class="n">myButton</span><span class="p">;</span>

  <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">myButton</span><span class="p">.</span><span class="n">onClick</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">OnButtonClick</span><span class="p">);</span>

  <span class="k">void</span> <span class="nf">OnButtonClick</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Click!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="动态创建按钮--设置点击事件">动态创建按钮 + 设置点击事件</h5>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">buttonObj</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">(</span><span class="s">"MyButton"</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">RectTransform</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">CanvasRenderer</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Image</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Button</span><span class="p">));</span>

<span class="n">Button</span> <span class="n">btn</span> <span class="p">=</span> <span class="n">buttonObj</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Button</span><span class="p">&gt;();</span>
<span class="n">btn</span><span class="p">.</span><span class="n">onClick</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"动态按钮点击"</span><span class="p">));</span>
</code></pre></div></div>

<h5 id="控制按钮状态变化">控制按钮状态变化</h5>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myButton</span><span class="p">.</span><span class="n">interactable</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

<span class="n">myButton</span><span class="p">.</span><span class="n">colors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ColorBlock</span>
<span class="p">{</span>
  <span class="n">normalColor</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">white</span><span class="p">,</span> 
  <span class="n">highlightedColor</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">yellow</span><span class="p">,</span> 
  <span class="n">pressedColor</span> <span class="p">=</span> <span class="n">Color</span><span class="p">,</span><span class="n">red</span><span class="p">,</span> 
  <span class="n">disabledColor</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">gray</span><span class="p">,</span> 
  <span class="n">colorMultiplier</span> <span class="p">=</span> <span class="m">1f</span><span class="p">,</span> 
  <span class="n">fadeDuration</span> <span class="p">=</span> <span class="m">0.1f</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="自定义扩展">自定义扩展</h4>
<p>可以通过接口实现更复杂的行为</p>

<table>
  <thead>
    <tr>
      <th>接口</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IPointerEnterHandler</code></td>
      <td>鼠标进入时触发</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IPointerExitHandler</code></td>
      <td>鼠标离开时触发</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IPointerClickHandler</code></td>
      <td>鼠标点击时触发</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ISubmitHandler</code></td>
      <td>键盘回车时触发（按钮聚焦状态下）</td>
    </tr>
  </tbody>
</table>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">MyButtonEx</span> <span class="p">:</span> <span class="n">MonoBehaviour</span><span class="p">,</span> <span class="n">IPointerEnterHandler</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">OnPointerEnter</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">eventData</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"鼠标进入按钮"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h5 id="高级交互">高级交互</h5>
<p>原始<code class="language-plaintext highlighter-rouge">Button</code>不支持长按、双击、右键等高级操作，可以通过扩展<code class="language-plaintext highlighter-rouge">EventTrigger</code>或实现接口自己处理，或自定义实现Button组件</p>

<h3 id="dropdownlegacy">Dropdown(Legacy)</h3>
<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Dropdown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">RectTransform</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Canvas</span><span class="w"> </span><span class="nv">Renderer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Image</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Dropdown</span><span class="w">
  </span><span class="o">|___</span><span class="nb">Label</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="err">当前选中项</span><span class="w">
  </span><span class="o">|___</span><span class="nb">Arrow</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="err">小箭头实现</span><span class="w">
  </span><span class="o">|___</span><span class="nv">Template</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">RectTransform</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Canvas</span><span class="w"> </span><span class="nv">Renderer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Image</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Scroll</span><span class="w"> </span><span class="nv">Rect</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="err">下拉菜单模板</span><span class="w">
        </span><span class="o">|___</span><span class="nv">Viewport</span><span class="w">
        </span><span class="o">|</span><span class="w">      </span><span class="o">|___</span><span class="nv">Content</span><span class="w">
        </span><span class="o">|</span><span class="w">             </span><span class="o">|___</span><span class="nb">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">RectTransform</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Toggle</span><span class="w">
        </span><span class="o">|</span><span class="w">                   </span><span class="o">|___</span><span class="nb">Item</span><span class="w"> </span><span class="nb">Background</span><span class="w">
        </span><span class="o">|</span><span class="w">                   </span><span class="o">|___</span><span class="nb">Item</span><span class="w"> </span><span class="nv">Checkmark</span><span class="w">
        </span><span class="o">|</span><span class="w">                   </span><span class="o">|___</span><span class="nb">Item</span><span class="w"> </span><span class="nb">Label</span><span class="w">
        </span><span class="o">|___</span><span class="nv">Scrollbar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">RectTransform</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Canvas</span><span class="w"> </span><span class="nv">Renderer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Image</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Scrollbar</span><span class="w">
                </span><span class="o">|___</span><span class="nv">Sliding</span><span class="w"> </span><span class="nb">Area</span><span class="w">
                           </span><span class="o">|___</span><span class="nv">Handle</span><span class="w">
</span></code></pre></div></div>

<h4 id="dropdown-panel">Dropdown Panel</h4>

<p><img src="/assets/images/DropdownPanel.jpg" alt="DropdownPanel" /></p>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Template</strong></td>
      <td>展开后的菜单列表的模板（Template）</td>
    </tr>
    <tr>
      <td><strong>Caption Text</strong></td>
      <td>当前选项显示的 Label 文本组件</td>
    </tr>
    <tr>
      <td><strong>Caption Image</strong></td>
      <td>当前选项显示的 Image（可选）</td>
    </tr>
    <tr>
      <td><strong>Item Text</strong></td>
      <td>下拉项显示用的 Text</td>
    </tr>
    <tr>
      <td><strong>Item Image</strong></td>
      <td>下拉项使用的图片（可选）</td>
    </tr>
    <tr>
      <td><strong>Options</strong></td>
      <td>所有的选项，<code class="language-plaintext highlighter-rouge">Dropdown.OptionData</code> 列表</td>
    </tr>
    <tr>
      <td><strong>Value</strong></td>
      <td>当前选中项的索引</td>
    </tr>
    <tr>
      <td><strong>Alpha Fade Speed</strong></td>
      <td>下拉列表打开或关闭时，列表的透明度变化速度</td>
    </tr>
    <tr>
      <td><strong>OnValueChanged</strong></td>
      <td>回调事件（当选项改变时触发）</td>
    </tr>
  </tbody>
</table>

<h4 id="scroll-rect-panel">Scroll Rect Panel</h4>
<p>Dropdown上的Scroll Rect是专用于Dropdown的，区别于通用的Scroll Rect</p>

<p><img src="/assets/images/ScrollRectPanelofDropdown.jpg" alt="ScrollRectPanelofDropdown" /></p>

<table>
  <thead>
    <tr>
      <th>组件/属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Content</strong></td>
      <td>要滚动的内容（通常是一个RectTransform，里面包含所有需要滚动的元素）</td>
    </tr>
    <tr>
      <td><strong>Viewport</strong></td>
      <td>可视区域（显示区域），内容超出部分会被裁剪</td>
    </tr>
    <tr>
      <td><strong>Horizontal/Vertical</strong></td>
      <td>是否开启水平或垂直滚动</td>
    </tr>
    <tr>
      <td><strong>Movement Type</strong></td>
      <td>滚动行为类型：</td>
    </tr>
    <tr>
      <td>    - Unrestricted</td>
      <td>内容滚动无限制，超出视口可自由移动</td>
    </tr>
    <tr>
      <td>    - Elastic</td>
      <td>弹性滚动，拖拽到边界时会有弹回效果</td>
    </tr>
    <tr>
      <td>    - Clamped</td>
      <td>内容滚动被限制在边界内，无法拖出视口之外</td>
    </tr>
    <tr>
      <td><strong>Elasticity</strong></td>
      <td>弹性系数，决定弹性滚动的“软硬度”</td>
    </tr>
    <tr>
      <td><strong>Inertia</strong></td>
      <td>惯性开关，决定拖拽释放后内容是否继续滑动</td>
    </tr>
    <tr>
      <td><strong>Deceleration Rate</strong></td>
      <td>惯性减速度，惯性滚动速度衰减快慢</td>
    </tr>
    <tr>
      <td><strong>Scroll Sensitivity</strong></td>
      <td>鼠标滚轮或触控滑动的灵敏度</td>
    </tr>
    <tr>
      <td><strong>OnValueChanged</strong></td>
      <td>滚动事件</td>
    </tr>
  </tbody>
</table>

<h5 id="工作原理">工作原理</h5>
<ul>
  <li>Scroll Rect监听用户的拖拽操作，根据拖动距离改变Content的位置</li>
  <li>超出Viewport的区域的内容会被裁剪</li>
  <li>支持惯性滚动，让滚动更自然流畅</li>
  <li>可以通过代码控制滚动位置、滚动监听事件等</li>
</ul>

<h4 id="viewport">Viewport</h4>

<ul>
  <li>Viewport是一个RectTransform，它定义了下拉列表展开时可视的区域大小和位置</li>
  <li>Viewport通常带有一个<code class="language-plaintext highlighter-rouge">Mask</code>组件（或<code class="language-plaintext highlighter-rouge">RectMask2D</code>），用来裁剪内容， 确保超出范围的内容不显示</li>
  <li>Viewport下挂载<code class="language-plaintext highlighter-rouge">Content</code>，Content里会动态生成每个选项 （Item）</li>
  <li>Content是一个垂直排列的容器（通常有Vertical Layout Group和 Content Size Fitter），它控制所有选项的排列和尺寸</li>
</ul>

<h4 id="示例">示例</h4>
<p><strong>创建一个Dropdown并监听选择变化</strong></p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.UI</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">DropdownExample</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">Dropdown</span> <span class="n">myDropdown</span><span class="p">;</span>

  <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">myDropdown</span><span class="p">.</span><span class="n">onValueChanged</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">OnDropdownValueChanged</span><span class="p">);</span>

    <span class="n">myDropdown</span><span class="p">.</span><span class="n">options</span><span class="p">.</span><span class="nf">Clear</span><span class="p">();</span>
    <span class="n">myDropdown</span><span class="p">.</span><span class="n">options</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">Dropdown</span><span class="p">.</span><span class="nf">OptionData</span><span class="p">(</span><span class="s">"选项 A"</span><span class="p">));</span>
    <span class="n">myDropdown</span><span class="p">.</span><span class="n">options</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">Dropdown</span><span class="p">.</span><span class="nf">OptionData</span><span class="p">(</span><span class="s">"选项 B"</span><span class="p">));</span>
    <span class="n">myDropdown</span><span class="p">.</span><span class="n">options</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">Dropdown</span><span class="p">.</span><span class="nf">OptionData</span><span class="p">(</span><span class="s">"选项 C"</span><span class="p">));</span>

    <span class="n">myDropdown</span><span class="p">.</span><span class="k">value</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nf">OnDropdownValueChanged</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"当前选择索引："</span> <span class="p">+</span> <span class="n">index</span><span class="p">);</span>
    <span class="n">Dubug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"当前选择内容："</span> <span class="p">+</span> <span class="n">myDropdown</span><span class="p">.</span><span class="n">options</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">text</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="扩展">扩展</h4>

<table>
  <thead>
    <tr>
      <th>用法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>动态加载选项</td>
      <td>用代码控制 options 数据源，比如从配置文件读取</td>
    </tr>
    <tr>
      <td>多级联动</td>
      <td>比如：国家 -&gt; 城市，选择国家后动态更新城市列表</td>
    </tr>
    <tr>
      <td>自定义表现</td>
      <td>替换 Item 的 Toggle 结构，实现自定义布局或图标</td>
    </tr>
  </tbody>
</table>

<h4 id="api">API</h4>

<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">options</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;Dropdown.OptionData&gt;</code></td>
      <td>Dropdown 的所有选项列表</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">value</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>当前选中选项的索引（从 0 开始）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">captionText</code></td>
      <td><code class="language-plaintext highlighter-rouge">Text</code></td>
      <td>用于显示当前选择文本的 UI Text 组件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">captionImage</code></td>
      <td><code class="language-plaintext highlighter-rouge">Image</code></td>
      <td>显示当前选择图片的 Image 组件（可选）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">itemText</code></td>
      <td><code class="language-plaintext highlighter-rouge">Text</code></td>
      <td>Dropdown 选项模板中 Item 的文本组件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">itemImage</code></td>
      <td><code class="language-plaintext highlighter-rouge">Image</code></td>
      <td>Dropdown 选项模板中 Item 的图片组件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">template</code></td>
      <td><code class="language-plaintext highlighter-rouge">RectTransform</code></td>
      <td>Dropdown 选项列表模板（包含 Viewport 等）</td>
    </tr>
  </tbody>
</table>

<p><strong>Event</strong></p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">onValueChanged</code></td>
      <td><code class="language-plaintext highlighter-rouge">Dropdown.DropdownEvent</code></td>
      <td>选中项改变时触发，带选中索引</td>
    </tr>
  </tbody>
</table>

<p><strong>Method</strong></p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>签名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ClearOptions()</code></td>
      <td><code class="language-plaintext highlighter-rouge">void ClearOptions()</code></td>
      <td>清空所有选项</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AddOptions(List&lt;string&gt;)</code></td>
      <td><code class="language-plaintext highlighter-rouge">void AddOptions(List&lt;string&gt; options)</code></td>
      <td>添加字符串选项列表</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AddOptions(List&lt;Sprite&gt;)</code></td>
      <td><code class="language-plaintext highlighter-rouge">void AddOptions(List&lt;Sprite&gt; options)</code></td>
      <td>添加图片选项列表</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AddOptions(List&lt;Dropdown.OptionData&gt;)</code></td>
      <td><code class="language-plaintext highlighter-rouge">void AddOptions(List&lt;Dropdown.OptionData&gt; options)</code></td>
      <td>添加 OptionData 列表</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">RefreshShownValue()</code></td>
      <td><code class="language-plaintext highlighter-rouge">void RefreshShownValue()</code></td>
      <td>刷新当前显示的选项文本和图片</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Show()</code></td>
      <td><code class="language-plaintext highlighter-rouge">void Show()</code></td>
      <td>展开下拉列表</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Hide()</code></td>
      <td><code class="language-plaintext highlighter-rouge">void Hide()</code></td>
      <td>关闭下拉列表</td>
    </tr>
  </tbody>
</table>

<h3 id="input-fieldlegacy">Input Field(Legacy)</h3>
<p><code class="language-plaintext highlighter-rouge">Input Field</code>是Unity中用于接收用户输入的UI组件，主要用于文本输入（如用户名，密码，聊天框等）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>InputField
|—— Palceholder(Text或TMP_Text)
|__ Text
</code></pre></div></div>

<ul>
  <li>InputField：主控件，管理交互逻辑</li>
  <li>Placeholder：提示文字，内容为空时显示</li>
  <li>Text：用户输入文本</li>
</ul>

<h4 id="input-field-panel">Input Field Panel</h4>

<p><img src="/assets/images/InputFieldPanel.jpg" alt="InputFieldPanel" /></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Text Component</code></td>
      <td>用户输入文字组件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">text</code></td>
      <td>当前输入的字符串</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">placeholder</code></td>
      <td>占位文字组件（Text 或 TMP_Text）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">characterLimit</code></td>
      <td>输入字符数限制</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">contentType</code></td>
      <td>内容类型（如密码、整数、电子邮件等）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">lineType</code></td>
      <td>单行或多行</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">inputType</code></td>
      <td>是否隐藏输入字符（如密码）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">keyboardType</code></td>
      <td>移动端的虚拟键盘类型</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">readOnly</code></td>
      <td>是否只读</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">caretBlinkRate</code></td>
      <td>光标闪烁速度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Custom Caret Color</code></td>
      <td>自定义光标颜色</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Hide Mobile Input</code></td>
      <td>隐藏移动设备键盘上方的原生输入框</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">selectionColor</code></td>
      <td>选中文本的背景色</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">should Activate OnSelect</code></td>
      <td>当InputField被选中时，是否自动激活并弹出键盘</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">On Value Changed</code></td>
      <td>当用户每次修改输入内容时调用（每个字符变动都会触发）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">On Submit</code></td>
      <td>当用户提交输入时触发即按下回车键时</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">On End Edit</code></td>
      <td>当输入框失去焦点或用户按下回车键时触发</td>
    </tr>
  </tbody>
</table>

<h4 id="api-1">API</h4>

<h5 id="properties-2">Properties</h5>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">text</code></td>
      <td><code class="language-plaintext highlighter-rouge">string</code></td>
      <td>当前输入框中的文本内容</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">textComponent</code></td>
      <td><code class="language-plaintext highlighter-rouge">Text</code></td>
      <td>用于显示文本的 UI 组件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">placeholder</code></td>
      <td><code class="language-plaintext highlighter-rouge">Graphic</code></td>
      <td>占位符（提示文本）组件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">characterLimit</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>最大输入字符数，0 表示不限制</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">contentType</code></td>
      <td><code class="language-plaintext highlighter-rouge">ContentType</code></td>
      <td>输入内容类型（标准、密码、数字等）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">inputType</code></td>
      <td><code class="language-plaintext highlighter-rouge">InputType</code></td>
      <td>输入显示方式（标准、密码隐藏等）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">keyboardType</code></td>
      <td><code class="language-plaintext highlighter-rouge">TouchScreenKeyboardType</code></td>
      <td>移动端软键盘类型</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">characterValidation</code></td>
      <td><code class="language-plaintext highlighter-rouge">CharacterValidation</code></td>
      <td>字符校验规则</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">multiLine</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否支持多行输入</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">lineType</code></td>
      <td><code class="language-plaintext highlighter-rouge">LineType</code></td>
      <td>输入框的换行方式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">readOnly</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否只读</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">onValidateInput</code></td>
      <td><code class="language-plaintext highlighter-rouge">Func&lt;string, int, char&gt;</code></td>
      <td>自定义输入字符验证回调</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">caretPosition</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>当前光标位置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">caretWidth</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>光标宽度（像素）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">caretBlinkRate</code></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>光标闪烁速度（次数/秒）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">caretColor</code></td>
      <td><code class="language-plaintext highlighter-rouge">Color</code></td>
      <td>光标颜色</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">customCaretColor</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否使用自定义光标颜色</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">selectionColor</code></td>
      <td><code class="language-plaintext highlighter-rouge">Color</code></td>
      <td>文本选中时的背景色</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">selectionAnchorPosition</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>选中起点</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">selectionFocusPosition</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>选中终点</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">shouldHideMobileInput</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否隐藏移动端原生输入框</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">touchScreenKeyboard</code></td>
      <td><code class="language-plaintext highlighter-rouge">TouchScreenKeyboard</code></td>
      <td>当前软键盘实例</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isFocused</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>输入框当前是否获得焦点</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">wasCanceled</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>输入是否被取消（如按返回键）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">onValueChanged</code></td>
      <td><code class="language-plaintext highlighter-rouge">UnityEvent&lt;string&gt;</code></td>
      <td>输入内容改变时触发</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">onEndEdit</code></td>
      <td><code class="language-plaintext highlighter-rouge">UnityEvent&lt;string&gt;</code></td>
      <td>输入结束时触发（失焦或按回车）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">asteriskChar</code></td>
      <td><code class="language-plaintext highlighter-rouge">char</code></td>
      <td>密码输入时显示的字符（默认是 <code class="language-plaintext highlighter-rouge">*</code>）</td>
    </tr>
  </tbody>
</table>

<h5 id="public-methods">Public Methods</h5>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ActivateInputField()</code></td>
      <td>激活输入框，开始处理输入事件（获得焦点，弹出软键盘）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DeactivateInputField()</code></td>
      <td>取消激活输入框，停止处理事件；如果输入未取消，会发送提交事件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ForceLabelUpdate()</code></td>
      <td>强制立即刷新文本显示（重新计算光标位置和可见文本）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GraphicUpdateComplete()</code></td>
      <td>（接口方法）通知画布图形更新完成</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LayoutComplete()</code></td>
      <td>（接口方法）通知布局更新完成</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MoveTextEnd()</code></td>
      <td>将光标移动到文本末尾</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MoveTextStart()</code></td>
      <td>将光标移动到文本开头</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnBeginDrag()</code></td>
      <td>处理开始拖动事件，判断是否监听拖动</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnDeselect()</code></td>
      <td>处理失去焦点事件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnDrag()</code></td>
      <td>处理拖动事件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnEndDrag()</code></td>
      <td>处理拖动结束事件，停止监听拖动</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnPointerClick()</code></td>
      <td>处理指针点击事件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnPointerDown()</code></td>
      <td>处理指针按下事件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnSubmit()</code></td>
      <td>处理提交事件（通常是按回车或软键盘上的提交键）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnUpdateSelected()</code></td>
      <td>处理选中更新事件（持续输入、光标移动等）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ProcessEvent()</code></td>
      <td>内部辅助函数，用于处理输入事件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Rebuild()</code></td>
      <td>重建输入框几何体（光标、选中高亮等）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetTextWithoutNotify()</code></td>
      <td>设置输入框文本内容但不触发 <code class="language-plaintext highlighter-rouge">onValueChanged</code> 事件，常用于程序内部修改文本时避免事件递归触发</td>
    </tr>
  </tbody>
</table>

<h5 id="protected-methods">Protected Methods</h5>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>功能说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Append(char c)</code></td>
      <td>在输入框当前文本末尾追加一个字符。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ClampPos(ref int pos)</code></td>
      <td>限制传入的光标或选择位置，保证不超过文本长度范围。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetCharacterIndexFromPosition(Vector2 pos)</code></td>
      <td>根据鼠标/指针位置计算对应文本中的字符索引。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">KeyPressed(Event evt)</code></td>
      <td>处理键盘事件，根据按键执行对应动作（输入、删除、光标移动等）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnDisable()</code></td>
      <td>MonoBehaviour 生命周期函数，输入框禁用时调用（做清理等）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnFocus()</code></td>
      <td>输入框获得焦点时初始化相关属性，准备输入。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SelectAll()</code></td>
      <td>选中输入框内所有文本，通常用于快捷键 Ctrl+A 操作。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SendOnSubmit()</code></td>
      <td>触发提交事件（相当于用户确认输入，如按回车）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UpdateLabel()</code></td>
      <td>刷新显示的文本内容，更新 UI 视图（光标和选区位置）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Validate(string text, int charIndex, char addedChar)</code></td>
      <td>对输入的字符进行校验（依据 <code class="language-plaintext highlighter-rouge">characterValidation</code> 设置）。</td>
    </tr>
  </tbody>
</table>

<h5 id="delegates">Delegates</h5>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">onValidateInput</code></td>
      <td><code class="language-plaintext highlighter-rouge">InputField.OnValidateInput</code></td>
      <td>自定义每个输入字符的校验</td>
    </tr>
  </tbody>
</table>

<h3 id="textmeshprotmp">TextMeshPro(TMP)</h3>
<p>TextMeshPro是Unity提供的高级文本渲染系统，相比传统的<code class="language-plaintext highlighter-rouge">UI.Text</code>和<code class="language-plaintext highlighter-rouge">TextMesh</code>，它提供了：</p>
<ul>
  <li>更清晰的字体渲染（支持SDF技术）</li>
  <li>丰富的排版控制（文字间距、行距、边框、阴影等）</li>
  <li>更强的富文本支持（颜色、图标、动画）</li>
  <li>更高的性能（批量合并、材质复用）</li>
</ul>

<h4 id="tmp组件类型">TMP组件类型</h4>

<table>
  <thead>
    <tr>
      <th>组件名称</th>
      <th>用途说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>TextMeshPro (3D)</strong></td>
      <td>用于3D世界的文本渲染（替代 <code class="language-plaintext highlighter-rouge">TextMesh</code>）</td>
    </tr>
    <tr>
      <td><strong>TextMeshProUGUI (UI)</strong></td>
      <td>用于UI Canvas的文本渲染（替代 <code class="language-plaintext highlighter-rouge">UI.Text</code>）</td>
    </tr>
  </tbody>
</table>

<h4 id="tmp-importer">TMP Importer</h4>

<p><img src="/assets/images/TMPImporter.jpg" alt="TMP Importer" /></p>

<p>TMP Importer是Unity第一次导入TextMeshPro包时自动弹出的一个向导窗口，也可以手动从菜单中打开<br />
它的作用是：</p>
<ul>
  <li>导入TMP的资源（默认字体、材质、示例场景等）</li>
  <li>升级旧的UI元素（可选，把现有的<code class="language-plaintext highlighter-rouge">Text</code>升级为<code class="language-plaintext highlighter-rouge">TextMeshProUGUI</code>）</li>
  <li>帮助初始化TMP设置</li>
</ul>

<h5 id="何时会看到tmp-importer">何时会看到TMP Importer</h5>
<ul>
  <li>第一次使用TMP功能时</li>
  <li>第一次安装TMP包时</li>
  <li>手动打开 <code class="language-plaintext highlighter-rouge">Window -&gt; TextMeshPro -&gt; Import TMP Essential Resources</code></li>
</ul>

<h5 id="tmp-importer提供的资源内容">TMP Importer提供的资源内容</h5>

<table>
  <thead>
    <tr>
      <th>内容</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Default Font Asset</strong></td>
      <td>默认使用的字体（LiberationSans SDF）</td>
    </tr>
    <tr>
      <td><strong>Default Material Presets</strong></td>
      <td>支持描边、阴影的材质</td>
    </tr>
    <tr>
      <td><strong>TMP Settings.asset</strong></td>
      <td>全局设置配置</td>
    </tr>
    <tr>
      <td><strong>Shaders</strong></td>
      <td>TMP 的渲染器使用的 SDF Shader</td>
    </tr>
    <tr>
      <td><strong>Examples &amp; Extras（可选）</strong></td>
      <td>示例场景、脚本、UI 风格演示等</td>
    </tr>
  </tbody>
</table>

<h4 id="tmp-vs-textlegacy">TMP vs Text(Legacy)</h4>

<table>
  <thead>
    <tr>
      <th>功能/特性</th>
      <th>Unity UI.Text</th>
      <th>TextMeshPro</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>清晰度</td>
      <td>低</td>
      <td>高（SDF）</td>
    </tr>
    <tr>
      <td>富文本支持</td>
      <td>有限</td>
      <td>强大</td>
    </tr>
    <tr>
      <td>图文混排</td>
      <td>无</td>
      <td>有</td>
    </tr>
    <tr>
      <td>字体控制</td>
      <td>基本</td>
      <td>精细</td>
    </tr>
    <tr>
      <td>性能（大批量）</td>
      <td>低</td>
      <td>高</td>
    </tr>
    <tr>
      <td>动态字体加载</td>
      <td>有</td>
      <td>支持</td>
    </tr>
  </tbody>
</table>

<p><strong>SDF字体</strong>
TMP使用SDF来实现高质量的文本缩放和效果（描边、投影）</p>
<ul>
  <li>在导入字体时会生成一个<code class="language-plaintext highlighter-rouge">.asset</code>文件（字体图集 + 字形信息）</li>
  <li>SDF渲染不依赖分辨率，UI可以任意缩放不失真</li>
</ul>

<h4 id="tmp---text">TMP - Text</h4>

<p><img src="/assets/images/TMPTextPanel_1.jpg" alt="TMPTextPanel_1" />
<img src="/assets/images/TMPTextPanel_2.jpg" alt="TMPTextPanel_2" /></p>

<h5 id="基础设置区">基础设置区</h5>
<ul>
  <li>Text Input：文字内容输入框（直接修改会改变显示内容）</li>
  <li>Enable RTL Editor：启用从右到左语言支持（如阿拉伯语、希伯来语）</li>
  <li>Text Style：选择预设的文字样式（一般用不到，除非用Style Sheet）</li>
</ul>

<h5 id="main-settings">Main Settings</h5>
<ul>
  <li>Font Asset：当前使用的字体资源</li>
  <li>Material Preset：当前字体使用的材质（会影响颜色、描边等）</li>
  <li>Font Style：B（粗体）、I（斜体）、U（下划线）、S（删除线）、AB（全部大写）、SC（小型大写）</li>
  <li>Font Size / Auto Size：字号和是否自动缩放</li>
  <li>Vertex Color：文字的顶点色（可用于动态变色）</li>
  <li>Spacing Options：控制字符、单词、段落、行的间距</li>
  <li>Mapping：水平/垂直映射方式，一般设为Character即可</li>
</ul>

<h5 id="extra-settings">Extra Settings</h5>

<ul>
  <li>Margins：文字四边内边距</li>
  <li>Geometry Sorting：渲染顺序（用于粒子、透明叠加等高级场景）</li>
  <li>Is Scale Static：是否标记为静态缩放（用于性能优化）</li>
  <li>Rich Text：是否允许富文本标签（如 <color>）</color></li>
  <li>Raycast Target：是否能被点击或射线检测命中</li>
  <li>Maskable：是否允许被 UI Mask 遮罩裁剪</li>
  <li>Parse Escape Characters：是否解析转义符 \n、\t</li>
  <li>Visible Descender：显示下沉字符（如 g, y）的空间</li>
  <li>Sprite Asset：图文混排用的精灵图集</li>
  <li>Style Sheet Asset：文字样式预设集合</li>
  <li>Kerning：特定字符对之间的间距微调，用于让文本在视觉上更加美观、易读</li>
  <li>Extra Padding：给字符添加额外的像素充填区域，以避免某些视觉效果被裁剪或显示不完整</li>
</ul>

<h5 id="material-inspector">Material Inspector</h5>

<ul>
  <li>Shader</li>
  <li>Face（主体文字）
    <ul>
      <li>Color：字体本体颜色</li>
      <li>Softness：模糊程度（文字边缘越柔和）</li>
      <li>Dilate：扩张/收缩字体（负值让文字细一点）</li>
    </ul>
  </li>
  <li>Outline（描边）
    <ul>
      <li>Color：描边颜色</li>
      <li>Thickness：描边厚度（默认是0，没有描边）</li>
    </ul>
  </li>
  <li>Underlay（阴影）</li>
  <li>Debug Settings（Shader调试）</li>
</ul>

<h3 id="toggle">Toggle</h3>

<h4 id="结构">结构</h4>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Toggle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Rect</span><span class="w"> </span><span class="nv">Transform</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Toggle</span><span class="w">
</span><span class="o">|___</span><span class="nb">Background</span><span class="p">(</span><span class="nb">Image</span><span class="p">)</span><span class="o">:</span><span class="err">勾选框的背景</span><span class="w">
</span><span class="o">|</span><span class="w">        </span><span class="o">|___</span><span class="nv">Checkmark</span><span class="err">（</span><span class="nb">Image</span><span class="err">）：√</span><span class="w">
</span><span class="o">|___</span><span class="nb">Label</span><span class="p">(</span><span class="nb">Text</span><span class="p">)</span><span class="err">：名称</span><span class="w">
</span></code></pre></div></div>

<h4 id="toggle-panel">Toggle Panel</h4>
<p><img src="/assets/images/TogglePanel.jpg" alt="TogglePanel" /></p>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isOn</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>当前是否勾选，<code class="language-plaintext highlighter-rouge">true</code> 表示已选中</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">onValueChanged</code></td>
      <td><code class="language-plaintext highlighter-rouge">UnityEvent&lt;bool&gt;</code></td>
      <td>状态切换时的回调，传入参数为新的状态</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">interactable</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否可以被点击</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">graphic</code></td>
      <td><code class="language-plaintext highlighter-rouge">Graphic</code></td>
      <td>勾选图像（Checkmark）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">group</code></td>
      <td><code class="language-plaintext highlighter-rouge">ToggleGroup</code></td>
      <td>所属的 ToggleGroup（用于单选）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Toggle Transition</code></td>
      <td><code class="language-plaintext highlighter-rouge">Toggle Transition</code></td>
      <td>状态切换时的视觉过渡效果</td>
    </tr>
  </tbody>
</table>

<h4 id="示例-1">示例</h4>
<h5 id="获取并监听toggle状态">获取并监听Toggle状态</h5>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.UI</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ToggleExample</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">Toggle</span> <span class="n">myToggle</span><span class="p">;</span>

  <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">myToggle</span><span class="p">.</span><span class="n">onValueChanged</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">OnToggleChanged</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nf">OnToggleChanged</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isOn</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"当前 Toggle 状态"</span> <span class="p">+</span> <span class="n">isOn</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>
<h4 id="toggle-group单选组">Toggle Group(单选组)</h4>
<p><code class="language-plaintext highlighter-rouge">ToggleGroup</code>组件用于实现多个Toggle的单选功能，类似于网页中的<code class="language-plaintext highlighter-rouge">radio button</code></p>

<p>设置方法：<br />
1.创建一个空物体并挂载<code class="language-plaintext highlighter-rouge">ToggleGroup</code><br />
2.将多个Toggle拖入该物体并在Inspector中的Toggle组件上设置<code class="language-plaintext highlighter-rouge">Group</code>为这个ToggleGroup<br />
3.每次只能勾选一个Toggle</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">ToggleGroup</span> <span class="n">toggleGroup</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">GetSelectedToggle</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Toggle</span> <span class="n">selected</span> <span class="p">=</span> <span class="n">toggleGroup</span><span class="p">.</span><span class="nf">ActiveToggles</span><span class="p">().</span><span class="nf">FirstOrDefault</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">selected</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"当前选中项： "</span> <span class="p">+</span> <span class="n">selected</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="api-2">API</h4>
<h5 id="properties-3">Properties</h5>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">graphic</code></td>
      <td><code class="language-plaintext highlighter-rouge">Graphic</code></td>
      <td>受状态影响的图像，通常是用于显示勾选标记的 <code class="language-plaintext highlighter-rouge">Checkmark</code>（<code class="language-plaintext highlighter-rouge">Image</code> 或其他 <code class="language-plaintext highlighter-rouge">Graphic</code>）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">group</code></td>
      <td><code class="language-plaintext highlighter-rouge">ToggleGroup</code></td>
      <td>当前 Toggle 所属于的 ToggleGroup，用于实现“单选”逻辑。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isOn</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>当前 Toggle 是否被选中，<code class="language-plaintext highlighter-rouge">true</code> 表示“开”；也可用于代码设置状态。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">onValueChanged</code></td>
      <td><code class="language-plaintext highlighter-rouge">UnityEvent&lt;bool&gt;</code></td>
      <td>当 Toggle 状态发生改变时触发的事件回调，参数是新的状态（true/false）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">toggleTransition</code></td>
      <td><code class="language-plaintext highlighter-rouge">Toggle.ToggleTransition</code></td>
      <td>状态切换的视觉过渡方式，枚举类型：<code class="language-plaintext highlighter-rouge">None</code> 或 <code class="language-plaintext highlighter-rouge">Fade</code>（淡入淡出）。</td>
    </tr>
  </tbody>
</table>

<h5 id="public-methods-1">Public Methods</h5>

<table>
  <thead>
    <tr>
      <th>方法 / 接口</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GraphicUpdateComplete()</code></td>
      <td><code class="language-plaintext highlighter-rouge">ICanvasElement</code> 接口方法</td>
      <td>图形更新完成时被调用（Canvas 渲染流程的一部分）。通常无需手动调用。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LayoutComplete()</code></td>
      <td><code class="language-plaintext highlighter-rouge">ICanvasElement</code> 接口方法</td>
      <td>布局更新完成时调用，确保组件根据布局正确显示。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Rebuild(CanvasUpdate update)</code></td>
      <td><code class="language-plaintext highlighter-rouge">ICanvasElement</code> 接口方法</td>
      <td>当 UI Canvas 需要重建时被调用，用于更新 Toggle 的布局或图形状态。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnPointerClick(PointerEventData eventData)</code></td>
      <td><code class="language-plaintext highlighter-rouge">IPointerClickHandler</code> 接口方法</td>
      <td>当 Toggle 被鼠标点击或触控点击时触发。会自动切换 <code class="language-plaintext highlighter-rouge">isOn</code> 状态并触发 <code class="language-plaintext highlighter-rouge">onValueChanged</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnSubmit(BaseEventData eventData)</code></td>
      <td><code class="language-plaintext highlighter-rouge">ISubmitHandler</code> 接口方法</td>
      <td>当用户按下“提交键”（如 Enter）时触发（用于键盘/手柄操作 UI）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetIsOnWithoutNotify(bool value)</code></td>
      <td>自定义方法</td>
      <td><strong>设置 Toggle 状态但不触发 <code class="language-plaintext highlighter-rouge">onValueChanged</code> 回调</strong>，适合你在代码中手动切换状态但不希望触发监听器时使用。</td>
    </tr>
  </tbody>
</table>

<h5 id="protected-mehtods">Protected Mehtods</h5>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnDisable</code></td>
      <td>参照MonoBehaviour.OnDisable</td>
    </tr>
  </tbody>
</table>

<h3 id="slider">Slider</h3>
<h4 id="结构-1">结构</h4>
<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Slider</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Rect</span><span class="w"> </span><span class="nv">Transform</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Slider</span><span class="w">
</span><span class="o">|___</span><span class="nb">Background</span><span class="p">(</span><span class="nb">Image</span><span class="p">)</span><span class="err">：滑动条颜色（不可变部分）</span><span class="w">
</span><span class="o">|___</span><span class="nv">Fill</span><span class="w"> </span><span class="nb">Area</span><span class="err">：包裹</span><span class="nv">Fill</span><span class="err">区域</span><span class="w">
</span><span class="o">|</span><span class="w">       </span><span class="o">|___</span><span class="nv">Fill</span><span class="p">(</span><span class="nv">image</span><span class="p">)</span><span class="err">：实际充填区域，随着值的改变而拉伸</span><span class="o">/</span><span class="err">缩放</span><span class="w">
</span><span class="o">|___</span><span class="nv">Handle</span><span class="w"> </span><span class="nv">Slide</span><span class="w"> </span><span class="nb">Area</span><span class="err">：可滑动范围的区域容器</span><span class="w">
             </span><span class="o">|___</span><span class="nv">Handle</span><span class="p">(</span><span class="nv">image</span><span class="p">)</span><span class="err">：可拖动的滑块，通常是个图标或者圆点</span><span class="w">
</span></code></pre></div></div>

<h4 id="slider-panel">Slider Panel</h4>
<p><img src="/assets/images/SliderPanel.jpg" alt="SliderPanel" /></p>

<ul>
  <li>Whole Numbers：是否只允许整数</li>
</ul>

<h4 id="api-3">API</h4>
<h5 id="properties-4">Properties</h5>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">direction</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">Slider.Direction</code></td>
      <td>滑动条的方向，从最小值到最大值的滑动方向。<br />可选：<br />• <code class="language-plaintext highlighter-rouge">LeftToRight</code><br />• <code class="language-plaintext highlighter-rouge">RightToLeft</code><br />• <code class="language-plaintext highlighter-rouge">BottomToTop</code><br />• <code class="language-plaintext highlighter-rouge">TopToBottom</code></td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">fillRect</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">RectTransform</code></td>
      <td>指定一个 <code class="language-plaintext highlighter-rouge">RectTransform</code>，作为滑动条的填充区域。滑动值变化时会调整此区域的大小。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">handleRect</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">RectTransform</code></td>
      <td>指定滑块的 <code class="language-plaintext highlighter-rouge">RectTransform</code>，用于显示可拖动的手柄。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">maxValue</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>滑动条允许的最大值。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">minValue</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>滑动条允许的最小值。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">value</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>当前的滑动值。可以手动设置，会同步更新滑块位置和填充。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">normalizedValue</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">float</code> (只读/可设)</td>
      <td>当前值归一化后（范围 0 到 1）的表示。设置它可以等价于设置 <code class="language-plaintext highlighter-rouge">value</code>。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">onValueChanged</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">UnityEvent&lt;float&gt;</code></td>
      <td>当 <code class="language-plaintext highlighter-rouge">value</code> 改变时触发的回调事件。可以在 Inspector 中指定函数响应变化。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">wholeNumbers</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否只允许整数值。勾选后即使你滑动到小数位置，也会自动取整。</td>
    </tr>
  </tbody>
</table>

<p><strong>示例：设置Slider参数</strong></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">Slider</span> <span class="n">mySlider</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">mySlider</span><span class="p">.</span><span class="n">minValue</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
  <span class="n">mySlider</span><span class="p">.</span><span class="n">maxValue</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
  <span class="n">mySlider</span><span class="p">.</span><span class="k">value</span> <span class="p">=</span> <span class="m">50</span><span class="p">;;</span>
  <span class="n">mySlider</span><span class="p">.</span><span class="n">wholeNumbers</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>

  <span class="n">mySlider</span><span class="p">.</span><span class="n">onValueChanged</span><span class="p">.</span><span class="nf">AddListener</span><span class="p">(</span><span class="n">OnSliderValueChanged</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">OnSliderValueChanged</span><span class="p">(</span><span class="kt">float</span> <span class="n">val</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"当前值"</span> <span class="p">+</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="public-methods-2">Public Methods</h5>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>来源接口 / 基类</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>FindSelectableOnDown()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Selectable</code></td>
      <td>返回下方的可选 UI 元素（用于键盘/手柄导航）。</td>
    </tr>
    <tr>
      <td><strong>FindSelectableOnUp()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Selectable</code></td>
      <td>返回上方的可选 UI 元素。</td>
    </tr>
    <tr>
      <td><strong>FindSelectableOnLeft()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Selectable</code></td>
      <td>返回左侧的可选 UI 元素。</td>
    </tr>
    <tr>
      <td><strong>FindSelectableOnRight()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Selectable</code></td>
      <td>返回右侧的可选 UI 元素。</td>
    </tr>
    <tr>
      <td><strong>GraphicUpdateComplete()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ICanvasElement</code></td>
      <td>在 UI 图形重绘完成时调用。</td>
    </tr>
    <tr>
      <td><strong>LayoutComplete()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ICanvasElement</code></td>
      <td>在 UI 布局更新完成时调用。</td>
    </tr>
    <tr>
      <td><strong>Rebuild(CanvasUpdate update)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ICanvasElement</code></td>
      <td>当 Canvas 需要重建 UI 时调用（刷新布局和图形）。</td>
    </tr>
    <tr>
      <td><strong>OnInitializePotentialDrag(PointerEventData)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">IInitializePotentialDragHandler</code></td>
      <td>初始化拖拽状态，设置拖拽方向或行为。</td>
    </tr>
    <tr>
      <td><strong>OnDrag(PointerEventData)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">IDragHandler</code></td>
      <td>当用户拖动 Handle 时调用，更新滑动值。</td>
    </tr>
    <tr>
      <td><strong>OnMove(AxisEventData)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">IMoveHandler</code></td>
      <td>当使用键盘或手柄操作滑块时调用（如方向键）。</td>
    </tr>
    <tr>
      <td><strong>SetDirection(Direction, bool)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Slider</code> 自身</td>
      <td>设置滑动方向，并决定是否调整 Fill 和 Handle 的布局。</td>
    </tr>
    <tr>
      <td><strong>SetValueWithoutNotify(float)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Slider</code> 自身</td>
      <td>设置数值但不触发 <code class="language-plaintext highlighter-rouge">onValueChanged</code> 回调事件。</td>
    </tr>
  </tbody>
</table>

<h5 id="protected-methods-1">Protected Methods</h5>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnDisable</code></td>
      <td>参照MonoBehaviour.OnDisable</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Set</code></td>
      <td>设置Slider的值</td>
    </tr>
  </tbody>
</table>

<h3 id="scrollbar">Scrollbar</h3>
<p><code class="language-plaintext highlighter-rouge">Scrollbar</code>是一个用于滚动控制的UI组件，常与<code class="language-plaintext highlighter-rouge">ScrollRect</code>搭配使用，控制列表、文本区域、图片等内容的滚动</p>

<h4 id="结构-2">结构</h4>
<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Scrollbar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Rect</span><span class="w"> </span><span class="nv">Transform</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Canvas</span><span class="w"> </span><span class="nv">Renderer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Image</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Scrollbar</span><span class="w">
</span><span class="o">|___</span><span class="nv">Sliding</span><span class="w"> </span><span class="nb">Area</span><span class="err">（滑动轨道范围）</span><span class="w">
           </span><span class="o">|___</span><span class="nv">Handle</span><span class="err">（滑块）</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Rect</span><span class="w"> </span><span class="nv">Transform</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Canvas</span><span class="w"> </span><span class="nv">Renderer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Image</span><span class="w">
</span></code></pre></div></div>

<h4 id="scrollbar-panel">Scrollbar Panel</h4>
<p><img src="/assets/images/ScrollbarPanel.jpg" alt="ScrollbarPanel" /></p>

<ul>
  <li>Size：滑块所占比率，值越小，滑块越短，内容和视口的比例的反映，由ScrollRect进行调节</li>
  <li>numberOfSteps：可选值个数，如果设置 &gt; 1，滑块将分段跳动</li>
</ul>

<h4 id="scrollbar-vs-slider">Scrollbar vs Slider</h4>

<table>
  <thead>
    <tr>
      <th>比较项</th>
      <th><code class="language-plaintext highlighter-rouge">Scrollbar</code></th>
      <th><code class="language-plaintext highlighter-rouge">Slider</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>用途</td>
      <td>滚动内容控制</td>
      <td>数值选择器</td>
    </tr>
    <tr>
      <td>是否可设置 <code class="language-plaintext highlighter-rouge">size</code></td>
      <td>是</td>
      <td>否</td>
    </tr>
    <tr>
      <td>与 <code class="language-plaintext highlighter-rouge">ScrollRect</code> 结合</td>
      <td>常用</td>
      <td>较少</td>
    </tr>
    <tr>
      <td>滑动方式</td>
      <td>滚轮、拖拽、点击轨道</td>
      <td>拖拽或编程控制</td>
    </tr>
  </tbody>
</table>

<h4 id="api-4">API</h4>
<h5 id="properties-5">Properties</h5>

<table>
  <thead>
    <tr>
      <th>成员</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>handleRect</strong></td>
      <td><code class="language-plaintext highlighter-rouge">RectTransform</code></td>
      <td>滑块（Handle）的 RectTransform。</td>
    </tr>
    <tr>
      <td><strong>direction</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Scrollbar.Direction</code></td>
      <td>滑动方向（枚举）。</td>
    </tr>
    <tr>
      <td><strong>value</strong></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>当前滚动值，范围 [0, 1]。</td>
    </tr>
    <tr>
      <td><strong>size</strong></td>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>滑块在轨道中所占比例 [0, 1]。值越小，滑块越短。</td>
    </tr>
    <tr>
      <td><strong>numberOfSteps</strong></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>分段数量。&gt;1 时启用分段滚动。</td>
    </tr>
    <tr>
      <td><strong>onValueChanged</strong></td>
      <td><code class="language-plaintext highlighter-rouge">UnityEvent&lt;float&gt;</code></td>
      <td>滚动值变化时调用。</td>
    </tr>
  </tbody>
</table>

<h6 id="public-methods-3">Public Methods</h6>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>类型 / 接口</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>FindSelectableOnDown()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Selectable</code>（基类）</td>
      <td>返回下方可选的 UI 控件（用于键盘/手柄方向导航）。</td>
    </tr>
    <tr>
      <td><strong>FindSelectableOnLeft()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Selectable</code>（基类）</td>
      <td>返回左侧可选的 UI 控件。</td>
    </tr>
    <tr>
      <td><strong>FindSelectableOnRight()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Selectable</code>（基类）</td>
      <td>返回右侧可选的 UI 控件。</td>
    </tr>
    <tr>
      <td><strong>FindSelectableOnUp()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Selectable</code>（基类）</td>
      <td>返回上方可选的 UI 控件。</td>
    </tr>
    <tr>
      <td><strong>GraphicUpdateComplete()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ICanvasElement</code></td>
      <td>在图形系统更新完成后调用，用于重绘完 UI 后的清理/处理。</td>
    </tr>
    <tr>
      <td><strong>LayoutComplete()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ICanvasElement</code></td>
      <td>布局系统更新完成时调用，通常用于收尾处理。</td>
    </tr>
    <tr>
      <td><strong>OnBeginDrag(PointerEventData)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">IBeginDragHandler</code></td>
      <td>当开始拖动滑块时触发（鼠标按下并准备拖动）。</td>
    </tr>
    <tr>
      <td><strong>OnDrag(PointerEventData)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">IDragHandler</code></td>
      <td>拖动过程中持续触发，更新 <code class="language-plaintext highlighter-rouge">value</code>。</td>
    </tr>
    <tr>
      <td><strong>OnInitializePotentialDrag(PointerEventData)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">IInitializePotentialDragHandler</code></td>
      <td>拖拽开始前初始化拖拽设置（如拖拽方向等）。</td>
    </tr>
    <tr>
      <td><strong>OnMove(AxisEventData)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">IMoveHandler</code></td>
      <td>响应键盘/手柄的移动事件（如方向键、左摇杆）。</td>
    </tr>
    <tr>
      <td><strong>OnPointerDown(PointerEventData)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">IPointerDownHandler</code></td>
      <td>当鼠标或触控按下滑条时触发。</td>
    </tr>
    <tr>
      <td><strong>OnPointerUp(PointerEventData)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">IPointerUpHandler</code></td>
      <td>当鼠标或触控释放时触发。</td>
    </tr>
    <tr>
      <td><strong>Rebuild(CanvasUpdate)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ICanvasElement</code></td>
      <td>在 Canvas 需要重新构建 UI 时调用，如尺寸或内容更新。</td>
    </tr>
    <tr>
      <td><strong>SetDirection(Direction, bool)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Scrollbar</code> 本身</td>
      <td>设置滑动方向，并决定是否重新布置滑块布局。</td>
    </tr>
    <tr>
      <td><strong>SetValueWithoutNotify(float)</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Scrollbar</code> 本身</td>
      <td>设置 <code class="language-plaintext highlighter-rouge">value</code> 但不触发 <code class="language-plaintext highlighter-rouge">onValueChanged</code> 回调，用于静默初始化。</td>
    </tr>
  </tbody>
</table>

<h5 id="protected-methods-2">Protected Methods</h5>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>所属</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>ClickRepeat(PointerEventData)</strong></td>
      <td>协程函数（Coroutine）</td>
      <td>当按住滑条空白区域（非 Handle）时启动，用于模拟持续点击（滚动），直到释放。通常由 <code class="language-plaintext highlighter-rouge">OnPointerDown</code> 启动，用于实现“点住滚动”的行为。</td>
    </tr>
    <tr>
      <td><strong>OnDisable()</strong></td>
      <td><code class="language-plaintext highlighter-rouge">MonoBehaviour</code> 生命周期方法</td>
      <td>当组件或 GameObject 被禁用时调用。用于清理状态，比如停止滑动协程、取消事件等。</td>
    </tr>
  </tbody>
</table>

<p><strong>ClickRepeat工作原理</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>用户点击 Scrollbar 空白区域（非 Handle）
↓
OnPointerDown 被触发
↓
启动协程 ClickRepeat
↓
每隔一段时间不断调整value，模拟“持续按压”
↓
OnPointerUp 或 OnDisable 停止协程
</code></pre></div></div>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ClickRepeat</code>不会在拖动Handle时触发，仅当点击轨道空白部分时才会执行通常用于快速向上/向下滚动</p>
</blockquote>

<h3 id="scroll-view">Scroll View</h3>
<h4 id="结构-3">结构</h4>
<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Scroll</span><span class="w"> </span><span class="nv">View</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Rect</span><span class="w"> </span><span class="nv">Transform</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Canvas</span><span class="w"> </span><span class="nv">Renderer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Image</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Scroll</span><span class="w"> </span><span class="nv">Rect</span><span class="w">
</span><span class="o">|___</span><span class="nv">Viewport</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Rect</span><span class="w"> </span><span class="nv">Transform</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Canvas</span><span class="w"> </span><span class="nv">Renderer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Image</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">Mask</span><span class="w">
</span><span class="o">|</span><span class="w">       </span><span class="o">|___</span><span class="nv">Content</span><span class="w">
</span><span class="o">|___</span><span class="nv">Scrollbar</span><span class="w"> </span><span class="nv">Horizontal</span><span class="w">
</span><span class="o">|</span><span class="w">       </span><span class="o">|___</span><span class="nv">Sliding</span><span class="w"> </span><span class="nb">Area</span><span class="w">
</span><span class="o">|</span><span class="w">       </span><span class="o">|___</span><span class="nv">Handle</span><span class="w">
</span><span class="o">|___</span><span class="nv">Scrollbar</span><span class="w"> </span><span class="nv">Vertical</span><span class="w">
        </span><span class="o">|___</span><span class="nv">Sliding</span><span class="w"> </span><span class="nb">Area</span><span class="w">
        </span><span class="o">|___</span><span class="nv">Handle</span><span class="w">
</span></code></pre></div></div>

<h4 id="scroll-rect-panel-1">Scroll Rect Panel</h4>
<p><img src="/assets/images/ScrollRectPanel.jpg" alt="ScrollRectPanel" /></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Content</strong></td>
      <td>滚动的内容区域（Transform）。必须设置。</td>
    </tr>
    <tr>
      <td><strong>Horizontal / Vertical</strong></td>
      <td>是否允许横向 / 纵向滚动。</td>
    </tr>
    <tr>
      <td><strong>Movement Type</strong></td>
      <td>滚动行为的类型：<br />• <code class="language-plaintext highlighter-rouge">Unrestricted</code>（无限滚动）<br />• <code class="language-plaintext highlighter-rouge">Elastic</code>（弹性回弹）<br />• <code class="language-plaintext highlighter-rouge">Clamped</code>（限制在边界）</td>
    </tr>
    <tr>
      <td><strong>Elasticity</strong></td>
      <td>弹性程度，适用于 Elastic 模式。</td>
    </tr>
    <tr>
      <td><strong>Inertia</strong></td>
      <td>是否使用惯性滚动（拖动停止后缓慢减速）。</td>
    </tr>
    <tr>
      <td><strong>Deceleration Rate</strong></td>
      <td>惯性减速速率（值越接近 0 减速越快）。</td>
    </tr>
    <tr>
      <td><strong>Scroll Sensitivity</strong></td>
      <td>鼠标滚轮或拖动的灵敏度。</td>
    </tr>
    <tr>
      <td><strong>Viewport</strong></td>
      <td>可视窗口（一般是带有 <code class="language-plaintext highlighter-rouge">Mask</code> 或 <code class="language-plaintext highlighter-rouge">RectMask2D</code> 的 UI 元素）。</td>
    </tr>
    <tr>
      <td><strong>Horizontal/Vertical Scrollbar</strong></td>
      <td>滚动条（可选）。</td>
    </tr>
    <tr>
      <td><strong>OnValueChanged</strong></td>
      <td>滚动时触发的事件（<code class="language-plaintext highlighter-rouge">Vector2</code>，x 为横向偏移，y 为纵向偏移，范围 0~1）。</td>
    </tr>
  </tbody>
</table>

<h4 id="使用要点">使用要点</h4>
<p>1.Content必须配合Layout Group使用<br />
常见组合：</p>
<ul>
  <li>Vertical Layout Group + Content Size Fitter (Preferred Height)</li>
  <li>或者使用Grid Layout Group实现网格布局</li>
</ul>

<p>2.可视区域需要加Mask<br />
否则滚动时会“溢出显示”</p>

<p>3.Content的Pivot通常设为(0, 1)<br />
也就是左上角，这样滚动方向更符合视觉直觉（从上往下滚）</p>

<h4 id="api-5">API</h4>
<h5 id="properties-6">Properties</h5>
<p><strong>内容控制</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">content</code></td>
      <td><strong>被滚动的内容区域</strong>，必须是 ScrollRect 的子节点，一般挂 Layout Group 和元素。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">viewport</code></td>
      <td><strong>可视区域</strong>，通常是带有 <code class="language-plaintext highlighter-rouge">Mask</code> 或 <code class="language-plaintext highlighter-rouge">RectMask2D</code> 的 RectTransform，用于裁剪 content。</td>
    </tr>
  </tbody>
</table>

<p><strong>滚动方向控制</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">horizontal</code></td>
      <td>是否启用 <strong>水平滚动</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">vertical</code></td>
      <td>是否启用 <strong>垂直滚动</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">horizontalNormalizedPosition</code></td>
      <td>当前水平滚动位置，<strong>0 = 左侧，1 = 右侧</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">verticalNormalizedPosition</code></td>
      <td>当前垂直滚动位置，<strong>0 = 底部，1 = 顶部</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">normalizedPosition</code></td>
      <td>一个 <code class="language-plaintext highlighter-rouge">(x, y)</code> 的向量，表示水平和垂直的标准化位置。</td>
    </tr>
  </tbody>
</table>

<p><strong>滚动行为与物理效果</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movementType</code></td>
      <td>滚动边界行为：<br />• <code class="language-plaintext highlighter-rouge">Unrestricted</code>: 不限制内容滚动出界<br />• <code class="language-plaintext highlighter-rouge">Clamped</code>: 限制内容不超出边界<br />• <code class="language-plaintext highlighter-rouge">Elastic</code>: 允许超出边界但有弹性回弹</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">elasticity</code></td>
      <td>内容超出边界时的回弹强度（只适用于 <code class="language-plaintext highlighter-rouge">Elastic</code> 模式）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">inertia</code></td>
      <td>是否启用 <strong>惯性滚动</strong>（用户松手后内容继续滑动）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">decelerationRate</code></td>
      <td>惯性滚动时的减速率，越小减速越快，0~1。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">velocity</code></td>
      <td>当前内容的滚动速度（仅运行时可读写）。</td>
    </tr>
  </tbody>
</table>

<p><strong>滚动灵敏度</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">scrollSensitivity</code></td>
      <td>鼠标滚轮或触摸板的滚动灵敏度，值越大越灵敏。</td>
    </tr>
  </tbody>
</table>

<p><strong>滚动条相关</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">horizontalScrollbar</code></td>
      <td>水平滚动条组件引用（可选）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">horizontalScrollbarSpacing</code></td>
      <td>水平滚动条与 viewport 之间的间距。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">horizontalScrollbarVisibility</code></td>
      <td>滚动条的显示策略（自动、永久等）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">verticalScrollbar</code></td>
      <td>垂直滚动条组件引用（可选）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">verticalScrollbarSpacing</code></td>
      <td>垂直滚动条与 viewport 之间的间距。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">verticalScrollbarVisibility</code></td>
      <td>垂直滚动条的显示策略。</td>
    </tr>
  </tbody>
</table>

<p><strong>事件</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">onValueChanged</code></td>
      <td>滚动位置变化时的事件回调，参数是 <code class="language-plaintext highlighter-rouge">Vector2(normalizedPosition)</code>。<br />可以用来联动其他 UI，或动态加载内容等。</td>
    </tr>
  </tbody>
</table>

<p><strong>与布局系统集成</strong></p>

<p>这些属性主要是用于ScrollRect本身作为UI元素时的布局信息（一般不常改）</p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">minWidth</code> / <code class="language-plaintext highlighter-rouge">minHeight</code></td>
      <td>布局系统要求的最小宽高。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">preferredWidth</code> / <code class="language-plaintext highlighter-rouge">preferredHeight</code></td>
      <td>建议的宽高，通常用于自动布局计算。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">flexibleWidth</code> / <code class="language-plaintext highlighter-rouge">flexibleHeight</code></td>
      <td>是否可以在布局中灵活伸缩。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">layoutPriority</code></td>
      <td>控制多布局系统下优先级（数字越高越优先）。</td>
    </tr>
  </tbody>
</table>

<h5 id="public-methods-4">Public Methods</h5>

<p><strong>与布局系统有关的方法</strong></p>

<p>这些方法一般由Unity的UI Layout系统自动调用，开发者很少直接使用，了解它们可以帮助搞清楚<code class="language-plaintext highlighter-rouge">ScrollRect</code>和布局系统的协作过程</p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CalculateLayoutInputHorizontal()</code></td>
      <td>告诉布局系统如何计算内容的宽度需求。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CalculateLayoutInputVertical()</code></td>
      <td>告诉布局系统如何计算内容的高度需求。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetLayoutHorizontal()</code></td>
      <td>设置子元素的水平布局（内部执行，如 Content 的定位）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetLayoutVertical()</code></td>
      <td>设置子元素的垂直布局。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LayoutComplete()</code></td>
      <td>布局系统完成后调用，通常用于布局结束时的清理。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Rebuild(CanvasUpdate update)</code></td>
      <td>在不同的 Canvas 更新阶段重建 UI（布局、绘制、交互等）。</td>
    </tr>
  </tbody>
</table>

<p><strong>拖拽相关方法（响应用户手势）</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnBeginDrag(PointerEventData eventData)</code></td>
      <td>当用户开始拖动 ScrollRect 时触发（鼠标或触摸开始拖动）。初始化拖动参数。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnDrag(PointerEventData eventData)</code></td>
      <td>拖动过程中持续触发，<strong>主要移动 Content</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnEndDrag(PointerEventData eventData)</code></td>
      <td>拖动结束时触发，决定是否开始 <strong>惯性滚动</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnInitializePotentialDrag(PointerEventData eventData)</code></td>
      <td>在系统检测到可能要开始拖拽时调用。设置拖拽相关参数，如 <code class="language-plaintext highlighter-rouge">useDragThreshold</code>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">StopMovement()</code></td>
      <td>手动停止滚动（将 <code class="language-plaintext highlighter-rouge">velocity</code> 设为零），可用于外部中断滚动行为。</td>
    </tr>
  </tbody>
</table>

<p><strong>鼠标滚轮事件</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnScroll(PointerEventData eventData)</code></td>
      <td>响应鼠标滚轮事件，常用于鼠标滑动滚动内容。ScrollRect 内部会根据 <code class="language-plaintext highlighter-rouge">scrollSensitivity</code> 来改变 <code class="language-plaintext highlighter-rouge">content</code> 的位置。</td>
    </tr>
  </tbody>
</table>

<p><strong>Canvas系统更新周期</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GraphicUpdateComplete()</code></td>
      <td>图形更新阶段完成后调用，通常用于清理绘制状态。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IsActive()</code></td>
      <td>ScrollRect 当前是否激活（继承自 <code class="language-plaintext highlighter-rouge">UIBehaviour</code>），用于判断是否参与渲染和交互。</td>
    </tr>
  </tbody>
</table>

<h5 id="示例-2">示例</h5>
<p><strong>自定义拖动方向（只允许竖直）</strong></p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">VerticalOnlyScrollRect</span> <span class="p">:</span> <span class="n">ScrollRect</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">eventData</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">vertical</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">delta</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">eventData</span><span class="p">.</span><span class="n">delta</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="k">base</span><span class="p">.</span><span class="nf">OnDrag</span><span class="p">(</span><span class="k">new</span> <span class="nf">PointerEventData</span><span class="p">(</span><span class="n">eventData</span><span class="p">.</span><span class="n">eventSystem</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">position</span> <span class="p">=</span> <span class="n">eventData</span><span class="p">.</span><span class="n">position</span><span class="p">,</span>
      <span class="n">delta</span> <span class="p">=</span> <span class="n">delta</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="ui更新">UI更新</h2>
<p>Unity的UI系统在每一帧里，都按照一定顺序对所有UI元素做布局计算、绘制更新、交互处理，这个顺序被划分成了几个阶段</p>

<h3 id="ui更新流程的3个阶段canvasupdate">UI更新流程的3个阶段（CanvasUpdate）</h3>
<p>Unity会调用实现了<code class="language-plaintext highlighter-rouge">ICanvasElement</code>接口的UI组件（如<code class="language-plaintext highlighter-rouge">Text</code>，<code class="language-plaintext highlighter-rouge">Image</code>，<code class="language-plaintext highlighter-rouge">ScrollRect</code>等），按顺序执行：</p>

<table>
  <thead>
    <tr>
      <th>阶段</th>
      <th>意义</th>
      <th>常见调用的方法</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1.<code class="language-plaintext highlighter-rouge">Layout</code> 阶段</td>
      <td>计算大小、位置</td>
      <td><code class="language-plaintext highlighter-rouge">CalculateLayoutInputHorizontal/Vertical</code>, <code class="language-plaintext highlighter-rouge">SetLayoutHorizontal/Vertical</code></td>
    </tr>
    <tr>
      <td>2.<code class="language-plaintext highlighter-rouge">Graphic</code> 阶段</td>
      <td>更新可视内容，比如文字、图片、颜色等</td>
      <td><code class="language-plaintext highlighter-rouge">GraphicUpdateComplete</code></td>
    </tr>
    <tr>
      <td>3.<code class="language-plaintext highlighter-rouge">LatePreRender</code> 阶段</td>
      <td>最后准备渲染前的调整</td>
      <td>比如强制设置滚动位置等</td>
    </tr>
  </tbody>
</table>

<h3 id="timelineper-frame">TimeLine(Per Frame)</h3>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Update()
↓
Layout阶段：
<span class="p">    -</span> ScrollRect：计算内容区域位置
<span class="p">    -</span> Text：计算文字排版
↓
Graphic阶段：
<span class="p">    -</span> Image：更新贴图
<span class="p">    -</span> Text：更新文字网格
↓
LatePreRender阶段：
<span class="p">    -</span> ScrollRect：修正 normalizedPosition
↓
渲染 → 显示画面
</code></pre></div></div>

<p>某些UI行为必须等到布局计算完成后才能准确执行，比如：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scrollRect</span><span class="p">.</span><span class="n">verticalNormalizedPosition</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span>
</code></pre></div></div>
<p>如果放在<code class="language-plaintext highlighter-rouge">Start()</code>里，它可能在布局阶段之前就执行了，所以不会生效</p>

<p>正确的方式是：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Canvas</span><span class="p">.</span><span class="nf">ForceUpdateCanvases</span><span class="p">();</span> <span class="c1">// 强制执行Layout阶段</span>
<span class="n">scrollRect</span><span class="p">.</span><span class="n">verticalNormalizedPosition</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="event-system">Event System</h2>
<p><code class="language-plaintext highlighter-rouge">Event System</code>是Unity UI System中的核心交互管理器，掌控了所有鼠标点击、键盘输入、触摸事件、UI导航的逻辑</p>

<p>Unity的Event System是一个处理用户输入事件的系统，用于发送“点击了谁”“选中了谁”之类的事件，属于UnityEngine.EventSystems命名空间</p>

<p><img src="/assets/images/EventSystemPanel.jpg" alt="EventSystemPanel" /></p>

<table>
  <thead>
    <tr>
      <th>组件</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>EventSystem</strong></td>
      <td>整个输入系统的“大脑”</td>
    </tr>
    <tr>
      <td><strong>Input Module</strong></td>
      <td>输入方式模块，比如处理鼠标、键盘、手柄（你可以切换）</td>
    </tr>
    <tr>
      <td><strong>Raycaster（挂在 Canvas 或 3D 对象上）</strong></td>
      <td>实际检测点击了哪个物体，比如：<code class="language-plaintext highlighter-rouge">GraphicRaycaster</code>, <code class="language-plaintext highlighter-rouge">PhysicsRaycaster</code></td>
    </tr>
  </tbody>
</table>

<p>EventSystem会追踪以下交互：</p>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>描述</th>
      <th>接口</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>点击 Click</td>
      <td>鼠标/触摸点击 UI</td>
      <td><code class="language-plaintext highlighter-rouge">IPointerClickHandler</code></td>
    </tr>
    <tr>
      <td>拖拽 Drag</td>
      <td>拖拽 ScrollRect、物品、滑块</td>
      <td><code class="language-plaintext highlighter-rouge">IDragHandler</code>, <code class="language-plaintext highlighter-rouge">IBeginDragHandler</code>, <code class="language-plaintext highlighter-rouge">IEndDragHandler</code></td>
    </tr>
    <tr>
      <td>悬停 Hover</td>
      <td>鼠标移动到 UI 上</td>
      <td><code class="language-plaintext highlighter-rouge">IPointerEnterHandler</code>, <code class="language-plaintext highlighter-rouge">IPointerExitHandler</code></td>
    </tr>
    <tr>
      <td>按钮按下</td>
      <td>长按、释放</td>
      <td><code class="language-plaintext highlighter-rouge">IPointerDownHandler</code>, <code class="language-plaintext highlighter-rouge">IPointerUpHandler</code></td>
    </tr>
    <tr>
      <td>键盘导航</td>
      <td>方向键移动焦点</td>
      <td><code class="language-plaintext highlighter-rouge">IMoveHandler</code></td>
    </tr>
    <tr>
      <td>输入</td>
      <td>表单输入</td>
      <td><code class="language-plaintext highlighter-rouge">ISubmitHandler</code>, <code class="language-plaintext highlighter-rouge">ISelectHandler</code></td>
    </tr>
  </tbody>
</table>

<p>任何的UI交互脚本，都是通过这些接口连接到Event System</p>

<h3 id="eventsystem的工作流程图">EventSystem的工作流程图</h3>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">鼠标</span><span class="o">/</span><span class="nt">键盘</span><span class="o">/</span><span class="nt">触摸输入</span><span class="o">]</span>
      <span class="err">↓</span>
<span class="o">[</span><span class="nt">Input</span> <span class="nt">Module</span><span class="o">]</span> <span class="err">→</span> <span class="nt">分析输入</span><span class="err">（</span><span class="nt">比如点击</span><span class="err">、</span><span class="nt">拖动</span><span class="err">、</span><span class="nt">导航</span><span class="err">）</span>
      <span class="err">↓</span>
<span class="o">[</span><span class="nt">Raycaster</span><span class="o">]</span> <span class="err">→</span> <span class="nt">检测点击了哪个</span> <span class="nt">UI</span> <span class="nt">元素</span>
      <span class="err">↓</span>
<span class="o">[</span><span class="nt">EventSystem</span><span class="o">]</span> <span class="err">→</span> <span class="nt">通知对应的组件执行接口函数</span><span class="err">（</span><span class="nt">如</span> <span class="nt">OnClick</span><span class="err">）</span>
</code></pre></div></div>

<h3 id="eventsystem-component">EventSystem Component</h3>
<h4 id="eventsystem"><code class="language-plaintext highlighter-rouge">EventSystem</code></h4>
<p>挂载在GameObject上，只有一个<br />
功能：</p>
<ul>
  <li>管理当前选中的UI对象</li>
  <li>管理输入模块</li>
  <li>分发事件：比如点击、拖动、选中等</li>
</ul>

<h4 id="eventsystem-panel">EventSystem Panel</h4>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>First Selected</strong></td>
      <td>初始选中的 UI 对象（用于导航/手柄）</td>
    </tr>
    <tr>
      <td><strong>Send Navigation Events</strong></td>
      <td>是否允许方向键或手柄移动选中项</td>
    </tr>
    <tr>
      <td><strong>Drag Threshold</strong></td>
      <td>拖拽时鼠标/手指移动多少才视为“拖拽”</td>
    </tr>
  </tbody>
</table>

<h4 id="standalone-input-module"><code class="language-plaintext highlighter-rouge">Standalone Input Module</code></h4>
<p>适合：鼠标 + 键盘控制<br />
Unity默认生成<br />
功能：把输入映射为事件（点击、拖动、导航）</p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Send Pointer Hover To Parent</td>
      <td>是否强制启用这个模块</td>
    </tr>
    <tr>
      <td>Horizontal Axis / Vertical Axis</td>
      <td>对应键盘方向键（默认是 “Horizontal” 和 “Vertical”）</td>
    </tr>
    <tr>
      <td>Submit Button / Cancel Button</td>
      <td>默认是 “Submit”（Enter）和 “Cancel”（Esc）</td>
    </tr>
    <tr>
      <td>Input Actions Per Second</td>
      <td>每秒导航几次</td>
    </tr>
    <tr>
      <td>Repeat Delay</td>
      <td>长按导航前的延迟时间</td>
    </tr>
  </tbody>
</table>

<h4 id="input-system-ui-input-module新系统"><code class="language-plaintext highlighter-rouge">Input System UI Input Module</code>（新系统）</h4>

<p>详见<a href="/posts/2025-06-03-Input-System/">Input System</a></p>

<p>适合：新版Unity Input System（使用<code class="language-plaintext highlighter-rouge">Input Actions</code>的）</p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Actions Asset</td>
      <td>你设置好的 <code class="language-plaintext highlighter-rouge">.inputactions</code> 文件</td>
    </tr>
    <tr>
      <td>Point / Click / Navigate / Submit 等</td>
      <td>分别绑定触摸、点击、方向等操作</td>
    </tr>
    <tr>
      <td>Move Repeat Rate / Delay</td>
      <td>同样是手柄方向键长按节奏</td>
    </tr>
  </tbody>
</table>

<h4 id="raycaster">Raycaster</h4>
<p>EventSystem本身不会知道你点到谁，它需要Raycaster组件配合UI或3D元素</p>

<h5 id="graphic-raycaster用于canvas-ui"><code class="language-plaintext highlighter-rouge">Graphic Raycaster</code>（用于Canvas UI）</h5>
<p>挂在<code class="language-plaintext highlighter-rouge">Canvas</code>上，专门检测UI元素是否被点中</p>

<p><a href="#graphic-raycaster">Canvas Graphic Raycaster</a></p>

<h5 id="physics-raycaster用于3d物体"><code class="language-plaintext highlighter-rouge">Physics Raycaster</code>（用于3D物体）</h5>
<p>挂在摄像机上，配合3D对象（带Collider）使用，检测鼠标是否点击到物体</p>

<h5 id="physics2d-raycaster用于2d物体"><code class="language-plaintext highlighter-rouge">Physics2D Raycaster</code>（用于2D物体）</h5>
<p>配合2D Collider检测点击或拖动等交互</p>

<h3 id="api-6">API</h3>
<h4 id="static-properties">Static Properties</h4>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">current</code></td>
      <td>返回当前EventSystem</td>
    </tr>
  </tbody>
</table>

<h4 id="properties-7">Properties</h4>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">alreadySelecting</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td><strong>只读</strong>属性，表示 EventSystem 当前是否正在执行 <code class="language-plaintext highlighter-rouge">SetSelectedGameObject()</code>。<br />⚠️ 一般用于内部防止递归调用选中事件。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">currentInputModule</code></td>
      <td><code class="language-plaintext highlighter-rouge">BaseInputModule</code></td>
      <td>当前正在使用的输入模块（如 <code class="language-plaintext highlighter-rouge">StandaloneInputModule</code> 或 <code class="language-plaintext highlighter-rouge">InputSystemUIInputModule</code>）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">currentSelectedGameObject</code></td>
      <td><code class="language-plaintext highlighter-rouge">GameObject</code></td>
      <td>当前选中的 UI 对象（例如当前焦点在某个按钮上时，这就是那个按钮）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">firstSelectedGameObject</code></td>
      <td><code class="language-plaintext highlighter-rouge">GameObject</code></td>
      <td>场景加载或 EventSystem 启动时最初被选中的对象（通常用于手柄/键盘导航）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isFocused</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>表示 EventSystem 是否处于“聚焦”状态。<br />在 PC 上，这通常意味着游戏窗口是否处于激活状态（失焦时不响应输入）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pixelDragThreshold</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>拖动时鼠标或手指要移动多少像素才算开始拖拽（用来防止误触拖动）。默认是 5。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sendNavigationEvents</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否启用方向键/手柄的导航事件（如按 ↑↓←→ 移动 UI 选择框）。关闭后不能用方向键移动焦点。</td>
    </tr>
  </tbody>
</table>

<h4 id="publicf-methods">Publicf Methods</h4>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>作用</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IsPointerOverGameObject()</code></td>
      <td>判断鼠标/手指是否悬停在 UI 上</td>
      <td>做点击穿透判断</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">RaycastAll()</code></td>
      <td>手动执行一次 UI 射线检测</td>
      <td>获取所有命中的 UI 元素</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetSelectedGameObject()</code></td>
      <td>设置当前聚焦的 UI</td>
      <td>控制导航焦点</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UpdateModules()</code></td>
      <td>刷新输入模块</td>
      <td>很少手动用，一般系统自动处理</td>
    </tr>
  </tbody>
</table>

<h2 id="focus">Focus</h2>
<p>在UI系统中，焦点（Focus）是指当前“被选中、正在响应输入”的UI元素</p>

<p>它表现为：</p>
<ul>
  <li>手柄/键盘控制时，按钮会被“高亮”</li>
  <li>输入框获得焦点后，可以输入文字</li>
  <li>焦点组件会响应<code class="language-plaintext highlighter-rouge">OnSelect</code>、<code class="language-plaintext highlighter-rouge">OnDeselect</code>、<code class="language-plaintext highlighter-rouge">ISubmitHandler</code>等接口</li>
</ul>

<p><strong>焦点只对以下操作有效：</strong></p>

<table>
  <thead>
    <tr>
      <th>操作</th>
      <th>依赖焦点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>按方向键移动 UI 选择</td>
      <td>依赖</td>
    </tr>
    <tr>
      <td>按 Enter 提交按钮</td>
      <td>依赖</td>
    </tr>
    <tr>
      <td>输入框自动聚焦后可打字</td>
      <td>依赖</td>
    </tr>
    <tr>
      <td>鼠标点击按钮</td>
      <td>不依赖焦点（靠点击 Raycast）</td>
    </tr>
  </tbody>
</table>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">EventSystem</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">currentSelectedGameObject</span>
</code></pre></div></div>
<p>这就是当前拥有焦点的那个UI元素</p>

<h3 id="示例-3">示例</h3>
<p>1.打开页面时设置初始焦点</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">GameObject</span> <span class="n">defaultButton</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">OnEnable</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">EventSystem</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="nf">SetSelectedGameObject</span><span class="p">(</span><span class="k">null</span><span class="p">);</span> <span class="c1">// 清空旧焦点</span>
  <span class="n">EventSystem</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="nf">SetSelectedGameObject</span><span class="p">(</span><span class="n">defaultButton</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>2.按键触发当前焦点的“提交”</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="nf">GetKeyDown</span><span class="p">(</span><span class="n">KeyCode</span><span class="p">.</span><span class="n">Return</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">go</span> <span class="p">=</span> <span class="n">EventSystem</span><span class="p">.</span><span class="n">currentSelectedGameObject</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">go</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">Execute</span><span class="p">&lt;</span><span class="n">ISubmitHandler</span><span class="p">&gt;(</span><span class="n">go</span><span class="p">,</span> <span class="k">new</span> <span class="nf">BaseEventData</span><span class="p">(</span><span class="n">EventSystem</span><span class="p">.</span><span class="n">current</span><span class="p">),</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">submitHandler</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="焦点与导航方向键控制">焦点与导航（方向键控制）</h3>
<p>每个<code class="language-plaintext highlighter-rouge">Selectable</code>UI（比如 Button、Toggle、InputField）都有导航设置</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Navigation</span> <span class="n">nav</span> <span class="p">=</span> <span class="n">myButton</span><span class="p">.</span><span class="n">navigation</span><span class="p">;</span>
<span class="n">nav</span><span class="p">.</span><span class="n">mode</span> <span class="p">=</span> <span class="n">Navigation</span><span class="p">.</span><span class="n">Mode</span><span class="p">.</span><span class="n">Eplicit</span><span class="p">;</span>
<span class="n">nav</span><span class="p">.</span><span class="n">delectOnRight</span> <span class="p">=</span> <span class="n">anotherButton</span><span class="p">;</span>
<span class="n">myButton</span><span class="p">.</span><span class="n">navigation</span> <span class="p">=</span> <span class="n">nav</span><span class="p">;</span>
</code></pre></div></div>
<p>按下方向键，跳转到指定的UI元素</p>

<h2 id="navigation">Navigation</h2>

<h2 id="effect">Effect</h2>

<h2 id="layout-system">Layout System</h2>
<h3 id="layout-group">Layout Group</h3>

<h3 id="contentsizefitter">ContentSizeFitter</h3>

<h3 id="aspectratiofitter">AspectRatioFitter</h3>

<h3 id="mask--rectmask2d">Mask / RectMask2D</h3>

<h2 id="draw-call">Draw Call</h2>

<h2 id="unity-ui-tookit">Unity UI Tookit</h2>

<h2 id="ui动画">UI动画</h2>

<h2 id="ui资源管理">UI资源管理</h2>

<h2 id="ui动态生成">UI动态生成</h2>

<h2 id="ui-manager-system">UI Manager System</h2>

<h2 id="ui性能优化">UI性能优化</h2>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-06-01T00:00:00+08:00">June 1, 2025</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/posts/2025-06-07-Joint/" class="pagination--pager" title="Joint">Previous</a>
    
    
      <a href="/posts/2025-06-08-Scene-System/" class="pagination--pager" title="Scene System">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/ljf12825" rel="nofollow noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">ljf12825's Blog</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
