<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.1 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Behaviour Tree - ljf12825’s Blog</title>
<meta name="description" content="Unity的行为树是一种常用于AI决策的结构，它在游戏开发中用于描述AI的行为和决策逻辑。它通过阻止一系列的节点来表示各种行为，树形结构的设计让它可以清晰地展示AI决策过程">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="ljf12825's Blog">
<meta property="og:title" content="Behaviour Tree">
<meta property="og:url" content="http://localhost:4000/posts/2025-06-14-Behaviour-Tree/">


  <meta property="og:description" content="Unity的行为树是一种常用于AI决策的结构，它在游戏开发中用于描述AI的行为和决策逻辑。它通过阻止一系列的节点来表示各种行为，树形结构的设计让它可以清晰地展示AI决策过程">







  <meta property="article:published_time" content="2025-06-01T00:00:00+08:00">






<link rel="canonical" href="http://localhost:4000/posts/2025-06-14-Behaviour-Tree/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="ljf12825's Blog Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- favicon -->
<link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon">

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          ljf12825's Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Categories</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tags</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Behaviour Tree">
    <meta itemprop="description" content="Unity的行为树是一种常用于AI决策的结构，它在游戏开发中用于描述AI的行为和决策逻辑。它通过阻止一系列的节点来表示各种行为，树形结构的设计让它可以清晰地展示AI决策过程">
    <meta itemprop="datePublished" content="2025-06-01T00:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/posts/2025-06-14-Behaviour-Tree/" itemprop="url">Behaviour Tree
</a>
          </h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>Unity的行为树是一种常用于AI决策的结构，它在游戏开发中用于描述AI的行为和决策逻辑。它通过阻止一系列的节点来表示各种行为，树形结构的设计让它可以清晰地展示AI决策过程</p>

<h2 id="基本概念">基本概念</h2>
<p>行为树的每个节点都有一个功能，它们通常分为以下几种类型</p>
<ul>
  <li>根节点（Root Node）：行为树的起始点</li>
  <li>选择节点（Selector Node）：类似于“或”运算，选择一个成功的子节点。如果一个子节点失败，则选择下一个子节点，直到找到成功的节点或者没有子节点可选</li>
  <li>序列节点（Sequence Node）：类似于“与”运算，执行所有子节点，直到一个子节点失败。如果任何一个子节点失败，序列节点就会失败</li>
  <li>动作节点（Action Node）：表示具体的行为或操作，例如移动、攻击、闲逛等</li>
  <li>条件节点（Condition Node）：检查是否满足某个条件，如果条件成立则返回成功，否则返回失败</li>
</ul>

<h2 id="行为树的执行过程">行为树的执行过程</h2>
<p>行为树的执行是从根节点开始，逐层向下执行。它通常会根据子节点的状态（成功、失败或运行中）来决定接下来的执行路径</p>
<ul>
  <li>成功：当某个节点成功完成时，它会返回“成功”状态，行为树会继续向下执行</li>
  <li>失败：当某个节点失败时，行为树会返回“失败”状态，选择其他路径或回溯</li>
  <li>运行中：有些节点会持续执行，并且需要多个帧来完成，比如“寻找敌人”或“等待某个事件发生”</li>
</ul>

<h2 id="行为树的优势">行为树的优势</h2>
<ul>
  <li>可扩展性：行为树非常适合处理复杂的AI逻辑，可以轻松地将新的行为和决策加入树中，而不需要修改现有代码</li>
  <li>模块化和可维护性：由于行为树的结构类似于树形，它更容易进行维护和扩展。每个节点都是独立的，只有一个明确的职责</li>
  <li>清晰的决策过程：行为树通过层级结构表达决策逻辑，使得复杂的AI决策变得清晰易懂</li>
</ul>

<h2 id="unity中行为树的实现">Unity中行为树的实现</h2>
<p>Unity中没有内建的行为树系统，但是可以使用一些现有的库来实现行为树，例如：</p>
<ul>
  <li>Unity ML-Agents：这个包包含了一些用于训练和开发AI代理的工具，但它的行为树实现较为基础</li>
  <li>Behaviour Designer：这是一个非常流行的Unity插件，它提供了一个图形化界面，便于设计和实现行为树</li>
  <li>NodeCanvas：另一个插件，支持行为树、状态机等多种AI决策系统，可以很方便地设计复杂的行为树</li>
  <li>Unity Behavior：2024年底Unity发布的免费行为树包，可视化</li>
</ul>

<h2 id="unity-ml-agents"><a href="/posts/2025-08-12-ML-Agents/">Unity ML-Agents</a></h2>
<p><a href="https://github.com/Unity-Technologies/ml-agents.git">GitHub ML-Agents</a></p>

<p>ML-Agents (Machine Learning Agents)是由Unity官方提供的一款工具包，旨在帮助开发者在Unity中实现和训练智能体（Agents）使用机器学习算法。它为游戏和仿真环境中的AI提供了一种灵活的方式，利用强化学习、监督学习等技术来训练代理学习从环境中获得经验并做出决策</p>

<p>ML-Agents提供了基于PyTorch的算法实现，可以方便地使用其提供的Python API，通过强化学习、模仿学习、神经进化或任何其他方法训练智能代理</p>

<h3 id="核心组件">核心组件</h3>
<p>ML-Agents的工作主要依赖于以下几个核心组件</p>
<ul>
  <li>
    <p>Agent：在Unity环境中，Agent是一个学习者，它与环境进行交互并根据所接收到的奖励（reward）和惩罚（penalty）来调整其行为策略。Agent可以是游戏中的一个角色或物体（如玩家、敌人、NPC等）</p>
  </li>
  <li>
    <p>Environment：环境是Agent交互的地方，包含了物理世界、场景中的其他对象等。它为Agent提供观测数据并接收来自Agent的动作。一个Unity场景通常包含多个对象，例如地面、障碍物、NPC、敌人等</p>
  </li>
  <li>
    <p>Brain：Brain负责决策，它是机器学习模型的实现，可以是一个简单的规则引擎或一个复杂的神经网络。以前，Brain在Unity中是一个单独的组件，现在已经被改进为训练代理的策略。ML-Agents通过Python脚本和Unity连接，进行训练和推理</p>
  </li>
  <li>
    <p>Academy：Academy是整个学习过程的核心管理者，它负责协调环境的重置、训练的初始化、代理的奖励以及多个Agent之间的同步</p>
  </li>
</ul>

<h3 id="机器学习的训练过程">机器学习的训练过程</h3>
<p>ML-Agents的训练过程包括以下几个主要步骤：</p>
<ol>
  <li>
    <p>设置环境：需要在Unity中创建一个合适的场景，设置Agent，并为Agent提供可观测的信息（如位置、速度、目标位置等）以及奖励机制（如击中目标、避开障碍物等）</p>
  </li>
  <li>
    <p>定义Agent的行为：需要为Agent编写C#脚本，告诉它如何根据环境的状态选择动作。通常这会涉及到对传入的观测数据进行处理，并输出动作（例如移动、跳跃等）</p>
  </li>
  <li>
    <p>训练Agent：通过ML-Agents中的Python接口，利用强化学习算法（如PPO、A3C、DDPG等）训练Agent。训练过程中，代理通过与环境的交互，逐步调整策略以最大化累积的奖励</p>
  </li>
  <li>
    <p>评估与优化：训练过程中，可以定期评估Agent的表现，查看它是否能成功完成任务，并根据结果调整训练策略或优化环境设计</p>
  </li>
</ol>

<h3 id="ml-agents的主要特性">ML-Agents的主要特性</h3>
<ul>
  <li>强化学习：ML-Agents最常用于强化学习（Reinforcement Learning），代理通过与环境交互、执行动作并接受奖励来学习最优策略</li>
  <li>模仿学习：ML-Agents也支持模仿学习（Imitation Learning），这是一种从专家演示中学习的方式。可以通过记录专家的行为，使用数据来训练Agent模仿这些行为</li>
  <li>多智能体系统：ML-Agents支持多个Agent同时训练，它们可以共享一个环境进行协作或对抗训练</li>
  <li>支持多种训练算法：目前，ML-Agent支持多个强化学习算法，如PPO、DDPG等。这些算法适应不同类型的问题，如连续动作空间或离散动作空间</li>
</ul>

<h3 id="ml-agent使用步骤">ML-Agent使用步骤</h3>
<ol>
  <li>安装ML-Agents
ML-Agents需要安装Unity插件和Python库
    <ul>
      <li>在Unity中，通过Package Manager安装<code class="language-plaintext highlighter-rouge">ML-Agents</code></li>
      <li>在Python环境中，使用以下命令安装ML-Agents
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  pip <span class="nb">install </span>mlagents
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>创建Agent
可以为Unity中的角色创建一个代理。代理需要实现如下接口
    <ul>
      <li>OnEpisodeBegin：每当一个训练回合开始时调用，通常用来重置代理和环境</li>
      <li>CollectObservation：每个步骤手机代理的环境状态，作为输入传递给机器学习模型</li>
      <li>OnActionReceived：每当代理执行一个动作时调用，基于该动作与环境的互动更新代理的状态，并奖励或惩罚代理</li>
    </ul>
  </li>
  <li>训练代理
通过Python训练脚本，可以开始训练代理。ML-Agents提供了一个命令行工具（<code class="language-plaintext highlighter-rouge">mlagents-learn</code>），可以通过它来启动训练
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mlagents-learn config/trainer_config.yaml <span class="nt">--run-id</span><span class="o">=</span>first_run
</code></pre></div>    </div>
  </li>
  <li>使用模型
一旦训练完成，可以导出训练好的模型，并将其加载到Unity项目中，直接替换代理的行为逻辑</li>
</ol>

<h3 id="训练的算法与策略">训练的算法与策略</h3>
<p>ML-Agents支持多种强化学习算法</p>
<ul>
  <li>PPO（Proximal Policy Optimization）：适用于大多数问题，是一种基于策略梯度的算法，能够较好地处理连续动作空间</li>
  <li>DDPG（Deep Deterministic Policy Gradient）：用于连续动作空间的深度强化学习算法，适合处理高维、连续的动作问题</li>
  <li>A3C（Asynchronous Advantage Actor-Critic）：适用于多智能体训练，利用多线程来提升训练效率</li>
</ul>

<h2 id="behavior-designer"><a href="/posts/2025-08-12-Behaviour-Designer/">Behavior Designer</a></h2>
<p>Behaviour Designer是一款强大的Unity插件，用于创建和管理行为树，它让开发者可以通过图形化界面设计复杂的AI行为，而不需要手动编写复杂的代码。Behaviour Designer的主要优势在于它提供了一种直观的方式来构建和调试AI的决策系统，同时支持强化学习和传统的AI算法</p>

<h3 id="behaviour-designer的核心功能">Behaviour Designer的核心功能</h3>
<ul>
  <li>图形化界面：Behaviour Designer提供了一个直观的拖拽式界面，使得设计和管理行为树变得非常容易。可以通过简单的拖动和连接节点来实现复杂的AI行为</li>
  <li>节点类型丰富：Behaviour Designer提供了多种节点类型，包括：
    <ul>
      <li>Selector：选择器节点，依次检查子节点，如果由一个子节点成功则返回成功</li>
      <li>Sequence：序列节点，依次执行子节点，直到有一个失败时返回失败</li>
      <li>Condition：条件节点，检查某些条件是否满足，通常用于判断是否执行某个动作</li>
      <li>Parallel：并行节点，允许多个子任务同时执行，直到所有任务完成或者有一个失败</li>
      <li>Inverter：取反节点，用于改变子节点的状态（例如将成功转为失败，将失败转为成功）</li>
    </ul>
  </li>
  <li>支持自定义节点：Behaviour Designer允许开发者编写自己的自定义行为节点，扩展它的功能。通过C#脚本，可以轻松地创建适应特定要求的节点</li>
  <li>多智能体支持：可以在同一个场景中创建多个智能体，并使用Behaviour Designer为每个智能体设计不同的行为树，支持不同的AI模式</li>
  <li>调试和监控：Behaviour Designer具有强大的调试功能，可以实时查看AI的状态、节点的执行情况以及执行的路径。这有助于快速诊断和优化AI的行为</li>
  <li>黑板（Blackboard）：黑板是存储智能体数据的容器，AI可以通过它共享数据和状态。行为树的节点可以访问黑板上的变量（如智能体的位置、血量、目标等），并基于这些信息进行决策</li>
</ul>

<h3 id="behaviour-designer的使用">Behaviour Designer的使用</h3>
<ol>
  <li>
    <p>安装Behaviour Designer
通过Unity的Package Manager或Asset Store安装Behaviour Designer</p>
  </li>
  <li>创建Behaviour Tree
创建一个新的行为树
    <ul>
      <li>在Unity中，右键点击项目窗口中的文件夹，选择Create &gt; Behavior Designer &gt; Behavior Tree</li>
      <li>给行为树命名，双击打开Behavior Tree编辑器</li>
    </ul>
  </li>
  <li>设计行为树
在Behavior Tree编辑器中，将看到一个空白的画布，可以通过拖拽不同的节点来创建和连接行为树，例如：
    <ul>
      <li>使用Selector节点来检查敌人是否在视野内，如果在视野内则进行攻击</li>
      <li>使用Sequence节点来执行巡逻和追击任务</li>
      <li>使用Action节点来执行实际的行为，比如移动到目标、攻击敌人等</li>
    </ul>
  </li>
</ol>

<p>可以根据需要不断添加、调整和优化行为树</p>

<ol>
  <li>
    <p>为Agent添加Behavior Tree
将设计好的行为树应用到Unity中的智能体（例如玩家、敌人或NPC）。需要为智能体添加Behavior Tree组件，选择刚才创建的行为树文件作为它的行为树源</p>
  </li>
  <li>调试与优化
    <ul>
      <li>实时调试：可以在运行时查看行为树的执行状态，知道哪些节点正在执行，哪些节点失败或成功。可以通过<code class="language-plaintext highlighter-rouge">Behavior Designer</code>的调试窗口实时查看行为树的执行流程</li>
      <li>性能优化：行为树本身非常高效，但在场景中有多个复杂的行为树时，仍然需要关注性能。通过将复杂的逻辑拆分为多个小任务，或使用Parallel和Inverter节点来优化执行路径，确保高效的计算</li>
    </ul>
  </li>
  <li>动态修改行为
可以在游戏运行时动态地修改AI的行为树或更改黑板上的数据。例如，敌人可能会根据当前的血量调整攻击策略，或者根据玩家的行为做出反应。Behavior Designer允许实时修改黑板数据和行为树</li>
</ol>

<h3 id="行为树的设计技巧">行为树的设计技巧</h3>
<ul>
  <li>分层设计：复杂的AI行为可以分解为多个子行为树。通过嵌套行为树或使用子树节点（Subtree Node），可以创建更为复杂和模块化的AI逻辑</li>
  <li>使用黑板：合理利用黑板来存储AI的状态数据（如目标位置、血量等），可以让行为树更加灵活且易于维护</li>
  <li>优化选择和序列节点的使用：选择器和序列节是行为树中的基础节点，使用时要确保其优先级设置合理，避免无意义的反复检查和执行</li>
  <li>模拟现实的AI决策：通过增加条件判断、引入随机性和决策回调，可以模拟更加智能的决策过程，使得AI的行为更接近真实世界中的复杂决策</li>
</ul>

<h3 id="behavior-designer-高级功能">Behavior Designer 高级功能</h3>
<ol>
  <li>多线程执行
Behavior Designer支持在多个线程中并行执行不同的任务，使得行为树的性能更高，尤其是当AI行为复杂且需要处理多个任务时（如多个敌人同时行动）</li>
  <li>事件驱动行为
可以设置一些事件（例如玩家进入攻击范围或触发特定的环境事件）来驱动AI行为树的切换，利用事件触发来灵活控制行为树的执行</li>
  <li>条件与动作分离
行为树中的节点通常包括条件判断和实际行为（动作），Behavior Designer允许清晰地将两者分开，便于调试和维护。例如，AI的巡逻i行为可以与判断敌人是否在视野内的逻辑分开</li>
  <li>内建的AI任务和动作
Behavior Designer包含了一些常用的AI任务和动作，如NavMesh移动、攻击、逃跑、等待等，可以大大简化开发过程</li>
</ol>

<h2 id="unity-behavior"><a href="/posts/2025-08-12-Unity-Behavior/">Unity Behavior</a></h2>
<p><a href="https://docs.unity3d.com/Packages/com.unity.behavior@1.0/manual/index.html">Manual Behavior</a></p>

<h2 id="自定义行为树实现">自定义行为树实现</h2>
<p>自定义行为树的实现涉及到创建一套系统，用于描述和管理AI代理（Agent）和行为决策</p>

<p>行为树的主要目的是通过一个树形结构来描述AI的决策过程，其中节点表示AI可能的行为或决策，根节点从树的顶端开始，逐层向下执行</p>
<ol>
  <li>设计行为树的基本结构
行为树的核心概念包括以下几种节点类型
    <ul>
      <li>根节点：行为树的起始点，通常包含一个选择节点或序列节点</li>
      <li>选择节点（Selector）：类似“或”逻辑，逐一尝试其子节点，直到一个子节点成功返回</li>
      <li>序列节点（Sequence）：类似“与”逻辑，依次尝试执行子节点，直到一个失败返回</li>
      <li>动作节点（Action）：具体的行为，如移动、攻击等</li>
      <li>条件节点（Condition）：判断条件是否成立，如“敌人在视野内”</li>
    </ul>
  </li>
  <li>定义行为树节点接口
定义一个抽象的节点类<code class="language-plaintext highlighter-rouge">BTNode</code>，所有的行为树节点都将继承自这个类
```cs
using System;
using System.Collections.Generic;
using UnityEngine;</li>
</ol>

<p>public enum NodeState
{
    SUCCESS,
    FAILURE,
    RUNNING
}</p>

<p>// 定义行为树节点接口
public abstract class BTNode
{
    public NodeState state;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public abstract NodeState Execute(); } ```
</code></pre></div></div>

<ol>
  <li>Selector实现
选择节点的作用是依次检查每个子节点，只要有一个子节点成功，它就会返回成功。否则，返回失败
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">SelectorNode</span> <span class="p">:</span> <span class="n">BTNode</span>
<span class="p">{</span>
 <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">BTNode</span><span class="p">&gt;</span> <span class="n">children</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">BTNode</span><span class="p">&gt;();</span>

 <span class="k">public</span> <span class="k">void</span> <span class="nf">AddChild</span><span class="p">(</span><span class="n">BTNode</span> <span class="n">child</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">children</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

 <span class="k">public</span> <span class="k">override</span> <span class="n">NodeState</span> <span class="nf">Execute</span><span class="p">()</span>
 <span class="p">{</span>
     <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="n">state</span> <span class="p">=</span> <span class="n">child</span><span class="p">.</span><span class="nf">Execute</span><span class="p">();</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="p">==</span> <span class="n">NodeState</span><span class="p">.</span><span class="n">SUCCESS</span><span class="p">)</span>
             <span class="k">return</span> <span class="n">NodeState</span><span class="p">.</span><span class="n">SUCCESS</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="n">NodeState</span><span class="p">.</span><span class="n">FAILURE</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Sequence实现
序列节点是按顺序依次执行其子节点，直到一个子节点失败，或者所有子节点执行成功
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">SequenceNode</span> <span class="p">:</span> <span class="n">BTNode</span>
<span class="p">{</span>
 <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">BTNode</span><span class="p">&gt;</span> <span class="n">children</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">BTNode</span><span class="p">&gt;();</span>

 <span class="k">public</span> <span class="k">void</span> <span class="nf">AddChild</span><span class="p">(</span><span class="n">BTNode</span> <span class="n">child</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">children</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

 <span class="k">public</span> <span class="k">override</span> <span class="n">NodeState</span> <span class="nf">Execute</span><span class="p">()</span>
 <span class="p">{</span>
     <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="n">state</span> <span class="p">=</span> <span class="n">child</span><span class="p">.</span><span class="nf">Execute</span><span class="p">();</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="p">==</span> <span class="n">NodeState</span><span class="p">.</span><span class="n">FAILURE</span><span class="p">)</span>
             <span class="k">return</span> <span class="n">NodeState</span><span class="p">.</span><span class="n">FAILURE</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="n">NodeState</span><span class="p">.</span><span class="n">SUCCESS</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Action实现
动作节点是叶子节点，执行具体的行为（如移动、攻击等）
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ActionNode</span> <span class="p">:</span> <span class="n">BTNode</span>
<span class="p">{</span>
 <span class="k">private</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">NodeState</span><span class="p">&gt;</span> <span class="n">action</span><span class="p">;</span>

 <span class="k">public</span> <span class="nf">ActionNode</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">NodeState</span><span class="p">&gt;</span> <span class="n">action</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="n">action</span> <span class="p">=</span> <span class="n">action</span><span class="p">;</span>

 <span class="k">public</span> <span class="k">override</span> <span class="n">NodeState</span> <span class="nf">Execute</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">action</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Condition实现
条件节点用于判断某个条件是否成立。例如，检测敌人是否在视野内
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">ConditionNode</span> <span class="p">:</span> <span class="n">BTNode</span>
<span class="p">{</span>
 <span class="k">private</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="n">condition</span><span class="p">;</span>

 <span class="k">public</span> <span class="nf">ConditionNode</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="n">condition</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="n">condition</span> <span class="p">=</span> <span class="n">condition</span><span class="p">;</span>

 <span class="k">public</span> <span class="k">override</span> <span class="n">NodeState</span> <span class="nf">Execute</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">condition</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">()</span> <span class="p">?</span> <span class="n">NodeState</span><span class="p">.</span><span class="n">SUCCESS</span> <span class="p">:</span> <span class="n">NodeState</span><span class="p">.</span><span class="n">FAILURE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>构建行为树
现在可以构建一个行为树，假设想要实现一个简单的敌人AI</li>
  <li>如果敌人被发现，攻击敌人</li>
  <li>如果敌人不在视野内，继续巡逻</li>
</ol>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">EnemyAI</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">BTNode</span> <span class="n">behaviourTree</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 创建行为树节点</span>
        <span class="n">SelectorNode</span> <span class="n">root</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SelectorNode</span><span class="p">();</span>

        <span class="c1">// 创建条件节点：检查敌人是否在视野内</span>
        <span class="n">ConditionNode</span> <span class="n">enemyInSight</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ConditionNode</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">IsEnemyInSight</span><span class="p">());</span>

        <span class="c1">// 创建动作节点：执行攻击</span>
        <span class="n">ActionNode</span> <span class="n">attackEnemy</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ActionNode</span><span class="p">(()</span> <span class="p">=&gt;</span> 
        <span class="p">{</span>
            <span class="nf">Attack</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">NodeState</span><span class="p">.</span><span class="n">SUCCESS</span><span class="p">;</span>
        <span class="p">});</span>

        <span class="c1">// 创建序列节点：敌人被发现 -&gt; 攻击</span>
        <span class="n">SequenceNode</span> <span class="n">sequence</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SequenceNode</span><span class="p">();</span>
        <span class="n">sequence</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="n">enemyInSight</span><span class="p">);</span>
        <span class="n">sequence</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="n">attackEnemy</span><span class="p">);</span>

        <span class="c1">// 将选择节点作为根节点</span>
        <span class="n">root</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="n">sequence</span><span class="p">);</span>

        <span class="c1">// 行为树</span>
        <span class="n">behaviorTree</span> <span class="p">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 执行行为树</span>
        <span class="n">behaviorTree</span><span class="p">.</span><span class="nf">Execute</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">IsEnemyInSight</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 假设简单的视野检测，返回随机值</span>
        <span class="k">return</span> <span class="n">UnityEngine</span><span class="p">.</span><span class="n">Random</span><span class="p">.</span><span class="k">value</span> <span class="p">&gt;</span> <span class="m">0.5f</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">Attack</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Attacking the enemy!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>调试与优化</strong><br />
在基本的行为树结构上，接下来可以</p>
<ul>
  <li>添加更多类型的节点（如黑板数据存储、任务节点等）</li>
  <li>调整节点之间的关系，使其更加复杂和智能</li>
  <li>在行为树中加入事件驱动机制，例如接收到伤害或其他外部条件时触发特定的行为</li>
</ul>

<p><strong>扩展与优化</strong>\</p>
<ul>
  <li>动态调整行为树：可以在游戏过程中动态修改行为树的结构或切换不同的行为树，例如根据敌人状态切换攻击模式</li>
  <li>黑板（Blackboard）：行为树的节点可以通过黑板来共享状态数据，如敌人的位置、角色的血量等</li>
  <li>多智能体支持：在大型游戏中，可能会有多个角色或敌人使用同一行为树。可以使用多线程或队列来管理多个智能体的行为执行</li>
</ul>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-06-01T00:00:00+08:00">June 1, 2025</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/posts/2025-06-13-Unity-Performance-Tuning/" class="pagination--pager" title="Unity Performance Tuning">Previous</a>
    
    
      <a href="/%E7%AC%94%E8%AE%B0/2025/06/01/Skybox.html" class="pagination--pager" title="Skybox">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/ljf12825" rel="nofollow noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">ljf12825's Blog</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
