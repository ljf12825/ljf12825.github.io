<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-06-23T12:31:38+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ljf12825’s Blog</title><subtitle>Efficient &amp; Elegant</subtitle><author><name>Jeff Lee</name><email>2548278761@qq.com</email></author><entry><title type="html">Skybox</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Skybox.html" rel="alternate" type="text/html" title="Skybox" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Skybox</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Skybox.html"><![CDATA[<p>Skybox是一种渲染技术，用于在3D场景中创建远景背景，例如天空、宇宙、城市天际线等<br />
它本质上是一种把纹理图贴在一个立方体（或球体）内侧的技巧，玩家看不到边界，只能看到包裹在四周的“天空”</p>

<h2 id="skybox的类型">Skybox的类型</h2>

<p>Unity中支持几种常见类型的Skybox材质（Shader）：</p>

<table>
  <thead>
    <tr>
      <th>Shader 类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>6 Sided</strong></td>
      <td>使用六张图片分别贴在立方体六个面上（一般来自 HDRI 贴图拆分）</td>
    </tr>
    <tr>
      <td><strong>Cubemap</strong></td>
      <td>使用一个立方体贴图（.cubemap）进行渲染</td>
    </tr>
    <tr>
      <td><strong>Procedural</strong></td>
      <td>程序化天空（可设置太阳、云层、颜色渐变）</td>
    </tr>
    <tr>
      <td><strong>HDRI Skybox (PBR)</strong></td>
      <td>用于高清真实感环境的 HDR 渲染，常用于 Unity HDRP</td>
    </tr>
  </tbody>
</table>

<h2 id="设置skybox的方法">设置Skybox的方法</h2>
<h3 id="1通过lighting设置全局skybox">1.通过Lighting设置全局Skybox</h3>
<p>1.创建一个Skybox材质：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Assets</code>-&gt;右键-&gt;<code class="language-plaintext highlighter-rouge">Create &gt; Material</code></li>
  <li>Shader选择为<code class="language-plaintext highlighter-rouge">Skybox/6 Sided</code>或<code class="language-plaintext highlighter-rouge">Skybox/Cubemap</code>或<code class="language-plaintext highlighter-rouge">Skybox/Procedural</code></li>
</ul>

<p>2.在材质中设置贴图（textures）或参数</p>

<p>3.打开<code class="language-plaintext highlighter-rouge">Window &gt; Rendering &gt; Lighting</code>面板</p>

<p>4.在<code class="language-plaintext highlighter-rouge">Environment &gt; Skybox Material</code>中拖入刚刚的材质</p>

<p>这会将该Skybox应用于整个场景</p>

<h3 id="2通过摄像机设置局部skybox高级">2.通过摄像机设置局部Skybox（高级）</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RenderSettings</span><span class="p">.</span><span class="n">skybox</span> <span class="p">=</span> <span class="n">mySkyboxMaterial</span><span class="p">;</span>
</code></pre></div></div>
<p>或为相机设置<code class="language-plaintext highlighter-rouge">Skybox</code>组件并赋值</p>

<h3 id="skybox与lighting的关系">Skybox与Lighting的关系</h3>
<p>Skybox不只是视觉上的背景，它还影响了：</p>
<ul>
  <li>Ambient Lighting（环境光）</li>
  <li>Reflection Probe（反射探针）</li>
  <li>全局光照（GI）计算</li>
</ul>

<p>所以换Skybox后记得：</p>
<ul>
  <li>在Lighting界面点击“Generate Lighting”</li>
  <li>使用Reflection Probe重新采样环境反射</li>
</ul>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity Component" /><category term="Light" /><category term="Render" /><category term="Graphics" /><summary type="html"><![CDATA[Skybox是一种渲染技术，用于在3D场景中创建远景背景，例如天空、宇宙、城市天际线等 它本质上是一种把纹理图贴在一个立方体（或球体）内侧的技巧，玩家看不到边界，只能看到包裹在四周的“天空”]]></summary></entry><entry><title type="html">Collider &amp;amp; Trigger</title><link href="http://localhost:4000/posts/2025-06-04-Collider-and-Trigger/" rel="alternate" type="text/html" title="Collider &amp;amp; Trigger" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Collider-and-Trigger</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-04-Collider-and-Trigger/"><![CDATA[<p>Unity中的碰撞体是物理系统的重要组成部分，负责定义游戏对象的形状以进行碰撞检测。简单来说，Collider是一个无形的边界，用于检测物体是否接触或重叠，从而触发碰撞事件和物理响应</p>

<h2 id="什么是collider">什么是Collider</h2>
<p>Collider是附加在游戏对象上的组件，用于告诉物理引擎这个对象的碰撞范围。Collider本身不会渲染形状，只是一个隐形的物理边界</p>

<h2 id="常见的collider类型">常见的Collider类型</h2>
<ul>
  <li>BoxCollider<br />
立方体形状的碰撞体，适合方形或长方体物体</li>
  <li>SphereCollider
球形碰撞体，适合球形或圆形物体</li>
  <li>CapsuleCollider
胶囊碰撞体，适合人物、柱子等</li>
  <li>MeshCollider
使用自定义网格模型做碰撞体，适合复杂形状，性能较差，且通常用于静态物体</li>
  <li>WheelCollider
专门用于车辆轮胎的碰撞和物理模拟</li>
</ul>

<h2 id="collider和rigidbody的关系">Collider和Rigidbody的关系</h2>
<ul>
  <li>Collider只负责检测碰撞，不会自定产生物理运动</li>
  <li>Rigidbody组件负责物理运动和动力学</li>
  <li>一个没有Rigidbody的物体的Collider会被当作“静态碰撞体”使用（静态障碍物），不会移动也不响应物理力</li>
  <li>一个有Rigidbody的物体可以在物理引擎驱动下移动，Collider会随物体运动</li>
</ul>

<h2 id="collider-panel">Collider Panel</h2>
<h3 id="box-collider">Box Collider</h3>
<p><img src="/assets/images/BoxColliderPanel.jpg" alt="BoxColliderPanel" /></p>
<ul>
  <li>IsTrigger
默认false，此时Collider是实体碰撞体，会阻挡其他物体，发生物理碰撞和反弹<br />
勾选时，Collider变成Trigger，不会阻挡其他物体，但会检测进入、离开和停留事件，可以用来做区域检测、事件触发等</li>
  <li>Provides Contacts
用于物理引擎的碰撞检测和接触点信息提供<br />
默认false，Collider可能只报告碰撞发生，但不提供详细的接触点信息，这样可以节省一些计算资源<br />
勾选后，Collider会提供详细的碰撞接触点信息，这样物理引擎在碰撞时，可以把碰撞的具体接触点信息暴露出来，供脚本或物理系统使用
    <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CollisionPointExample</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">OnCollisionEnter</span><span class="p">(</span><span class="n">Collision</span> <span class="n">collision</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="n">ContactPoint</span> <span class="n">contact</span> <span class="k">in</span> <span class="n">collision</span><span class="p">.</span><span class="n">contacts</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">//接触点位置</span>
      <span class="n">Vector3</span> <span class="n">contactPoint</span> <span class="p">=</span> <span class="n">contact</span><span class="p">.</span><span class="n">point</span><span class="p">;</span>
      <span class="c1">//接触点法线方向</span>
      <span class="n">Vector3</span> <span class="n">contactNormal</span> <span class="p">=</span> <span class="n">contact</span><span class="p">.</span><span class="n">normal</span><span class="p">;</span>

      <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">contactPoint</span><span class="p">}</span><span class="s">, </span><span class="p">{</span><span class="n">contactNormal</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>如果时触发碰撞，IsTrigger勾选情况下，用的是OnTriggerEnter(Collider other)，这个回调中没有接触点信息，只能检测触发</p>
  </li>
  <li>Material
指的是Physics Material，用于控制物理行为的材质<br />
Create -&gt; Physics Material，编辑后拖入使用<br />
作用：Physics Material用于定义物体在碰撞时的物理特性，比如摩擦力（Friction）、弹性（Bounciness）
常用属性
    <ul>
      <li>Dynamic Friction 动摩擦力</li>
      <li>Static Friction 静摩擦力</li>
      <li>Bounciness 弹力（0到1之间，1表示完全反弹）</li>
      <li>Friction Combine 摩擦组合方式（与另一个碰撞体交互时如何合成摩擦）</li>
      <li>Bounce Combine 弹性组合方式（与另一个碰撞体交互时如何合成弹性）</li>
    </ul>
  </li>
  <li>Center
    <ul>
      <li>指的是碰撞体在物体局部坐标系中的中心点位置</li>
      <li>类型是Vector3</li>
      <li>不会移动GameObject本身，只会改变碰撞体的位置</li>
    </ul>
  </li>
  <li>Size
    <ul>
      <li>指碰撞体的尺寸</li>
      <li>类型是Vector3</li>
      <li>控制这个碰撞盒子的大小</li>
    </ul>
  </li>
  <li>Layer Overrides
    <ul>
      <li>Layer Override Priority
用于控制多个Collider在同一物体或子物体上时，哪个Collider的物理层优先生效<br />
如果一个物体上有多个Collider，并且它们分别设置了不同的Layer，Unity需要一个优先级来判断最终物体的碰撞行为应该归属哪个Layer<br />
When 2 Colliders have conflicting overrides, the settings of the collider with the higher priority are taken</li>
      <li>Include Layers
Layers to include when producing collisions</li>
      <li>Exclude Layers
Layers to exclude when producing collisions</li>
    </ul>
  </li>
</ul>

<h3 id="capsulecollider">CapsuleCollider</h3>
<p><img src="/assets/images/CapsuleColliderPanel.jpg" alt="CapsuleColliderPanel" /></p>
<ul>
  <li>Edit Collider
显示Collider边界<br />
Hold Alt after clicking control handle to pin center in place（中心缩放） 
Hold Shift after clicking control handle to scale uniformly（等比缩放）</li>
  <li>Direction
The axis of the capsule’s lengthwise orientation in the GameObject’s local space</li>
</ul>

<h3 id="meshcollider">MeshCollider</h3>
<p><img src="/assets/images/MeshColliderPanel.jpg" alt="MeshColliderPanel" />
<code class="language-plaintext highlighter-rouge">MeshCollider</code>是Unity提供的一个基于Mesh的碰撞体组件，它允许你使用一个Mesh的集合外形作为碰撞体检测的形状<br />
它可以让你的碰撞体检测看起来和你的物体一样精细</p>

<ul>
  <li>Convex
是否把Mesh处理为凸包<br />
如果勾选了：
    <ul>
      <li>可以用于动态刚体</li>
      <li>可以用作Trigger</li>
      <li>不能太复杂（最多255个三角形）</li>
    </ul>

    <p>如果不勾选：</p>
    <ul>
      <li>可精确表示复杂网格，但只能用于静态物体</li>
      <li>不支持Trigger和Rigidbody</li>
    </ul>
  </li>
</ul>

<p><strong>MeshCollider Convex使用注意事项</strong></p>

<table>
  <thead>
    <tr>
      <th>场景</th>
      <th>是否适合用 MeshCollider</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>地形、建筑（静态）</td>
      <td>非 Convex MeshCollider</td>
    </tr>
    <tr>
      <td>可交互物体 + Rigidbody</td>
      <td>Convex MeshCollider</td>
    </tr>
    <tr>
      <td>复杂模型 + Trigger</td>
      <td>Convex MeshCollider（前提是够简单）</td>
    </tr>
    <tr>
      <td>移动物体 + 非 Convex</td>
      <td>不支持，会报错</td>
    </tr>
    <tr>
      <td>高性能要求的游戏</td>
      <td>尽量少用 MeshCollider，建议用简化碰撞体代替</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>Cooking Options
用于控制在碰撞体生成（或烘焙）过程中如何处理网格数据，以提高碰撞效率或调试准确性<br />
Unity在运行时将网格数据转换为物理引擎能使用的碰撞形式格式，这个过程叫做Mesh Cooking</li>
</ul>

<h3 id="terrian-collider">Terrian Collider</h3>
<ul>
  <li>Enable Tree Colliders
When selected, Tree Colliders will be enabled</li>
</ul>

<h3 id="wheel-collider">Wheel Collider</h3>
<p><img src="/assets/images/WheelColliderPanel.jpg" alt="WheelColliderPanel" /></p>
<ul>
  <li>Wheel Damping Rate
轮阻，轮子滚动时的摩擦衰减速度</li>
  <li>Suspension Distance
悬挂行程，表示悬挂系统允许轮子从默认位置向下延伸的最大距离，单位是米</li>
  <li>Force App Point Distance
力施加点距离，控制Unity向车体施加力的位置，距离轮子中心的垂直距离，单位是米；可以理解为手推玩具车的高度</li>
  <li>Suspension Spring
用于模拟汽车的避震器（弹簧 + 阻尼）
    <ul>
      <li>Spring
弹簧刚度，越大越硬</li>
      <li>Damper
阻尼，阻止弹簧震荡的速度，越大越稳定</li>
      <li>Target Position
悬挂初始压缩程度，0表示全伸展，1表示全压缩</li>
    </ul>
  </li>
  <li>Forward Friction &amp; Sideways Friction
控制轮子在前进方向/侧向的摩擦行为
<code class="language-plaintext highlighter-rouge">Forward Friction</code>：控制加速、刹车的打滑程度
<code class="language-plaintext highlighter-rouge">Sideways Friction</code>：控制漂移、转弯时的打滑程度
    <ul>
      <li>Extremum Slip
轮胎开始打滑时的滑动值阈值</li>
      <li>Extremum Value
极限摩擦力值（未打滑前）</li>
      <li>Asymptote Slip
完全失控打滑时的滑动值阈值</li>
      <li>Asymptote Value
极限打滑摩擦力值</li>
      <li>Stiffness
总体摩擦刚度系数（0-1）。调节摩擦强度的“乘法器”
<strong>Wheel Collider API</strong></li>
    </ul>
  </li>
  <li>Motor Torque
通过代码向轮子添加驱动力（加速）
    <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wheelCollider</span><span class="p">.</span><span class="n">motorTorque</span> <span class="p">=</span> <span class="m">200f</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>Brake Torque
刹车力
    <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wheelCollider</span><span class="p">.</span><span class="n">brakeTorque</span> <span class="p">=</span> <span class="m">500f</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>Steer Angle
控制论在（尤其是前轮）的转向角度
    <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wheelCollider</span><span class="p">.</span><span class="n">steerAngle</span> <span class="p">=</span> <span class="m">30f</span><span class="p">;</span>
</code></pre></div>    </div>
    <p><strong>使用WheelCollider</strong></p>
  </li>
</ul>

<p>在车体下放置空 GameObject，添加 <code class="language-plaintext highlighter-rouge">WheelCollider</code>。</p>

<p>设置合适的 <code class="language-plaintext highlighter-rouge">Radius</code> 和 <code class="language-plaintext highlighter-rouge">Suspension</code>。</p>

<p>使用一个轮胎模型作为视觉轮子（但它自己不加 Collider）。</p>

<p>每帧用代码同步 <code class="language-plaintext highlighter-rouge">WheelCollider.GetWorldPose()</code> 更新轮胎模型位置旋转。</p>

<p>用 <code class="language-plaintext highlighter-rouge">motorTorque</code>、<code class="language-plaintext highlighter-rouge">brakeTorque</code>、<code class="language-plaintext highlighter-rouge">steerAngle</code> 控制车轮。</p>

<p><strong>示例：同步轮子模型</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">WheelCollider</span> <span class="n">wheelCollider</span><span class="p">;</span>
<span class="k">public</span> <span class="n">Transform</span> <span class="n">wheelModel</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Vector3</span> <span class="n">pos</span><span class="p">;</span>
  <span class="n">Quaternion</span> <span class="n">rot</span><span class="p">;</span>
  <span class="n">wheelCollider</span><span class="p">.</span><span class="nf">GetWorldPose</span><span class="p">(</span><span class="k">out</span> <span class="n">pos</span><span class="p">,</span> <span class="k">out</span> <span class="n">rot</span><span class="p">);</span>
  <span class="n">wheelModel</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">pos</span><span class="p">;</span>
  <span class="n">wheelModel</span><span class="p">.</span><span class="n">rotation</span> <span class="p">=</span> <span class="n">rot</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="对齐collider和gameobject">对齐Collider和GameObject</h2>
<p>要保证Collider与GameObject完全重合，要让Collider的Center对准模型的中心，并让他的Size或Radius匹配模型的尺寸</p>

<h3 id="方法一使用mesh-renderer的bounds手动对齐">方法一：使用Mesh Renderer的Bounds手动对齐</h3>
<p>1.选中GameObject<br />
2.查看Inspector面板中的Mesh Renderer或Mesh Filter：</p>
<ul>
  <li>记下它的Bounds和Center</li>
</ul>

<p>3.在Collider中手动设置</p>

<h3 id="方法二使用unity自动对齐">方法二：使用Unity自动对齐</h3>
<p>在Inspector面板中，点击组件右上角的菜单-&gt;<code class="language-plaintext highlighter-rouge">Reset</code><br />
或删除后重新添加Box Collider，Unity会自动用Mesh尺寸初始化</p>
<blockquote>
  <p>注意：自动添加只对Unity支持的标志Mesh效果好，对导入模型FBX有时不准确</p>
</blockquote>

<h3 id="方法三通过脚本自动匹配mesh-bounds">方法三：通过脚本自动匹配Mesh Bounds</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="p">[</span><span class="nf">RequireComponent</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">BoxCollider</span><span class="p">))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">FitColliderToMesh</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">mesh</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshFilter</span><span class="p">&gt;().</span><span class="n">sharedMesh</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">bounds</span> <span class="p">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">collider</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">BoxCollider</span><span class="p">&gt;();</span>
    <span class="n">collider</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="n">bounds</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
    <span class="n">collider</span><span class="p">.</span><span class="n">size</span> <span class="p">=</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>注意：<code class="language-plaintext highlighter-rouge">mesh.bounds</code>是局部坐标系下的范围<br />
如果模型被缩放，需要做缩放修正</p>

<h3 id="检查是否重合的方法">检查是否重合的方法</h3>
<p>1.Gizmo显示：Scene视图中选中物体，勾选Gizmo，可以看到Collider的框是否保住模型<br />
2.调试代码验证接触：你可以在运行是打印<code class="language-plaintext highlighter-rouge">Collider.contacts[0].point</code>看碰撞点位置是否符合预期<br />
3.把Mesh设成透明或关闭渲染，观察Collider是否贴合</p>

<h3 id="collider基类-api">Collider基类 API</h3>
<p><strong>常用属性</strong></p>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">enabled</code></td>
      <td>是否启用该碰撞体，禁用后不参与碰撞检测。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isTrigger</code></td>
      <td>是否作为触发器（Trigger），开启后不阻挡，只触发事件。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">attachedRigidbody</code></td>
      <td>关联的 Rigidbody 组件（如果有的话）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bounds</code></td>
      <td>碰撞体的世界轴对齐包围盒（<code class="language-plaintext highlighter-rouge">Bounds</code> 类型）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sharedMaterial</code></td>
      <td>物理材质，控制摩擦力和弹力。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">material</code></td>
      <td>碰撞体当前使用的物理材质实例。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">contactOffset</code></td>
      <td>碰撞体接触判定的偏移距离，影响物理碰撞的灵敏度。</td>
    </tr>
  </tbody>
</table>

<p><strong>常用方法</strong></p>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ClosestPoint(Vector3 position)</code></td>
      <td>返回碰撞体表面上距离指定点最近的点。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance)</code></td>
      <td>以射线检测碰撞体是否被击中，返回击中信息。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetComponent&lt;T&gt;()</code></td>
      <td>获取挂载在同一GameObject上的组件（Collider继承自Component，所以可用此方法）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnCollisionEnter/OnTriggerEnter</code></td>
      <td>物理事件回调，不是Collider自带的方法，但Collider触发时会调用对应脚本方法。</td>
    </tr>
  </tbody>
</table>

<p><strong>事件相关</strong><br />
Collider本身没有事件接口，但它的物理交互会调用以下MonoBehaviour的回调方法</p>

<table>
  <thead>
    <tr>
      <th>事件名</th>
      <th>触发条件</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnCollisionEnter(Collision collision)</code></td>
      <td>碰撞开始</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnCollisionStay(Collision collision)</code></td>
      <td>碰撞持续</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnCollisionExit(Collision collision)</code></td>
      <td>碰撞结束</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnTriggerEnter(Collider other)</code></td>
      <td>触发器进入</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnTriggerStay(Collider other)</code></td>
      <td>触发器持续</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnTriggerExit(Collider other)</code></td>
      <td>触发器离开</td>
    </tr>
  </tbody>
</table>

<h2 id="什么是trigger">什么是Trigger</h2>
<p>Trigger是Collider组件的一个特殊状态，用来检测物体的进入、停留和离开事件，但不会产生物理碰撞和响应<br />
Trigger是Collider的感应区域模式</p>

<h3 id="trigger应用场景">Trigger应用场景</h3>
<ul>
  <li>检测角色进入某个区域（陷阱、传送门、对话触发区）</li>
  <li>收集物品（进入物品碰撞区域后触发拾取）</li>
  <li>触发游戏事件（比如开门、启动机关）</li>
  <li>检测敌人视野范围</li>
</ul>

<h3 id="注意事项">注意事项</h3>
<ul>
  <li>触发器本身不会组织物体移动，物体可以自由穿过</li>
  <li>要保证触发事件能被调用，涉及的GameObject至少一个带有Collider（且其中至少一个是Trigger）和Rigidbody组件，一般建议被检测的物体带Rigidbody</li>
  <li>如果两个物体都没有Rigidbody，触发事件不会发生</li>
</ul>

<p><strong>本模块仅讲Collider作为组件的使用，详细物理系统请参照：</strong><br />
<a href="/posts/2025-06-03-Physics-System/">Physics System</a></p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity Component" /><category term="Physics System" /><summary type="html"><![CDATA[Unity中的碰撞体是物理系统的重要组成部分，负责定义游戏对象的形状以进行碰撞检测。简单来说，Collider是一个无形的边界，用于检测物体是否接触或重叠，从而触发碰撞事件和物理响应]]></summary></entry><entry><title type="html">Behaviour Tree</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Behaviour-Tree.html" rel="alternate" type="text/html" title="Behaviour Tree" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Behaviour-Tree</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Behaviour-Tree.html"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><category term="AI" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Unity Performance Tuning</title><link href="http://localhost:4000/posts/2025-06-13-Unity-Performance-Tuning/" rel="alternate" type="text/html" title="Unity Performance Tuning" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Unity-Performance-Tuning</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-13-Unity-Performance-Tuning/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Unity Profiler</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Unity-Profiler.html" rel="alternate" type="text/html" title="Unity Profiler" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Unity-Profiler</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Unity-Profiler.html"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity Tool" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">TileMap</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/TileMap.html" rel="alternate" type="text/html" title="TileMap" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/TileMap</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/TileMap.html"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><category term="Unity Component" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Unity NetWork</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Unity-NetWork.html" rel="alternate" type="text/html" title="Unity NetWork" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Unity-NetWork</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Unity-NetWork.html"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity NetWork" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Terrain</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Terrain.html" rel="alternate" type="text/html" title="Terrain" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Terrain</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Terrain.html"><![CDATA[<p>在Unity中，Terrain是一个专门用于制作大规模、自然风格场景的强大工具</p>

<h2 id="什么是terrain">什么是Terrain</h2>
<p>Terrain是Unity提供的一个内置组件，用于在场景中创建可编辑的地形<br />
它由多个部分组成：</p>
<ul>
  <li>地形本体（高度图控制的网格）</li>
  <li>纹理涂层（地表材质贴图）</li>
  <li>植被/树木/草</li>
  <li>光照支持（光照贴图、探针）</li>
  <li>LOD和剔除</li>
</ul>

<h2 id="terrain的核心结构">Terrain的核心结构</h2>

<table>
  <thead>
    <tr>
      <th>模块</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>高度图（Heightmap）</strong></td>
      <td>决定地形的高低起伏</td>
    </tr>
    <tr>
      <td><strong>绘制材质（Layers）</strong></td>
      <td>地面纹理（如草地、岩石、雪）混合涂刷</td>
    </tr>
    <tr>
      <td><strong>细节对象（Details）</strong></td>
      <td>草、石头、花等低多边形细节（大量渲染优化）</td>
    </tr>
    <tr>
      <td><strong>树木系统（Trees）</strong></td>
      <td>批量放置支持 LOD 的树</td>
    </tr>
    <tr>
      <td><strong>碰撞体</strong></td>
      <td>自动生成地形碰撞</td>
    </tr>
    <tr>
      <td><strong>光照支持</strong></td>
      <td>支持烘焙光照图、Light Probe、反射探针</td>
    </tr>
  </tbody>
</table>

<h2 id="terrain-data">Terrain Data</h2>
<p><code class="language-plaintext highlighter-rouge">Terrain Data</code>是地形的“后端数据容器”，和<code class="language-plaintext highlighter-rouge">Terrain</code>组件一起工作，一个<code class="language-plaintext highlighter-rouge">Terrain</code>组件绑定一个<code class="language-plaintext highlighter-rouge">TerrainData</code>资源</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Terrain</span> <span class="n">terrain</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Terrain</span><span class="p">&gt;();</span>
<span class="n">TerrainData</span> <span class="n">data</span> <span class="p">=</span> <span class="n">terrain</span><span class="p">.</span><span class="n">terrainData</span><span class="p">;</span>
</code></pre></div></div>
<h3 id="terraindata保存的内容"><code class="language-plaintext highlighter-rouge">TerrainData</code>保存的内容</h3>
<h4 id="高度图heightmap">高度图（Heightmap）</h4>
<ul>
  <li>用灰度图(float[,])描述地形的高度</li>
  <li>控制地形表面的形状
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span><span class="p">[,]</span> <span class="n">heights</span> <span class="p">=</span> <span class="n">terrainData</span><span class="p">.</span><span class="nf">GetHeights</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="纹理图层splatmaps">纹理图层（Splatmaps）</h4>
<ul>
  <li>每层纹理混合信息</li>
  <li>用来混合多个地形材质（如泥土、草地、雪）
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span><span class="p">[,,]</span> <span class="n">alphamaps</span> <span class="p">=</span> <span class="n">terrainData</span><span class="p">.</span><span class="nf">GetAlphamaps</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="细节对象detailsgrass">细节对象（Details/Grass）</h4>
<ul>
  <li>如草地、灌木，用细节地图存储
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="p">[,]</span> <span class="n">detailMap</span> <span class="p">=</span> <span class="n">terrainData</span><span class="p">.</span><span class="nf">GetDetailLayer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">detailLayerIndex</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="树对象trees">树对象（Trees）</h4>
<ul>
  <li>存储每棵树的位置、缩放、原型类型
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TreeInstance</span><span class="p">[]</span> <span class="n">trees</span> <span class="p">=</span> <span class="n">terrainData</span><span class="p">.</span><span class="n">treeInstances</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="分辨率信息">分辨率信息</h4>
<ul>
  <li>高度图分辨率：决定地形精细度</li>
  <li>控制图分辨率：纹理混合图精度</li>
  <li>细节图分辨率：草木布置精度
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">terrainData</span><span class="p">.</span><span class="n">heightmapResolution</span>
<span class="n">terrainData</span><span class="p">.</span><span class="n">alphamapResolution</span>
<span class="n">terrainData</span><span class="p">.</span><span class="n">detailResolution</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>示例：运行时生成地形</strong></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">GenerateTerrain</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">TerrainData</span> <span class="n">terrainData</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TerrainData</span><span class="p">();</span>
  <span class="n">terrainData</span><span class="p">.</span><span class="n">heightmapResolution</span> <span class="p">=</span> <span class="m">513</span><span class="p">;</span>
  <span class="n">terrainData</span><span class="p">.</span><span class="n">size</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="m">1000</span><span class="p">);</span>

  <span class="kt">float</span><span class="p">[,]</span> <span class="n">heights</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="m">513</span><span class="p">,</span> <span class="m">513</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="m">513</span><span class="p">;</span> <span class="p">++</span><span class="n">x</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="m">513</span><span class="p">;</span> <span class="p">++</span><span class="n">y</span><span class="p">)</span>
    <span class="n">heights</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">PerlinNoise</span><span class="p">(</span><span class="n">x</span> <span class="p">*</span> <span class="m">0.01f</span><span class="p">,</span> <span class="n">y</span> <span class="p">*</span> <span class="m">0.01f</span><span class="p">)</span> <span class="p">*</span> <span class="m">0.2f</span><span class="p">;</span>
  
  <span class="n">terrainData</span><span class="p">.</span><span class="nf">SetHeights</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">heights</span><span class="p">);</span>

  <span class="n">GameObject</span> <span class="n">terrainGO</span> <span class="p">=</span> <span class="n">Terrain</span><span class="p">.</span><span class="nf">CreateTerrainGameObject</span><span class="p">(</span><span class="n">terrainData</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="注意事项">注意事项</h3>

<table>
  <thead>
    <tr>
      <th>限制</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>只能在主线程读写</td>
      <td>不支持多线程访问（除非用 <code class="language-plaintext highlighter-rouge">NativeArray</code> Hack）</td>
    </tr>
    <tr>
      <td>修改后需刷新</td>
      <td>修改 <code class="language-plaintext highlighter-rouge">terrainData</code> 后需设置给 <code class="language-plaintext highlighter-rouge">Terrain</code> 才生效</td>
    </tr>
    <tr>
      <td>不可跨 Terrain 共享贴图索引</td>
      <td>每个地形的 <code class="language-plaintext highlighter-rouge">TerrainLayer[]</code> 不能乱用，需要独立处理</td>
    </tr>
  </tbody>
</table>

<h2 id="terrain-in-inspector">Terrain in Inspector</h2>
<p>场景中的Terrain对象一般会包含以下模块</p>
<ul>
  <li>Terrain（主组件）</li>
  <li>Terrain Collider（自动附加）</li>
  <li>Terrain Tools（各种绘制工具）</li>
  <li>Terrain Settings（参数设置）</li>
</ul>

<h3 id="create-neighbor-terrains">Create Neighbor Terrains</h3>
<p><img src="/assets/images/CreateNeighborTerrains.jpg" alt="CreateNeighborTerrains" /></p>

<h4 id="这是什么">这是什么</h4>
<p>Unity的每一个Terrain是一个地形快（chunk），当你需要构建更大的世界地图时：</p>
<blockquote>
  <p>你可以将多个地形快拼接在一起，形成一个无缝连接的大地图
<code class="language-plaintext highlighter-rouge">Create Neighbor Terrains</code>就是一个快捷工具，让你快速在上下左右形成新的Terrain，并自动设置它们之间的连接关系（Neighbor）</p>
</blockquote>

<h4 id="unity会做什么">Unity会做什么</h4>
<ul>
  <li>自动创建一个或多个相邻的Terrain GameObject</li>
  <li>与当前的Terrain无缝拼接（边界贴合）</li>
  <li>自动设置每个地形的Neighbor引用（主要用于LOD过渡等）</li>
</ul>

<p><img src="/assets/images/TerrainNeighbor.jpg" alt="TerrainsNeighbor" /></p>

<h4 id="创建后的terrain有哪些特征">创建后的Terrain有哪些特征</h4>
<ul>
  <li>分辨率与当前Terrain一致</li>
  <li>初始高度图为空白</li>
  <li>材质/Detail Layer/树/Layer并不会自动继承，需要手动复制</li>
  <li>已经自动设置了<code class="language-plaintext highlighter-rouge">SetNeighbor</code>（Unity会在内部管理连接信息）</li>
</ul>

<h4 id="为什么需要neighbor信息">为什么需要Neighbor信息</h4>
<p>Unity Terrain在运行时做：</p>
<ul>
  <li>LOD边界融合（避免接缝）</li>
  <li>光照探针插值正确性</li>
  <li>寻路/NavMesh分布</li>
</ul>

<p>也就是说，如果你手动创建了多个Terrain，没有设置Neighbor，会出现：</p>
<ul>
  <li>LOD切换时断裂</li>
  <li>光照贴图不连续</li>
  <li>草树渲染突然中断</li>
</ul>

<h4 id="tips">Tips</h4>
<p>多Terrain的场景通常配合：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Streaming</code>（按需加载块）</li>
  <li><code class="language-plaintext highlighter-rouge">Runtime Stitching</code>（连接边界）
可以使用插件如MicroSplat/Gaia等进行多地形管理</li>
</ul>

<h3 id="paintterrain">PaintTerrain</h3>
<p><img src="/assets/images/PaintTerrain.jpg" alt="PaintTerrain" /></p>

<p>这是Unity Terrain系统用于手动“绘制”地形的工具，类似PS中的笔刷，但是用于三维地形，可以用它来：</p>
<ul>
  <li>提升/降低地形</li>
  <li>涂抹纹理（比如：草、图、雪）</li>
  <li>铺设草和石头（Detail）</li>
  <li>放置树木（Tree）</li>
  <li>设置材质混合</li>
  <li>创建地形孔洞（如山洞入口）</li>
</ul>

<h4 id="sub-tools">Sub Tools</h4>
<h5 id="1raise-or-lower-terrain">1.Raise or Lower Terrain</h5>
<blockquote>
  <p>用笔刷将地形向上或向下推动</p>
</blockquote>

<ul>
  <li>Bursh Size：笔刷大小（影响范围）</li>
  <li>Opacity：强度（提升速度）</li>
  <li>Target Strength：单次推拉的力量</li>
  <li>可用于画山、丘陵、平原</li>
</ul>

<p>配合<code class="language-plaintext highlighter-rouge">Shift</code>反向操作</p>

<h5 id="2set-height">2.Set Height</h5>
<blockquote>
  <p>把地形调整到某个统一的高度（例如建平台）</p>
</blockquote>

<ul>
  <li>设置<code class="language-plaintext highlighter-rouge">Target Height</code>，然后绘制地形</li>
  <li>适合制作建筑平台、河面、平地道路</li>
</ul>

<p>可以使用<code class="language-plaintext highlighter-rouge">Flatten</code>一键铺平当前Terrain</p>

<h5 id="3smooth-height平滑地形">3.Smooth Height（平滑地形）</h5>
<blockquote>
  <p>平滑地形的高低差，让地形更自然</p>
</blockquote>

<ul>
  <li>常用于锐利山峰边缘平滑处理</li>
  <li>减少单位移动时的突兀感</li>
</ul>

<h5 id="4paint-texture涂地表材质">4.Paint Texture（涂地表材质）</h5>
<blockquote>
  <p>把不同纹理“画”到地形上，实现草地、雪地、沙漠的混合过渡</p>
  <ul>
    <li>每个纹理时一个Terrain Layer</li>
    <li>Unity支持多图混合（最多8张）</li>
    <li>使用笔刷方式混合地表纹理</li>
  </ul>
</blockquote>

<p>示例层：</p>
<ul>
  <li>Layer1：Grass</li>
  <li>Layer2：Dirt</li>
  <li>Layer3：Rock</li>
</ul>

<p>支持自定义笔刷、混合过渡控制（Opacity）<br />
<code class="language-plaintext highlighter-rouge">Add Layer</code>添加纹理层，选用PBR材质（支持BaseMap、NormalMap）</p>

<h5 id="5terrain-holes">5.Terrain Holes</h5>
<blockquote>
  <p>画出洞，让地形有缺口（可用于洞穴、地道入口）</p>
</blockquote>

<ul>
  <li>类似“橡皮擦”，直接擦掉地形面片</li>
  <li>可用于：
    <ul>
      <li>做地下世界入口</li>
      <li>配合Portal、Volume、Trigger使用
默认不可通过地形下看见，需要你手动铺地板或连接其他网格模型</li>
    </ul>
  </li>
</ul>

<h3 id="paint-trees">Paint Trees</h3>
<p><img src="/assets/images/PaintTrees.jpg" alt="PaintTrees" /></p>

<p><code class="language-plaintext highlighter-rouge">Paint Trees</code>是Unity Terrain中用于批量种植树木的工具，它支持使用不同树模型的自动随机分布、缩放、选择、LOD显示等，是创建森林、山地植被的关键工具</p>
<h4 id="添加树模型">添加树模型</h4>
<p>点击 “Edit Trees” → “Add Tree…”：</p>
<ul>
  <li>在弹出的窗口中选择一个 树的 Prefab</li>
  <li>Unity 支持：
    <ul>
      <li>Tree Creator 制作的树（.tree 文件）</li>
      <li>SpeedTree 模型（.spm 文件）</li>
      <li>自己导入的 FBX/Prefab 模型（需带有 LOD/Collider）</li>
    </ul>
  </li>
</ul>

<p>要求：</p>
<ul>
  <li>树不能有刚体或Animator</li>
  <li>树Prefab中必须包含Mesh Renderer（或SpeedTree）</li>
</ul>

<h4 id="种树参数设置">种树参数设置</h4>
<p>添加好树之后，就可以开始“画树”了，主要参数如下：</p>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Brush Size</strong></td>
      <td>控制笔刷直径（影响范围）</td>
    </tr>
    <tr>
      <td><strong>Tree Density</strong></td>
      <td>控制单位面积内种植的数量</td>
    </tr>
    <tr>
      <td><strong>Tree Height/Width</strong></td>
      <td>控制树的缩放范围（有最小和最大）</td>
    </tr>
    <tr>
      <td><strong>Color Variation</strong></td>
      <td>控制颜色的随机扰动（偏红、偏绿、偏亮等）</td>
    </tr>
    <tr>
      <td><strong>Random Rotation</strong></td>
      <td>勾选后自动随机 Y 轴旋转树（防止重复感）</td>
    </tr>
  </tbody>
</table>

<p>每画一次，就会在当前区域根据密度、大小、颜色等参数生成多个树</p>

<h4 id="树木渲染和性能优化">树木渲染和性能优化</h4>
<p>Unity的Terrain树有专门的渲染优化方案</p>
<h5 id="billboard看板树">Billboard（看板树）</h5>
<ul>
  <li>当树距离相机较远时，自动变成平面图片</li>
  <li>极大减少了远距离渲染负担</li>
</ul>

<h5 id="lod支持">LOD支持</h5>
<ul>
  <li>使用SpeedTree模型或LOD Group的树可自动切换模型精度</li>
  <li>可自定义LOD阶段</li>
</ul>

<h5 id="gpu-instancing">GPU Instancing</h5>
<ul>
  <li>大量相同的树会使用GPU Instancing批处理渲染</li>
  <li>极大提高性能，适合森林、大面积自然场景</li>
</ul>

<h4 id="树的碰撞">树的碰撞</h4>
<p>默认树时没有碰撞器的，但你可以启用碰撞</p>
<ul>
  <li>勾选<code class="language-plaintext highlighter-rouge">Tree Collider</code>（取决于添加的树的prefab）</li>
  <li>或者在Runtime中为某些特殊树添加<code class="language-plaintext highlighter-rouge">Capsule Collider</code>等</li>
</ul>

<p>适用于：</p>
<ul>
  <li>玩家可以撞到树</li>
  <li>砍树系统</li>
  <li>遮挡判断</li>
</ul>

<h4 id="几种树的比较">几种树的比较</h4>

<table>
  <thead>
    <tr>
      <th>工具</th>
      <th>特点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Tree Creator</strong></td>
      <td>Unity 内置的老式树编辑器，支持风、LOD，效率不高，（2022版本已弃用）</td>
    </tr>
    <tr>
      <td><strong>SpeedTree</strong></td>
      <td>高级树木生成工具，效果好，适合中大型项目（但是商业插件）</td>
    </tr>
    <tr>
      <td><strong>普通 Prefab 树</strong></td>
      <td>自己做的 FBX + LOD，灵活但需优化得当</td>
    </tr>
    <tr>
      <td><strong>Terrain 树</strong></td>
      <td>专为大量地形种树优化，性能最佳但不支持动画/刚体</td>
    </tr>
  </tbody>
</table>

<h3 id="paint-details">Paint Details</h3>
<p><img src="/assets/images/PaintDetails.jpg" alt="PaintDetails" /></p>

<p><code class="language-plaintext highlighter-rouge">Paint Details</code>是Unity Terrain系统中用于在地形上批量绘制“小型自然细节”的工具，它与<code class="language-plaintext highlighter-rouge">Paint Trees</code>类似，但用于体积更小、密度更高的细节对象，是构建自然场景的关键补充</p>

<h4 id="如何添加细节类型">如何添加细节类型</h4>
<p>点击面板中的：Edit Details → Add Detail Mesh / Add Grass Texture</p>

<p>Unity提供两种添加方式</p>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>描述</th>
      <th>适用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Detail Mesh</strong></td>
      <td>3D Mesh 物体</td>
      <td>小石头、蘑菇、落叶、低模草</td>
    </tr>
    <tr>
      <td><strong>Grass Texture</strong></td>
      <td>Billboard（摄像机对面）草贴图</td>
      <td>草地、麦田、灌木等</td>
    </tr>
  </tbody>
</table>

<h5 id="add-grass-texture">Add Grass Texture</h5>
<p>用于画贴图式草，性能最高</p>
<ul>
  <li>你只需指定一个灰度图草纹理（通常带透明背景）</li>
  <li>Unity会使用Billboard模式渲染草</li>
  <li>草会随风飘动（可在Terrain Setting设置Wind参数）</li>
  <li>可调颜色混合范围、尺寸、透明度</li>
</ul>

<h5 id="add-detail-mesh">Add Detail Mesh</h5>
<ul>
  <li>可选一个Prefab（如石头、蘑菇、底模模型）</li>
  <li>用于3D小物件渲染</li>
  <li>可以勾选GPU Instancing以提升性能</li>
</ul>

<p>注意：</p>
<ul>
  <li>太复杂的Mesh会降低性能</li>
  <li>太密集的放置会导致Draw Call飙升</li>
</ul>

<h4 id="paint参数">Paint参数</h4>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Brush Size</strong></td>
      <td>笔刷范围（单位为世界坐标）</td>
    </tr>
    <tr>
      <td><strong>Opacity</strong></td>
      <td>笔刷强度（一次能刷多少）</td>
    </tr>
    <tr>
      <td><strong>Target Strength</strong></td>
      <td>总体密度（越高越密）</td>
    </tr>
    <tr>
      <td><strong>Random Color / Size</strong></td>
      <td>自动扰动草的颜色、尺寸，提升自然感</td>
    </tr>
    <tr>
      <td><strong>Noise Spread</strong></td>
      <td>控制颜色/透明度变化分布程度（更逼真）</td>
    </tr>
  </tbody>
</table>

<h4 id="渲染与性能优化">渲染与性能优化</h4>

<h5 id="优化特性">优化特性</h5>

<table>
  <thead>
    <tr>
      <th>技术</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Billboard 渲染</strong></td>
      <td>仅用平面草贴图，看起来像 3D 实际是贴图</td>
    </tr>
    <tr>
      <td><strong>GPU Instancing</strong></td>
      <td>Detail Mesh 会批处理，显著降低 Draw Call</td>
    </tr>
    <tr>
      <td><strong>LOD 剔除</strong></td>
      <td>距离过远会剔除渲染，节省性能</td>
    </tr>
  </tbody>
</table>

<p>注意：</p>
<ul>
  <li>草的渲染非常依赖显卡带宽，大量草可能拖慢帧率</li>
  <li>Detail Mesh应尽量简化为低面数模型</li>
  <li>尽量不要混用太多不同Detail类型</li>
</ul>

<h5 id="风动效果设置">风动效果设置</h5>
<ul>
  <li>草地的“飘动”来自于<code class="language-plaintext highlighter-rouge">Terrain Setting</code>中的Wind Settings for Grass</li>
  <li>可调：
    <ul>
      <li>Speed（速度）</li>
      <li>Size（波动幅度）</li>
      <li>Bending（弯曲度）</li>
      <li>Grass Tint（颜色偏移）</li>
    </ul>
  </li>
</ul>

<p>默认Terrain草是静态烘焙的，运行时不支持动态添加
但可以：</p>
<ul>
  <li>使用脚本控制<code class="language-plaintext highlighter-rouge">DetailPrototype</code>动态添加/刷新</li>
  <li>使用<code class="language-plaintext highlighter-rouge">GPU Instancing + Compute Shader</code>自制草系统</li>
</ul>

<h3 id="terrain-settings">Terrain Settings</h3>
<p><img src="/assets/images/TerrainSetting_1.jpg" alt="TerrainSetting_1" />
<img src="/assets/images/TerrainSetting_2.jpg" alt="TerrainSetting_2" /></p>

<h4 id="basic-terrain">Basic Terrain</h4>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Grouping ID</strong></td>
      <td>地形自动拼接的组编号。多个地形设置相同 ID，可自动连接边界。</td>
    </tr>
    <tr>
      <td><strong>Auto Connect</strong></td>
      <td>自动连接相邻地形边缘（启用后根据 Grouping ID）。</td>
    </tr>
    <tr>
      <td><strong>Draw</strong></td>
      <td>控制地形是否可见。取消勾选可临时隐藏地形。</td>
    </tr>
    <tr>
      <td><strong>Draw Instanced</strong></td>
      <td>使用 GPU Instancing 渲染瓦片，节省 draw call，推荐开启。</td>
    </tr>
    <tr>
      <td><strong>Enable Ray Tracing Support</strong></td>
      <td>支持光线追踪（HDRP下使用）。</td>
    </tr>
    <tr>
      <td><strong>Pixel Error</strong></td>
      <td>地形 LOD 精度。数值越低越精细，越高越省性能（建议 PC: 1<del>5，移动端：5</del>15）。</td>
    </tr>
    <tr>
      <td><strong>Minimum/Maximum Detail Limit</strong></td>
      <td>限制 LOD 变化范围（较少使用，可保持默认）。</td>
    </tr>
    <tr>
      <td><strong>Base Map Dist.</strong></td>
      <td>多远使用低分辨率贴图（节省远处渲染消耗）。</td>
    </tr>
    <tr>
      <td><strong>Cast Shadows</strong></td>
      <td>地形是否投射阴影。</td>
    </tr>
    <tr>
      <td><strong>Reflection Probes</strong></td>
      <td>是否使用反射探针，推荐使用 <code class="language-plaintext highlighter-rouge">Blend Probes</code>。</td>
    </tr>
    <tr>
      <td><strong>Material</strong></td>
      <td>使用的地形材质，默认是 <code class="language-plaintext highlighter-rouge">TerrainLit</code> 或 <code class="language-plaintext highlighter-rouge">Default-Terrain-Standard</code>。</td>
    </tr>
  </tbody>
</table>

<h4 id="tree--detail-objects">Tree &amp; Detail Objects</h4>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Draw</strong></td>
      <td>控制是否渲染树木和草丛等细节。</td>
    </tr>
    <tr>
      <td><strong>Bake Light Probes For Trees</strong></td>
      <td>树木是否参与光照探针烘焙。</td>
    </tr>
    <tr>
      <td><strong>Remove Light Probe Ringing</strong></td>
      <td>防止光照探针边界产生光晕伪影。</td>
    </tr>
    <tr>
      <td><strong>Preserve Tree Prototype</strong></td>
      <td>保持原始树模型设置。</td>
    </tr>
    <tr>
      <td><strong>Tree Motion Vectors</strong></td>
      <td>设置树木是否支持运动矢量（用于动效或后期处理）。</td>
    </tr>
    <tr>
      <td><strong>Detail Distance</strong></td>
      <td>草/细节渲染距离（推荐 60~100，性能关键）。</td>
    </tr>
    <tr>
      <td><strong>Detail Density Scale</strong></td>
      <td>草的密度百分比（1 = 全密度，调小省性能）。</td>
    </tr>
    <tr>
      <td><strong>Tree Distance</strong></td>
      <td>树木的最大渲染距离（推荐 PC: 500~1000）。</td>
    </tr>
    <tr>
      <td><strong>Billboard Start</strong></td>
      <td>多远开始使用看板树（节省性能）。</td>
    </tr>
    <tr>
      <td><strong>Fade Length</strong></td>
      <td>Billboard 淡入淡出的距离，提升视觉平滑度。</td>
    </tr>
    <tr>
      <td><strong>Max Mesh Trees</strong></td>
      <td>同屏最多渲染多少真实 Mesh 树，超过则不渲染。</td>
    </tr>
    <tr>
      <td><strong>Detail Scatter Mode</strong></td>
      <td>控制草丛分布策略（Coverage 更均匀，推荐）。</td>
    </tr>
  </tbody>
</table>

<h4 id="wind-settings-for-grass">Wind Settings for Grass</h4>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Speed / Size / Bending</strong></td>
      <td>控制风的速度、大小、弯曲程度。</td>
    </tr>
    <tr>
      <td><strong>Grass Tint</strong></td>
      <td>草的全局色调调整（可以统一偏绿、偏黄）。</td>
    </tr>
  </tbody>
</table>

<h4 id="mesh-resolution">Mesh Resolution</h4>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Terrain Width / Length / Height</strong></td>
      <td>地形尺寸（单位：米）</td>
    </tr>
    <tr>
      <td><strong>Detail Resolution Per Patch</strong></td>
      <td>每块 Detail Patch 中草的分布密度。</td>
    </tr>
    <tr>
      <td><strong>Detail Resolution</strong></td>
      <td>整体地形上草丛/细节的划分格子数。越高越细腻但越耗。</td>
    </tr>
  </tbody>
</table>

<h4 id="holes-settings">Holes Settings</h4>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Compress Holes Texture</strong></td>
      <td>对地形挖洞贴图进行压缩，节省内存。</td>
    </tr>
  </tbody>
</table>

<h4 id="texture-resolutions">Texture Resolutions</h4>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Heightmap Resolution</strong></td>
      <td>地形高度图精度，建议：513 或 1025（越高越细腻）</td>
    </tr>
    <tr>
      <td><strong>Control Texture Resolution</strong></td>
      <td>混合贴图精度，控制多种材质混合（如草+土+雪）</td>
    </tr>
    <tr>
      <td><strong>Base Texture Resolution</strong></td>
      <td>远距离使用的 Base Map 分辨率（节省远处性能）</td>
    </tr>
  </tbody>
</table>

<h4 id="lighting">Lighting</h4>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Contribute Global Illumination</strong></td>
      <td>地形是否参与全局光照（用于 Lightmap/GI）</td>
    </tr>
    <tr>
      <td><strong>Receive Global Illumination</strong></td>
      <td>接收 GI 的方式：<code class="language-plaintext highlighter-rouge">Lightmaps</code> 或 <code class="language-plaintext highlighter-rouge">Light Probes</code></td>
    </tr>
  </tbody>
</table>

<h4 id="lightmapping">Lightmapping</h4>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Scale In Lightmap</strong></td>
      <td>地形占 Lightmap 的比例。越高越清晰（但更占用空间）</td>
    </tr>
    <tr>
      <td><strong>Lightmap Parameters</strong></td>
      <td>控制烘焙时的精度、抗锯齿、间距等，可选低中高 preset。</td>
    </tr>
  </tbody>
</table>

<h4 id="quality-settings">Quality Settings</h4>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Ignore Quality Settings</strong></td>
      <td>是否忽略当前全局 Quality 设置的控制，强制使用当前面板设定。</td>
    </tr>
  </tbody>
</table>

<h2 id="主要地形制作方式">主要地形制作方式</h2>
<h3 id="1手动笔刷绘制适用于小项目快速原型">1.手动笔刷绘制（适用于小项目、快速原型）</h3>
<ul>
  <li>Unity自带Terrain工具，支持高度、纹理、树、草等绘制</li>
  <li>优点：操作直观，上手快</li>
  <li>缺点：效率低、不易保持美术风格一致，细节靠人工修</li>
  <li>使用场景：教学演示、小型独立游戏、快速原型</li>
</ul>

<h3 id="2外部dcc工具制作---导入高度图专业项目常用">2.外部DCC工具制作 -&gt; 导入高度图（专业项目常用）</h3>
<ul>
  <li>使用专业地形软件或美术工具生成高质量地形，再导入Unity：</li>
</ul>

<table>
  <thead>
    <tr>
      <th>工具</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>World Machine</strong></td>
      <td>高级噪声算法，真实山脉地貌生成</td>
    </tr>
    <tr>
      <td><strong>Gaea</strong></td>
      <td>节点式地形设计工具，艺术控制更强</td>
    </tr>
    <tr>
      <td><strong>Blender / Houdini</strong></td>
      <td>使用建模 + 程序化节点生成复杂地形</td>
    </tr>
    <tr>
      <td><strong>Photoshop</strong></td>
      <td>手绘/合成灰度高度图</td>
    </tr>
    <tr>
      <td><strong>Substance Designer</strong></td>
      <td>高度图 + Splatmap生成</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>Unity支持将这些高度图作为<code class="language-plaintext highlighter-rouge">Raw</code>导入，并通过<code class="language-plaintext highlighter-rouge">TerrainData</code>生成地形</li>
</ul>

<h3 id="3程序生成地形runtime或编译器内">3.程序生成地形（Runtime或编译器内）</h3>
<ul>
  <li>常用于开放世界、沙盒、随机地图类型游戏</li>
  <li>通过代码控制<code class="language-plaintext highlighter-rouge">TerrainData</code>的高度图、纹理图、细节对象等
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span><span class="p">[,]</span> <span class="n">heights</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="p">++</span><span class="n">x</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="p">++</span><span class="n">y</span><span class="p">)</span>
  <span class="n">heights</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">PerlinNoise</span><span class="p">(</span><span class="n">x</span> <span class="p">*</span> <span class="m">0.05f</span><span class="p">,</span> <span class="n">y</span> <span class="p">*</span> <span class="m">0.05f</span><span class="p">);</span>
<span class="n">terrainData</span><span class="p">.</span><span class="nf">SetHeights</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">heights</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>可加入：
    <ul>
      <li>噪声函数（Perlin、Simplex）</li>
      <li>河流生成</li>
      <li>村庄、道路布置</li>
    </ul>
  </li>
</ul>

<h3 id="插件生成最强大的方式">插件生成（最强大的方式）</h3>
<p>Unity商城中有许多强大的地形插件：</p>

<table>
  <thead>
    <tr>
      <th>插件</th>
      <th>功能特色</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Gaia Pro</strong></td>
      <td>一站式地形生成、生态系统、海洋、天气</td>
    </tr>
    <tr>
      <td><strong>MapMagic 2</strong></td>
      <td>节点图式、程序化地形、支持多地形拼接</td>
    </tr>
    <tr>
      <td><strong>Terrain Composer 2</strong></td>
      <td>高自由度、数据驱动生成</td>
    </tr>
    <tr>
      <td><strong>MicroSplat / MegaSplat</strong></td>
      <td>高级地形贴图混合、溶解、湿度等效果</td>
    </tr>
    <tr>
      <td><strong>Vegetation Studio Pro</strong></td>
      <td>大规模草木渲染优化</td>
    </tr>
  </tbody>
</table>

<h2 id="terrain-lod-编写调优">Terrain LOD 编写/调优</h2>
<p>在Unity中，Terrain的LOD是通过高度图分辨率、<code class="language-plaintext highlighter-rouge">Pixel Error</code>、以及细节分布分辨率来自动控制网格细分级别。</p>

<p>但Unity也允许通过Shader或代码进一步控制、调优甚至自定义LOD系统</p>

<h3 id="unity-terrain的lod原理">Unity Terrain的LOD原理</h3>
<p>Unity的内置Terrain使用以下机制实现LOD：</p>

<table>
  <thead>
    <tr>
      <th>控制项</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Pixel Error</code></td>
      <td>控制地形 LOD 变化的灵敏度（越高越糙但更快）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Base Map Distance</code></td>
      <td>多远开始只用 base map 贴图（低分辨率预览）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Detail Resolution Per Patch</code></td>
      <td>每块 patch 的细节分辨率，影响草和细节的 LOD。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Detail Distance / Tree Distance</code></td>
      <td>控制草木显示距离。</td>
    </tr>
  </tbody>
</table>

<p>Unity Terrain会自动把地形划分为多个Patch（块），并对每块Patch做LOD</p>

<h3 id="自定义地形lod-shader">自定义地形LOD Shader</h3>
<p>如果想完全控制地形LOD，特别是在自写Mesh Terrain时，可以通过<code class="language-plaintext highlighter-rouge">Shader + C#</code>实现</p>

<p><strong>示例：通过高度图动态LOD网格</strong></p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 顶点 shader 中使用 distance 控制 mesh LOD 精度</span>
<span class="n">float</span> <span class="n">distanceToCamera</span> <span class="o">=</span> <span class="nb">distance</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="n">float</span> <span class="n">lodLevel</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">distanceToCamera</span> <span class="o">/</span> <span class="n">_LodRange</span><span class="p">);</span> <span class="c1">// 0~1</span>
<span class="c1">// 然后根据lodLevel选择不同精度的高度图采样</span>
</code></pre></div></div>

<p>也可以用 Tessellation Shader 来实现更智能的细分控制</p>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nb">domain</span><span class="p">(</span><span class="s">"tri"</span><span class="p">)]</span>
<span class="p">[</span><span class="nb">partitioning</span><span class="p">(</span><span class="s">"fractional_even"</span><span class="p">)]</span>
<span class="p">[</span><span class="nb">outputtopology</span><span class="p">(</span><span class="s">"triangle_cw"</span><span class="p">)]</span>
<span class="p">[</span><span class="nb">patchconstantfunc</span><span class="p">(</span><span class="s">"PatchConstantFunction"</span><span class="p">)]</span>
<span class="p">[</span><span class="nb">outputcontrolpoints</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="kt">void</span> <span class="nf">TessellationHullFunction</span><span class="p">(...)</span>
<span class="p">{</span>
  <span class="c1">// 自定义 LOD 控制 tessellationFactor</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="lod调优策略">LOD调优策略</h3>

<table>
  <thead>
    <tr>
      <th>调优目标</th>
      <th>技术手段</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>提高性能</td>
      <td>增大 Pixel Error、减小 Patch 分辨率、加大 base map 距离</td>
    </tr>
    <tr>
      <td>增加视觉质量</td>
      <td>减少 Pixel Error、开启实时阴影、使用高精度高度图</td>
    </tr>
    <tr>
      <td>跨平台支持</td>
      <td>低端设备禁用草地、禁用阴影、减少树距离</td>
    </tr>
    <tr>
      <td>编程控制</td>
      <td>使用 <code class="language-plaintext highlighter-rouge">terrain.detailObjectDistance = x</code>、<code class="language-plaintext highlighter-rouge">terrain.heightmapPixelError = x</code> 动态调节</td>
    </tr>
  </tbody>
</table>

<h2 id="terrain-gpu-instancing草树渲染优化">Terrain GPU Instancing（草、树渲染优化）</h2>
<p><code class="language-plaintext highlighter-rouge">Terrain GPU Instancing</code>是Unity用于优化草和树渲染性能的关键技术，它能显著减少Draw Call数量，加速大量重复物体的渲染，非常适合用于大场景、开放世界、森林等</p>

<h3 id="什么是gpu-instancing">什么是GPU Instancing</h3>
<p>GPU Instancing(GPU 实例化)是指：</p>
<blockquote>
  <p>一次提交，多次绘制相同物体，减少CPU-&gt;GPU的调用次数</p>
</blockquote>

<ul>
  <li>普通方式：每棵草都一次Draw Call（开销爆炸）</li>
  <li>Instancing：同一模型、不同位置-&gt;1次Draw Call，绘制所有实例</li>
</ul>

<h3 id="在unity-terrain中的应用">在Unity Terrain中的应用</h3>
<h4 id="details-gpu-instancing">Details GPU Instancing</h4>
<p>Unity 2018+起支持：</p>
<ul>
  <li>使用材质类型：Instanced Mesh 或 Grass Mesh</li>
  <li>并开启“Enable GPU Instancing”选项</li>
</ul>

<p>操作方法：<br />
1.打开Terrain面板-&gt;<code class="language-plaintext highlighter-rouge">Paint Details</code>工具</p>

<p>2.点击<code class="language-plaintext highlighter-rouge">Edit Details</code> -&gt; <code class="language-plaintext highlighter-rouge">Add Detail Mesh</code></p>

<p>3.在弹窗中：</p>
<ul>
  <li>选择一个小草模型（Mesh）</li>
  <li>勾选Use GPU Instancing</li>
  <li>设置距离、颜色、密度等参数</li>
</ul>

<p>4.Unity自动启用GPU实例渲染</p>
<blockquote>
  <p>注意：草贴图（billboard类型）默认不支持GPU Instancing，需改为Mesh类型或自定义Shader</p>
</blockquote>

<h4 id="trees-gpu-instancing">Trees GPU Instancing</h4>
<p>树的GPU Instancing 需要满足两个条件：</p>
<ul>
  <li>模型为Mesh（非SpeedTree）</li>
  <li>树的材质启用GPU Instancing</li>
</ul>

<p>操作：<br />
1.打开<code class="language-plaintext highlighter-rouge">Paint Trees</code>工具</p>

<p>2.添加树种时选择普通Mesh树（非SpeedTree）</p>

<p>3.确保其材质上开启GPU Instancing</p>

<h3 id="注意事项-1">注意事项</h3>

<table>
  <thead>
    <tr>
      <th>限制 / 要点</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>草的材质必须使用 <strong>支持 Instancing 的 Shader</strong>（如 URP Lit 或自写）</td>
      <td> </td>
    </tr>
    <tr>
      <td>Instancing 不等于合批，它是“并行绘制”，但仍然占用 GPU VRAM</td>
      <td> </td>
    </tr>
    <tr>
      <td>不支持完全随机模型或颜色（需通过 Shader 控制实例差异）</td>
      <td> </td>
    </tr>
    <tr>
      <td>若草量极大，结合 <strong>LOD、Culling、地形剔除工具</strong> 更有效</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="高阶优化">高阶优化</h3>

<table>
  <thead>
    <tr>
      <th>技术</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>LOD + Crossfade</strong></td>
      <td>减少远距离树模型复杂度</td>
    </tr>
    <tr>
      <td><strong>Vegetation Studio Pro / Nature Renderer</strong></td>
      <td>插件增强 GPU 草渲染（支持更远距离、风、阴影）</td>
    </tr>
    <tr>
      <td><strong>Compute Shader Grass（高级）</strong></td>
      <td>自己写草系统，全 GPU 控制，风、互动等</td>
    </tr>
  </tbody>
</table>

<p><strong>示例：自定义URP Shader支持Instancing</strong></p>
<pre><code class="language-shader">Tags {"RenderType" = "Opaque"}
Pass{
  ...
  CGPROGRAM
  #pragma vertex vert
  #pragma fragment frag
  #pragma multi_compile_instancing

  UNITY_INSTANCING_BUFFER_START(Props)
  UNITY_INSTANCING_BUFFER_END(Props)

  struct appdata
  {
    float4 vertex : POSITION;
    UNITY_VERTEX_INPUT_INSTANCE_ID
  };

  struct v2f
  {
    float4 pos : SV_POSITION;
    UNITY_VERTEX_INPUT_INSTANCE_ID
  };

  v2f vert(appdata v)
  {
    UNITY_SETUP_INSTANCE_ID(v);
    ...
  }
  ...
  ENDCG
}
</code></pre>

<h2 id="使用terrain-toolkit插件或gaia等地形生成工具">使用Terrain Toolkit插件或Gaia等地形生成工具</h2>
<p>TODO</p>

<h2 id="多地形拼接无缝过渡">多地形拼接、无缝过渡</h2>
<p>Unity的Terrain是单独的GameObject，每个最多4097*4097高度图/贴图分辨率，单地形很难承载整个世界，因此需要：</p>
<blockquote>
  <p>将世界划分为多个Terrain块，拼接形成一个整体大地图</p>
</blockquote>

<h3 id="拼接方式">拼接方式</h3>
<h4 id="方法一unity内建-create-neighbor-terrains">方法一：Unity内建 Create Neighbor Terrains</h4>
<p>见上文</p>

<h4 id="方法二代码方式设置neighbor">方法二：代码方式设置Neighbor</h4>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">terrain</span><span class="p">.</span><span class="nf">SetNeighbor</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bottom</span><span class="p">);</span>
</code></pre></div></div>
<p>Unity的渲染系统通过<code class="language-plaintext highlighter-rouge">SetNeighbors</code>方法了解哪些Terrain相邻，从而实现：</p>
<ul>
  <li>地形LOD平滑衔接</li>
  <li>避免裂缝/LOD跳跃</li>
  <li>正确生成相邻地形的阴影、光照探针等</li>
</ul>

<h3 id="如何实现高度无缝">如何实现高度无缝</h3>
<h4 id="方法一在编辑时使用同步工具">方法一：在编辑时使用同步工具</h4>
<ul>
  <li>用Terrain Tools插件中的<code class="language-plaintext highlighter-rouge">Terrain Stitch Tool</code></li>
  <li>或用插件（如Gaia、Wrold Creator）自动生成高度图并拼接</li>
</ul>

<h4 id="方法二手动同步边界高度">方法二：手动同步边界高度</h4>
<p>当你修改Terrain A的边缘时，要同步更新Terrain B相邻边缘的高度（可通过代码或工具完成）</p>

<h3 id="如何实现纹理无缝">如何实现纹理无缝</h3>
<p>使用相同的SplatMap（地形图层）</p>
<ul>
  <li>确保所有Terrain使用相同的Terrain Layer（纹理材质）</li>
  <li>地形混合时，使用相同规则的笔刷强度</li>
  <li>地图边缘刷贴图时过渡得要自然（如混合2~3中Layer）</li>
</ul>

<h3 id="生态系统草树边界过渡">生态系统（草/树）边界过渡</h3>
<ul>
  <li>插件会对自动边界进行生态镜像过渡</li>
  <li>自定义草系统需处理边界草的“半草”同步问题</li>
  <li>植被生成算法需考虑相邻Terrain的坐标范围</li>
</ul>

<h3 id="lod无缝过渡与裂缝问题crack">LOD无缝过渡与裂缝问题（Crack）</h3>
<p>Unity Terrain会自动处理LOD，但如果没有设置邻居关系或高度差距大，会出现裂缝<br />
解决办法：</p>
<ul>
  <li>一定调用<code class="language-plaintext highlighter-rouge">SetNeighbors</code></li>
  <li>保证相邻Terrain的边缘高度一致</li>
  <li>使用LOD抗裂缝策略（如添加额外边界顶点）</li>
</ul>

<h2 id="结合导航烘焙navmesh--terrain">结合导航烘焙（NavMesh + Terrain）</h2>
<p><a href="/posts/2025-06-11-Navigation/">Navigation</a></p>

<h2 id="runtime地形修改voxel地形破坏">Runtime地形修改（Voxel、地形破坏）</h2>

<h3 id="运行时地形修改的主流方案概览">运行时地形修改的主流方案概览</h3>

<table>
  <thead>
    <tr>
      <th>模式</th>
      <th>原理</th>
      <th>优点</th>
      <th>缺点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Voxel Terrain</strong></td>
      <td>使用体素数据构建地形并动态生成 Mesh</td>
      <td>灵活，可完全修改、破坏、挖掘</td>
      <td>实现复杂，需要自定义系统</td>
    </tr>
    <tr>
      <td><strong>Custom Mesh Terrain</strong></td>
      <td>自定义网格，允许直接编辑 Mesh 顶点</td>
      <td>控制精细，可用于挤压、凹陷</td>
      <td>不适合大地图或地形细节</td>
    </tr>
    <tr>
      <td><strong>Shader-Based Deformation</strong></td>
      <td>用 Shader 或 Compute Shader 动态修改高度图</td>
      <td>实时效率高，可 GPU 运算</td>
      <td>精度有限，修改不可永久保存</td>
    </tr>
    <tr>
      <td><strong>Unity Terrain Heightmap 修改</strong></td>
      <td>修改 <code class="language-plaintext highlighter-rouge">TerrainData.SetHeights()</code></td>
      <td>保留 Unity Terrain 优势</td>
      <td>修改粒度受限，效率较低</td>
    </tr>
  </tbody>
</table>

<h3 id="方案一体素地形voxel-terrain">方案一：体素地形（Voxel Terrain）</h3>
<p>类似<em>Minecraft</em>风格的可破坏地形</p>

<p>实现流程：<br />
1.创建体素数据结构（3D数组）</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="p">[,,]</span> <span class="n">voxels</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">];</span>
</code></pre></div></div>

<p>2.定义每种方块类型（空气、土、石头等）</p>

<p>3.使用Marching Cubes或Greedy Mesh算法生成Mesh</p>

<p>4.实现挖掘、填充逻辑（修改数组，重新生成Mesh）</p>

<p>5.使用Chunk分块机制优化性能</p>

<h3 id="方案二修改unity-terrain高度图setheights">方案二：修改Unity Terrain高度图（SetHeights）</h3>
<p>适用于地形凹陷、爆炸坑、地形塑形</p>

<p><strong>示例</strong></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">DigHole</span><span class="p">(</span><span class="n">Terrain</span> <span class="n">terrain</span><span class="p">,</span> <span class="n">Vector3</span> <span class="n">worldPos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span> <span class="kt">float</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">TerrainData</span> <span class="n">tData</span> <span class="p">=</span> <span class="n">terrain</span><span class="p">.</span><span class="n">terrainData</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">xRes</span> <span class="p">=</span> <span class="n">tData</span><span class="p">.</span><span class="n">heightmapResolution</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">yRes</span> <span class="p">=</span> <span class="n">tData</span><span class="p">.</span><span class="n">heightmapResolution</span><span class="p">;</span>

  <span class="n">Vector3</span> <span class="n">terrainPos</span> <span class="p">=</span> <span class="n">worldPos</span> <span class="p">=</span> <span class="n">terrain</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">terrainPos</span><span class="p">.</span><span class="n">x</span> <span class="p">/</span> <span class="n">tData</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">*</span> <span class="n">xRes</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">terrainPos</span><span class="p">.</span><span class="n">z</span> <span class="p">/</span> <span class="n">tData</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="p">*</span> <span class="n">yRes</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">r</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">RoundToInt</span><span class="p">((</span><span class="n">radius</span> <span class="p">/</span> <span class="n">tData</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">*</span> <span class="n">xRes</span><span class="p">);</span>
  <span class="kt">float</span><span class="p">[,]</span> <span class="n">heights</span> <span class="p">=</span> <span class="n">tData</span><span class="p">.</span><span class="nf">GetHeights</span><span class="p">(</span><span class="n">x</span> <span class="p">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">y</span> <span class="p">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span> <span class="p">*</span> <span class="m">2</span><span class="p">,</span> <span class="n">r</span> <span class="p">*</span> <span class="m">2</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">r</span> <span class="p">*</span> <span class="m">2</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="n">r</span> <span class="p">*</span> <span class="m">2</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span>
    <span class="p">{</span>
      <span class="kt">float</span> <span class="n">dist</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="nf">Distance</span><span class="p">(</span><span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="p">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="p">-=</span> <span class="n">depth</span> <span class="p">*</span> <span class="p">(</span><span class="m">1f</span> <span class="p">-</span> <span class="n">dist</span> <span class="p">/</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">tData</span><span class="p">.</span><span class="nf">SetHeights</span><span class="p">(</span><span class="n">x</span> <span class="p">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">y</span> <span class="p">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">heights</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>注意：</p>
<ul>
  <li>每次<code class="language-plaintext highlighter-rouge">SetHeights</code>开销较大，频繁修改可能掉帧</li>
  <li>修改后不会自动更新NavMesh，需要手动<code class="language-plaintext highlighter-rouge">NavMeshSurface.BuildNavMesh()</code></li>
</ul>

<h3 id="方案三自定义mesh地形修改">方案三：自定义Mesh地形修改</h3>
<p>可以用Procedural Mesh创建“可破坏”的Mesh地面，然后直接修改顶点高度</p>

<p>核心点：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Mesh.vertices</code> + <code class="language-plaintext highlighter-rouge">Mesh.RecalculateNormals()</code></li>
  <li>可用于地形凹陷、打击坑</li>
  <li>可结合Shader实现更复杂视觉反馈</li>
</ul>

<h3 id="gpu地形修改shadercompute-shader">GPU地形修改（Shader/Compute Shader）</h3>
<p>适合需要大量实时修改的场景，如地面波纹、动态地形变化</p>

<p>常用技巧：</p>
<ul>
  <li>通过<code class="language-plaintext highlighter-rouge">RenderTexture</code>存储高度图</li>
  <li>通过Compute Shader修改像素</li>
  <li>在Shader中将高度图应用为<code class="language-plaintext highlighter-rouge">vertex displacement</code></li>
</ul>

<p>可参考：Unity官方例子<code class="language-plaintext highlighter-rouge">GPU Terrain Stamp</code>或Amplify Shader Editor示例</p>

<h2 id="terrain-api">Terrain API</h2>
<h3 id="static-properies">Static Properies</h3>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>中文说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">activeTerrain</code></td>
      <td>当前活动的 Terrain（场景中主地形）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">activeTerrains</code></td>
      <td>场景中所有激活的 Terrain 列表</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">compressedHolesFormat</code></td>
      <td>压缩后地形洞孔纹理的图形格式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">compressedHolesTextureFormat</code></td>
      <td>压缩后地形洞孔纹理的纹理格式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">heightmapFormat</code></td>
      <td>地形高度图的图形格式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">heightmapRenderTextureFormat</code></td>
      <td>地形高度图的 RenderTextureFormat</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">holesFormat</code></td>
      <td>未压缩的地形洞孔纹理的图形格式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">holesRenderTextureFormat</code></td>
      <td>地形洞孔纹理的 RenderTextureFormat</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">normalmapFormat</code></td>
      <td>地形法线贴图的图形格式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">normalmapRenderTextureFormat</code></td>
      <td>地形法线贴图的渲染纹理格式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">normalmapTextureFormat</code></td>
      <td>地形法线贴图的纹理格式</td>
    </tr>
  </tbody>
</table>

<h3 id="properties">Properties</h3>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>中文说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">allowAutoConnect</code></td>
      <td>是否自动连接邻近地形</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bakeLightProbesForTrees</code></td>
      <td>是否为树烘焙内部光照探针（仅编辑器）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">basemapDistance</code></td>
      <td>超过该距离时使用预计算的低分辨率底图</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bottomNeighbor</code></td>
      <td>下方邻接地形</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">collectDetailPatches</code></td>
      <td>从内存中收集细节贴片</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">deringLightProbesForTrees</code></td>
      <td>去除树上的光照探针振铃（仅编辑器）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">detailObjectDensity</code></td>
      <td>草和细节对象的密度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">detailObjectDistance</code></td>
      <td>草和细节对象的最大可视距离</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">drawHeightmap</code></td>
      <td>是否绘制地形几何（高度图）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">drawInstanced</code></td>
      <td>是否启用 GPU Instancing 渲染地形</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">drawTreesAndFoliage</code></td>
      <td>是否绘制树和细节对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">editorRenderFlags</code></td>
      <td>控制地形在编辑器中显示哪些内容</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">enableHeightmapRayTracing</code></td>
      <td>是否启用地形高度图的光线追踪加速结构</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">groupingID</code></td>
      <td>地形自动连接的分组 ID</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">heightmapMaximumLOD</code></td>
      <td>地形最大渲染 LOD 级别</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">heightmapMinimumLODSimplification</code></td>
      <td>最简化的渲染精度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">heightmapPixelError</code></td>
      <td>LOD 切换时的误差控制</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ignoreQualitySettings</code></td>
      <td>是否忽略 QualitySettings 中的地形配置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">keepUnusedRenderingResources</code></td>
      <td>是否在一定帧数后释放未使用的摄像机渲染资源</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">leftNeighbor</code></td>
      <td>左侧邻接地形（X 方向负方向）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">lightmapIndex</code></td>
      <td>静态光照贴图索引</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">lightmapScaleOffset</code></td>
      <td>静态光照贴图的缩放和偏移</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">materialTemplate</code></td>
      <td>渲染地形使用的材质模板</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">normalmapTexture</code></td>
      <td>从高度图生成的法线贴图</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">patchBoundsMultiplier</code></td>
      <td>地形边界框的缩放倍率</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">preserveTreePrototypeLayers</code></td>
      <td>树实例的图层处理方式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">realtimeLightmapIndex</code></td>
      <td>实时光照贴图索引</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">realtimeLightmapScaleOffset</code></td>
      <td>实时光照贴图的缩放和偏移</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">reflectionProbeUsage</code></td>
      <td>反射探针使用方式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">renderingLayerMask</code></td>
      <td>地形渲染器的渲染图层遮罩</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rightNeighbor</code></td>
      <td>右侧邻接地形（X 方向正方向）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">shadowCastingMode</code></td>
      <td>地形阴影模式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">terrainData</code></td>
      <td>地形数据资源，包含高度图、纹理等</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">topNeighbor</code></td>
      <td>上方邻接地形</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">treeBillboardDistance</code></td>
      <td>树木转为 billboard 的距离</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">treeCrossFadeLength</code></td>
      <td>树从 Mesh 到 billboard 的过渡距离</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">treeDistance</code></td>
      <td>树的最大渲染距离</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">treeLODBiasMultiplier</code></td>
      <td>树 LOD 偏差乘数</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">treeMaximumFullLODCount</code></td>
      <td>完整 LOD 树的最大数量</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">treeMotionVectorModeOverride</code></td>
      <td>SpeedTree 的运动矢量渲染模式</td>
    </tr>
  </tbody>
</table>

<h3 id="public-methods">Public Methods</h3>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>中文说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AddTreeInstance(TreeInstance)</code></td>
      <td>向地形添加一个树实例</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Flush()</code></td>
      <td>强制刷新 Terrain 更改</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetClosestReflectionProbes(List)</code></td>
      <td>获取与地形相交的反射探针及其权重</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetKeepUnusedCameraRenderingResources()</code></td>
      <td>查询摄像机资源是否被保留</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetPosition()</code></td>
      <td>获取地形在世界空间中的位置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetSplatMaterialPropertyBlock()</code></td>
      <td>获取混合材质的参数设置</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SampleHeight(Vector3)</code></td>
      <td>采样地形在某世界位置的高度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetKeepUnusedCameraRenderingResources(bool)</code></td>
      <td>设置是否保留摄像机的地形资源</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetNeighbors(left, top, right, bottom)</code></td>
      <td>设置地形的邻居（用于 LOD 缝合）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetSplatMaterialPropertyBlock()</code></td>
      <td>设置混合材质渲染属性</td>
    </tr>
  </tbody>
</table>

<h3 id="static-methods">Static Methods</h3>

<table>
  <thead>
    <tr>
      <th>方法名</th>
      <th>中文说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CreateTerrainGameObject(TerrainData)</code></td>
      <td>从 <code class="language-plaintext highlighter-rouge">TerrainData</code> 创建带碰撞器的地形 GameObject</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetActiveTerrains(List&lt;Terrain&gt;)</code></td>
      <td>填充一个列表，获取当前激活的所有 Terrain</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetConnectivityDirty()</code></td>
      <td>标记当前连接状态为无效（需重新连接）</td>
    </tr>
  </tbody>
</table>

<p><strong>详见<a href="https://docs.unity3d.com/ScriptReference/Terrain.html">UnityScripting Terrain</a></strong></p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Renderer" /><category term="Unity System" /><category term="Unity Component" /><summary type="html"><![CDATA[在Unity中，Terrain是一个专门用于制作大规模、自然风格场景的强大工具]]></summary></entry><entry><title type="html">Import Assets</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets.html" rel="alternate" type="text/html" title="Import Assets" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets.html"><![CDATA[<p>Unity支持多种格式的资源文件，并能自动识别并进行初步处理</p>

<h2 id="资源导入基本流程">资源导入基本流程</h2>
<p><strong>1.将资源文件拖入<code class="language-plaintext highlighter-rouge">Assets</code>目录中（Unity会自动导入）</strong><br />
<strong>2.在Inspector面板中查看导入设置</strong><br />
<strong>3.配置相关参数，比如压缩方式、贴图类型、是否生成碰撞体等</strong><br />
<strong>4.使用资源（拖到场景、作为材质贴图、挂到AudioSource等）</strong></p>

<h2 id="模型">模型</h2>

<h3 id="支持格式">支持格式</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.fbx</code>推荐</li>
  <li><code class="language-plaintext highlighter-rouge">.obj</code></li>
  <li><code class="language-plaintext highlighter-rouge">.dae</code>（Collada）</li>
  <li><code class="language-plaintext highlighter-rouge">.blend</code>（需要Blender）</li>
</ul>

<h3 id="导入流程">导入流程</h3>
<p>1.拖拽<code class="language-plaintext highlighter-rouge">.fbx</code>文件到<code class="language-plaintext highlighter-rouge">Assets</code>文件夹<br />
2.选中模型文件，查看<code class="language-plaintext highlighter-rouge">Inspector</code>的导入设置</p>
<ul>
  <li>Scale Factor：缩放（一般保持默认）</li>
  <li>Import Animations：是否导入动画</li>
  <li>Import Materials：是否导入材质</li>
  <li>Generate Colliders：是否自动生成碰撞体</li>
</ul>

<h3 id="导入后组成">导入后组成</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Model</code>: 3D网格</li>
  <li><code class="language-plaintext highlighter-rouge">Rig</code>（如果有骨骼）：用于动画绑定</li>
  <li><code class="language-plaintext highlighter-rouge">Animation</code>：包含的动画片段</li>
  <li><code class="language-plaintext highlighter-rouge">Materials</code>：自动生成或关联的材质</li>
</ul>

<h2 id="贴图">贴图</h2>

<h3 id="支持格式-1">支持格式</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.png</code>、<code class="language-plaintext highlighter-rouge">.jpg</code>、<code class="language-plaintext highlighter-rouge">.tga</code>、<code class="language-plaintext highlighter-rouge">.psd</code>（支持图层）等</li>
</ul>

<h3 id="导入流程-1">导入流程</h3>

<p>1.拖入图片文件
2.在Inspector中设置：</p>
<ul>
  <li>sRGB（Color Texture）：颜色贴图用，法线贴图需取消勾选</li>
  <li>Alpha Is Transparency：如果使用透明通道</li>
  <li>Wrap Mode：Repeat（平铺）或Clamp（拉伸）</li>
  <li>Filter Mode：Bilinear、Trilinear、Point（像素风）</li>
  <li>Compression：高压缩（小体积）还是高质量（清晰）</li>
  <li>Texture Type:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Default</code>（通用）</li>
      <li><code class="language-plaintext highlighter-rouge">Sprite</code>（用于UI）</li>
      <li><code class="language-plaintext highlighter-rouge">Normal map</code>（法线贴图）</li>
      <li><code class="language-plaintext highlighter-rouge">Lightmap</code>（光照图）</li>
    </ul>
  </li>
</ul>

<h2 id="音频">音频</h2>

<h3 id="支持格式-2">支持格式</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.mp3</code>（压缩）</li>
  <li><code class="language-plaintext highlighter-rouge">.wav</code>（无损）</li>
  <li><code class="language-plaintext highlighter-rouge">.ogg</code>（高效）</li>
  <li><code class="language-plaintext highlighter-rouge">.aiff</code></li>
</ul>

<h2 id="导入流程-2">导入流程</h2>

<p>1.拖入音频文件<br />
2.在<code class="language-plaintext highlighter-rouge">Inspector</code>中设置：</p>
<ul>
  <li>Load Type：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Decompress On Load</code>（加载时解压，适合短音效）</li>
      <li><code class="language-plaintext highlighter-rouge">Streaming</code>（边播放边加载，适合背景音乐）</li>
    </ul>
  </li>
  <li>Compression Format:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Vorbis</code>、<code class="language-plaintext highlighter-rouge">ADPCM</code>、<code class="language-plaintext highlighter-rouge">PCM</code></li>
    </ul>
  </li>
  <li>3D Sound：是否启用3D空间化</li>
  <li>Loop：是否循环播放</li>
</ul>

<blockquote>
  <p><strong>资源组织建议：</strong> 使用好的文件夹结构和命名习惯，可以极大提高开发效率</p>
</blockquote>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><summary type="html"><![CDATA[Unity支持多种格式的资源文件，并能自动识别并进行初步处理]]></summary></entry><entry><title type="html">Layer</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Layer.html" rel="alternate" type="text/html" title="Layer" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Layer</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Layer.html"><![CDATA[<p>在Unity中，Layer是要给非常重要的系统<br />
它主要用于：</p>
<ul>
  <li>控制物体的渲染与相机的可见性</li>
  <li>控制物理碰撞（配合Layer Collision Matrix）</li>
  <li>通过脚本进行物体分类和筛选</li>
</ul>

<h2 id="什么是layer">什么是Layer</h2>

<p>Layer是给GameObject打的“标签”，但它和<code class="language-plaintext highlighter-rouge">Tag</code>不一样，Layer是用于功能性控制的，特别在：</p>
<ul>
  <li>摄像机的Culling Mask</li>
  <li>光照影响（Light Culling）</li>
  <li>物理碰撞（Physics Layer）</li>
  <li>射线检测（Raycast Layer）</li>
</ul>

<h2 id="layer的使用场景">Layer的使用场景</h2>
<h3 id="1摄像机视野控制culling-mask">1.摄像机视野控制（Culling Mask）</h3>
<p>在Camera组件中，你可以设置</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Culling Mask -&gt; 选择哪些Layer可以被该相机看到
</code></pre></div></div>

<p><strong>用途：</strong></p>
<ul>
  <li>UI相机只看UI层</li>
  <li>小地图相机只看敌人层</li>
  <li>分屏镜头每个只看自己的部分</li>
</ul>

<h3 id="2物理碰撞控制layer-collision-matrix">2.物理碰撞控制（Layer Collision Matrix）</h3>
<p>在菜单中：</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Edit</span> <span class="s">-&gt;</span> <span class="s">Project</span> <span class="s">Settings</span> <span class="s">-&gt;</span> <span class="s">Physics</span>
</code></pre></div></div>

<p>你可以看到Layer Collision Matrix，它控制：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>哪些Layer和哪些Layer能发生物理碰撞
</code></pre></div></div>

<p><strong>用途：</strong></p>
<ul>
  <li>玩家层与敌人层可以碰撞，但不和自身碰撞</li>
  <li>子弹不撞自己</li>
  <li>角色不被UI的Collider打断</li>
</ul>

<h3 id="3射线检测">3.射线检测</h3>
<p>可以通过Layer来控制射线是否命中某个对象</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">layerMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Physics</span><span class="p">.</span><span class="nf">Raycast</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="k">out</span> <span class="n">hit</span><span class="p">,</span> <span class="m">100f</span><span class="p">,</span> <span class="n">layerMask</span><span class="p">))</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Hit enemy"</span><span class="p">);</span>
</code></pre></div></div>

<p>也可以多层合并：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">mask</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">))</span> <span class="p">|</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"NPC"</span><span class="p">));</span>
</code></pre></div></div>
<h2 id="内置与自定义layer">内置与自定义Layer</h2>

<h3 id="内置layerunity默认的">内置Layer（Unity默认的）</h3>

<table>
  <thead>
    <tr>
      <th>编号</th>
      <th>名称</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>Default</td>
      <td>默认层</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Water</td>
      <td>水体特效</td>
    </tr>
    <tr>
      <td>5</td>
      <td>UI</td>
      <td>UI 专用</td>
    </tr>
  </tbody>
</table>

<h3 id="自定义layer">自定义Layer</h3>
<p>Unity允许你最多使用32个Layer（编号 0~31），其中前几个是保留的<br />
自定义方式：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">选中</span> <span class="n">GameObject</span> <span class="o">-&gt;</span> <span class="n">Inspector</span> <span class="o">-&gt;</span> <span class="n">Layer</span> <span class="o">-&gt;</span> <span class="k">Add</span> <span class="n">Layer</span><span class="p">...</span>
</code></pre></div></div>
<p>添加后可为GameObject设置：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Layer</span> <span class="s">-&gt;</span> <span class="s">你刚添加的层名</span>
</code></pre></div></div>
<h2 id="layer与tag的区别">Layer与Tag的区别</h2>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>Layer</th>
      <th>Tag</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>数量限制</td>
      <td>最多 32 个</td>
      <td>无限制</td>
    </tr>
    <tr>
      <td>用于渲染控制</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>用于物理控制</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>用于分类查找</td>
      <td>有限制（用 LayerMask）</td>
      <td>✅（用 CompareTag 等）</td>
    </tr>
    <tr>
      <td>性能优化</td>
      <td>✅（用于剔除、射线过滤）</td>
      <td>❌</td>
    </tr>
  </tbody>
</table>

<h3 id="建议">建议</h3>
<ul>
  <li>给每种功能的对象分配专属Layer</li>
  <li>摄像机、光源、UI、Trigger检测都应依赖Layer控制逻辑</li>
</ul>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><summary type="html"><![CDATA[在Unity中，Layer是要给非常重要的系统 它主要用于： 控制物体的渲染与相机的可见性 控制物理碰撞（配合Layer Collision Matrix） 通过脚本进行物体分类和筛选]]></summary></entry></feed>