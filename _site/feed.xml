<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-07-15T21:57:48+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ljf12825’s Blog</title><subtitle>Efficient &amp; Elegant</subtitle><author><name>Jeff Lee</name><email>2548278761@qq.com</email></author><entry><title type="html">Unity Component Communication</title><link href="http://localhost:4000/posts/2025-07-15-Unity-Component-Communication/" rel="alternate" type="text/html" title="Unity Component Communication" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Unity-Component-Communication</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Unity-Component-Communication/"><![CDATA[<table>
  <thead>
    <tr>
      <th>通信方式</th>
      <th>类型</th>
      <th>是否推荐</th>
      <th>示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetComponent&lt;T&gt;()</code> 直接调用</td>
      <td>显式调用</td>
      <td>推荐</td>
      <td><code class="language-plaintext highlighter-rouge">GetComponent&lt;Health&gt;().TakeDamage(10);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnityEvent</code></td>
      <td>事件系统</td>
      <td>推荐</td>
      <td>在 Inspector 中绑定事件</td>
    </tr>
    <tr>
      <td>C# 委托/事件 (<code class="language-plaintext highlighter-rouge">delegate</code>, <code class="language-plaintext highlighter-rouge">event</code>)</td>
      <td>原生 C#</td>
      <td>推荐</td>
      <td><code class="language-plaintext highlighter-rouge">public event Action OnDead;</code></td>
    </tr>
    <tr>
      <td>接口调用（如 <code class="language-plaintext highlighter-rouge">IDamageable</code>）</td>
      <td>解耦方式</td>
      <td>推荐</td>
      <td><code class="language-plaintext highlighter-rouge">target.GetComponent&lt;IDamageable&gt;()?.TakeDamage()</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ScriptableObject</code> 事件</td>
      <td>高级数据驱动</td>
      <td>推荐</td>
      <td>Game-wide event bus</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SendMessage()</code> / <code class="language-plaintext highlighter-rouge">BroadcastMessage()</code></strong></td>
      <td>反射调用</td>
      <td>不推荐</td>
      <td><code class="language-plaintext highlighter-rouge">SendMessage("Explode")</code></td>
    </tr>
  </tbody>
</table>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Syntax" /><category term="Unity Class" /><summary type="html"><![CDATA[通信方式 类型 是否推荐 示例 GetComponent&lt;T&gt;() 直接调用 显式调用 推荐 GetComponent&lt;Health&gt;().TakeDamage(10); UnityEvent 事件系统 推荐 在 Inspector 中绑定事件 C# 委托/事件 (delegate, event) 原生 C# 推荐 public event Action OnDead; 接口调用（如 IDamageable） 解耦方式 推荐 target.GetComponent&lt;IDamageable&gt;()?.TakeDamage() ScriptableObject 事件 高级数据驱动 推荐 Game-wide event bus SendMessage() / BroadcastMessage() 反射调用 不推荐 SendMessage("Explode")]]></summary></entry><entry><title type="html">Audio System</title><link href="http://localhost:4000/posts/2025-06-11-Audio-System/" rel="alternate" type="text/html" title="Audio System" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Audio-System</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-11-Audio-System/"><![CDATA[<p>Audio System 是 Unity中处理游戏所有声音播放、管理和混音的核心模块</p>

<h2 id="audio-clip">Audio Clip</h2>
<p>在Unity中，<code class="language-plaintext highlighter-rouge">AudioClip</code>是表示音频资源的核心类，用于播放、管理和处理音频数据（如音乐、音效、语音等）</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AudioCilp</span> <span class="p">:</span> <span class="n">Object</span>
</code></pre></div></div>
<ul>
  <li>它存储音频数据，可以被<code class="language-plaintext highlighter-rouge">AudioSource</code>组件播放</li>
  <li>通常通过将音频文件（如<code class="language-plaintext highlighter-rouge">.wav</code>、<code class="language-plaintext highlighter-rouge">.mp3</code>、<code class="language-plaintext highlighter-rouge">.ogg</code>）导入到Unity项目中生成AudioClip</li>
  <li>可用来播放背景音乐（BGM）、音效（SFX）、语音（VO）等</li>
</ul>

<p><img src="/assets/images/AudioClipExample.jpg" alt="AudioClipExample" /></p>

<h3 id="audioclip的常见使用方式">AudioClip的常见使用方式</h3>
<p>1.在Inspector中拖入音频文件</p>
<ul>
  <li>拖一个音频文件到<code class="language-plaintext highlighter-rouge">Assets</code>文件夹</li>
  <li>Unity自动将其导入为<code class="language-plaintext highlighter-rouge">AudioClip</code></li>
  <li>拖到<code class="language-plaintext highlighter-rouge">AudioSource.clip</code>上即可播放</li>
</ul>

<p>2.通过代码播放AudioClip</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">AudioSource</span> <span class="n">audioSource</span><span class="p">;</span>
<span class="k">public</span> <span class="n">AudioClip</span> <span class="n">clip</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">autioSource</span><span class="p">.</span><span class="n">clip</span> <span class="p">=</span> <span class="n">clip</span><span class="p">;</span>
    <span class="n">audioSource</span><span class="p">.</span><span class="nf">Play</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="audioclip的导入设置">AudioClip的导入设置</h3>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Force To Mono</strong></td>
      <td>强制单声道</td>
    </tr>
    <tr>
      <td><strong>Normalize</strong></td>
      <td>自动将音频的音量标准化到一个统一的最大音量水平，避免音量过低或过高</td>
    </tr>
    <tr>
      <td><strong>Ambisonic</strong></td>
      <td>沉浸式3D空间音频，启用后Unity会使用Ambisonic解码器处理音频方向，需安装第三方插件使用</td>
    </tr>
    <tr>
      <td><strong>Load Type</strong></td>
      <td>Streaming（长音频），Decompress on Load（短音效）</td>
    </tr>
    <tr>
      <td><strong>Compression Format</strong></td>
      <td>压缩格式 PCM（无压缩） / Vorbis（有损压缩，开源格式，推荐） / MP3（有损压缩，商业格式）</td>
    </tr>
    <tr>
      <td><strong>Sample Rate</strong></td>
      <td>音质与性能平衡 Preserve Sample Rate（保留原始采样率）, Optimize Sample Rate（优化采样率）, Override Sample Rate（强制指定采样）</td>
    </tr>
    <tr>
      <td><strong>Preload Audio Data</strong></td>
      <td>是否在启动时加载到内存</td>
    </tr>
    <tr>
      <td><strong>Load in Background</strong></td>
      <td>是否异步加载</td>
    </tr>
  </tbody>
</table>

<h3 id="创建自定义audioclip">创建自定义AudioClip</h3>
<p>可以在运行时动态生成AudioClip，例如用于程序化音效或语言合成</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AudioClip</span> <span class="n">myClip</span> <span class="p">=</span> <span class="n">AudioClip</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="s">"MySine"</span><span class="p">,</span> <span class="n">sampleLength</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="n">sampleRate</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
<span class="n">myClip</span><span class="p">.</span><span class="nf">SetData</span><span class="p">(</span><span class="n">floatArray</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="注意事项">注意事项</h3>
<ul>
  <li>AudioClip是资源，不等于播放器，需要<code class="language-plaintext highlighter-rouge">AudioSource</code>来播放</li>
  <li>不要在频繁播放音效时反复创建AudioClip实例，应使用对象池或缓存机制</li>
  <li><code class="language-plaintext highlighter-rouge">.m4a</code>等不推荐格式导入可能生成不了可用的<code class="language-plaintext highlighter-rouge">AudioClip</code></li>
</ul>

<h2 id="主要组件">主要组件</h2>

<table>
  <thead>
    <tr>
      <th>Category</th>
      <th>Component Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Audio</strong></td>
      <td>Chorus Filter</td>
    </tr>
    <tr>
      <td> </td>
      <td>Distortion Filter</td>
    </tr>
    <tr>
      <td> </td>
      <td>Echo Filter</td>
    </tr>
    <tr>
      <td> </td>
      <td>High Pass Filter</td>
    </tr>
    <tr>
      <td> </td>
      <td>Listener</td>
    </tr>
    <tr>
      <td> </td>
      <td>Low Pass Filter</td>
    </tr>
    <tr>
      <td> </td>
      <td>Reverv Filter</td>
    </tr>
    <tr>
      <td> </td>
      <td>Reverv Zone</td>
    </tr>
    <tr>
      <td> </td>
      <td>Source</td>
    </tr>
  </tbody>
</table>

<h2 id="组件">组件</h2>
<h3 id="audio-source">Audio Source</h3>
<p><code class="language-plaintext highlighter-rouge">AudioSource</code>是Unity中用于播放声音的核心组件，负责控制音频的播放、暂停、停止、3D效果、音量等</p>

<p><img src="/assets/images/AudioSourcePanel.jpg" alt="AudioSourcePanel" /></p>

<h4 id="面板字段">面板字段</h4>

<table>
  <thead>
    <tr>
      <th><strong>属性</strong></th>
      <th><strong>描述</strong></th>
      <th><strong>使用场景</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Audio Clip</strong></td>
      <td>音频片段的引用，指定播放的声音文件。</td>
      <td>通过此属性指定要播放的音频文件。</td>
    </tr>
    <tr>
      <td><strong>Output</strong></td>
      <td>默认情况下，音频直接输出到场景中的 <code class="language-plaintext highlighter-rouge">AudioListener</code>，也可以输出到 <code class="language-plaintext highlighter-rouge">AudioMixer</code> 进行处理。</td>
      <td>如果需要使用 <code class="language-plaintext highlighter-rouge">AudioMixer</code> 对音频进行处理，设置此属性。</td>
    </tr>
    <tr>
      <td><strong>Mute</strong></td>
      <td>启用时，声音播放但被静音。</td>
      <td>用于临时静音音频，但不停止播放。</td>
    </tr>
    <tr>
      <td><strong>Bypass Effects</strong></td>
      <td>启用时，跳过应用于 <code class="language-plaintext highlighter-rouge">AudioSource</code> 的所有音效。</td>
      <td>用于快速禁用所有音频效果，音频将以原始状态播放。</td>
    </tr>
    <tr>
      <td><strong>Bypass Listener Effects</strong></td>
      <td>启用时，跳过 <code class="language-plaintext highlighter-rouge">AudioListener</code> 上的所有音效。</td>
      <td>用于快速禁用所有监听器效果，影响的是音频在场景中的接收。</td>
    </tr>
    <tr>
      <td><strong>Bypass Reverb Zones</strong></td>
      <td>启用时，跳过场景中的所有混响区域。</td>
      <td>如果场景中有多个混响区域，使用此属性来禁用它们对音频的影响。</td>
    </tr>
    <tr>
      <td><strong>Play On Awake</strong></td>
      <td>启用时，场景启动时会自动播放音频。</td>
      <td>背景音乐等需要在场景启动时自动播放的音频可以启用此属性。</td>
    </tr>
    <tr>
      <td><strong>Loop</strong></td>
      <td>启用时，音频在播放完毕后会自动循环播放。</td>
      <td>用于循环播放音效或背景音乐。</td>
    </tr>
    <tr>
      <td><strong>Priority</strong></td>
      <td>音频源的优先级。值越低，音频优先级越高。0 表示最重要，256 表示最不重要。</td>
      <td>在多个音频源同时播放时，优先级较低的音频可能会被系统暂停或降低音量。音乐通常设置为 0，确保它不会被临时停掉。</td>
    </tr>
    <tr>
      <td><strong>Volume</strong></td>
      <td>音量控制，表示距离 <code class="language-plaintext highlighter-rouge">AudioListener</code> 一米时的音量大小。</td>
      <td>控制音效的音量大小，通常在 0 到 1 之间调节。</td>
    </tr>
    <tr>
      <td><strong>Pitch</strong></td>
      <td>控制音频的音高和播放速度，1 为正常速度，大于 1 提高音高，低于 1 降低音高。</td>
      <td>用于调节音效的音调或播放速度。</td>
    </tr>
    <tr>
      <td><strong>Stereo Pan</strong></td>
      <td>控制音频在立体声中的位置，-1 为左声道，1 为右声道，0 为中央。</td>
      <td>适用于 2D 音频，调整音效在左右声道中的位置。</td>
    </tr>
    <tr>
      <td><strong>Spatial Blend</strong></td>
      <td>控制音频的 3D 空间效果，0 为纯 2D 音频，1 为纯 3D 音频。</td>
      <td>用于控制音频是否为 3D 音效，3D 音效会受到音源和监听器位置的影响。</td>
    </tr>
    <tr>
      <td><strong>Reverb Zone Mix</strong></td>
      <td>控制音频信号与混响区域的混合比例，范围为 0 到 1，1 到 1.1 范围内允许 10 dB 的放大效果。</td>
      <td>用于将音频信号与场景中的混响效果混合，模拟不同的环境音效。</td>
    </tr>
    <tr>
      <td><strong>3D Sound Settings</strong></td>
      <td>3D 音效设置，具体依赖于 <code class="language-plaintext highlighter-rouge">Spatial Blend</code>。</td>
      <td>用于调整 3D 音效的各种参数，比如声音的衰减、距离等。</td>
    </tr>
    <tr>
      <td><strong>Doppler Level</strong></td>
      <td>控制 Doppler 效应的强度，设置为 0 时不会有 Doppler 效果。</td>
      <td>模拟运动物体产生的音高变化效应，常用于车辆、飞行物等的音效。</td>
    </tr>
    <tr>
      <td><strong>Spread</strong></td>
      <td>设置 3D 音效的扩散角度，适用于立体声或多声道音频。</td>
      <td>用于调整声音的扩散角度，尤其是 3D 音频和多声道音频的效果。</td>
    </tr>
    <tr>
      <td><strong>Min Distance</strong></td>
      <td>当监听器与音源的距离小于此值时，音频会保持最大音量，超出该距离后开始衰减。</td>
      <td>控制音效在 3D 空间中的音量范围。</td>
    </tr>
    <tr>
      <td><strong>Max Distance</strong></td>
      <td>控制音频停止衰减的最大距离，超过此距离时音量保持恒定。</td>
      <td>设置音效衰减的最大距离。超出此距离后音效音量不再变化。</td>
    </tr>
    <tr>
      <td><strong>Rolloff Mode</strong></td>
      <td>控制音效衰减的方式。</td>
      <td>根据需要选择不同的衰减模式：</td>
    </tr>
    <tr>
      <td>- <strong>Logarithmic Rolloff</strong></td>
      <td>音效在接近时非常响亮，但随着距离增加衰减得很快。</td>
      <td>用于模拟自然的音量衰减。</td>
    </tr>
    <tr>
      <td>- <strong>Linear Rolloff</strong></td>
      <td>音效随着距离增加而逐渐变小，衰减线性。</td>
      <td>用于模拟更平滑的音量衰减。</td>
    </tr>
    <tr>
      <td>- <strong>Custom Rolloff</strong></td>
      <td>根据自定义图表设置音效衰减。</td>
      <td>用于实现自定义的衰减曲线，适应特殊的音效需求。</td>
    </tr>
  </tbody>
</table>

<h3 id="audio-listener">Audio Listener</h3>
<p>行为类似耳机类设备，接收场景内AudioSource的输入，通过计算机扬声器输出，通常挂载主摄像机上<br />
如果音源是3D的，监听器将模拟声音在3D世界中的位置、速度和方向<br />
每个场景中只能有一个Audio Listener</p>

<h3 id="audio-mixer">Audio Mixer</h3>
<p><code class="language-plaintext highlighter-rouge">Audio Mixer</code>是Unity中用于处理和控制游戏音频的强大工具，它允许你对音频信号进行多轨编辑、实时混音、效果处理和音量控制</p>

<h4 id="功能和用法">功能和用法</h4>

<p>1.音频轨道管理（Channels）<br />
在 Audio Mixer 中，你可以将多个音频源（如背景音乐、环境音效、UI 音效等）分配到不同的轨道上进行独立控制。每个轨道都可以有自己的音量、效果和其他处理器。</p>

<p>2.实时音效处理<br />
Audio Mixer 提供了多种内置的音效处理器（如 Reverb、Echo、Low-pass filter、Distortion 等），你可以实时调整这些效果来改变音频的听感。例如，你可以模拟一个声音在大房间中的回响，或者调整音频的高频和低频响应。</p>

<p>3.音量控制和动态调整<br />
你可以通过 Audio Mixer 中的 Volume Faders 来控制每个音频轨道的音量，并且支持实时调节。比如，你可以设定背景音乐的音量在游戏的某些场景中变化，或者根据游戏的状态（如玩家的行动、战斗、对话等）来调节音量。</p>

<p>4.Duck/Sidechain Compression<br />
Duck 是 Audio Mixer 中常用的动态处理功能，通常用于背景音乐和环境音效，避免这些音效与重要声音（如角色对话或枪声）发生冲突。你可以通过设置侧链压缩（sidechain compression）来实现这种效果。例如，当敌人发出声音时，背景音乐的音量会自动降低。</p>

<p>5.Snapshot 和过渡效果（Transitions）<br />
Snapshot 是一种音频状态，允许你在不同的游戏场景或条件下迅速切换音频的设置。例如，切换到战斗场景时，你可以通过切换到战斗音效的 Snapshot，来提升战斗音乐的音量并加入额外的音效处理。</p>

<p>6.控制游戏中的音频混合器<br />
你可以通过代码动态控制音频混合器的参数（例如音量、效果和 Snapshot）：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.Audio</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">AudioManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">AudioMixer</span> <span class="n">audioMixer</span><span class="p">;</span>

    <span class="c1">// 设置音量</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetVolume</span><span class="p">(</span><span class="kt">float</span> <span class="n">volume</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">audioMixer</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="s">"MasterVolume"</span><span class="p">,</span> <span class="n">volume</span><span class="p">);</span>

    <span class="c1">// 切换到一个音频快照</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SwitchToSnapshot</span><span class="p">(</span><span class="n">AudioMixerSnapshot</span> <span class="n">snapshot</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">snapshot</span><span class="p">.</span><span class="nf">TransitionTo</span><span class="p">(</span><span class="m">1.0f</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>7.Audio Mixer 和 Audio Sources 的结合<br />
Audio Mixer 还与 AudioSource 结合使用，通过将多个 AudioSource 连接到同一个 Audio Mixer，你可以统一管理所有音频的效果。例如，背景音乐、UI 音效和环境音效都可以通过一个混音器进行调整。具体操作可以在 Audio Source 的 Output 属性中设置。</p>

<h4 id="使用方法">使用方法</h4>
<p>1.创建一个 Audio Mixer</p>
<ul>
  <li>在 Project 窗口中，右击并选择 Create -&gt; Audio Mixer，然后给它命名。</li>
  <li>双击创建的 Audio Mixer 以打开音频混音器窗口。</li>
</ul>

<p>2.添加音频轨道</p>
<ul>
  <li>在 Audio Mixer 窗口中，点击右上角的 + 按钮，选择 Create Group，然后为该轨道命名。每个音频源将连接到这个轨道。</li>
  <li>你可以为每个轨道添加 效果（比如 Reverb 或 Echo）和 音量控制（通过 Fader）。</li>
</ul>

<p>3.连接 Audio Source 到 Audio Mixer</p>
<ul>
  <li>选择你想要控制的 AudioSource，然后在 Inspector 面板中的 Output 部分，选择你刚刚创建的 Audio Mixer 的轨道。
4.设置 Snapshot 和过渡效果</li>
  <li>在 Audio Mixer 中，点击 Snapshots 标签页，创建新的 Snapshot，设置需要的音量和效果。</li>
  <li>你可以使用代码或事件系统来切换快照。例如，战斗开始时，可以切换到一个包含增强音效和音乐的 Snapshot。</li>
</ul>

<p>5.调整实时音效</p>
<ul>
  <li>在音频轨道上添加效果，调整参数并实时监听效果的变化。比如你可以使用 Low-Pass Filter 来调整环境音效，使其在不同的环境下具有不同的氛围。</li>
</ul>

<h2 id="结合">结合</h2>

<h2 id="api">API</h2>
<h3 id="audio-source-1">Audio Source</h3>
<h4 id="properties">Properties</h4>

<table>
  <thead>
    <tr>
      <th><strong>属性</strong></th>
      <th><strong>说明</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>bypassEffects</strong></td>
      <td>跳过音频源的效果处理（如滤波器组件或全局监听器滤波器）。</td>
    </tr>
    <tr>
      <td><strong>bypassListenerEffects</strong></td>
      <td>设置为 <code class="language-plaintext highlighter-rouge">true</code> 时，音频源的音频信号不会应用全局监听器效果。</td>
    </tr>
    <tr>
      <td><strong>bypassReverbZones</strong></td>
      <td>设置为 <code class="language-plaintext highlighter-rouge">true</code> 时，音频源不会路由到全局混响区域。</td>
    </tr>
    <tr>
      <td><strong>clip</strong></td>
      <td>默认播放的 <code class="language-plaintext highlighter-rouge">AudioClip</code>。</td>
    </tr>
    <tr>
      <td><strong>dopplerLevel</strong></td>
      <td>设置音频源的多普勒效应比例。</td>
    </tr>
    <tr>
      <td><strong>gamepadSpeakerOutputType</strong></td>
      <td>获取或设置音频源的游戏手柄音频输出类型。</td>
    </tr>
    <tr>
      <td><strong>ignoreListenerPause</strong></td>
      <td>允许音频源在 <code class="language-plaintext highlighter-rouge">AudioListener.pause</code> 为 <code class="language-plaintext highlighter-rouge">true</code> 时继续播放（用于菜单音效或暂停菜单中的背景音乐）。</td>
    </tr>
    <tr>
      <td><strong>ignoreListenerVolume</strong></td>
      <td>使音频源忽略 <code class="language-plaintext highlighter-rouge">AudioListener</code> 的音量设置。</td>
    </tr>
    <tr>
      <td><strong>isPlaying</strong></td>
      <td>返回音频源是否正在播放音频资源（只读）。</td>
    </tr>
    <tr>
      <td><strong>isVirtual</strong></td>
      <td>如果所有由该音频源播放的声音都被音频系统剔除，则为 <code class="language-plaintext highlighter-rouge">true</code>。</td>
    </tr>
    <tr>
      <td><strong>loop</strong></td>
      <td>检查音频剪辑是否循环播放。</td>
    </tr>
    <tr>
      <td><strong>maxDistance</strong></td>
      <td>设置声音不再变得更轻或停止衰减的距离，取决于衰减模式。</td>
    </tr>
    <tr>
      <td><strong>minDistance</strong></td>
      <td>在该距离内，音频源的音量将不再增大。</td>
    </tr>
    <tr>
      <td><strong>mute</strong></td>
      <td>静音或取消静音音频源。</td>
    </tr>
    <tr>
      <td><strong>outputAudioMixerGroup</strong></td>
      <td>设置音频源的音频信号路由到的目标混音器组。</td>
    </tr>
    <tr>
      <td><strong>panStereo</strong></td>
      <td>对播放声音进行立体声平移（左或右）。仅适用于单声道或立体声的声音。</td>
    </tr>
    <tr>
      <td><strong>pitch</strong></td>
      <td>设置音频源的音高。</td>
    </tr>
    <tr>
      <td><strong>playOnAwake</strong></td>
      <td>启用该属性可以使音频源在组件或游戏对象激活时自动播放音频源。</td>
    </tr>
    <tr>
      <td><strong>priority</strong></td>
      <td>设置音频源的优先级。</td>
    </tr>
    <tr>
      <td><strong>resource</strong></td>
      <td>默认播放的音频资源。</td>
    </tr>
    <tr>
      <td><strong>reverbZoneMix</strong></td>
      <td>设置音频源信号混合到与混响区域相关的全局混响效果的程度。</td>
    </tr>
    <tr>
      <td><strong>rolloffMode</strong></td>
      <td>设置或获取音频源如何根据距离进行衰减。</td>
    </tr>
    <tr>
      <td><strong>spatialBlend</strong></td>
      <td>设置音频源受 3D 空间化计算（如衰减、多普勒效应等）的影响程度。0.0 为完全 2D，1.0 为完全 3D。</td>
    </tr>
    <tr>
      <td><strong>spatialize</strong></td>
      <td>启用或禁用空间化处理。</td>
    </tr>
    <tr>
      <td><strong>spatializePostEffects</strong></td>
      <td>设置空间化效果是在效果过滤器之前还是之后插入的。</td>
    </tr>
    <tr>
      <td><strong>spread</strong></td>
      <td>设置 3D 立体或多声道声音的扩展角度（单位：度）。</td>
    </tr>
    <tr>
      <td><strong>time</strong></td>
      <td>音频源播放位置（单位：秒）。</td>
    </tr>
    <tr>
      <td><strong>timeSamples</strong></td>
      <td>音频源的当前播放位置（单位：PCM 样本）。</td>
    </tr>
    <tr>
      <td><strong>velocityUpdateMode</strong></td>
      <td>设置音频源是否应在固定更新或动态更新时更新。</td>
    </tr>
    <tr>
      <td><strong>volume</strong></td>
      <td>设置音频源的音量（范围：0.0 到 1.0）。</td>
    </tr>
  </tbody>
</table>

<h4 id="public-methods">Public Methods</h4>

<table>
  <thead>
    <tr>
      <th><strong>方法/属性</strong></th>
      <th><strong>说明</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>DisableGamepadOutput</strong></td>
      <td>禁用此音频源的游戏手柄音频输出。</td>
    </tr>
    <tr>
      <td><strong>GetAmbisonicDecoderFloat</strong></td>
      <td>读取附加在 <code class="language-plaintext highlighter-rouge">AudioSource</code> 上的自定义 Ambisonic 解码器效果的用户定义参数。</td>
    </tr>
    <tr>
      <td><strong>GetCustomCurve</strong></td>
      <td>获取指定 <code class="language-plaintext highlighter-rouge">AudioSourceCurveType</code> 的当前自定义曲线。</td>
    </tr>
    <tr>
      <td><strong>GetOutputData</strong></td>
      <td>提供当前播放的音频源的输出数据块。</td>
    </tr>
    <tr>
      <td><strong>GetSpatializerFloat</strong></td>
      <td>读取附加在 <code class="language-plaintext highlighter-rouge">AudioSource</code> 上的自定义空间化效果的用户定义参数。</td>
    </tr>
    <tr>
      <td><strong>GetSpectrumData</strong></td>
      <td>提供当前播放的音频源的音频频率数据块（频谱数据）。</td>
    </tr>
    <tr>
      <td><strong>Pause</strong></td>
      <td>暂停当前播放的音频剪辑。</td>
    </tr>
    <tr>
      <td><strong>Play</strong></td>
      <td>播放音频剪辑。</td>
    </tr>
    <tr>
      <td><strong>PlayDelayed</strong></td>
      <td>延迟指定秒数后播放音频剪辑。建议使用此函数替代旧的 <code class="language-plaintext highlighter-rouge">Play(delay)</code> 函数，后者接受样本数作为参数。</td>
    </tr>
    <tr>
      <td><strong>PlayOneShot</strong></td>
      <td>播放一个 <code class="language-plaintext highlighter-rouge">AudioClip</code>，并根据 <code class="language-plaintext highlighter-rouge">volumeScale</code> 调整音频源的音量。</td>
    </tr>
    <tr>
      <td><strong>PlayOnGamepad</strong></td>
      <td>启用音频源通过指定的游戏手柄播放。</td>
    </tr>
    <tr>
      <td><strong>PlayScheduled</strong></td>
      <td>在绝对时间线上（由 <code class="language-plaintext highlighter-rouge">AudioSettings.dspTime</code> 提供）指定的时间播放音频剪辑。</td>
    </tr>
    <tr>
      <td><strong>SetAmbisonicDecoderFloat</strong></td>
      <td>设置附加在 <code class="language-plaintext highlighter-rouge">AudioSource</code> 上的自定义 Ambisonic 解码器效果的用户定义参数。</td>
    </tr>
    <tr>
      <td><strong>SetCustomCurve</strong></td>
      <td>设置指定 <code class="language-plaintext highlighter-rouge">AudioSourceCurveType</code> 的自定义曲线。</td>
    </tr>
    <tr>
      <td><strong>SetScheduledEndTime</strong></td>
      <td>更改已调度播放的声音的结束时间。注意，由于时序的原因，某些重新调度的请求可能无法完成。</td>
    </tr>
    <tr>
      <td><strong>SetScheduledStartTime</strong></td>
      <td>更改已调度播放的声音的开始时间。</td>
    </tr>
    <tr>
      <td><strong>SetSpatializerFloat</strong></td>
      <td>设置附加在 <code class="language-plaintext highlighter-rouge">AudioSource</code> 上的自定义空间化效果的用户定义参数。</td>
    </tr>
    <tr>
      <td><strong>Stop</strong></td>
      <td>停止播放音频剪辑。</td>
    </tr>
    <tr>
      <td><strong>UnPause</strong></td>
      <td>取消暂停，恢复播放此音频源。</td>
    </tr>
  </tbody>
</table>

<h4 id="static-methods">Static Methods</h4>

<table>
  <thead>
    <tr>
      <th><strong>方法/属性</strong></th>
      <th><strong>说明</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>GamepadSpeakerSupportsOutputType</strong></td>
      <td>检查平台是否支持在游戏手柄上输出音频的特定类型。</td>
    </tr>
    <tr>
      <td><strong>PlayClipAtPoint</strong></td>
      <td>在世界空间中的指定位置播放一个 <code class="language-plaintext highlighter-rouge">AudioClip</code>。这个方法会自动为音频源创建一个临时的 <code class="language-plaintext highlighter-rouge">AudioSource</code>。</td>
    </tr>
  </tbody>
</table>

<h3 id="audio-listener-1">Audio Listener</h3>
<h4 id="static-properties">Static Properties</h4>

<table>
  <thead>
    <tr>
      <th><strong>属性</strong></th>
      <th><strong>说明</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>pause</strong></td>
      <td>获取或设置音频系统的暂停状态。若为 <code class="language-plaintext highlighter-rouge">true</code>，音频将暂停播放。</td>
    </tr>
    <tr>
      <td><strong>volume</strong></td>
      <td>控制游戏音量的全局设置（范围从 0.0 到 1.0），用于调节整个游戏的音量。</td>
    </tr>
  </tbody>
</table>

<h4 id="properties-1">Properties</h4>

<table>
  <thead>
    <tr>
      <th><strong>属性</strong></th>
      <th><strong>说明</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>velocityUpdateMode</strong></td>
      <td>设置 <code class="language-plaintext highlighter-rouge">AudioListener</code> 是否应在固定更新或动态更新时进行更新。<code class="language-plaintext highlighter-rouge">FixedUpdate</code> 或 <code class="language-plaintext highlighter-rouge">Update</code> 中更新监听器的位置和速度。</td>
    </tr>
  </tbody>
</table>

<h4 id="static-methods-1">Static Methods</h4>

<table>
  <thead>
    <tr>
      <th><strong>方法</strong></th>
      <th><strong>说明</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>GetOutputData</strong></td>
      <td>提供音频监听器（主监听器）输出数据的一个数据块。通常用于实时分析音频输出的信号。</td>
    </tr>
    <tr>
      <td><strong>GetSpectrumData</strong></td>
      <td>提供音频监听器（主监听器）的频谱数据的一个数据块，用于音频的频率分析，常用于音频可视化和动态效果处理。</td>
    </tr>
  </tbody>
</table>

<h3 id="audio-mixer-1">Audio Mixer</h3>
<h4 id="properties-2">Properties</h4>

<table>
  <thead>
    <tr>
      <th><strong>属性</strong></th>
      <th><strong>说明</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>outputAudioMixerGroup</strong></td>
      <td><strong>路由目标</strong>：设置音频源的音频信号应该输出到哪个音频混音器组。每个音频源可以选择一个目标音频混音器组，这决定了音频信号的路由路径，常用于将不同类型的音频信号（如背景音乐、效果音、语音等）分配到不同的处理组中。</td>
    </tr>
    <tr>
      <td><strong>updateMode</strong></td>
      <td><strong>音频混音器时间更新模式</strong>：设置 <code class="language-plaintext highlighter-rouge">AudioMixer</code> 的时间如何进展，尤其在 <strong>Snapshot</strong> 过渡期间。可以控制在时间过渡（如混音器快照转换）过程中，混音器的行为。常用于调整音频的渐变、平滑过渡等效果。</td>
    </tr>
  </tbody>
</table>

<h4 id="public-methods-1">Public Methods</h4>

<table>
  <thead>
    <tr>
      <th><strong>方法/属性</strong></th>
      <th><strong>说明</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>ClearFloat</strong></td>
      <td>重置一个暴露的参数到其初始值。通常用于清除在混音器中对某个暴露参数的修改。</td>
    </tr>
    <tr>
      <td><strong>FindMatchingGroups</strong></td>
      <td>在混音器中查找与指定路径匹配的组。该路径形式为 “Master Group/Child Group/Grandchild Group”，例如，<code class="language-plaintext highlighter-rouge">Master/WATER/DROPS</code> 返回组 DROPS。</td>
    </tr>
    <tr>
      <td><strong>FindSnapshot</strong></td>
      <td>根据指定的名称查找并返回匹配的快照（名称必须完全匹配）。</td>
    </tr>
    <tr>
      <td><strong>GetFloat</strong></td>
      <td>返回指定暴露参数的值。如果该参数不存在，函数将返回 <code class="language-plaintext highlighter-rouge">false</code>。在调用 <code class="language-plaintext highlighter-rouge">SetFloat</code> 或 <code class="language-plaintext highlighter-rouge">ClearFloat</code> 后，返回的值将是当前快照或快照过渡期间的值。</td>
    </tr>
    <tr>
      <td><strong>SetFloat</strong></td>
      <td>设置指定暴露参数的值。一旦调用该方法，混音器快照将不再控制此暴露参数，并且只能通过 <code class="language-plaintext highlighter-rouge">AudioMixer.SetFloat</code> 方法修改该参数。</td>
    </tr>
    <tr>
      <td><strong>TransitionToSnapshots</strong></td>
      <td>转换到指定快照的加权混合。可用于游戏中根据状态的不同在不同的音频快照之间过渡，或通过三角插值来实现快照之间的平滑过渡。</td>
    </tr>
  </tbody>
</table>

<h2 id="性能">性能</h2>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><summary type="html"><![CDATA[Audio System 是 Unity中处理游戏所有声音播放、管理和混音的核心模块]]></summary></entry><entry><title type="html">Object</title><link href="http://localhost:4000/posts/2025-07-11-Object/" rel="alternate" type="text/html" title="Object" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Object</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-11-Object/"><![CDATA[<p>Object是Unity中所有内建物体的基类，实现在UnityEngine.CoreModule中，不同于C#中的<code class="language-plaintext highlighter-rouge">System.Object</code>，它是托管层（C#）和原生引擎层（C++）之间的桥梁，背后绑定着Unity C++引擎层的资源句柄</p>

<h2 id="object的特点unity的特有行为">Object的特点（Unity的特有行为）</h2>
<p><strong>引擎资源的绑定</strong></p>

<p>每个<code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>对象都对应一个C++层对象，它们通过一个<code class="language-plaintext highlighter-rouge">instance 2D</code>来关联，且资源的生命周期不由GC管理</p>

<p>比如：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">go</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">();</span>
<span class="n">Object</span><span class="p">.</span><span class="nf">Destroy</span><span class="p">(</span><span class="n">go</span><span class="p">);</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span> <span class="p">==</span> <span class="k">null</span><span class="p">);</span>  <span class="c1">// true</span>
</code></pre></div></div>
<p>这就是Object的“鬼行为”，此处的<code class="language-plaintext highlighter-rouge">go == null</code>并非等价于<code class="language-plaintext highlighter-rouge">object is null</code></p>

<p><strong>Unity的“fake null”机制</strong></p>

<p>Unity重写了<code class="language-plaintext highlighter-rouge">==</code>操作符</p>

<p>如果一个<code class="language-plaintext highlighter-rouge">Object</code>对象在引擎层已经被销毁（Destroy过），但C#还保有托管引用，这时候：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span> <span class="p">==</span> <span class="k">null</span><span class="p">);</span> <span class="c1">// true</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="k">null</span><span class="p">));</span> <span class="c1">// false</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="nf">ReferenceEquals</span><span class="p">(</span><span class="n">go</span><span class="p">,</span> <span class="k">null</span><span class="p">));</span> <span class="c1">// false</span>
</code></pre></div></div>
<p>这是Unity为了安全做的改动行为，防止对已经销毁的对象操作，引起native崩溃</p>

<h3 id="底层原理">底层原理</h3>
<p>Unity的<code class="language-plaintext highlighter-rouge">Object</code>在C#层其实只是一个代理，它对应的C++引擎层对象通过C#层的<code class="language-plaintext highlighter-rouge">IntPtr m_CachedPtr</code>与C++对象通信（该字段可以在反编译时看到）</p>

<p>资源对象（比如一个贴图）在编译器导入时会被转换为native object，保存在场景或资源文件中，加载时通过Unity自己的反序列化系统生成C#代理对象，并挂接<code class="language-plaintext highlighter-rouge">m_CachedPtr</code></p>

<p>Unity会使用C++引擎进行资源生命周期的管理，而不是C#的GC，所以Destroy调的是C++的释放接口</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sometimes an instance of Object can be in detached state, where there is no underlying native object. T
his can happen if the instance references an native object that has been destroyed, or a missing Asset or missing type. 
Detached objects retain their InstanceID, but the object cannot be used to call methods or access properties. 
An object in this state will appear to be null, because of special implementations of operator==, operator!= and Ojbect.bool.
Because the object is not truly null, a call to Object.ReferenceEquals(myobject, null) will return false.

The null-comditional operator(?.)and the null-coalescing operator(??)are not supported with Unity Object because they cannot be overridden to treat detached objects the same as null.
It is only safe to use those operators in your scripts if there is certainty that the objects being checked are never in a detached state.
</code></pre></div></div>

<h2 id="object-api">Object API</h2>
<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">name</code></td>
      <td><code class="language-plaintext highlighter-rouge">string</code></td>
      <td>对象名称（可读写）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hideFlags</code></td>
      <td><code class="language-plaintext highlighter-rouge">HideFlags</code></td>
      <td>控制对象是否可隐藏/可编辑/保存</td>
    </tr>
  </tbody>
</table>

<p><strong><code class="language-plaintext highlighter-rouge">hideFlags</code></strong><br />
常见用途：</p>
<ul>
  <li>隐藏对象</li>
  <li>防止误删或编辑</li>
  <li>不让对象随着场景保存（通常用于运行时生成的对象）</li>
</ul>

<p>常用枚举值</p>

<table>
  <thead>
    <tr>
      <th>枚举值</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.None</code></td>
      <td>默认行为，无隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideInHierarchy</code></td>
      <td>在 Hierarchy 视图中隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideInInspector</code></td>
      <td>在 Inspector 中隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.NotEditable</code></td>
      <td>不允许用户编辑（灰掉）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSave</code></td>
      <td>场景保存时不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSaveInBuild</code></td>
      <td>打包时不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSaveInEditor</code></td>
      <td>编辑器中不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideAndDontSave</code></td>
      <td>隐藏并不保存（临时对象）</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetInstanceID</code></td>
      <td>获得object的实例ID</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ToString</code></td>
      <td>返回<code class="language-plaintext highlighter-rouge">object.name</code></td>
    </tr>
  </tbody>
</table>

<p><strong>Static Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
      <th>示例/说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Destroy(Object obj)</code></td>
      <td>销毁一个对象，在当前帧结束时生效</td>
      <td><code class="language-plaintext highlighter-rouge">Destroy(gameObject);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Destroy(Object obj, float t)</code></td>
      <td>延迟 t 秒销毁对象</td>
      <td><code class="language-plaintext highlighter-rouge">Destroy(gameObject, 2.0f);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DestroyImmediate(Object obj)</code></td>
      <td>立刻销毁对象，<strong>只推荐在编辑器中使用</strong></td>
      <td><code class="language-plaintext highlighter-rouge">DestroyImmediate(gameObject);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DontDestroyOnLoad(Object target)</code></td>
      <td>场景切换时不销毁该对象</td>
      <td>常用于单例或管理器类</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindAnyObjectByType&lt;T&gt;()</code></td>
      <td>获取任何已加载的指定类型对象（不保证顺序）</td>
      <td>替代旧版 <code class="language-plaintext highlighter-rouge">FindObjectOfType</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindFirstObjectByType&lt;T&gt;()</code></td>
      <td>获取第一个找到的指定类型对象（可能更快）</td>
      <td>常用于初始化查找</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindObjectsByType&lt;T&gt;()</code></td>
      <td>获取所有已加载的指定类型对象</td>
      <td><code class="language-plaintext highlighter-rouge">var allEnemies = FindObjectsByType&lt;Enemy&gt;();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(Object original)</code></td>
      <td>克隆一个对象（创建副本）</td>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(prefab);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(Object original, Vector3 position, Quaternion rotation)</code></td>
      <td>在指定位置和旋转创建克隆</td>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(prefab, pos, rot);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstantiateAsync(Object original)</code></td>
      <td>异步克隆对象，返回 <code class="language-plaintext highlighter-rouge">AsyncInstantiateOperation</code></td>
      <td>用于 Addressables 或大型对象，节省主线程开销</td>
    </tr>
  </tbody>
</table>

<p><strong>Operators</strong></p>

<table>
  <thead>
    <tr>
      <th>操作符</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否存在</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator!=</code></td>
      <td>比较两个object是否引用不同的物体</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator==</code></td>
      <td>是否引用相同</td>
    </tr>
  </tbody>
</table>

<h2 id="object与资源的关系">Object与资源的关系</h2>
<p>几乎所有资源类型（包括预制体、贴图、材质、音频、动画等）都继承自<code class="language-plaintext highlighter-rouge">Object</code></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Texture</span> <span class="n">tex</span> <span class="p">=</span> <span class="n">Resources</span><span class="p">.</span><span class="n">Load</span><span class="p">&lt;</span><span class="n">Texture</span><span class="p">&gt;(</span><span class="s">"MyTexture"</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Resources.Load&lt;T&gt;()</code>返回的其实就是一个<code class="language-plaintext highlighter-rouge">Object</code>的子类（这里是Texture）</p>

<h2 id="继承关系">继承关系</h2>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Object
  ├── GameObject
  └── Component
        ├── MonoBehaviour
        └── Transform / Collider / Renderer / ...
</code></pre></div></div>
<p>所以可以有：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">go</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">();</span>
<span class="n">Object</span> <span class="n">obj</span> <span class="p">=</span> <span class="n">go</span><span class="p">;</span> <span class="c1">// legal</span>
<span class="n">Component</span> <span class="n">comp</span> <span class="p">=</span> <span class="n">go</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
<span class="n">Object</span> <span class="n">o2</span> <span class="p">=</span> <span class="n">comp</span><span class="p">;</span> <span class="c1">// legal</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">new</code>出来的<code class="language-plaintext highlighter-rouge">GameObject</code>是合法的，但不能<code class="language-plaintext highlighter-rouge">new</code> <code class="language-plaintext highlighter-rouge">Transform</code>或<code class="language-plaintext highlighter-rouge">Renderer</code>，必须用<code class="language-plaintext highlighter-rouge">AddComponent</code>等引擎API创建</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Syntax" /><category term="Unity Class" /><summary type="html"><![CDATA[Object是Unity中所有内建物体的基类，实现在UnityEngine.CoreModule中，不同于C#中的System.Object，它是托管层（C#）和原生引擎层（C++）之间的桥梁，背后绑定着Unity C++引擎层的资源句柄]]></summary></entry><entry><title type="html">Native Layer to C# Layer</title><link href="http://localhost:4000/posts/2025-07-15-Native-Layer-to-C#-Layer/" rel="alternate" type="text/html" title="Native Layer to C# Layer" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Native-Layer-to-C#-Layer</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Native-Layer-to-C#-Layer/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Underlying Principle" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Loose Coupling</title><link href="http://localhost:4000/posts/2025-07-15-Loose-Coupling/" rel="alternate" type="text/html" title="Loose Coupling" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Loose-Coupling</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Loose-Coupling/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Architecture" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Game Design Patterns</title><link href="http://localhost:4000/posts/2025-07-15-Game-Design-Patterns/" rel="alternate" type="text/html" title="Game Design Patterns" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Game-Design-Patterns</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Game-Design-Patterns/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Architecture" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Interface Oriented Design</title><link href="http://localhost:4000/posts/2025-07-15-Interface-Oriented-Design/" rel="alternate" type="text/html" title="Interface Oriented Design" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Interface-Oriented-Design</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Interface-Oriented-Design/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Architecture" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Game Architecture</title><link href="http://localhost:4000/posts/2025-07-15-Game-Architecture/" rel="alternate" type="text/html" title="Game Architecture" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Game-Architecture</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Game-Architecture/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Architecture" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Import Assets</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets.html" rel="alternate" type="text/html" title="Import Assets" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets.html"><![CDATA[<p>Unity支持多种格式的资源文件，并能自动识别并进行初步处理</p>

<h2 id="资源导入基本流程">资源导入基本流程</h2>
<p><strong>1.将资源文件拖入<code class="language-plaintext highlighter-rouge">Assets</code>目录中（Unity会自动导入）</strong><br />
<strong>2.在Inspector面板中查看导入设置</strong><br />
<strong>3.配置相关参数，比如压缩方式、贴图类型、是否生成碰撞体等</strong><br />
<strong>4.使用资源（拖到场景、作为材质贴图、挂到AudioSource等）</strong></p>

<h2 id="模型">模型</h2>

<h3 id="支持格式">支持格式</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.fbx</code>推荐</li>
  <li><code class="language-plaintext highlighter-rouge">.obj</code></li>
  <li><code class="language-plaintext highlighter-rouge">.dae</code>（Collada）</li>
  <li><code class="language-plaintext highlighter-rouge">.blend</code>（需要Blender）</li>
</ul>

<h3 id="导入流程">导入流程</h3>
<p>1.拖拽<code class="language-plaintext highlighter-rouge">.fbx</code>文件到<code class="language-plaintext highlighter-rouge">Assets</code>文件夹<br />
2.选中模型文件，查看<code class="language-plaintext highlighter-rouge">Inspector</code>的导入设置</p>
<ul>
  <li>Scale Factor：缩放（一般保持默认）</li>
  <li>Import Animations：是否导入动画</li>
  <li>Import Materials：是否导入材质</li>
  <li>Generate Colliders：是否自动生成碰撞体</li>
</ul>

<h3 id="导入后组成">导入后组成</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Model</code>: 3D网格</li>
  <li><code class="language-plaintext highlighter-rouge">Rig</code>（如果有骨骼）：用于动画绑定</li>
  <li><code class="language-plaintext highlighter-rouge">Animation</code>：包含的动画片段</li>
  <li><code class="language-plaintext highlighter-rouge">Materials</code>：自动生成或关联的材质</li>
</ul>

<h2 id="贴图">贴图</h2>

<h3 id="支持格式-1">支持格式</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.png</code>、<code class="language-plaintext highlighter-rouge">.jpg</code>、<code class="language-plaintext highlighter-rouge">.tga</code>、<code class="language-plaintext highlighter-rouge">.psd</code>（支持图层）等</li>
</ul>

<h3 id="导入流程-1">导入流程</h3>

<p>1.拖入图片文件
2.在Inspector中设置：</p>
<ul>
  <li>sRGB（Color Texture）：颜色贴图用，法线贴图需取消勾选</li>
  <li>Alpha Is Transparency：如果使用透明通道</li>
  <li>Wrap Mode：Repeat（平铺）或Clamp（拉伸）</li>
  <li>Filter Mode：Bilinear、Trilinear、Point（像素风）</li>
  <li>Compression：高压缩（小体积）还是高质量（清晰）</li>
  <li>Texture Type:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Default</code>（通用）</li>
      <li><code class="language-plaintext highlighter-rouge">Sprite</code>（用于UI）</li>
      <li><code class="language-plaintext highlighter-rouge">Normal map</code>（法线贴图）</li>
      <li><code class="language-plaintext highlighter-rouge">Lightmap</code>（光照图）</li>
    </ul>
  </li>
</ul>

<h2 id="音频">音频</h2>

<h3 id="支持格式-2">支持格式</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.mp3</code>（压缩）</li>
  <li><code class="language-plaintext highlighter-rouge">.wav</code>（无损）</li>
  <li><code class="language-plaintext highlighter-rouge">.ogg</code>（高效）</li>
  <li><code class="language-plaintext highlighter-rouge">.aiff</code></li>
</ul>

<h2 id="导入流程-2">导入流程</h2>

<p>1.拖入音频文件<br />
2.在<code class="language-plaintext highlighter-rouge">Inspector</code>中设置：</p>
<ul>
  <li>Load Type：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Decompress On Load</code>（加载时解压，适合短音效）</li>
      <li><code class="language-plaintext highlighter-rouge">Streaming</code>（边播放边加载，适合背景音乐）</li>
    </ul>
  </li>
  <li>Compression Format:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Vorbis</code>、<code class="language-plaintext highlighter-rouge">ADPCM</code>、<code class="language-plaintext highlighter-rouge">PCM</code></li>
    </ul>
  </li>
  <li>3D Sound：是否启用3D空间化</li>
  <li>Loop：是否循环播放</li>
</ul>

<blockquote>
  <p><strong>资源组织建议：</strong> 使用好的文件夹结构和命名习惯，可以极大提高开发效率</p>
</blockquote>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><summary type="html"><![CDATA[Unity支持多种格式的资源文件，并能自动识别并进行初步处理]]></summary></entry><entry><title type="html">Layer</title><link href="http://localhost:4000/posts/2025-06-01-Layer/" rel="alternate" type="text/html" title="Layer" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Layer</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-01-Layer/"><![CDATA[<p>在Unity中，Layer是要给非常重要的系统<br />
它主要用于：</p>
<ul>
  <li>控制物体的渲染与相机的可见性</li>
  <li>控制物理碰撞（配合Layer Collision Matrix）</li>
  <li>通过脚本进行物体分类和筛选</li>
</ul>

<h2 id="什么是layer">什么是Layer</h2>

<p>Layer是给GameObject打的“标签”，但它和<code class="language-plaintext highlighter-rouge">Tag</code>不一样，Layer是用于功能性控制的，特别在：</p>
<ul>
  <li>摄像机的Culling Mask</li>
  <li>光照影响（Light Culling）</li>
  <li>物理碰撞（Physics Layer）</li>
  <li>射线检测（Raycast Layer）</li>
</ul>

<h2 id="layer的使用场景">Layer的使用场景</h2>
<h3 id="1摄像机视野控制culling-mask">1.摄像机视野控制（Culling Mask）</h3>
<p>在Camera组件中，你可以设置</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Culling Mask -&gt; 选择哪些Layer可以被该相机看到
</code></pre></div></div>

<p><strong>用途：</strong></p>
<ul>
  <li>UI相机只看UI层</li>
  <li>小地图相机只看敌人层</li>
  <li>分屏镜头每个只看自己的部分</li>
</ul>

<p>Layer不仅能控制每个物体是否被摄像机看到，还能与多个摄像机协作实现更加复杂的视图效果</p>

<p>例如，在多人游戏中，你可以为每个玩家设置独立的摄像机，每个摄像机通过不同的Culling Mask来渲染不同的场景部分</p>

<p>示例：多摄像头分屏控制</p>

<p>在分屏游戏中，可以设置多个摄像机，每个摄像机只渲染属于特定玩家的物体</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">camera1</span><span class="p">.</span><span class="n">cullingMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Player1"</span><span class="p">);</span>
<span class="n">camera2</span><span class="p">.</span><span class="n">cullingMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LaeryMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Player2"</span><span class="p">);</span>
</code></pre></div></div>
<p>通过这种方式，你能够在同一个场景中显示不同的物体，仅限于特定玩家的视野</p>

<h3 id="2物理碰撞控制layer-collision-matrix">2.物理碰撞控制（Layer Collision Matrix）</h3>
<p>在菜单中：</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Edit</span> <span class="s">-&gt;</span> <span class="s">Project</span> <span class="s">Settings</span> <span class="s">-&gt;</span> <span class="s">Physics</span>
</code></pre></div></div>

<p>你可以看到Layer Collision Matrix，它控制哪些Layer和哪些Layer能发生物理碰撞</p>

<p>如果在游戏中有多个物体不需要彼此发生碰撞，可以通过Layer来减少不必要的碰撞检测，提高性能</p>

<p><strong>用途：</strong></p>
<ul>
  <li>玩家层与敌人层可以碰撞，但不和自身碰撞</li>
  <li>子弹不撞自己</li>
  <li>角色不被UI的Collider打断</li>
</ul>

<h3 id="3射线检测">3.射线检测</h3>
<p>可以通过Layer来控制射线是否命中某个对象</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">layerMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Physics</span><span class="p">.</span><span class="nf">Raycast</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="k">out</span> <span class="n">hit</span><span class="p">,</span> <span class="m">100f</span><span class="p">,</span> <span class="n">layerMask</span><span class="p">))</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Hit enemy"</span><span class="p">);</span>
</code></pre></div></div>

<p>也可以多层合并：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">mask</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">))</span> <span class="p">|</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"NPC"</span><span class="p">));</span>
</code></pre></div></div>
<h2 id="内置与自定义layer">内置与自定义Layer</h2>

<h3 id="内置layerunity默认的">内置Layer（Unity默认的）</h3>

<table>
  <thead>
    <tr>
      <th>编号</th>
      <th>名称</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>Default</td>
      <td>默认层</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Water</td>
      <td>水体特效</td>
    </tr>
    <tr>
      <td>5</td>
      <td>UI</td>
      <td>UI 专用</td>
    </tr>
  </tbody>
</table>

<h3 id="自定义layer">自定义Layer</h3>
<p>Unity允许你最多使用32个Layer（编号 0~31），其中前几个是保留的<br />
自定义方式：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">选中</span> <span class="n">GameObject</span> <span class="o">-&gt;</span> <span class="n">Inspector</span> <span class="o">-&gt;</span> <span class="n">Layer</span> <span class="o">-&gt;</span> <span class="k">Add</span> <span class="n">Layer</span><span class="p">...</span>
</code></pre></div></div>
<p>添加后可为GameObject设置：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Layer</span> <span class="s">-&gt;</span> <span class="s">你刚添加的层名</span>
</code></pre></div></div>
<h2 id="layer与tag的区别">Layer与Tag的区别</h2>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>Layer</th>
      <th>Tag</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>数量限制</td>
      <td>最多 32 个</td>
      <td>无限制</td>
    </tr>
    <tr>
      <td>用于渲染控制</td>
      <td>是</td>
      <td>否</td>
    </tr>
    <tr>
      <td>用于物理控制</td>
      <td>是</td>
      <td>否</td>
    </tr>
    <tr>
      <td>用于分类查找</td>
      <td>有限制（用 LayerMask）</td>
      <td>可以（用 CompareTag 等）</td>
    </tr>
    <tr>
      <td>性能优化</td>
      <td>优化（用于剔除、射线过滤）</td>
      <td>无优化</td>
    </tr>
  </tbody>
</table>

<h3 id="建议">建议</h3>
<ul>
  <li>给每种功能的对象分配专属Layer</li>
  <li>摄像机、光源、UI、Trigger检测都应依赖Layer控制逻辑</li>
</ul>

<h2 id="layer性能优化与管理">Layer性能优化与管理</h2>
<h3 id="layer管理的最佳实践">Layer管理的最佳实践</h3>
<ul>
  <li>避免过多的Layer：虽然Unity最多允许32个Layer，但不建议频繁使用大量的Layer。过多的Layer会增加管理和维护的难度，且可能会影响性能。建议将层次结构设计得尽量简洁，避免无谓的冗余</li>
  <li>分层管理：根据物体的功能将其分配到不同的Layer中，例如：
    <ul>
      <li>游戏角色：<code class="language-plaintext highlighter-rouge">Player</code>,<code class="language-plaintext highlighter-rouge">Enemy</code></li>
      <li>UI界面：<code class="language-plaintext highlighter-rouge">UI</code>,<code class="language-plaintext highlighter-rouge">Menu</code></li>
      <li>特效：<code class="language-plaintext highlighter-rouge">PerticleEffects</code></li>
      <li>背景：<code class="language-plaintext highlighter-rouge">Background</code></li>
    </ul>
  </li>
</ul>

<p>通过合理的分层，既能提高渲染效率，也便于后期维护</p>

<h3 id="动态控制layer">动态控制Layer</h3>
<p>在一些场景中，可能需要根据物体的状态动态改变其Layer。比如，当玩家接触到某个特殊的物体时，可以改变其Layer，使其在某些摄像机的视野中不可见或不可碰撞</p>

<p>示例：动态更改Layer：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gameObject</span><span class="p">.</span><span class="n">layer</span> <span class="p">=</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Invisible"</span><span class="p">);</span>
</code></pre></div></div>
<p>通过动态修改Layer，能够灵活控制物体的行为和渲染效果</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><summary type="html"><![CDATA[在Unity中，Layer是要给非常重要的系统 它主要用于： 控制物体的渲染与相机的可见性 控制物理碰撞（配合Layer Collision Matrix） 通过脚本进行物体分类和筛选]]></summary></entry></feed>