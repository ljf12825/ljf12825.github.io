<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-07-28T19:22:32+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ljf12825’s Blog</title><subtitle>Efficient &amp; Elegant</subtitle><author><name>Jeff Lee</name><email>2548278761@qq.com</email></author><entry><title type="html">Unity Editor</title><link href="http://localhost:4000/posts/2025-07-22-Unity-Editor/" rel="alternate" type="text/html" title="Unity Editor" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Unity-Editor</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-22-Unity-Editor/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Editor" /><category term="Tool" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Mesh</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Mesh.html" rel="alternate" type="text/html" title="Mesh" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Mesh</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Mesh.html"><![CDATA[<p>Unity中的Mesh（网格）是一切3D模型、地形、角色、道具、甚至某些UI元素的几何基础，是“物体的骨架”<br />
包含顶点、面、法线、UV、颜色等数据，是3D图形渲染的核心单位</p>

<h2 id="mesh的构成">Mesh的构成</h2>

<table>
  <thead>
    <tr>
      <th>数据</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>顶点（Vertices）</strong></td>
      <td>网格的点，构成形状的基础</td>
    </tr>
    <tr>
      <td><strong>三角形（Triangles）</strong></td>
      <td>每三个顶点组成一个三角面，是渲染最小单元</td>
    </tr>
    <tr>
      <td><strong>法线（Normals）</strong></td>
      <td>每个顶点的方向，用于光照计算</td>
    </tr>
    <tr>
      <td><strong>UV 坐标（UVs）</strong></td>
      <td>纹理坐标，用来决定贴图怎么铺在模型上</td>
    </tr>
    <tr>
      <td><strong>顶点色（Colors）</strong></td>
      <td>每个顶点的颜色，用于特效、调色</td>
    </tr>
    <tr>
      <td><strong>切线（Tangents）</strong></td>
      <td>用于法线贴图的方向辅助向量</td>
    </tr>
  </tbody>
</table>

<p>这些数据最终会交给GPU，进行渲染</p>

<h2 id="mesh在unity中的用途">Mesh在Unity中的用途</h2>

<table>
  <thead>
    <tr>
      <th>用途</th>
      <th>举例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>渲染模型</td>
      <td>静态模型、角色模型、环境场景</td>
    </tr>
    <tr>
      <td>自定义几何体</td>
      <td>Procedural Mesh（如地形、波浪、水面）</td>
    </tr>
    <tr>
      <td>碰撞体数据</td>
      <td>Mesh Collider 也使用 Mesh</td>
    </tr>
    <tr>
      <td>特效/轨迹</td>
      <td>线性 Mesh（如剑气轨迹、能量波）</td>
    </tr>
    <tr>
      <td>角色换装</td>
      <td>动态换装系统中组合不同 Mesh</td>
    </tr>
  </tbody>
</table>

<h2 id="如何创建操作mesh">如何创建、操作Mesh</h2>
<p>Unity提供<code class="language-plaintext highlighter-rouge">Mesh</code>类，支持自定义几何体</p>

<h3 id="示例创建一个简单三角形mesh">示例：创建一个简单三角形Mesh</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Mesh</span> <span class="n">mesh</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Mesh</span><span class="p">();</span>

<span class="n">Vector3</span><span class="p">[]</span> <span class="n">vertices</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector3</span><span class="p">[]</span>
<span class="p">{</span>
    <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
    <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
    <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
<span class="p">};</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">triangles</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">};</span>

<span class="n">mesh</span><span class="p">.</span><span class="n">vertices</span> <span class="p">=</span> <span class="n">vertices</span><span class="p">;</span>
<span class="n">mesh</span><span class="p">.</span><span class="n">triangles</span> <span class="p">=</span> <span class="n">triangles</span><span class="p">;</span>
<span class="n">mesh</span><span class="p">.</span><span class="nf">RecalculateNormals</span><span class="p">();</span> <span class="c1">// 自动生成法线</span>

<span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshFilter</span><span class="p">&gt;().</span><span class="n">mesh</span> <span class="p">=</span> <span class="n">mesh</span><span class="p">;</span>
</code></pre></div></div>
<h2 id="meshfilter-和-meshrenderer">MeshFilter 和 MeshRenderer</h2>
<p>在Unity中，<code class="language-plaintext highlighter-rouge">MeshFilter</code>和<code class="language-plaintext highlighter-rouge">MeshRenderer</code>是构成立体物体（3D模型）渲染的核心组件</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">MeshFilter</code>：提供集合形状（顶点、三角形等）</li>
  <li><code class="language-plaintext highlighter-rouge">MeshRenderer</code>：将形状渲染到屏幕上（使用材质、光照等）</li>
</ul>

<p><img src="/assets/images/MeshFilterandMeshRenderer.jpg" alt="MeshFilterandMeshRenderer" />;</p>

<h3 id="meshfilter提供模型数据">MeshFilter：提供模型数据</h3>
<ul>
  <li>MeshFilter包含一个Mesh对象，这是3D模型的几何体，比如立方体、球体、角色模型等</li>
  <li>这些Mesh是<code class="language-plaintext highlighter-rouge">.fbx</code>、<code class="language-plaintext highlighter-rouge">.obj</code>导入的，或运行时通过代码生成</li>
</ul>

<p>可以通过以下方式获取或赋值Mesh</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MeshFilter</span> <span class="n">mf</span> <span class="p">=</span> <span class="n">GetComponenet</span><span class="p">&lt;</span><span class="n">MeshFilter</span><span class="p">&gt;();</span>
<span class="n">Mesh</span> <span class="n">mesh</span> <span class="p">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">mesh</span><span class="p">;</span> <span class="c1">// 当前使用的实例化mesh</span>
<span class="n">mf</span><span class="p">.</span><span class="n">mesh</span> <span class="p">=</span> <span class="n">someOtherMesh</span><span class="p">;</span> <span class="c1">// 替换为新的Mesh</span>
</code></pre></div></div>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">.mesh</code>是一个实例副本，你修改它不会影响原始资源；<code class="language-plaintext highlighter-rouge">.sharedMesh</code>是共享原始资源</p>
</blockquote>

<h3 id="meshrenderer负责把模型画出来">MeshRenderer：负责把模型画出来</h3>
<ul>
  <li>MeshRenderer负责把<code class="language-plaintext highlighter-rouge">MeshFilter</code>提供的几何体渲染到屏幕上</li>
  <li>控制材质、阴影、光照、剔除、光照探针等参数</li>
</ul>

<h4 id="面板参数">面板参数</h4>
<h5 id="element-0-1">Element 0, 1…</h5>
<ul>
  <li>控制使用哪个材质渲染对应子网格</li>
  <li>通常一个对象只有一个材质，如果是多个SubMesh，会有多个材质槽
适用场景：</li>
  <li>多材质角色：身体/衣服/装备使用不同的材质</li>
  <li>不同部件不同特效：一个材质透明，一个闪光</li>
</ul>

<h5 id="lighting">Lighting</h5>
<p><strong>Cast Shadows(投射阴影)</strong></p>
<ul>
  <li>控制该物体是否想地面等对象投影</li>
  <li>选项：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">On</code>：始终投射阴影</li>
      <li><code class="language-plaintext highlighter-rouge">Off</code>：不投影</li>
      <li><code class="language-plaintext highlighter-rouge">Two Sided</code>：背面也能投影（适用于双面平面）</li>
      <li><code class="language-plaintext highlighter-rouge">Shadows Only</code>：只显示阴影，不渲染模型本体（隐形）</li>
    </ul>
  </li>
</ul>

<p><strong>Receive Shadows(接收阴影)</strong></p>
<ul>
  <li>是否接收其他物体的阴影（比如树被房子挡住时）</li>
  <li>关闭可提升性能，但视觉上可能不真实</li>
</ul>

<h5 id="probes探针相关环境光间接光">Probes（探针相关，环境光/间接光）</h5>
<p>在Unity中，<code class="language-plaintext highlighter-rouge">Probes</code>是一类帮助处理间接光照和环境反射的技术，目的是让动态物体（如角色、道具）在光照和反射效果上看起来更自然，融入环境</p>

<p><strong>为什么需要探针</strong></p>

<p>Unity中有两类光照</p>
<ul>
  <li>直接光照：来自灯光（如Dirctional Light）</li>
  <li>间接光照：来自物体间的反弹、环境照明</li>
</ul>

<p>对于静态物体，Unity可以烘焙光照贴图（Lightmap）来记录间接光照<br />
但动态物体（移动的角色、道具）不能使用烘焙光照贴图，这时候就需要探针来帮它“感受环境的光”</p>

<blockquote>
  <p>探针是一种轻量级采样方式，让动态物体获得类似烘焙光照/环境反射的技术，从而避免使用高开销的实时光照和实时反射</p>
</blockquote>

<p><strong>Light Probes</strong></p>
<ul>
  <li>是否接受光照探针（动态光照采样，用于小物体，如动态角色）</li>
  <li>一般设置为<code class="language-plaintext highlighter-rouge">Blend Probes</code>（自动采样探针）</li>
</ul>

<p><strong>Reflection Probes</strong></p>
<ul>
  <li>是否使用反射探针（环境反射用）</li>
  <li>选项：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Off</code></li>
      <li><code class="language-plaintext highlighter-rouge">Blend Probes</code>（常用）</li>
      <li><code class="language-plaintext highlighter-rouge">Simple</code>（不混合，只是用最近一个）</li>
    </ul>
  </li>
</ul>

<h5 id="additional-settings附加设置">Additional Settings（附加设置）</h5>
<p><strong>Motion Vectors</strong></p>
<ul>
  <li>控制是否为该物体生成运动矢量（供后处理如动态模糊使用）</li>
  <li>推荐开启：<code class="language-plaintext highlighter-rouge">Per Object Motion</code></li>
</ul>

<p><strong>Lightmap Static</strong></p>
<ul>
  <li>如果你将对象标记为静态，会自动启用Lightmap烘焙支持</li>
  <li>静态光照适用于不动的建筑、地面等</li>
</ul>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Renderer" /><category term="Graphic" /><summary type="html"><![CDATA[Unity中的Mesh（网格）是一切3D模型、地形、角色、道具、甚至某些UI元素的几何基础，是“物体的骨架” 包含顶点、面、法线、UV、颜色等数据，是3D图形渲染的核心单位]]></summary></entry><entry><title type="html">Probability and Randomness in Games</title><link href="http://localhost:4000/posts/2025-07-21-Probability-and-Randomness-in-Games/" rel="alternate" type="text/html" title="Probability and Randomness in Games" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Probability-and-Randomness-in-Games</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-21-Probability-and-Randomness-in-Games/"><![CDATA[<p>概率和随机是紧密相关的概念，它们常用于决定事件的发生与结果；在大多数游戏中，概率和随机数的使用涉及到随机事件的模拟，例如：</p>
<ul>
  <li>伤害计算</li>
  <li>随机事件发生</li>
  <li>物品掉落</li>
  <li>Rouge Like</li>
  <li>抽牌，掷骰子</li>
  <li>AI决策和行为树</li>
  <li>Slots</li>
  <li>装备合成或转化</li>
  <li>Mystery Box Like</li>
  <li>物理模拟和碰撞检测</li>
</ul>

<p>它们的发生的概率是相等或不等的，数值是随机的或伪随机的</p>

<p>随机和概率在非强竞技场景下的应用非常广泛，或增加了游戏性、或提高了游戏性能、或旨在提升玩家游戏时长、或旨在增加游戏营收，由此产生的效益和收益无疑是巨大的</p>

<p>从游戏实现到数值设计，从具体实现到哲学抽象</p>

<h2 id="概率与随机的定义">概率与随机的定义</h2>
<ul>
  <li><strong>概率</strong>是一种数学概念，指的是某件事情发生的可能性，通常用0到1之间的数字表示
    <ul>
      <li>P = 0：事件不可能发生</li>
      <li>P = 1：事件一定会发生</li>
      <li>P = 0.5：事件发生和不发生的概率相同</li>
    </ul>
  </li>
  <li><strong>随机</strong>是指一种无法确定的行为或过程，结果是不可预测的，但概率可以帮助对其结果进行量化和描述</li>
</ul>

<h2 id="具体实现">具体实现</h2>
<p>游戏中概率的实现方式通常取决于具体需求，以下是常见的几种实现</p>

<h3 id="随机数生成器random-number-generator-rng">随机数生成器（Random Number Generator, RNG）</h3>
<p>这是最常见的做法，通过随机数来模拟概率事件，可以用来生成各种各样的结果，如掉落物品、敌人AI行为、事件触发等</p>
<ul>
  <li>均匀分布（Uniform Distribution）
对于简单的概率，可以通过生成一个范围内的随机数，判断其是否满足概率条件
例如，假设在0~1之间生成一个随机数<code class="language-plaintext highlighter-rouge">r</code>，并且下那个要这个事件发生的概率为<code class="language-plaintext highlighter-rouge">P</code>，则
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">r</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">P</span> <span class="p">=</span> <span class="m">0.7f</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="p">&lt;=</span> <span class="n">P</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 事件发生</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>这样，当<code class="language-plaintext highlighter-rouge">r</code>小于<code class="language-plaintext highlighter-rouge">P</code>时，事件就会发生，发生的概率是<code class="language-plaintext highlighter-rouge">P</code></p>
  </li>
  <li>
    <p>正态分布（Normal Distribution）
如果需要模拟像物理系统、敌人行为等更复杂的概率，可以使用更复杂的分布来模拟</p>

    <p>比如正态分布可以用来模拟某些变量在某个中心值附近波动的情况，例如敌人的伤害、成绩、健康指标</p>

    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">mean</span> <span class="p">=</span> <span class="m">50f</span><span class="p">;</span> <span class="c1">// 均值</span>
<span class="kt">float</span> <span class="n">stdDev</span> <span class="p">=</span> <span class="m">10f</span><span class="p">;</span> <span class="c1">// 标准差</span>
<span class="kt">float</span> <span class="n">randomValue</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Clamp</span><span class="p">(</span><span class="nf">RandomNormal</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">stdDev</span><span class="p">),</span> <span class="m">0f</span><span class="p">,</span> <span class="m">100f</span><span class="p">);</span> <span class="c1">// 生成随机值，区间[0, 100]，Mathf.Clamp为区间限制</span>

<span class="kt">float</span> <span class="nf">RandomNormal</span><span class="p">(</span><span class="kt">float</span> <span class="n">mean</span><span class="p">,</span> <span class="kt">float</span> <span class="n">stdDev</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">float</span> <span class="n">u1</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">u2</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">z0</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(-</span><span class="m">2f</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">u1</span><span class="p">))</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Cos</span><span class="p">(</span><span class="m">2f</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">PI</span> <span class="p">*</span> <span class="n">u2</span><span class="p">);</span> <span class="c1">// Box-Muller变换：这是一种通过两个均匀分布的随机数来生成标准正态分布（均值为0， 标准差为1）的随机数方法</span>
  <span class="k">return</span> <span class="n">mean</span> <span class="p">+</span> <span class="n">z0</span> <span class="p">*</span> <span class="n">stdDev</span><span class="p">;</span> <span class="c1">// 将z0转换为具有给定均值和标准差的正态分布随机数</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>Box-Muller变换公式：$z_0=\sqrt{-2\cdot\ln(u_1)}\cdot\cos(2\cdot\pi\cdot u_2)$</p>
  </li>
  <li>泊松分布（Possion Distribution）
泊松分布是一个用于描述单位时间或单位区域内随机事件发生次数的概率分布，特别适用于那些事件独立且发生频率较低的场合</li>
</ul>

<p>泊松分布概率质量函数（PMF）：$P(k,\lambda)=\frac{\lambda^k\cdot e^{-\lambda}}{k!}$</p>

<p>其中：</p>
<ul>
  <li>k是事件发生的次数（非负整数）</li>
  <li>λ是单位时间或单位区域内的平均事件发生次数（称为泊松分布的参数）</li>
  <li>e是自然对数底数</li>
</ul>

<p>泊松分布常用于模拟稀有事件，比如在一个时间段内生成一个非常小概率的事件（例如，掉落西游物品）。这种情况比较少见，但在模拟游戏中的“稀有事件”时很有用</p>

<p>应用场景：生成爆发性事件，比如在某个特定条件下掉落非常稀有的物品</p>

<p><strong>泊松分布的随机数生成</strong></p>

<p>为了生成符合泊松分布的随机数，可以使用<strong>逆变换抽样法</strong></p>
<ul>
  <li>首先生成一个均匀分布的随机数u∈[0,1)</li>
  <li>然后通过求和方式生成符合泊松分布的随机数</li>
</ul>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 生成符合泊松分布的随机数</span>
<span class="kt">int</span> <span class="nf">GeneratePoissonRandom</span><span class="p">(</span><span class="kt">double</span> <span class="n">lambda</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 使用逆变换抽样法来生成泊松分布的随机数</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">L</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Exp</span><span class="p">(-</span><span class="n">lambda</span><span class="p">);</span> <span class="c1">// e^(-λ)</span>
    <span class="kt">double</span> <span class="n">p</span> <span class="p">=</span> <span class="m">1.0</span><span class="p">;</span> <span class="c1">// 初始值</span>
    <span class="kt">double</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0.0</span><span class="p">;</span>

    <span class="c1">// 循环直到累积的概率小于L</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span> <span class="p">&gt;</span> <span class="n">L</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">++</span><span class="n">k</span><span class="p">;</span>
        <span class="n">p</span> <span class="p">*=</span> <span class="n">Random</span><span class="p">.</span><span class="n">Shared</span><span class="p">.</span><span class="nf">NextDouble</span><span class="p">();</span> <span class="c1">// 生成[0, 1)之间的随机数</span>
        <span class="n">sum</span> <span class="p">+=</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">k</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span> <span class="c1">// 返回事件发生的次数</span>
<span class="p">}</span>
</code></pre></div></div>
<p>解释：</p>
<ol>
  <li>生成泊松分布的随机数：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">lambda</code>是泊松分布的参数，表示单位时间或单位区域内平均时间发生次数</li>
      <li>通过计算 $e^{-λ}$ 得到<code class="language-plaintext highlighter-rouge">L</code>，然后生成一个随机数<code class="language-plaintext highlighter-rouge">p</code>，并将它与<code class="language-plaintext highlighter-rouge">L</code>进行比较</li>
      <li>在<code class="language-plaintext highlighter-rouge">p</code>大于<code class="language-plaintext highlighter-rouge">L</code>的情况下，继续累积随机数并增加事件发生次数<code class="language-plaintext highlighter-rouge">k</code>。直到<code class="language-plaintext highlighter-rouge">p</code>小于<code class="language-plaintext highlighter-rouge">L</code>，返回事件发生次数</li>
    </ul>
  </li>
  <li>逆变换法：
    <ul>
      <li>通过不断生成随机数并进行乘积，直到满足某些条件来生成符合泊松分布的随机数，这个过程通常使用累积概率的方式来进行</li>
    </ul>
  </li>
</ol>

<h3 id="加权概率">加权概率</h3>
<p>如果想给不同的事件分配不同的发生概率，可以使用加权概率</p>

<p>这常用于掉落系统、选择不同的路径、敌人AI决策等</p>

<p>举例：</p>

<p>假设有四个掉落物品和它们掉落的概率分别是：</p>
<ul>
  <li>A：50%</li>
  <li>B：30%</li>
  <li>C：15%</li>
  <li>D：5%</li>
</ul>

<p>可以将这些概率转化为权重</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="p">[]</span> <span class="n">weights</span> <span class="p">=</span> <span class="p">{</span><span class="m">50</span><span class="p">,</span> <span class="m">30</span><span class="p">,</span> <span class="m">15</span><span class="p">,</span> <span class="m">5</span><span class="p">};</span> <span class="c1">// 权重数组</span>
<span class="kt">int</span> <span class="n">totalWeight</span> <span class="p">=</span> <span class="n">weights</span><span class="p">.</span><span class="nf">Sum</span><span class="p">();</span> <span class="c1">// 权重总和</span>
<span class="kt">int</span> <span class="n">randomValue</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">totalWeight</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">chosenItemIndex</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">weightSum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

<span class="c1">// 根据随机值选择物品</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">weights</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">weightSum</span> <span class="p">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">randomValue</span> <span class="p">&lt;</span> <span class="n">weightSum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">chosenItemIndex</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这样，便可以根据权重控制概率的分布</p>

<h3 id="事件驱动状态机">事件驱动（状态机）</h3>
<p>在一些复杂的游戏中，可能不仅仅是通过概率来决定事件的发生，还需要多重条件和事件的交互。</p>

<p>例如，AI行为可能需要根据玩家的行为，敌人血量等多重因素来随机选择。</p>

<p>可以使用类似状态机的结构，根据多个条件来触发不同的概率事件。</p>

<h3 id="表格查找">表格查找</h3>
<p>通过查找一个概率表或曲线来返回结果，这在特定场景下非常有用</p>

<p>例如玩家经验值的增长可以通过查表来确定每个经验值段的增长概率</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="n">experienceTable</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">0.2f</span><span class="p">},</span>
    <span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">},</span>
    <span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">0.3f</span><span class="p">},</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">level</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">)</span> <span class="p">&lt;</span> <span class="n">experienceTable</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
<span class="p">{</span>
    <span class="c1">// 根据经验表，玩家升到下一等级</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="伪随机与真随机">伪随机与真随机</h3>
<p>游戏中通常使用的是伪随机数生成器（PRNG），它通过算法生成看似随机的数字，但实际上是可能预测的（如果知道种子）。对于一些安全性要求较高的情况，可能会使用真随机数生成器（例如利用系统时间、硬件噪声等）</p>

<h4 id="伪随机数pseudo-random-number">伪随机数（Pseudo-Random Number）</h4>
<p>伪随机数是通过某种算法从一个初始值（称为种子）生成的看似随机的数。虽然生成的数值分布和真正的随机数非常相似，但它们是可预测的，只要知道了生成过程的算法和种子值，理论上就可以预测后续的随机数</p>

<h5 id="生成方式">生成方式</h5>
<p>伪随机数生成器（PRNG）通常依赖于一个数学公式（或递归关系）来计算每个随机数。最常见的PRNG算法是<strong>线性同余法（Linear Congruential Generator, LCG）</strong> 和 <strong>梅森旋转算法（Mersenne Twister）</strong></p>

<p>例如，梅森旋转算法（Mersenne Twister）是一个非常流行的伪随机数生成器，它提供了均匀分布的高质量随机数，并且有非常长的周期（大约2^32 - 1次生成）</p>

<h5 id="特点">特点</h5>
<ul>
  <li>确定性：伪随机数的生成是基于种子值的，因此它是可预测的，只要知道种子和算法，就能预测所有生成的数值</li>
  <li>高效：伪随机数生成器的计算过程是非常高效的，通常不需要额外的硬件支持</li>
  <li>周期性：伪随机数有一个固定的周期，过了这个周期，它会重复</li>
</ul>

<h5 id="应用">应用</h5>
<ul>
  <li>游戏开发：伪随机数用于游戏中的随机事件生成（如物品掉落、战斗伤害等）</li>
  <li>模拟与建模：如蒙特卡洛模拟、物理模拟等</li>
  <li>加密：虽然伪随机数是可以预测的，但在某些加密算法中，伪随机数可以用于生成密钥等，前提是它们要足够难以预测</li>
</ul>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用种子初始化伪随机数生成器</span>
<span class="n">System</span><span class="p">.</span><span class="n">Random</span> <span class="n">rng</span> <span class="p">=</span> <span class="k">new</span> <span class="n">System</span><span class="p">.</span><span class="nf">Random</span><span class="p">(</span><span class="m">12345</span><span class="p">);</span> <span class="c1">// 种子为12345</span>
<span class="kt">int</span> <span class="n">randomNumber</span> <span class="p">=</span> <span class="n">rng</span><span class="p">.</span><span class="nf">Next</span><span class="p">();</span>
</code></pre></div></div>

<h4 id="真随机数true-random-numbers">真随机数（True Random Numbers）</h4>
<p>真随机数是通过物理过程产生的随机数，而非通过算法计算。它们的生成依赖于某种物理现象（例如电子噪声、放射性衰变等），这些现象的结果是完全不可预测的，具有完全的随机性</p>

<h5 id="生成方式-1">生成方式</h5>
<p>真随机数通常是由硬件随机数生成器（HRNG）生成。这些生成器通过测量物理现象（如热噪声、光子的运动等）来产生随机数。常见的硬件随机数生成器有基于噪声的电路、光子计数器等。</p>

<p>例如，Intel的RDRAND指令可以通过硬件生成真随机数，或者一些第三方硬件设备也可以用来生成真随机数</p>

<h5 id="特点-1">特点</h5>
<ul>
  <li>完全不可预测</li>
  <li>慢速</li>
  <li>无周期性</li>
</ul>

<h5 id="应用-1">应用</h5>
<ul>
  <li>加密：在安全性要求较高的应用中，真随机数被用来生成加密密钥、初始化向量（IV）等，确保密码学算法的安全性</li>
  <li>科学实验：如量子随机数生成等领域，真随机数可用于保证实验的完全随机性</li>
  <li>高度安全应用：如数字签名、身份验证和区块链技术中的随机数</li>
</ul>

<p>有些平台提供硬件支持来生成真随机数，例如Intel的RDRAND指令，或者使用操作系统提供的随机源（如<code class="language-plaintext highlighter-rouge">/dev/random</code>）</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C语言示例：从/dev/random读取真随机数</span>
<span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"/dev/random"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rand_num</span><span class="p">;</span>
<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rand_num</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rand_num</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="蒙特卡洛方法模拟连续概率事件">蒙特卡洛方法模拟连续概率事件</h3>
<p>有些游戏可能需要连续的概率事件，而不仅仅是一次性判定。比如，在模拟物理系统、模拟经济系统等复杂系统中，连续的事件可能会影响最终的概率结果</p>

<p>蒙特卡洛方法（Monte Carlo Method）是一类基于随机数的数值计算方法，通过模拟随机样本来解决数学问题，特别是那些难以通过传统解析方法解决的问题。它得名于摩纳哥的蒙特卡洛赌场，因为这种方法的核心思想与赌博中的随机性相似——依赖于大量的随机抽样来推测最终结果。</p>

<h4 id="基本概念">基本概念</h4>
<p>蒙特卡洛方法通过生成大量的随机数来模拟系统的行为，并通过这些随机样本来估计一个复杂系统的结果或计算一个数学问题的近似解。它尤其适用于求解那些具有复杂概率模型或多维积分的问题。</p>

<h4 id="应用场景">应用场景</h4>
<p>蒙特卡洛方法可以应用于很多领域，特别是那些无法通过简单解析解法解决的问题。常见的应用包括：</p>
<ul>
  <li>数值积分：特别是高维积分</li>
  <li>优化问题：例如最小化或最大化某个目标函数</li>
  <li>物理模拟：如粒子模拟、统计物理</li>
  <li>金融工程：如期权定价、风险分析</li>
  <li>机器学习：如贝叶斯推理、Markov Chain Monte Carlo (MCMC) 方法</li>
</ul>

<h4 id="蒙特卡洛方法的基本步骤">蒙特卡洛方法的基本步骤</h4>
<ol>
  <li>定义问题：首先明确想要解决的问题，通常是计算某个期望值、概率、积分等</li>
  <li>随机采样：根据问题的定义，随机生成一组输入样本。这些样本可以来自一个已知的概率分布或均匀分布</li>
  <li>评估样本：对每个样本计算相应的函数值（或其他相关量）</li>
  <li>求取统计量：对所有样本的结果进行统计分析，通常是求取平均值、方差等统计量</li>
  <li>结果估计：根据样本的统计量来估计问题的解</li>
</ol>

<h4 id="应用实例">应用实例</h4>
<p><strong>示例1：估计圆周率（π）</strong></p>

<p>最经典的蒙特卡洛方法之一是通过随机点来估计圆周率（π）。可以将一个单位正方形放入单位圆内，然后随机生成一些点，计算这些点落在圆内的比例。</p>

<p>步骤：</p>
<ol>
  <li>随机生成一些点<code class="language-plaintext highlighter-rouge">(x, y)</code>，其中<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>的取值范围为[0, 1]</li>
  <li>判断每个点是否落在单位圆内：即检查<code class="language-plaintext highlighter-rouge">x^2 + y^2 &lt;= 1</code></li>
  <li>计算落在圆内的点的比例，乘以4就是π的近似值</li>
</ol>

<p>数学推导：<br />
单位元的面积是<code class="language-plaintext highlighter-rouge">π * r ^ 2</code>，而正方形的面积是<code class="language-plaintext highlighter-rouge">1 * 1 = 1</code>，所以落在圆内的点的比例大约是<code class="language-plaintext highlighter-rouge">π / 4</code></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C#</span>
<span class="kt">int</span> <span class="n">totalPoints</span> <span class="p">=</span> <span class="m">1000000</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">pointsInsideCircle</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">totalPoints</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">x</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">y</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">*</span> <span class="n">x</span> <span class="p">+</span> <span class="n">y</span> <span class="p">*</span> <span class="n">y</span> <span class="p">&lt;=</span> <span class="m">1</span><span class="p">)</span> <span class="p">++</span> <span class="n">pointsInsideCircle</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">piEstimate</span> <span class="p">=</span> <span class="m">4</span> <span class="p">*</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">pointsInsideCircle</span> <span class="p">/</span> <span class="n">totalPoints</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>示例2：估算积分</strong>
估算函数<code class="language-plaintext highlighter-rouge">f(x) = x ^ 2</code>在区间<code class="language-plaintext highlighter-rouge">[0, 1]</code>上的定积分</p>

<p>步骤：</p>
<ol>
  <li>随机生成<code class="language-plaintext highlighter-rouge">N</code>个<code class="language-plaintext highlighter-rouge">x</code>值，范围是<code class="language-plaintext highlighter-rouge">[0, 1]</code></li>
  <li>对于每个<code class="language-plaintext highlighter-rouge">x</code>，计算<code class="language-plaintext highlighter-rouge">f(x) = x ^ 2</code>的值</li>
  <li>求所有<code class="language-plaintext highlighter-rouge">f(x)</code>的平均值，并乘以区间长度</li>
</ol>

<p>数学推导：<br />
积分的近似值就是<code class="language-plaintext highlighter-rouge">f(x)</code>的平均值乘以区间长度</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C#</span>
<span class="kt">int</span> <span class="n">totalSamples</span> <span class="p">=</span> <span class="m">1000000</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">totalSample</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">x</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>
    <span class="n">sum</span> <span class="p">+=</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="n">integralEstimate</span> <span class="p">=</span> <span class="n">sum</span> <span class="p">/</span> <span class="n">totalSamples</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="蒙特卡洛方法的优缺点">蒙特卡洛方法的优缺点</h4>
<p>优点：</p>
<ul>
  <li>适用性广泛：可以处理各种复杂的、高维度的、概率性的数学问题，尤其是解析解难以获得时</li>
  <li>简单易实现：不需要数学推导</li>
  <li>并行计算：蒙特卡洛方法中的样本生成和评估通常是独立的，因此可以很容易地并行化，适合现代多核处理器</li>
</ul>

<p>缺点：</p>
<ul>
  <li>精度较低：近似解，样本数量和计算成本成反比，和计算精度成正比</li>
  <li>计算量大：尤其是在高维空间中，所需的样本数量增长非常快，导致计算量增加</li>
  <li>误差评估：在使用蒙特卡洛方法时，通常需要进行误差分析，估算所得到的结果的误差范围</li>
</ul>

<h4 id="蒙特卡洛方法的改进">蒙特卡洛方法的改进</h4>
<ul>
  <li>重要性抽样：在采样时，优先选择那些对结果贡献较大的区域，从而提高效率</li>
  <li>方差降低技术：如控制变量法和分层抽样，通过减少方差来加速收敛</li>
  <li>MCMC：用于高维空间的样本生成和推理，常用于统计学和机器学习中</li>
</ul>

<h4 id="蒙特卡洛方法在游戏中的应用">蒙特卡洛方法在游戏中的应用</h4>

<h2 id="哲学抽象">哲学抽象</h2>

<h3 id="随机性与平衡性">随机性与平衡性</h3>
<p>游戏中的随机性往往需要与游戏的平衡性进行协调。过高的随机性可能导致游戏体验的不稳定和不可预测，而过低的随机性则可能让游戏失去挑战性和趣味性。例如，在战斗系统中，伤害值可能会受到随机性影响，但在确保平衡的前提下，可以给玩家一定的“可预测性”来增加策略性</p>

<p>常见随机性问题：</p>
<ul>
  <li>冰箱效应：如果某个事件的概率过高或过低，玩家可能会觉得过于频繁或完全不可能发生</li>
  <li>冷却期：有时玩家可能觉得某些事件的触发过于随机，尤其是在有多个成功或失败条件的情况下。适当地调整“冷却期”或引入玩家操作的变量，能有效避免这种感觉</li>
</ul>

<h3 id="使用随机数种子">使用随机数种子</h3>
<p>为了避免“随机性”被完全掌控（比如在测试时），开发者可以人为设定随机数的种子，通过固定种子来保证结果的可复现性</p>

<h3 id="多人游戏中的随机性">多人游戏中的随机性</h3>
<p>在多人游戏中，同步随机性（例如，随机数的生成应该在所有玩家的客户端和服务器上同步）可能成为一个问题。为了保证公平性，通常会把随机数生成放在服务器端进行，并将结果同步到客户端</p>]]></content><author><name>ljf12825</name></author><category term="Game Principle" /><category term="Game" /><category term="Random" /><summary type="html"><![CDATA[概率和随机是紧密相关的概念，它们常用于决定事件的发生与结果；在大多数游戏中，概率和随机数的使用涉及到随机事件的模拟，例如： 伤害计算 随机事件发生 物品掉落 Rouge Like 抽牌，掷骰子 AI决策和行为树 Slots 装备合成或转化 Mystery Box Like 物理模拟和碰撞检测]]></summary></entry><entry><title type="html">Unity Packaging and Building</title><link href="http://localhost:4000/posts/2025-07-18-Unity-Packaging-and-Building/" rel="alternate" type="text/html" title="Unity Packaging and Building" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Unity-Packaging-and-Building</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-18-Unity-Packaging-and-Building/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Build" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Assets Import and Load</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Assets-Import-and-Load.html" rel="alternate" type="text/html" title="Assets Import and Load" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Assets-Import-and-Load</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Assets-Import-and-Load.html"><![CDATA[<p>如何将外部资源导入到Unity中并在运行时使用</p>

<h2 id="资源导入">资源导入</h2>
<p>资源导入是指Unity将外部资源文件（如.fbx、.png、.mp3等）转换为引擎可以使用的内部格式。导入过程不仅包括将资源放入Unity项目中，还涉及到Unity如何优化、压缩、管理这些资源</p>

<h3 id="资源导入的关键步骤">资源导入的关键步骤</h3>
<ul>
  <li>文件放置：在资源文件中放入Unity项目的<code class="language-plaintext highlighter-rouge">Assets</code>文件中。Unity会自动检测到这些文件，并开始导入流程</li>
  <li>导入设置：在Inspector面板中，选中资源文件后，可以看到不同类型资源的导入设置（如<code class="language-plaintext highlighter-rouge">Texture Type</code>、<code class="language-plaintext highlighter-rouge">Model Import Settings</code>等）。不同的资源类型有不同的设置，影响最终的导入结果
    <ul>
      <li>对于纹理，可以设置纹理的类型（如2D或Sprite），以及压缩选项（如DXT1、DXT5等）</li>
      <li>对于模型，可以设置模型的网格、骨骼、动画等导入选项</li>
      <li>对于音频，可以设置压缩类型、采样率等</li>
    </ul>
  </li>
  <li>资源优化：Unity会根据导入设置自动处理资源，可能会进行压缩、网格简化、生成多种LOD等优化操作</li>
  <li>Meta文件：Unity会为每个导入的资源创建一个<code class="language-plaintext highlighter-rouge">.meta</code>文件，用于保存资源的设置、ID等信息。这个文件对资源管理非常重要，尤其是在团队协作时，避免丢失资源链接</li>
</ul>

<h3 id="常见的资源类型导入">常见的资源类型导入</h3>
<ul>
  <li>
    <p>纹理（Texture）：Unity会自动识别常见的纹理文件类型，并提供压缩、过滤等选项
详见<a href="/posts/2025-06-29-Texture/">Texture 导入</a></p>
  </li>
  <li>
    <p>模型（Models）：Unity支持多种3D模型格式，尤其是<code class="language-plaintext highlighter-rouge">.fbx</code>，并支持自动生成碰撞体、网格和骨骼动画
详见<a href="/posts/2025-06-07-Model/">Model</a></p>
  </li>
  <li>
    <p>音频（Audio）：音频文件支持不同的压缩格式，可以设置为单声道、立体声等
详见<a href="/posts/2025-06-11-Audio-System/">Audio System</a></p>
  </li>
  <li>
    <p>动画（Animations）：可以通过<code class="language-plaintext highlighter-rouge">Animator</code>系统来管理和播放
详见<a href="/posts/2025-06-11-Animation-System/">Animation System</a></p>
  </li>
</ul>

<h2 id="资源加载">资源加载</h2>
<p>在游戏运行时，如何高效地加载和管理这些已经导入的资源至关重要，尤其是在需要加载大量资源时。Unity提供了多种加载资源的方式，以便优化性能和内存使用</p>

<h3 id="class-resources">class Resources</h3>
<p><code class="language-plaintext highlighter-rouge">Resources</code>类在Unity中提供了一种动态加载资产的方式，允许你访问存储在特定文件夹中的对象，如Texture，Prefab，Audio Clips等。这些文件必须存放在项目中名为“Resources”的文件夹内</p>

<h4 id="存放资产到resources文件夹">存放资产到Resources文件夹</h4>
<ul>
  <li>希望在运行时动态加载的所有资产必须存放在名为“Resources”的文件夹中。你可以在<code class="language-plaintext highlighter-rouge">Assets</code>目录下创建多个“Resources”文件夹</li>
  <li>存放在这些文件夹中的资产不会通过Inspector自动引用，因此Unity无法对它们进行优化，直接包含在最终构建中</li>
</ul>

<h4 id="加载方式">加载方式</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Resources.Load()</code>和<code class="language-plaintext highlighter-rouge">Resources.FindObjectsOfTypeAll()</code>函数可以用来加载和访问资产
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Resouces.Load()</code>：按路径加载单个资产</li>
      <li><code class="language-plaintext highlighter-rouge">Resouces.FindObjectsOfTypeAll()</code>：用于查找并访问场景中或<code class="language-plaintext highlighter-rouge">Resources</code>文件夹下的所有对象</li>
    </ul>
  </li>
  <li>使用路径加载资产时，所有存放在<code class="language-plaintext highlighter-rouge">Resources</code>文件夹中的资产会被纳入构建中，这可能导致构建大小增加</li>
</ul>

<h4 id="构建优化问题">构建优化问题</h4>
<p>通常，Unity 会通过 Inspector 曝露对资产的引用，这样在构建时它可以自动计算出哪些资产是实际使用的，从而避免不必要的资源被包含在最终构建中。但如果使用 <code class="language-plaintext highlighter-rouge">Resources</code> 文件夹，Unity 无法做到这一点，因此所有资产都会被包含在构建中，即使你没有使用它们</p>

<h4 id="不推荐过度使用路径加载">不推荐过度使用路径加载</h4>
<p>使用路径名来加载资产会导致代码不那么可复用，因为脚本会硬编码依赖于资产存放的位置。这不如通过Inspector暴露的引用直观和易于维护</p>

<h4 id="使用场景">使用场景</h4>
<p>在一些情况下，直接通过代码加载资产会更方便，特别是在你需要在运行时生成对象时。例如，程序化生成一个游戏物体并为其赋予纹理，或者加载动态生成的资源时，使用 Resources.Load() 会非常方便</p>

<h4 id="内存管理">内存管理</h4>
<p>使用 <code class="language-plaintext highlighter-rouge">Resources.Load()</code> 加载的资产，特别是纹理等资源，可能会占用内存，即使这些实例没有出现在场景中。为了释放内存，可以调用 <code class="language-plaintext highlighter-rouge">Resources.UnloadUnusedAssets()</code> 来卸载不再使用的资源。</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Resources</code>文件夹在创建项目时不会自动生成，需要手动创建这个文件夹才能使用</p>
</blockquote>

<h4 id="api">API</h4>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindObjectsOfTypeAll</code></td>
      <td>返回当前内存中所有指定类型 <code class="language-plaintext highlighter-rouge">T</code> 的对象列表。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstanceIDIsValid</code></td>
      <td>如果给定的实例 ID 对应一个有效的对象，则返回 <code class="language-plaintext highlighter-rouge">true</code>。该对象可能已经被删除或尚未加载到内存中。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstanceIDsToValidArray</code></td>
      <td>将实例 ID 数组转换为布尔数组，指示每个实例 ID 是否对应内存中的有效对象。对象可能已删除或未加载。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstanceIDToObject</code></td>
      <td>将实例 ID 转换为对象引用。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstanceIDToObjectList</code></td>
      <td>将实例 ID 数组转换为对象引用列表。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Load</code></td>
      <td>加载存储在 <code class="language-plaintext highlighter-rouge">Resources</code> 文件夹路径下的指定类型的资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAll</code></td>
      <td>加载 <code class="language-plaintext highlighter-rouge">Resources</code> 文件夹路径下的文件夹或文件中的所有资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAsync</code></td>
      <td>异步加载存储在 <code class="language-plaintext highlighter-rouge">Resources</code> 文件夹路径下的资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnloadAsset</code></td>
      <td>从内存中卸载指定的资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnloadUnusedAssets</code></td>
      <td>卸载未使用的资源，释放内存。</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.unity3d.com/ScriptReference/Resources.html">Unity Scripting Resources</a></p>

<h3 id="asset-bundles">Asset Bundles</h3>
<p>Asset Bundles是Unity的一个资源打包系统，允许开发者将游戏中的资源（如模型、纹理、音频等）打包成一个或多个独立的文件（称为Asset Bundles），以便按需加载。</p>

<p>这种方式适用于大规模资源的管理，尤其是当资源文件较大或需要动态加载时，Asset Bundles提供了比<code class="language-plaintext highlighter-rouge">Resources</code>文件夹更灵活的资源加载和内存管理方式</p>

<h4 id="asset-bundles的核心概念">Asset Bundles的核心概念</h4>
<ul>
  <li>打包：将游戏资源（如纹理、模型、音频等）打包成独立的文件，以便后期按需加载</li>
  <li>加载：通过代码加载Asset Bundles中的资源，而不是将所有资源一次性加载到内存中，从而优化内存使用和加载速度</li>
  <li>卸载：通过代码释放已加载的Asset Bundles资源，确保内存得到有效管理</li>
</ul>

<h4 id="创建asset-bundles">创建Asset Bundles</h4>
<p>创建Asset Bundles的过程涉及将资源打包成独立的文件，这些文件可以在运行时动态加载</p>

<p>打包资源步骤：</p>
<ol>
  <li>设置资源为Asset Bundle：
  在Unity编辑器中，选择资源（如纹理、模型、音频等），在<code class="language-plaintext highlighter-rouge">Inspector</code>面板中为资源分配一个Asset Bundles名称
    <ul>
      <li>在<code class="language-plaintext highlighter-rouge">Inspector</code>中的<code class="language-plaintext highlighter-rouge">Asset Bundle</code>选项设置中，给资源指定一个名字，例如：<code class="language-plaintext highlighter-rouge">MyBundle/Textures</code></li>
    </ul>
  </li>
  <li>构建Asset Bundles
  使用BuildPipeline API构建 Asset Bundles
  ```cs
  using UnityEditor;</li>
</ol>

<p>public class AssetBundleBuilder
  {
    [MenuItem(“Assets/Build Asset Bundles”)]
    static void BuildAllAssetBundles()
    {
      BuildPipeline.BuildAssetBundles(“Assets/AssetBundles”, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows);
    }
  }</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  这段代码会将所有标记为Asset Bundle的资源打包到`Assets/Bundles`目录中，并生成适用于Windows平台的Asset Bundle
    - `BuildAssetBundleOptionjs.None`：没有特殊选项，可以根据需要选择不同的选项（例如压缩、增量构建等）
    - `BuildTarget.StandaloneWindows`：指定构建目标平台，可以选择其他平台

3. 输出：
  构建后，Unity会在指定的目录中生成Asset Bundle文件

#### 加载Asset Bundles
在游戏运行时，可以通过以下方式加载和使用Asset Bundles

加载Asset Bundle：
加载Asset Bundle通常是异步的，避免阻塞主线程，保证游戏运行流畅
- 从文件系统加载Asset Bundle
  ```cs
  using UnityEngine;

  public class AssetBundleLoader : MonoBehaviour
  {
    AssetBundle myLoadedAssetBundle;

    void Start()
    {
      // 异步加载 Asset Bundle
      StartCoroutine(LoadAssetBundleAsync("Assets/AssetBundles/MyBundle"));
    }

    IEnumerator LoadAssetBundleAsync(string bundleUrl)
    {
      // 异步加载Asset Bundle
      AssetBundleCreateRequest bundleRequest = AssetBundle.LoadFromFileAsync(bundleUrl);
      yield return bundleRequest;

      myLoadedAssetBundle = bundleRequest.assetBundle;
      if (myLoadedAssetBundle == null)
      {
        Debug.LogError("Failed to load AssetBundle!");
        yield break;
      }

      // 加载资源
      AssetBundleRequest assetRequest = myLoadedAssetBundle.LoadAssetAsync&lt;Texture&gt;("MyTextrue");
      yield reutrn assetRequest;

      Texture texture = assetRequest.asset as Texture;
      // 使用加载的资源

    }
  }
</code></pre></div></div>

<ul>
  <li>从URL加载Asset Bundle（适用于远程资源）
  如果Asset Bundle存储在远程服务器上，可以使用<code class="language-plaintext highlighter-rouge">UnityWebRequest</code>从URL加载资源
  ```cs
  using UnityEngine;
  using UnityEngine.Networking;</li>
</ul>

<p>public class AssetBundleRemoteLoader : MonoBehaviour
  {
    AssetBundle myLoadedAssetBundle;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void Start()
{
  StartCoroutine(LoadAssetBundleFromURL("http://mycdn.com/assets/MyBundle"));
}

IEnumerator LoadAssetBundleFromURL(string url)
{
  UnityWebRequest www = UnityWebRequestAssetBundle.GetAssetBundle(url);
  yield return www.SendWebRequest();

  if (www.result != UnityWebRequest.Result.Success)
  {
    Debug.LogError("Failed to load AssetBundle from URL!");
    yield break;
  }

  myLoadedAssetBundle = DownloadHandlerAssetBundle.GetContent(www);
  AssetBundleRequest assetRequest = myLoadedAssetBundle.LoadAssetAsync&lt;Texture&gt;("MyTexture");
  yield return assetRequest;

  Texture texture = assetRequest.asset as Texture;
  // 使用加载的资源

}   }   ```
</code></pre></div></div>

<ul>
  <li>加载资源：通过<code class="language-plaintext highlighter-rouge">LoadAssetAsync()</code>或<code class="language-plaintext highlighter-rouge">LoadAsset()</code>方法加载Asset Bundle中的资源， <code class="language-plaintext highlighter-rouge">LoadAssetAsync()</code>更适合异步加载，可以避免阻塞主线程</li>
</ul>

<h4 id="卸载asset-bundle">卸载Asset Bundle</h4>
<p>加载后的Asset Bundle和资源可以通过<code class="language-plaintext highlighter-rouge">Unload()</code>方法释放，以防止内存泄露</p>
<ul>
  <li>卸载资源和Asset Bundle
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myLoadAssetBundle</span><span class="p">.</span><span class="nf">Unload</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
</code></pre></div>    </div>
    <p><code class="language-plaintext highlighter-rouge">false</code>参数意味着只卸载Asset Bundle，不会卸载已经加载的资源。如果设置为<code class="language-plaintext highlighter-rouge">true</code>，则会卸载资源和Asset Bundle</p>
  </li>
</ul>

<h4 id="asset-bundle的优点和缺点">Asset Bundle的优点和缺点</h4>
<p>优点：</p>
<ol>
  <li>按需加载：Asset Bundles 允许你将资源分离成不同的包，并且按需加载，这减少了内存的占用，并提高了加载速度。</li>
  <li>资源分组和优化：你可以将资源按类型或加载频率进行分组（例如，UI 资源、场景资源、远程资源），并根据需要加载，提高游戏性能。</li>
  <li>远程资源加载：Asset Bundles 支持从远程服务器加载资源，非常适合动态内容更新、DLC（可下载内容）和游戏数据包的分发。</li>
  <li>平台兼容性：你可以为不同的平台（Windows、Android、iOS）构建不同的 Asset Bundle，确保在不同平台上使用合适的资源格式。</li>
</ol>

<p>缺点：</p>
<ol>
  <li>管理复杂：随着游戏项目变得越来越大，Asset Bundles 的管理和维护可能变得更加复杂。你需要合理分配资源、管理多个 Asset Bundle、确保版本一致性等。</li>
  <li>版本控制：由于 Asset Bundles 是外部资源包，Unity 并不直接将它们与项目文件一起进行版本控制。你需要单独管理 Asset Bundles 的版本和依赖关系。</li>
  <li>构建时间：Asset Bundles 构建过程可能需要一些时间，尤其是当项目包含大量资源时。</li>
  <li>缓存管理：在远程加载资源时，可能会遇到缓存问题，需要合理设置 CDN 或服务器端的缓存策略，确保资源的最新版本被加载。</li>
</ol>

<h4 id="api-1">API</h4>
<p><strong>Static Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">memoryBudgetKB</code></td>
      <td>控制共享的 AssetBundle 加载缓存的大小，默认值为 1MB。</td>
    </tr>
  </tbody>
</table>

<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isStreamedSceneAssetBundle</code></td>
      <td>如果 AssetBundle 包含 Unity 场景文件，则返回 <code class="language-plaintext highlighter-rouge">true</code>。</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Contains</code></td>
      <td>检查 AssetBundle 是否包含特定的对象。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetAllAssetNames</code></td>
      <td>返回 AssetBundle 中所有资源的名称。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetAllScenePaths</code></td>
      <td>返回 AssetBundle 中所有场景的路径。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAllAssets</code></td>
      <td>同步加载 AssetBundle 中包含的所有资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAllAssetsAsync</code></td>
      <td>异步加载 AssetBundle 中包含的所有资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAsset</code></td>
      <td>同步加载 AssetBundle 中的某个资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAssetAsync</code></td>
      <td>异步加载 AssetBundle 中的某个资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAssetWithSubAssets</code></td>
      <td>同步加载 AssetBundle 中的资源及其子资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAssetWithSubAssetsAsync</code></td>
      <td>异步加载 AssetBundle 中的资源及其子资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Unload</code></td>
      <td>卸载 AssetBundle，释放其占用的数据。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnloadAsync</code></td>
      <td>异步卸载 AssetBundle 中的资源。</td>
    </tr>
  </tbody>
</table>

<p><strong>Static Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetAllLoadedAssetBundles</code></td>
      <td>获取当前所有已加载的 AssetBundle 的枚举。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromFile</code></td>
      <td>从磁盘文件同步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromFileAsync</code></td>
      <td>从磁盘文件异步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromMemory</code></td>
      <td>从内存区域同步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromMemoryAsync</code></td>
      <td>从内存区域异步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromStream</code></td>
      <td>从托管流同步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromStreamAsync</code></td>
      <td>从托管流异步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">RecompressAssetBundleAsync</code></td>
      <td>异步将下载或存储的 AssetBundle 从一个构建压缩格式重新压缩到另一个。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnloadAllAssetBundles</code></td>
      <td>卸载所有当前加载的 AssetBundle。</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.html">Unity Scripting AssetBundle</a></p>

<h3 id="addressable-assets-system">Addressable Assets System</h3>
<p>这是Unity推荐的现代资源加载方式，通过Addressable Asset System，开发者可以将资源分组并动态加载，支持远程加载资源包，极大地提升了资源管理的灵活性和性能</p>

<h4 id="简介">简介</h4>
<p>Addressable Asset System允许开发者通过地址使用资产，一旦一个资产被标记为“addressable”，它便生成一个地址，可以在任何地方被调用；无论这个资产是在本地或远程，系统都会定位它和它的依赖，然后返回它</p>

<p>通过<code class="language-plaintext highlighter-rouge">Windows-&gt;Asset Management-&gt;Addressables</code>使用地址资源系统</p>

<p>Addressables使用异步加载技术，支持从任意位置加载任意依赖项集合。无论是使用直接引用、传统Asset Bundle还是Resources文件夹，Addressables都可以提供一种更简便的方法</p>

<p><a href="/posts/2025-06-05-Addressables/">Addressables</a></p>

<h2 id="资源卸载">资源卸载</h2>
<p>资源加载后，不及时释放也可能导致内存泄露</p>

<h2 id="资源优化">资源优化</h2>
<p>为了优化资源的加载与使用，Unity有多种工具和策略</p>
<ul>
  <li>Asset Bundles：Unity提供的Asset Bundles可以将资源打包成一个文件，支持按需加载，适合于游戏内容更新或者大规模的资源管理</li>
  <li>内存管理：Unity的内存管理非常关键，尤其是在移动设备或者内存受限的设备上。通过精确的资源加载和卸载策略，可以避免内存占用过多</li>
</ul>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Asset" /><summary type="html"><![CDATA[如何将外部资源导入到Unity中并在运行时使用]]></summary></entry><entry><title type="html">Object</title><link href="http://localhost:4000/posts/2025-07-11-Object/" rel="alternate" type="text/html" title="Object" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Object</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-11-Object/"><![CDATA[<p>Object是Unity中所有内建物体的基类，实现在UnityEngine.CoreModule中，不同于C#中的<code class="language-plaintext highlighter-rouge">System.Object</code>，它是托管层（C#）和原生引擎层（C++）之间的桥梁，背后绑定着Unity C++引擎层的资源句柄</p>

<h2 id="object的特点unity的特有行为">Object的特点（Unity的特有行为）</h2>
<p><strong>引擎资源的绑定</strong></p>

<p>每个<code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>对象都对应一个C++层对象，它们通过一个<code class="language-plaintext highlighter-rouge">instance 2D</code>来关联，且资源的生命周期不由GC管理</p>

<p>比如：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">go</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">();</span>
<span class="n">Object</span><span class="p">.</span><span class="nf">Destroy</span><span class="p">(</span><span class="n">go</span><span class="p">);</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span> <span class="p">==</span> <span class="k">null</span><span class="p">);</span>  <span class="c1">// true</span>
</code></pre></div></div>
<p>这就是Object的“鬼行为”，此处的<code class="language-plaintext highlighter-rouge">go == null</code>并非等价于<code class="language-plaintext highlighter-rouge">object is null</code></p>

<p><strong>Unity的“fake null”机制</strong>
<code class="language-plaintext highlighter-rouge">fake null</code>是Unity中一个特有的概念，通常用来描述已经销毁的对象或者已经不再有效的对象的引用。尽管对象被销毁了，但它仍然存在一个“假”引用，这个引用就像是一个假的<code class="language-plaintext highlighter-rouge">null</code>，它指向的对象实际上已经不再有效，但在代码层面看起来却任然是一个对象。具体来说，<code class="language-plaintext highlighter-rouge">fake null</code>让你能够获得一个对象引用，但该对象的属性和方法无法被正常访问，或者会返回默认值，或者不会产生期望的结果</p>

<p>Unity重写了<code class="language-plaintext highlighter-rouge">==</code>操作符</p>

<p>如果一个<code class="language-plaintext highlighter-rouge">Object</code>对象在引擎层已经被销毁（Destroy过），但C#还保有托管引用，这时候：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span> <span class="p">==</span> <span class="k">null</span><span class="p">);</span> <span class="c1">// true</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="k">null</span><span class="p">));</span> <span class="c1">// false</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="nf">ReferenceEquals</span><span class="p">(</span><span class="n">go</span><span class="p">,</span> <span class="k">null</span><span class="p">));</span> <span class="c1">// false</span>
</code></pre></div></div>

<p>为什么需要fake null</p>
<ol>
  <li>
    <p>避免NullReferenceException
在传统的编程中，如果一个对象被销毁或设为<code class="language-plaintext highlighter-rouge">null</code>，而你还试图访问它的属性或方法，就会引发<code class="language-plaintext highlighter-rouge">NullReferenceException</code>错误。在Unity中，许多对象的销毁并不立即释放内存，尤其是当销毁了一个游戏对象或组件时。为了避免频繁的<code class="language-plaintext highlighter-rouge">null</code>检查和避免程序崩溃，Unity引入了<code class="language-plaintext highlighter-rouge">fake null</code></p>
  </li>
  <li>
    <p>内存管理的优化
Unity并不是立即销毁对象，而是将其“标记”为无效，保持它的引用存在，但无法访问。这使得Unity可以更高效地管理内存。内存的实际释放通常依赖于垃圾回收器，而不是对象销毁后立即释放内存，从而避免频繁的内存分配和释放造成的性能瓶颈</p>
  </li>
</ol>

<p><code class="language-plaintext highlighter-rouge">fake null</code>行为总结</p>
<ol>
  <li>引用存在，但对象无效</li>
  <li>不抛出异常</li>
  <li>确保内存管理不会立即释放内存</li>
</ol>

<h3 id="底层原理">底层原理</h3>
<p>Unity的<code class="language-plaintext highlighter-rouge">Object</code>在C#层其实只是一个代理，它对应的C++引擎层对象通过C#层的<code class="language-plaintext highlighter-rouge">IntPtr m_CachedPtr</code>与C++对象通信（该字段可以在反编译时看到）</p>

<p>资源对象（比如一个贴图）在编译器导入时会被转换为native object，保存在场景或资源文件中，加载时通过Unity自己的反序列化系统生成C#代理对象，并挂接<code class="language-plaintext highlighter-rouge">m_CachedPtr</code></p>

<p>Unity会使用C++引擎进行资源生命周期的管理，而不是C#的GC，所以Destroy调的是C++的释放接口</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sometimes an instance of Object can be in detached state, where there is no underlying native object. T
his can happen if the instance references an native object that has been destroyed, or a missing Asset or missing type. 
Detached objects retain their InstanceID, but the object cannot be used to call methods or access properties. 
An object in this state will appear to be null, because of special implementations of operator==, operator!= and Ojbect.bool.
Because the object is not truly null, a call to Object.ReferenceEquals(myobject, null) will return false.

The null-comditional operator(?.)and the null-coalescing operator(??)are not supported with Unity Object because they cannot be overridden to treat detached objects the same as null.
It is only safe to use those operators in your scripts if there is certainty that the objects being checked are never in a detached state.
</code></pre></div></div>

<h2 id="object-api">Object API</h2>
<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">name</code></td>
      <td><code class="language-plaintext highlighter-rouge">string</code></td>
      <td>对象名称（可读写）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hideFlags</code></td>
      <td><code class="language-plaintext highlighter-rouge">HideFlags</code></td>
      <td>控制对象是否可隐藏/可编辑/保存</td>
    </tr>
  </tbody>
</table>

<p><strong><code class="language-plaintext highlighter-rouge">hideFlags</code></strong><br />
常见用途：</p>
<ul>
  <li>隐藏对象</li>
  <li>防止误删或编辑</li>
  <li>不让对象随着场景保存（通常用于运行时生成的对象）</li>
</ul>

<p>常用枚举值</p>

<table>
  <thead>
    <tr>
      <th>枚举值</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.None</code></td>
      <td>默认行为，无隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideInHierarchy</code></td>
      <td>在 Hierarchy 视图中隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideInInspector</code></td>
      <td>在 Inspector 中隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.NotEditable</code></td>
      <td>不允许用户编辑（灰掉）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSave</code></td>
      <td>场景保存时不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSaveInBuild</code></td>
      <td>打包时不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSaveInEditor</code></td>
      <td>编辑器中不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideAndDontSave</code></td>
      <td>隐藏并不保存（临时对象）</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetInstanceID</code></td>
      <td>获得object的实例ID</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ToString</code></td>
      <td>返回<code class="language-plaintext highlighter-rouge">object.name</code></td>
    </tr>
  </tbody>
</table>

<p><strong>Static Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
      <th>示例/说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Destroy(Object obj)</code></td>
      <td>销毁一个对象，在当前帧结束时生效</td>
      <td><code class="language-plaintext highlighter-rouge">Destroy(gameObject);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Destroy(Object obj, float t)</code></td>
      <td>延迟 t 秒销毁对象</td>
      <td><code class="language-plaintext highlighter-rouge">Destroy(gameObject, 2.0f);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DestroyImmediate(Object obj)</code></td>
      <td>立刻销毁对象，<strong>只推荐在编辑器中使用</strong></td>
      <td><code class="language-plaintext highlighter-rouge">DestroyImmediate(gameObject);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DontDestroyOnLoad(Object target)</code></td>
      <td>场景切换时不销毁该对象</td>
      <td>常用于单例或管理器类</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindAnyObjectByType&lt;T&gt;()</code></td>
      <td>获取任何已加载的指定类型对象（不保证顺序）</td>
      <td>替代旧版 <code class="language-plaintext highlighter-rouge">FindObjectOfType</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindFirstObjectByType&lt;T&gt;()</code></td>
      <td>获取第一个找到的指定类型对象（可能更快）</td>
      <td>常用于初始化查找</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindObjectsByType&lt;T&gt;()</code></td>
      <td>获取所有已加载的指定类型对象</td>
      <td><code class="language-plaintext highlighter-rouge">var allEnemies = FindObjectsByType&lt;Enemy&gt;();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(Object original)</code></td>
      <td>克隆一个对象（创建副本）</td>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(prefab);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(Object original, Vector3 position, Quaternion rotation)</code></td>
      <td>在指定位置和旋转创建克隆</td>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(prefab, pos, rot);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstantiateAsync(Object original)</code></td>
      <td>异步克隆对象，返回 <code class="language-plaintext highlighter-rouge">AsyncInstantiateOperation</code></td>
      <td>用于 Addressables 或大型对象，节省主线程开销</td>
    </tr>
  </tbody>
</table>

<p><strong>Operators</strong></p>

<table>
  <thead>
    <tr>
      <th>操作符</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否存在</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator!=</code></td>
      <td>比较两个object是否引用不同的物体</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator==</code></td>
      <td>是否引用相同</td>
    </tr>
  </tbody>
</table>

<h2 id="object与资源的关系">Object与资源的关系</h2>
<p>几乎所有资源类型（包括预制体、贴图、材质、音频、动画等）都继承自<code class="language-plaintext highlighter-rouge">Object</code></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Texture</span> <span class="n">tex</span> <span class="p">=</span> <span class="n">Resources</span><span class="p">.</span><span class="n">Load</span><span class="p">&lt;</span><span class="n">Texture</span><span class="p">&gt;(</span><span class="s">"MyTexture"</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Resources.Load&lt;T&gt;()</code>返回的其实就是一个<code class="language-plaintext highlighter-rouge">Object</code>的子类（这里是Texture）</p>

<h2 id="继承关系">继承关系</h2>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Object
  ├── GameObject
  └── Component
        ├── MonoBehaviour
        └── Transform / Collider / Renderer / ...
</code></pre></div></div>
<p>所以可以有：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">go</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">();</span>
<span class="n">Object</span> <span class="n">obj</span> <span class="p">=</span> <span class="n">go</span><span class="p">;</span> <span class="c1">// legal</span>
<span class="n">Component</span> <span class="n">comp</span> <span class="p">=</span> <span class="n">go</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
<span class="n">Object</span> <span class="n">o2</span> <span class="p">=</span> <span class="n">comp</span><span class="p">;</span> <span class="c1">// legal</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">new</code>出来的<code class="language-plaintext highlighter-rouge">GameObject</code>是合法的，但不能<code class="language-plaintext highlighter-rouge">new</code> <code class="language-plaintext highlighter-rouge">Transform</code>或<code class="language-plaintext highlighter-rouge">Renderer</code>，必须用<code class="language-plaintext highlighter-rouge">AddComponent</code>等引擎API创建</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Syntax" /><category term="Unity Class" /><summary type="html"><![CDATA[Object是Unity中所有内建物体的基类，实现在UnityEngine.CoreModule中，不同于C#中的System.Object，它是托管层（C#）和原生引擎层（C++）之间的桥梁，背后绑定着Unity C++引擎层的资源句柄]]></summary></entry><entry><title type="html">Unity Component Communication</title><link href="http://localhost:4000/posts/2025-07-15-Unity-Component-Communication/" rel="alternate" type="text/html" title="Unity Component Communication" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Unity-Component-Communication</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Unity-Component-Communication/"><![CDATA[<table>
  <thead>
    <tr>
      <th>通信方式</th>
      <th>类型</th>
      <th>是否推荐</th>
      <th>示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetComponent&lt;T&gt;()</code> 直接调用</td>
      <td>显式调用</td>
      <td>推荐</td>
      <td><code class="language-plaintext highlighter-rouge">GetComponent&lt;Health&gt;().TakeDamage(10);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnityEvent</code></td>
      <td>事件系统</td>
      <td>推荐</td>
      <td>在 Inspector 中绑定事件</td>
    </tr>
    <tr>
      <td>C# 委托/事件 (<code class="language-plaintext highlighter-rouge">delegate</code>, <code class="language-plaintext highlighter-rouge">event</code>)</td>
      <td>原生 C#</td>
      <td>推荐</td>
      <td><code class="language-plaintext highlighter-rouge">public event Action OnDead;</code></td>
    </tr>
    <tr>
      <td>接口调用（如 <code class="language-plaintext highlighter-rouge">IDamageable</code>）</td>
      <td>解耦方式</td>
      <td>推荐</td>
      <td><code class="language-plaintext highlighter-rouge">target.GetComponent&lt;IDamageable&gt;()?.TakeDamage()</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ScriptableObject</code> 事件</td>
      <td>高级数据驱动</td>
      <td>推荐</td>
      <td>Game-wide event bus</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SendMessage()</code> / <code class="language-plaintext highlighter-rouge">BroadcastMessage()</code></strong></td>
      <td>反射调用</td>
      <td>不推荐</td>
      <td><code class="language-plaintext highlighter-rouge">SendMessage("Explode")</code></td>
    </tr>
  </tbody>
</table>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Syntax" /><category term="Unity Class" /><summary type="html"><![CDATA[通信方式 类型 是否推荐 示例 GetComponent&lt;T&gt;() 直接调用 显式调用 推荐 GetComponent&lt;Health&gt;().TakeDamage(10); UnityEvent 事件系统 推荐 在 Inspector 中绑定事件 C# 委托/事件 (delegate, event) 原生 C# 推荐 public event Action OnDead; 接口调用（如 IDamageable） 解耦方式 推荐 target.GetComponent&lt;IDamageable&gt;()?.TakeDamage() ScriptableObject 事件 高级数据驱动 推荐 Game-wide event bus SendMessage() / BroadcastMessage() 反射调用 不推荐 SendMessage("Explode")]]></summary></entry><entry><title type="html">Native Layer to Script Layer</title><link href="http://localhost:4000/posts/2025-07-15-Native-Layer-to-Script-Layer/" rel="alternate" type="text/html" title="Native Layer to Script Layer" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Native-Layer-to-Script-Layer</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Native-Layer-to-Script-Layer/"><![CDATA[<h2 id="the-bridge-between-native-layer-and-script-layer">The Bridge between Native Layer and Script Layer</h2>
<p>Unity引擎运行时，本质上是一个C++引擎内核 + C#脚本层的结构</p>

<p>所写的<code class="language-plaintext highlighter-rouge">MonoBehaviour</code>只是在C#中的一个代理对象，真正控制游戏运行的逻辑、渲染、物理等是C++层在执行</p>

<p>所以从<code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>开始，Unity构建了一个“双向映射体系”</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C++对象（native） &lt;--- instance ID --- UnityEngine.Object（C#托管对象）
        ↑                                       ↑
    内存资源                                   脚本代理
</code></pre></div></div>

<h3 id="从object到monobehaviour的完整继承链">从Object到MonoBehaviour的完整继承链</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.Object （纯托管）
└── UnityEngine.Object （托管对象，桥梁类）
    ├── GameObject（托管对象）
    └── Component
        ├── Transform / Renderer / Collider...（托管对象）
        └── MonoBehaviour （托管行为对象，支持生命周期方法）
</code></pre></div></div>
<p>它们都不是普通的C#对象，它们都与C++侧的“实体”挂钩，甚至生命周期也是引擎控制的</p>

<h3 id="native-layer-与-script-layer的绑定方式">native layer 与 script layer的绑定方式</h3>
<p>Unity会通过一套机制将C++层对象暴露给C#层，这其中最关键的桥梁是：<code class="language-plaintext highlighter-rouge">instance ID + GCHandle + m_CachedPtr</code></p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">m_CachedPtr</code></td>
      <td><code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>中保留的指针，指向C++对象的地址（Unsafe）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GCHandle</code></td>
      <td>Unity用于保持托管对象不被GC收走，native端持有</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Instance ID</code></td>
      <td>每个 C++ native 对象的唯一标识，Unity使用它查找C#代理对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ScriptingObject</code></td>
      <td>C++对象的基类，用于和C#对象绑定（runtime下存在）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MonoObject*</code></td>
      <td>指向 C# 对象的原生指针（Mono环境时）</td>
    </tr>
  </tbody>
</table>

<p>流程图：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C++对象 (ScriptingObject)
   ↕ instance ID
C#对象（UnityEngine.Object） ← GCHandle ← C++
         ↑
      m_CachedPtr → C++对象
</code></pre></div></div>

<h3 id="instance-id">instance ID</h3>
<p>Unity通过使用<code class="language-plaintext highlighter-rouge">instance ID</code>统一管理对象</p>

<p>每个在C++层的Unity对象都有一个唯一的标识符，即<code class="language-plaintext highlighter-rouge">instance ID</code>，它用于区分不同的C++对象。这个标识符的作用类似于内存中的指针</p>
<ul>
  <li>在C#中，可以通过<code class="language-plaintext highlighter-rouge">UnityEngine.Object.GetInstanceID()</code>获取该对象的<code class="language-plaintext highlighter-rouge">instance ID</code></li>
  <li>在C++中，通过这个<code class="language-plaintext highlighter-rouge">instance ID</code>可以找到实际的对象。所有Unity引擎的原生对象都会被注册到一个全局的对象管理器中，这个管理器会维护<code class="language-plaintext highlighter-rouge">instance ID</code>和对象之间的映射</li>
</ul>

<p>可以把<code class="language-plaintext highlighter-rouge">instance ID</code>想象成一个类似于数据库中的“主键”，它指向C++层中的实际属性。在C#层，Unity通过<code class="language-plaintext highlighter-rouge">m_CachedPtr</code>或类似机制与C++对象建立联系。C#调用一个方法或访问一个属性时，实际上就是通过这个<code class="language-plaintext highlighter-rouge">instance ID</code>去C++层查找并操作相应对象的</p>

<h3 id="c层对象的生命周期管理">C++层对象的生命周期管理</h3>
<p>在Unity中，C++层的对象生命周期是由引擎控制的，而不是像普通的C#对象那样由GC自动回收。也就是说，C++对象在被销毁时，并不会立即被C#垃圾处理器回收，而是由Unity引擎自己管理</p>

<p>关键点：</p>
<ul>
  <li>C++层对象的创建和销毁：Unity引擎在创建或销毁对象时，会在C#层为这些C++对象创建对应的托管代理。当你调用<code class="language-plaintext highlighter-rouge">Destroy()</code>或<code class="language-plaintext highlighter-rouge">DestroyImmediate()</code>时，Unity会标记这个对象为待销毁，但实际销毁操作会发生在引擎的下一帧</li>
  <li>GCHandle和<code class="language-plaintext highlighter-rouge">instance ID</code>：为了防止C#垃圾回收器误回收正在被引擎使用的对象，Unity会使用<code class="language-plaintext highlighter-rouge">GCHandle</code>来防止C#层的对象被GC销毁。<code class="language-plaintext highlighter-rouge">GCHandle</code>是一个特定的标记，它告诉C#的垃圾回收器，这个对象在native层还有引用，不应该被回收</li>
  <li>内存管理：一旦<code class="language-plaintext highlighter-rouge">GameObject</code>或其他对象在C++层销毁，Unity会通过管理器从托管层移除该对象，确保其不再被访问。此时，C#层的引用会变成<code class="language-plaintext highlighter-rouge">null</code>，也就无法再访问该对象了。若访问，C#层会返回<code class="language-plaintext highlighter-rouge">null</code>，这便是Unity的<code class="language-plaintext highlighter-rouge">fake null</code>行为</li>
</ul>

<h3 id="c和c的指针交互">C#和C++的指针交互</h3>
<p>在C#和C++之间，<code class="language-plaintext highlighter-rouge">m_CachedPtr</code>是Unity使用的一个关键字段，它保存了C++对象的指针。这个指针并不会直接暴露，而是通过<code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>的方法间接访问</p>

<p>例如，当使用<code class="language-plaintext highlighter-rouge">Instantiate()</code>克隆一个对象时，C#层会创建一个新的对象，并将其<code class="language-plaintext highlighter-rouge">m_CachedPtr</code>指向一个新的C++对象。这种机制确保了C#和C++层可以同步管理对象的创建、销毁和引用</p>

<p>为什么不直接使用C++指针</p>
<ul>
  <li>安全性：如果C#直接操作C++指针，那么内存管理将变得非常复杂，容易发生野指针错误（例如访问已销毁的对象）</li>
  <li>跨平台：Unity需要支持多个平台，如果直接操作原始指针，会导致平台之间的不兼容</li>
</ul>

<h3 id="内存和资源管理native与managed内存">内存和资源管理：Native与Managed内存</h3>
<p>Unity对内存的管理通常分为两类：托管内存（Managed Memory）和原生内存（Native Memory）</p>

<p>托管内存：</p>
<ul>
  <li>这是C#层的内存，由.NET的垃圾回收器负责管理。Unity中的许多类都在托管内存中分配</li>
  <li>例如，通过<code class="language-plaintext highlighter-rouge">new GameObject()</code>创建一个对象时，它实际上是在托管内存中创建了一个<code class="language-plaintext highlighter-rouge">GameObject</code>代理类，该类最终通过<code class="language-plaintext highlighter-rouge">instance ID</code>和C++对象绑定</li>
</ul>

<p>原生内存：</p>
<ul>
  <li>这是C++层的内存。Unity对这些内存进行严格管理，确保它们被正确地分配和释放</li>
  <li>对于一个<code class="language-plaintext highlighter-rouge">GameObject</code>，它在C++层的实际数据都存在原生内存中。C#只能通过指针和绑定方法访问这些内存数据，而不能直接操作它</li>
</ul>

<h3 id="资源的加载与卸载的底层机制">资源的加载与卸载的底层机制</h3>
<p>Unity的资源管理在C++层也有对应的资源对象，它们通过资源路径和资源管理系统来加载和卸载</p>

<p>当使用<code class="language-plaintext highlighter-rouge">Resource.Load()</code>或<code class="language-plaintext highlighter-rouge">Addressables</code>加载资源时，Unity会在C++层将资源加载到内存中，并返回一个C#层的代理对象。这些资源的引用计数会由C++层管理，当没有对象再引用这些资源时，C++层会负责销毁这些内存并释放内存</p>

<h3 id="性能和优化">性能和优化</h3>

<ol>
  <li>
    <p>频繁的资源加载和卸载：如果你在每帧都调用 Resources.Load() 或频繁销毁对象，可能会导致性能瓶颈。推荐使用 Addressables 或 Object Pooling 技术来优化资源管理。</p>
  </li>
  <li>
    <p>避免大量无效对象：例如，创建大量的 GameObject、MonoBehaviour，然后频繁销毁。这样不仅会增加垃圾回收的负担，还会在 C++ 层产生频繁的对象创建和销毁开销。可以使用对象池来减少这种开销。</p>
  </li>
  <li>
    <p>内存泄漏问题：如果对象在 C++ 层没有正确销毁，可能导致内存泄漏。特别是 MonoBehaviour 等绑定对象，它们的销毁需要确保在 C# 层正确解除引用，否则即使对象在 C++ 层销毁，C# 层的引用仍会阻止 GC 回收。</p>
  </li>
</ol>

<h3 id="对象创建过程">对象创建过程</h3>
<p>以创建一个<code class="language-plaintext highlighter-rouge">GameObject</code>为例：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">go</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">(</span><span class="s">"Hero"</span><span class="p">);</span>
</code></pre></div></div>
<p>在背后发生了：</p>
<ol>
  <li>C#调用UnityEngine的构造方法</li>
  <li>Unity C#层调用了内部绑定的native构造函数（通过<code class="language-plaintext highlighter-rouge">[NativeMethod]</code>或<code class="language-plaintext highlighter-rouge">extern</code>实现）</li>
  <li>C++中创建了一个<code class="language-plaintext highlighter-rouge">GameObject</code>对象，并注册<code class="language-plaintext highlighter-rouge">instance ID</code></li>
  <li>Unity C++层为这个对象创建一个C#代理，分配内存，绑定<code class="language-plaintext highlighter-rouge">m_CachedPtr</code></li>
  <li>如果启用脚本（MonoBehaviour），则Unity会通过反射或运行时代码绑定，自动挂载脚本（生成MonoObject，绑定）</li>
</ol>

<h2 id="monobehaviour的生命周期的控制">MonoBehaviour的生命周期的控制</h2>
<p>生命周期函数是Unity引擎每帧自动调度的：</p>
<ul>
  <li>Unity在每帧中，遍历所有激活的<code class="language-plaintext highlighter-rouge">GameObject</code>和<code class="language-plaintext highlighter-rouge">Component</code></li>
  <li>检查是否存在重写的生命周期函数</li>
  <li>调用托管对象中的方法（通过反射或自动生成的绑定）</li>
</ul>

<h2 id="monobehaviour是怎么挂载的">MonoBehaviour是怎么挂载的</h2>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gameObject</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">MyScript</span><span class="p">&gt;();</span>
</code></pre></div></div>
<p>内部流程：</p>
<ol>
  <li>C#调用泛型方法<code class="language-plaintext highlighter-rouge">AddComponent&lt;T&gt;()</code></li>
  <li>UnityC#层调用底层<code class="language-plaintext highlighter-rouge">AddComponent(Type t)</code>(native bridge)</li>
  <li>引擎C++层创建一个<code class="language-plaintext highlighter-rouge">MonoBehaviour</code>实例（C++对象）</li>
  <li>引擎创建对应的C#代理对象，并调用构造函数</li>
  <li>将代理对象挂到该<code class="language-plaintext highlighter-rouge">GameObject</code>下，并添加到调度列表中</li>
  <li>引擎在适当时机调用<code class="language-plaintext highlighter-rouge">Awake() -&gt; Start() -&gt; Update()</code></li>
</ol>

<p>所以不能用<code class="language-plaintext highlighter-rouge">new MyScript()</code>创建MonoBehaviour，它不是纯托管类，是托管↔native绑定类</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Underlying Principle" /><summary type="html"><![CDATA[The Bridge between Native Layer and Script Layer Unity引擎运行时，本质上是一个C++引擎内核 + C#脚本层的结构]]></summary></entry><entry><title type="html">Layer</title><link href="http://localhost:4000/posts/2025-06-01-Layer/" rel="alternate" type="text/html" title="Layer" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Layer</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-01-Layer/"><![CDATA[<p>在Unity中，Layer是要给非常重要的系统<br />
它主要用于：</p>
<ul>
  <li>控制物体的渲染与相机的可见性</li>
  <li>控制物理碰撞（配合Layer Collision Matrix）</li>
  <li>通过脚本进行物体分类和筛选</li>
</ul>

<h2 id="什么是layer">什么是Layer</h2>

<p>Layer是给GameObject打的“标签”，但它和<code class="language-plaintext highlighter-rouge">Tag</code>不一样，Layer是用于功能性控制的，特别在：</p>
<ul>
  <li>摄像机的Culling Mask</li>
  <li>光照影响（Light Culling）</li>
  <li>物理碰撞（Physics Layer）</li>
  <li>射线检测（Raycast Layer）</li>
</ul>

<h2 id="layer的使用场景">Layer的使用场景</h2>
<h3 id="1摄像机视野控制culling-mask">1.摄像机视野控制（Culling Mask）</h3>
<p>在Camera组件中，你可以设置</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Culling Mask -&gt; 选择哪些Layer可以被该相机看到
</code></pre></div></div>

<p><strong>用途：</strong></p>
<ul>
  <li>UI相机只看UI层</li>
  <li>小地图相机只看敌人层</li>
  <li>分屏镜头每个只看自己的部分</li>
</ul>

<p>Layer不仅能控制每个物体是否被摄像机看到，还能与多个摄像机协作实现更加复杂的视图效果</p>

<p>例如，在多人游戏中，你可以为每个玩家设置独立的摄像机，每个摄像机通过不同的Culling Mask来渲染不同的场景部分</p>

<p>示例：多摄像头分屏控制</p>

<p>在分屏游戏中，可以设置多个摄像机，每个摄像机只渲染属于特定玩家的物体</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">camera1</span><span class="p">.</span><span class="n">cullingMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Player1"</span><span class="p">);</span>
<span class="n">camera2</span><span class="p">.</span><span class="n">cullingMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LaeryMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Player2"</span><span class="p">);</span>
</code></pre></div></div>
<p>通过这种方式，你能够在同一个场景中显示不同的物体，仅限于特定玩家的视野</p>

<h3 id="2物理碰撞控制layer-collision-matrix">2.物理碰撞控制（Layer Collision Matrix）</h3>
<p>在菜单中：</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Edit</span> <span class="s">-&gt;</span> <span class="s">Project</span> <span class="s">Settings</span> <span class="s">-&gt;</span> <span class="s">Physics</span>
</code></pre></div></div>

<p>你可以看到Layer Collision Matrix，它控制哪些Layer和哪些Layer能发生物理碰撞</p>

<p>如果在游戏中有多个物体不需要彼此发生碰撞，可以通过Layer来减少不必要的碰撞检测，提高性能</p>

<p><strong>用途：</strong></p>
<ul>
  <li>玩家层与敌人层可以碰撞，但不和自身碰撞</li>
  <li>子弹不撞自己</li>
  <li>角色不被UI的Collider打断</li>
</ul>

<h3 id="3射线检测">3.射线检测</h3>
<p>可以通过Layer来控制射线是否命中某个对象</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">layerMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Physics</span><span class="p">.</span><span class="nf">Raycast</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="k">out</span> <span class="n">hit</span><span class="p">,</span> <span class="m">100f</span><span class="p">,</span> <span class="n">layerMask</span><span class="p">))</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Hit enemy"</span><span class="p">);</span>
</code></pre></div></div>

<p>也可以多层合并：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">mask</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">))</span> <span class="p">|</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"NPC"</span><span class="p">));</span>
</code></pre></div></div>
<h2 id="内置与自定义layer">内置与自定义Layer</h2>

<h3 id="内置layerunity默认的">内置Layer（Unity默认的）</h3>

<table>
  <thead>
    <tr>
      <th>编号</th>
      <th>名称</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>Default</td>
      <td>默认层</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Water</td>
      <td>水体特效</td>
    </tr>
    <tr>
      <td>5</td>
      <td>UI</td>
      <td>UI 专用</td>
    </tr>
  </tbody>
</table>

<h3 id="自定义layer">自定义Layer</h3>
<p>Unity允许你最多使用32个Layer（编号 0~31），其中前几个是保留的<br />
自定义方式：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">选中</span> <span class="n">GameObject</span> <span class="o">-&gt;</span> <span class="n">Inspector</span> <span class="o">-&gt;</span> <span class="n">Layer</span> <span class="o">-&gt;</span> <span class="k">Add</span> <span class="n">Layer</span><span class="p">...</span>
</code></pre></div></div>
<p>添加后可为GameObject设置：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Layer</span> <span class="s">-&gt;</span> <span class="s">你刚添加的层名</span>
</code></pre></div></div>
<h2 id="layer与tag的区别">Layer与Tag的区别</h2>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>Layer</th>
      <th>Tag</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>数量限制</td>
      <td>最多 32 个</td>
      <td>无限制</td>
    </tr>
    <tr>
      <td>用于渲染控制</td>
      <td>是</td>
      <td>否</td>
    </tr>
    <tr>
      <td>用于物理控制</td>
      <td>是</td>
      <td>否</td>
    </tr>
    <tr>
      <td>用于分类查找</td>
      <td>有限制（用 LayerMask）</td>
      <td>可以（用 CompareTag 等）</td>
    </tr>
    <tr>
      <td>性能优化</td>
      <td>优化（用于剔除、射线过滤）</td>
      <td>无优化</td>
    </tr>
  </tbody>
</table>

<h3 id="建议">建议</h3>
<ul>
  <li>给每种功能的对象分配专属Layer</li>
  <li>摄像机、光源、UI、Trigger检测都应依赖Layer控制逻辑</li>
</ul>

<h2 id="layer性能优化与管理">Layer性能优化与管理</h2>
<h3 id="layer管理的最佳实践">Layer管理的最佳实践</h3>
<ul>
  <li>避免过多的Layer：虽然Unity最多允许32个Layer，但不建议频繁使用大量的Layer。过多的Layer会增加管理和维护的难度，且可能会影响性能。建议将层次结构设计得尽量简洁，避免无谓的冗余</li>
  <li>分层管理：根据物体的功能将其分配到不同的Layer中，例如：
    <ul>
      <li>游戏角色：<code class="language-plaintext highlighter-rouge">Player</code>,<code class="language-plaintext highlighter-rouge">Enemy</code></li>
      <li>UI界面：<code class="language-plaintext highlighter-rouge">UI</code>,<code class="language-plaintext highlighter-rouge">Menu</code></li>
      <li>特效：<code class="language-plaintext highlighter-rouge">PerticleEffects</code></li>
      <li>背景：<code class="language-plaintext highlighter-rouge">Background</code></li>
    </ul>
  </li>
</ul>

<p>通过合理的分层，既能提高渲染效率，也便于后期维护</p>

<h3 id="动态控制layer">动态控制Layer</h3>
<p>在一些场景中，可能需要根据物体的状态动态改变其Layer。比如，当玩家接触到某个特殊的物体时，可以改变其Layer，使其在某些摄像机的视野中不可见或不可碰撞</p>

<p>示例：动态更改Layer：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gameObject</span><span class="p">.</span><span class="n">layer</span> <span class="p">=</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Invisible"</span><span class="p">);</span>
</code></pre></div></div>
<p>通过动态修改Layer，能够灵活控制物体的行为和渲染效果</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><summary type="html"><![CDATA[在Unity中，Layer是要给非常重要的系统 它主要用于： 控制物体的渲染与相机的可见性 控制物理碰撞（配合Layer Collision Matrix） 通过脚本进行物体分类和筛选]]></summary></entry><entry><title type="html">Tag</title><link href="http://localhost:4000/posts/2025-06-01-Tag/" rel="alternate" type="text/html" title="Tag" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Tag</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-01-Tag/"><![CDATA[<p>在Unity中，Tag是用来标记和分类GameObject的一种轻量级方法，主要用于在代码中查找和判断物体的类型或身份</p>

<h2 id="tag的核心作用">Tag的核心作用</h2>

<table>
  <thead>
    <tr>
      <th>功能</th>
      <th>示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>分类物体</td>
      <td>Player、Enemy、Item、UI 等</td>
    </tr>
    <tr>
      <td>逻辑判断</td>
      <td>判断一个物体是不是玩家</td>
    </tr>
    <tr>
      <td>查找特定对象</td>
      <td><code class="language-plaintext highlighter-rouge">GameObject.FindWithTag()</code></td>
    </tr>
    <tr>
      <td>触发器/碰撞器逻辑判断</td>
      <td><code class="language-plaintext highlighter-rouge">if (other.CompareTag("Enemy"))</code></td>
    </tr>
  </tbody>
</table>

<h2 id="tag的使用方法">Tag的使用方法</h2>

<h3 id="1设置tag">1.设置Tag</h3>
<p>1.选中一个 GameObject
2.Inspector 面板 → 上方的 “Tag” 下拉菜单
3.如果没有想要的标签 → 点击 Add Tag… → 添加一个新的字符串
4.回到物体，设置为刚才新建的 Tag</p>
<blockquote>
  <p><strong>注意：</strong> Tag是字符串类型，但Unity会为你管理列表，不用硬编码</p>
</blockquote>

<h3 id="2使用tag查找对象">2.使用Tag查找对象</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">player</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">FindWithTag</span><span class="p">(</span><span class="s">"Player"</span><span class="p">);</span>
</code></pre></div></div>
<p>或者查找多个对象：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span><span class="p">[]</span> <span class="n">enemies</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">FindGameObjectsWithTag</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="3在触发器或碰撞中判断tag">3.在触发器或碰撞中判断Tag</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">OnTriggerEnter</span><span class="p">(</span><span class="n">Collider</span> <span class="n">other</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">))</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"撞到敌人了！"</span><span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>推荐使用CompareTag()，而不是<code class="language-plaintext highlighter-rouge">other.tag == "Enemy"</code>，性能更好，也可避免拼写错误引发异常</p>
</blockquote>

<h2 id="示例">示例</h2>
<h3 id="标记玩家">标记玩家</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="s">"Player"</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">PlayerHealth</span> <span class="n">hp</span> <span class="p">=</span> <span class="n">other</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">PlayerHealth</span><span class="p">&gt;();</span>
    <span class="n">hp</span><span class="p">.</span><span class="nf">TakeDamage</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="标记子弹敌人道具等">标记子弹、敌人、道具等</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="s">"Projectile"</span><span class="p">))</span> <span class="nf">Destroy</span><span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">);</span>
</code></pre></div></div>
<h3 id="用于全局查找对象比如ui控件">用于全局查找对象（比如UI控件）</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">healthBar</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">FindWithTag</span><span class="p">(</span><span class="s">"HealthBar"</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="建议">建议</h2>
<ul>
  <li>Tag符合逻辑判断</li>
  <li>不适合控制物理、渲染行为，应交由Layer完成</li>
  <li>避免硬编码字符串，建议自定义一个Tag常量类</li>
</ul>

<h2 id="tag-vs-layer">Tag vs Layer</h2>
<h3 id="主要功能">主要功能</h3>
<ul>
  <li>
    <p>Tag：
用于标记和分类物体。Tag是要给字符串类型，主要用于逻辑上的分类，帮助在代码中识别不同的物体。它适用于标记物体的类型或身份</p>
  </li>
  <li>
    <p>Layer：
用于物理和渲染的分类。Layer用于将物体分配到不同的物理层或渲染层。它通常用于碰撞检测、摄像机的渲染、遮挡剔除等方面</p>
  </li>
</ul>

<h3 id="应用场景">应用场景</h3>

<table>
  <thead>
    <tr>
      <th>功能</th>
      <th>Tag</th>
      <th>Layer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>逻辑分类</strong></td>
      <td>逻辑上的分类（如<code class="language-plaintext highlighter-rouge">Player</code>、<code class="language-plaintext highlighter-rouge">Enemy</code>、<code class="language-plaintext highlighter-rouge">NPC</code>等）</td>
      <td>不适合做逻辑分类</td>
    </tr>
    <tr>
      <td><strong>物理交互</strong></td>
      <td>无直接影响</td>
      <td>控制物体与物理系统的交互（如碰撞、触发）</td>
    </tr>
    <tr>
      <td><strong>渲染控制</strong></td>
      <td>无直接影响</td>
      <td>控制哪些物体由摄像机渲染，或者被物理引擎处理</td>
    </tr>
    <tr>
      <td><strong>代码查找</strong></td>
      <td>可以通过代码查找特定标签的物体（<code class="language-plaintext highlighter-rouge">FindWithTag()</code>）</td>
      <td>不支持通过代码直接查找物体</td>
    </tr>
    <tr>
      <td><strong>数量限制</strong></td>
      <td>默认有7个内置标签，可自由添加自定义标签</td>
      <td>内置5个层，支持最多32个层（Layer）</td>
    </tr>
  </tbody>
</table>

<h2 id="性能优化">性能优化</h2>
<p><code class="language-plaintext highlighter-rouge">GameObject.FindWithTag()</code>和<code class="language-plaintext highlighter-rouge">GameObject.Find()</code>性能差异</p>

<h3 id="1gameobjectfind">1.GameObject.Find()</h3>
<p>`GameObject.Find()用于根据物体的名字查找游戏对象。它的工作原理时遍历当前场景中的所有游戏对象，并检查它们的名字是否与给定的字符串匹配。由于它们是基于字符串的比较来查找物体，查找过程中需要遍历所有场景中的物体，并逐一比较名字，性能相对较低，尤其是在场景中有大量物体时</p>

<p>性能特点：</p>
<ul>
  <li>遍历所有物体：它会遍历场景中的每个物体并进行字符串比较，直到找到匹配的物体</li>
  <li>性能消耗大：尤其在场景中物体数量较多时，<code class="language-plaintext highlighter-rouge">Find()</code>的性能较差。每次调用都会产生额外的性能开销</li>
  <li>不建议在Update中频繁使用：如果你在<code class="language-plaintext highlighter-rouge">Update()</code>或其他频繁调用的函数中使用<code class="language-plaintext highlighter-rouge">Find()</code>，会导致帧率下降</li>
</ul>

<p>适用场景：<br />
适用于场景中物体不多，或者物体名字是唯一且不需要频繁查找的场景</p>

<h3 id="2gameobjectfindwithtag">2.GameObject.FindWithTag()</h3>
<p><code class="language-plaintext highlighter-rouge">GameObject.FindWithTag()</code>是根据物体的Tag查找物体。Unity内部对标签进行了优化处理，标签通常是通过整数索引来管理，而不是字符串比较，因此比<code class="language-plaintext highlighter-rouge">Find()</code>更高效</p>

<p>性能特点：</p>
<ul>
  <li>标签优化：Unity通过内部索引表来管理标签，查找时直接使用整数值进行对比，性能比<code class="language-plaintext highlighter-rouge">Find()</code>要好</li>
  <li>只查找有特定标签的物体：<code class="language-plaintext highlighter-rouge">FindWithTag()</code>只会查找那些拥有特定标签的物体，这减少了查找范围，避免了遍历所有物体</li>
  <li>更高效：相比<code class="language-plaintext highlighter-rouge">Find()</code>，<code class="language-plaintext highlighter-rouge">FindWithTag()</code>的性能开销要小得多，尤其在场景中有大量物体时，它仍能保持较好的性能</li>
</ul>

<p>适用场景：<br />
适用于当你需要按类型查找物体时，比如查找所有敌人、玩家或道具等。尤其当场景中有大量物体时，<code class="language-plaintext highlighter-rouge">FindWithTag()</code>能显著提高查找效率</p>

<h2 id="高级tag管理方法">高级Tag管理方法</h2>
<p>在大型项目中，游戏对象的数量通常非常庞大，简单的Tag管理可能会导致代码混乱、性能瓶颈等问题。因此，合理的Tag管理变得尤为重要</p>

<h3 id="避免硬编码tag字符串">避免硬编码Tag字符串</h3>
<p>虽然Unity允许在<code class="language-plaintext highlighter-rouge">Inspector</code>中设置Tag，但使用字符串类型的Tag容易导致代码中出现硬编码，导致在后期修改时很不方便。</p>

<p>硬编码（Hardcoding）是指在程序代码中直接使用固定值，而不是通过变量、常量、配置文件等灵活方式配置。这种做法会导致编码的可维护性差，一旦需要修改这些值，开发者就需要修改代码本身，甚至重新编译程序</p>

<p>示例：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">gameObject</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">))</span> <span class="c1">// Enemry就是硬编码</span>
<span class="p">{</span>
    <span class="c1">// 做一些敌人的处理</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了解决这个问题，可以使用常量类来管理所有的Tag</p>

<p>示例：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Tags</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">Player</span> <span class="p">=</span> <span class="s">"Player"</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">Enemy</span> <span class="p">=</span> <span class="s">"Enemy"</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">Item</span> <span class="p">=</span> <span class="s">"Item"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>使用常量类可以避免拼写错误，并使代码更具可维护性。例如：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">player</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">FindWithTag</span><span class="p">(</span><span class="n">Tags</span><span class="p">.</span><span class="n">Player</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="统一的tag命名规则">统一的Tag命名规则</h3>
<p>在多人开发的项目中，多个开发者可能会使用不同的命名方式来为物体指定Tag，这容易造成命名冲突或不一致的情况。为了避免这种情况，可以提前指定一个统一的Tag命名规则。<br />
例如，可以按照功能、类型等进行分类：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Player</code>,<code class="language-plaintext highlighter-rouge">Enemy</code>等可以归类为“角色”</li>
  <li><code class="language-plaintext highlighter-rouge">Projectile</code>,<code class="language-plaintext highlighter-rouge">Item</code>等可以归类为“道具”</li>
  <li><code class="language-plaintext highlighter-rouge">UI</code>，<code class="language-plaintext highlighter-rouge">Background</code>等可以归类为“UI”或“场景”元素</li>
</ul>

<p>通过规范化命名，能够提高项目的可读性和协作效率</p>

<h2 id="tag与其他unity功能的结合">Tag与其他Unity功能的结合</h2>
<h3 id="tag与事件系统结合">Tag与事件系统结合</h3>
<p>在游戏开发中，很多逻辑需要根据物体的类型来触发不同的事件。使用Tag可以帮助我们快速识别不同类型的物体，并在适当的时候触发事件</p>

<p>示例：使用Tag触发事件</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">OnCollisionEnter</span><span class="p">(</span><span class="n">Collision</span> <span class="n">collision</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="n">Tags</span><span class="p">.</span><span class="n">Player</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// 触发玩家碰撞事件</span>
        <span class="n">EventManager</span><span class="p">.</span><span class="nf">TriggerEvent</span><span class="p">(</span><span class="s">"PlayerHit"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="n">Tags</span><span class="p">.</span><span class="n">Enemy</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// 触发敌人碰撞事件</span>
        <span class="n">EventManager</span><span class="p">.</span><span class="nf">TriggerEvent</span><span class="p">(</span><span class="s">"EnemyHit"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这种方法不仅能提高代码的可读性，还能使事件管理更加灵活</p>

<h3 id="tag与layer结合使用">Tag与Layer结合使用</h3>
<p>有时，Unity中需要将物体分类以控制它们与物理引擎的交互，或者控制它们的渲染。通过将Tag和Layer结合使用，可以达到更精细的控制</p>

<p>示例：使用Layer控制物理交互</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">OnCollisionEnter</span><span class="p">(</span><span class="n">Collision</span> <span class="n">collision</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果碰撞对象是敌人，并且它属于特定的Layer</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="n">Tags</span><span class="p">.</span><span class="n">Enemy</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="n">layer</span> <span class="p">==</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"EnemyLayer"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// 执行敌人的死亡逻辑</span>
        <span class="nf">Destroy</span><span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>通过这种方式，可以使用Layer来精确控制物体的碰撞检测和物理交互，而使用Tag来区分物体的身份和类型</p>

<h2 id="tag的性能优化">Tag的性能优化</h2>
<h3 id="避免频繁调用find和findwithtag">避免频繁调用Find()和FindWithTag()</h3>
<p>在大型项目中，频繁调用<code class="language-plaintext highlighter-rouge">GameObject.Find()</code>和<code class="language-plaintext highlighter-rouge">GameObject.FindWithTag()</code>会对性能造成不小的影响。尤其是在<code class="language-plaintext highlighter-rouge">Update()</code>中反复调用这些方法时，可能会导致游戏的帧率大幅下降</p>

<p>解决方案：缓存查找结果
如果某个物体会被频繁访问，可以考虑将其引用存储在一个变量中，从而避免每次都进行查找</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">GameObejct</span> <span class="n">palyer</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">palyer</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">FindWithTag</span><span class="p">(</span><span class="n">Tags</span><span class="p">.</span><span class="n">Player</span><span class="p">);</span> <span class="c1">// 缓存查找结果</span>

<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">player</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 在这里使用缓存的player引用</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="使用对象池object-pooling优化查找性能">使用对象池（Object Pooling）优化查找性能</h3>
<p>对于需要频繁查找的物体，使用对象池是要给不错的选择。对象池能够避免频繁地实例化和销毁对象，减少性能开销，同时提高代码的可复用性</p>

<p>示例：对象池模式</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">EnemyPool</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">GameObject</span> <span class="n">enemyPrefab</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">GameObject</span><span class="p">&gt;</span> <span class="n">enemyPool</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">GameObject</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">GameObject</span> <span class="nf">GetEnemy</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">enemy</span> <span class="k">in</span> <span class="n">enemyPool</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">enemy</span><span class="p">.</span><span class="n">activeInHierarchy</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">enemy</span><span class="p">.</span><span class="nf">SetActive</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">enemy</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">var</span> <span class="n">newEnemy</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">enemyPrefab</span><span class="p">);</span>
        <span class="n">enemyPool</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">newEnemy</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">newEnemy</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>对象池能够使得<code class="language-plaintext highlighter-rouge">FindWithTag()</code>等查找操作不再频繁发生，从而提升性能</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><summary type="html"><![CDATA[在Unity中，Tag是用来标记和分类GameObject的一种轻量级方法，主要用于在代码中查找和判断物体的类型或身份]]></summary></entry></feed>