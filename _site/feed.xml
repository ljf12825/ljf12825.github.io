<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-06-29T22:07:32+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ljf12825’s Blog</title><subtitle>Efficient &amp; Elegant</subtitle><author><name>Jeff Lee</name><email>2548278761@qq.com</email></author><entry><title type="html">UI Event System</title><link href="http://localhost:4000/posts/2025-06-29-UI-Event-System/" rel="alternate" type="text/html" title="UI Event System" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/UI-Event-System</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-29-UI-Event-System/"><![CDATA[<h2 id="event-system">Event System</h2>
<p><code class="language-plaintext highlighter-rouge">Event System</code>是Unity UI System中的核心交互管理器，掌控了所有鼠标点击、键盘输入、触摸事件、UI导航的逻辑</p>

<p>Unity的Event System是一个处理用户输入事件的系统，用于发送“点击了谁”“选中了谁”之类的事件，属于UnityEngine.EventSystems命名空间</p>

<p><img src="/assets/images/EventSystemPanel.jpg" alt="EventSystemPanel" /></p>

<table>
  <thead>
    <tr>
      <th>组件</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>EventSystem</strong></td>
      <td>整个输入系统的“大脑”</td>
    </tr>
    <tr>
      <td><strong>Input Module</strong></td>
      <td>输入方式模块，比如处理鼠标、键盘、手柄（你可以切换）</td>
    </tr>
    <tr>
      <td><strong>Raycaster（挂在 Canvas 或 3D 对象上）</strong></td>
      <td>实际检测点击了哪个物体，比如：<code class="language-plaintext highlighter-rouge">GraphicRaycaster</code>, <code class="language-plaintext highlighter-rouge">PhysicsRaycaster</code></td>
    </tr>
  </tbody>
</table>

<p>EventSystem会追踪以下交互：</p>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>描述</th>
      <th>接口</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>点击 Click</td>
      <td>鼠标/触摸点击 UI</td>
      <td><code class="language-plaintext highlighter-rouge">IPointerClickHandler</code></td>
    </tr>
    <tr>
      <td>拖拽 Drag</td>
      <td>拖拽 ScrollRect、物品、滑块</td>
      <td><code class="language-plaintext highlighter-rouge">IDragHandler</code>, <code class="language-plaintext highlighter-rouge">IBeginDragHandler</code>, <code class="language-plaintext highlighter-rouge">IEndDragHandler</code></td>
    </tr>
    <tr>
      <td>悬停 Hover</td>
      <td>鼠标移动到 UI 上</td>
      <td><code class="language-plaintext highlighter-rouge">IPointerEnterHandler</code>, <code class="language-plaintext highlighter-rouge">IPointerExitHandler</code></td>
    </tr>
    <tr>
      <td>按钮按下</td>
      <td>长按、释放</td>
      <td><code class="language-plaintext highlighter-rouge">IPointerDownHandler</code>, <code class="language-plaintext highlighter-rouge">IPointerUpHandler</code></td>
    </tr>
    <tr>
      <td>键盘导航</td>
      <td>方向键移动焦点</td>
      <td><code class="language-plaintext highlighter-rouge">IMoveHandler</code></td>
    </tr>
    <tr>
      <td>输入</td>
      <td>表单输入</td>
      <td><code class="language-plaintext highlighter-rouge">ISubmitHandler</code>, <code class="language-plaintext highlighter-rouge">ISelectHandler</code></td>
    </tr>
  </tbody>
</table>

<p>任何的UI交互脚本，都是通过这些接口连接到Event System</p>

<h3 id="eventsystem的工作流程图">EventSystem的工作流程图</h3>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">鼠标</span><span class="o">/</span><span class="nt">键盘</span><span class="o">/</span><span class="nt">触摸输入</span><span class="o">]</span>
      <span class="err">↓</span>
<span class="o">[</span><span class="nt">Input</span> <span class="nt">Module</span><span class="o">]</span> <span class="err">→</span> <span class="nt">分析输入</span><span class="err">（</span><span class="nt">比如点击</span><span class="err">、</span><span class="nt">拖动</span><span class="err">、</span><span class="nt">导航</span><span class="err">）</span>
      <span class="err">↓</span>
<span class="o">[</span><span class="nt">Raycaster</span><span class="o">]</span> <span class="err">→</span> <span class="nt">检测点击了哪个</span> <span class="nt">UI</span> <span class="nt">元素</span>
      <span class="err">↓</span>
<span class="o">[</span><span class="nt">EventSystem</span><span class="o">]</span> <span class="err">→</span> <span class="nt">通知对应的组件执行接口函数</span><span class="err">（</span><span class="nt">如</span> <span class="nt">OnClick</span><span class="err">）</span>
</code></pre></div></div>

<h3 id="eventsystem-component">EventSystem Component</h3>
<h4 id="eventsystem"><code class="language-plaintext highlighter-rouge">EventSystem</code></h4>
<p>挂载在GameObject上，只有一个<br />
功能：</p>
<ul>
  <li>管理当前选中的UI对象</li>
  <li>管理输入模块</li>
  <li>分发事件：比如点击、拖动、选中等</li>
</ul>

<h4 id="eventsystem-panel">EventSystem Panel</h4>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>First Selected</strong></td>
      <td>初始选中的 UI 对象（用于导航/手柄）</td>
    </tr>
    <tr>
      <td><strong>Send Navigation Events</strong></td>
      <td>是否允许方向键或手柄移动选中项</td>
    </tr>
    <tr>
      <td><strong>Drag Threshold</strong></td>
      <td>拖拽时鼠标/手指移动多少才视为“拖拽”</td>
    </tr>
  </tbody>
</table>

<h4 id="standalone-input-module"><code class="language-plaintext highlighter-rouge">Standalone Input Module</code></h4>
<p>适合：鼠标 + 键盘控制<br />
Unity默认生成<br />
功能：把输入映射为事件（点击、拖动、导航）</p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Send Pointer Hover To Parent</td>
      <td>是否强制启用这个模块</td>
    </tr>
    <tr>
      <td>Horizontal Axis / Vertical Axis</td>
      <td>对应键盘方向键（默认是 “Horizontal” 和 “Vertical”）</td>
    </tr>
    <tr>
      <td>Submit Button / Cancel Button</td>
      <td>默认是 “Submit”（Enter）和 “Cancel”（Esc）</td>
    </tr>
    <tr>
      <td>Input Actions Per Second</td>
      <td>每秒导航几次</td>
    </tr>
    <tr>
      <td>Repeat Delay</td>
      <td>长按导航前的延迟时间</td>
    </tr>
  </tbody>
</table>

<h4 id="input-system-ui-input-module新系统"><code class="language-plaintext highlighter-rouge">Input System UI Input Module</code>（新系统）</h4>

<p>详见<a href="/posts/2025-06-03-Input-System/">Input System</a></p>

<p>适合：新版Unity Input System（使用<code class="language-plaintext highlighter-rouge">Input Actions</code>的）</p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Actions Asset</td>
      <td>你设置好的 <code class="language-plaintext highlighter-rouge">.inputactions</code> 文件</td>
    </tr>
    <tr>
      <td>Point / Click / Navigate / Submit 等</td>
      <td>分别绑定触摸、点击、方向等操作</td>
    </tr>
    <tr>
      <td>Move Repeat Rate / Delay</td>
      <td>同样是手柄方向键长按节奏</td>
    </tr>
  </tbody>
</table>

<h4 id="raycaster">Raycaster</h4>
<p>EventSystem本身不会知道你点到谁，它需要Raycaster组件配合UI或3D元素</p>

<h5 id="graphic-raycaster用于canvas-ui"><code class="language-plaintext highlighter-rouge">Graphic Raycaster</code>（用于Canvas UI）</h5>
<p>挂在<code class="language-plaintext highlighter-rouge">Canvas</code>上，专门检测UI元素是否被点中</p>

<p><a href="#graphic-raycaster">Canvas Graphic Raycaster</a></p>

<h5 id="physics-raycaster用于3d物体"><code class="language-plaintext highlighter-rouge">Physics Raycaster</code>（用于3D物体）</h5>
<p>挂在摄像机上，配合3D对象（带Collider）使用，检测鼠标是否点击到物体</p>

<h5 id="physics2d-raycaster用于2d物体"><code class="language-plaintext highlighter-rouge">Physics2D Raycaster</code>（用于2D物体）</h5>
<p>配合2D Collider检测点击或拖动等交互</p>

<h3 id="api">API</h3>
<h4 id="static-properties">Static Properties</h4>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">current</code></td>
      <td>返回当前EventSystem</td>
    </tr>
  </tbody>
</table>

<h4 id="properties">Properties</h4>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">alreadySelecting</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td><strong>只读</strong>属性，表示 EventSystem 当前是否正在执行 <code class="language-plaintext highlighter-rouge">SetSelectedGameObject()</code>。<br /> 一般用于内部防止递归调用选中事件。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">currentInputModule</code></td>
      <td><code class="language-plaintext highlighter-rouge">BaseInputModule</code></td>
      <td>当前正在使用的输入模块（如 <code class="language-plaintext highlighter-rouge">StandaloneInputModule</code> 或 <code class="language-plaintext highlighter-rouge">InputSystemUIInputModule</code>）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">currentSelectedGameObject</code></td>
      <td><code class="language-plaintext highlighter-rouge">GameObject</code></td>
      <td>当前选中的 UI 对象（例如当前焦点在某个按钮上时，这就是那个按钮）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">firstSelectedGameObject</code></td>
      <td><code class="language-plaintext highlighter-rouge">GameObject</code></td>
      <td>场景加载或 EventSystem 启动时最初被选中的对象（通常用于手柄/键盘导航）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isFocused</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>表示 EventSystem 是否处于“聚焦”状态。<br />在 PC 上，这通常意味着游戏窗口是否处于激活状态（失焦时不响应输入）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pixelDragThreshold</code></td>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>拖动时鼠标或手指要移动多少像素才算开始拖拽（用来防止误触拖动）。默认是 5。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sendNavigationEvents</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否启用方向键/手柄的导航事件（如按 ↑↓←→ 移动 UI 选择框）。关闭后不能用方向键移动焦点。</td>
    </tr>
  </tbody>
</table>

<h4 id="public-methods">Public Methods</h4>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>作用</th>
      <th>常见用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IsPointerOverGameObject()</code></td>
      <td>判断鼠标/手指是否悬停在 UI 上</td>
      <td>做点击穿透判断</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">RaycastAll()</code></td>
      <td>手动执行一次 UI 射线检测</td>
      <td>获取所有命中的 UI 元素</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetSelectedGameObject()</code></td>
      <td>设置当前聚焦的 UI</td>
      <td>控制导航焦点</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UpdateModules()</code></td>
      <td>刷新输入模块</td>
      <td>很少手动用，一般系统自动处理</td>
    </tr>
  </tbody>
</table>

<h2 id="focus">Focus</h2>
<p>在UI系统中，焦点（Focus）是指当前“被选中、正在响应输入”的UI元素</p>

<p>它表现为：</p>
<ul>
  <li>手柄/键盘控制时，按钮会被“高亮”</li>
  <li>输入框获得焦点后，可以输入文字</li>
  <li>焦点组件会响应<code class="language-plaintext highlighter-rouge">OnSelect</code>、<code class="language-plaintext highlighter-rouge">OnDeselect</code>、<code class="language-plaintext highlighter-rouge">ISubmitHandler</code>等接口</li>
</ul>

<p><strong>焦点只对以下操作有效：</strong></p>

<table>
  <thead>
    <tr>
      <th>操作</th>
      <th>依赖焦点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>按方向键移动 UI 选择</td>
      <td>依赖</td>
    </tr>
    <tr>
      <td>按 Enter 提交按钮</td>
      <td>依赖</td>
    </tr>
    <tr>
      <td>输入框自动聚焦后可打字</td>
      <td>依赖</td>
    </tr>
    <tr>
      <td>鼠标点击按钮</td>
      <td>不依赖焦点（靠点击 Raycast）</td>
    </tr>
  </tbody>
</table>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">EventSystem</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">currentSelectedGameObject</span>
</code></pre></div></div>
<p>这就是当前拥有焦点的那个UI元素</p>

<h3 id="示例">示例</h3>
<p>1.打开页面时设置初始焦点</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">GameObject</span> <span class="n">defaultButton</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">OnEnable</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">EventSystem</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="nf">SetSelectedGameObject</span><span class="p">(</span><span class="k">null</span><span class="p">);</span> <span class="c1">// 清空旧焦点</span>
  <span class="n">EventSystem</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="nf">SetSelectedGameObject</span><span class="p">(</span><span class="n">defaultButton</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>2.按键触发当前焦点的“提交”</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="nf">GetKeyDown</span><span class="p">(</span><span class="n">KeyCode</span><span class="p">.</span><span class="n">Return</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">go</span> <span class="p">=</span> <span class="n">EventSystem</span><span class="p">.</span><span class="n">currentSelectedGameObject</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">go</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">Execute</span><span class="p">&lt;</span><span class="n">ISubmitHandler</span><span class="p">&gt;(</span><span class="n">go</span><span class="p">,</span> <span class="k">new</span> <span class="nf">BaseEventData</span><span class="p">(</span><span class="n">EventSystem</span><span class="p">.</span><span class="n">current</span><span class="p">),</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">submitHandler</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="焦点与导航方向键控制">焦点与导航（方向键控制）</h3>
<p>每个<code class="language-plaintext highlighter-rouge">Selectable</code>UI（比如 Button、Toggle、InputField）都有导航设置</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Navigation</span> <span class="n">nav</span> <span class="p">=</span> <span class="n">myButton</span><span class="p">.</span><span class="n">navigation</span><span class="p">;</span>
<span class="n">nav</span><span class="p">.</span><span class="n">mode</span> <span class="p">=</span> <span class="n">Navigation</span><span class="p">.</span><span class="n">Mode</span><span class="p">.</span><span class="n">Eplicit</span><span class="p">;</span>
<span class="n">nav</span><span class="p">.</span><span class="n">delectOnRight</span> <span class="p">=</span> <span class="n">anotherButton</span><span class="p">;</span>
<span class="n">myButton</span><span class="p">.</span><span class="n">navigation</span> <span class="p">=</span> <span class="n">nav</span><span class="p">;</span>
</code></pre></div></div>
<p>按下方向键，跳转到指定的UI元素</p>

<h2 id="navigation">Navigation</h2>
<p>用户可以通过键盘、手柄、遥控器等输入设备，在UI组件之间切换焦点并触发交互</p>

<p>导航的核心是EventSystem，它负责追踪当前的Selected GameObject，处理导航方向输入</p>

<p>Selectable系列组件包含导航信息，决定方向键或手柄移动时焦点跳转到哪个元素，UI组件都继承自Selectable类</p>

<p>属性：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Navigation</code>：定义导航方式和目标
    <ul>
      <li>None：禁用导航</li>
      <li>Horizontal/Vertical：自动寻找相邻组件</li>
      <li>Automatic：Unity自动推断相邻组件</li>
      <li>Explicit：手动指定每个方向的目标组件</li>
    </ul>
  </li>
</ul>

<h3 id="建议">建议</h3>
<ul>
  <li>尽量在PC/主机UI中设置清晰的导航路径</li>
  <li>尽可能使用Explicit导航，避免自动导航出错</li>
  <li>初始界面时设置默认选中项（通过<code class="language-plaintext highlighter-rouge">EventSystem.current.SetSelectedGameObjct</code>）</li>
  <li>遇到复杂导航需求时，可自定义导航逻辑</li>
</ul>

<h3 id="常见问题">常见问题</h3>
<ul>
  <li>EventSystem丢失或禁用，导致导航无效</li>
  <li>同一帧中多个<code class="language-plaintext highlighter-rouge">SetSelectedGameObject</code>造成焦点混乱</li>
  <li>Navigation设置为None/Automatic导致意外行为</li>
  <li>多个可交互对象重叠或遮挡，Unity自动导航判定错误</li>
</ul>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity Component" /><category term="UGUI" /><summary type="html"><![CDATA[Event System Event System是Unity UI System中的核心交互管理器，掌控了所有鼠标点击、键盘输入、触摸事件、UI导航的逻辑]]></summary></entry><entry><title type="html">Object Pooling</title><link href="http://localhost:4000/posts/2025-06-06-Object-Pooling/" rel="alternate" type="text/html" title="Object Pooling" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Object-Pooling</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-06-Object-Pooling/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Texture</title><link href="http://localhost:4000/posts/2025-06-29-Texture/" rel="alternate" type="text/html" title="Texture" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Texture</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-29-Texture/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity Component" /><category term="Render" /><category term="Graphics" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Mask</title><link href="http://localhost:4000/posts/2025-06-29-Mask/" rel="alternate" type="text/html" title="Mask" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Mask</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-29-Mask/"><![CDATA[<p><img src="/assets/images/MaskPanel.jpg" alt="MaskPanel" /></p>

<h2 id="mask">Mask</h2>
<p><code class="language-plaintext highlighter-rouge">Mask</code>用于裁剪UI子元素的显示区域，通常搭配图片、Scroll View、头像裁剪等使用</p>

<h3 id="核心功能和行为">核心功能和行为</h3>

<table>
  <thead>
    <tr>
      <th>特点</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>子物体只在 Mask 图像区域内显示</td>
      <td>超出部分不可见（不销毁，只裁剪）</td>
    </tr>
    <tr>
      <td>遮罩区域基于 <code class="language-plaintext highlighter-rouge">Image</code> 的透明度</td>
      <td>非透明部分就是显示区域</td>
    </tr>
    <tr>
      <td>不支持软遮罩（软边缘）</td>
      <td>默认是硬裁剪，想要软遮罩需用 Shader 或 <code class="language-plaintext highlighter-rouge">UIEffect</code> 等插件</td>
    </tr>
  </tbody>
</table>

<h3 id="使用方法">使用方法</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MaskParent(Image + Mask)
|___Content(Text / Image /等UI)
</code></pre></div></div>
<ul>
  <li>父物体挂<code class="language-plaintext highlighter-rouge">Image</code> + <code class="language-plaintext highlighter-rouge">Mask</code>，并设置图片为遮罩区域</li>
  <li>子物体放置UI内容，超出遮罩图形范围会被裁剪</li>
</ul>

<h3 id="常见用途">常见用途</h3>

<table>
  <thead>
    <tr>
      <th>场景</th>
      <th>使用方式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ScrollView 滚动列表</td>
      <td>Viewport 挂 <code class="language-plaintext highlighter-rouge">Image + Mask</code>，内容只显示在视窗中</td>
    </tr>
    <tr>
      <td>圆形头像裁剪</td>
      <td>使用圆形 <code class="language-plaintext highlighter-rouge">Image + Mask</code> 裁剪方形头像图片</td>
    </tr>
    <tr>
      <td>进度条遮罩</td>
      <td>遮罩下滑动另一个图片或文字，实现“擦除”或“揭示”效果</td>
    </tr>
    <tr>
      <td>文字遮挡/选中效果</td>
      <td>对文字进行遮罩只显示一部分或高亮部分</td>
    </tr>
  </tbody>
</table>

<h3 id="裁剪区域">裁剪区域</h3>
<p><code class="language-plaintext highlighter-rouge">Mask</code>裁剪的区域由挂载<code class="language-plaintext highlighter-rouge">Mask</code>的GameObject的<code class="language-plaintext highlighter-rouge">Image</code>的Alpha通道决定</p>

<table>
  <thead>
    <tr>
      <th>Image 类型</th>
      <th>Mask 效果</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sprite (Alpha通道)</td>
      <td>透明处裁剪，实色处显示</td>
    </tr>
    <tr>
      <td>Sprite (无 Alpha 通道)</td>
      <td>整张图片为裁剪区域</td>
    </tr>
    <tr>
      <td>没有 Image 组件</td>
      <td><code class="language-plaintext highlighter-rouge">Mask</code> 不起作用（它依赖 <code class="language-plaintext highlighter-rouge">Image</code>）</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Image的<code class="language-plaintext highlighter-rouge">Raycast Target</code>设置不影响裁剪，但影响事件响应</p>
</blockquote>

<h2 id="rect-mask-2d">Rect Mask 2D</h2>
<p><code class="language-plaintext highlighter-rouge">RectMask2D</code>是Unity UI中专为矩形区域裁剪而设计的遮罩组件，功能和<code class="language-plaintext highlighter-rouge">Mask</code>类似，但更高效、轻量，只适用于矩形裁剪</p>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th><code class="language-plaintext highlighter-rouge">RectMask2D</code></th>
      <th><code class="language-plaintext highlighter-rouge">Mask</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>遮罩形状</strong></td>
      <td>只能是矩形</td>
      <td>任意形状（基于 alpha 通道）</td>
    </tr>
    <tr>
      <td><strong>性能</strong></td>
      <td>高效</td>
      <td>相对较低（使用 Stencil Buffer）</td>
    </tr>
    <tr>
      <td><strong>软遮罩支持</strong></td>
      <td>不支持</td>
      <td>也不支持（需 Shader 实现）</td>
    </tr>
    <tr>
      <td><strong>需要 Image 吗</strong></td>
      <td>不需要</td>
      <td>必须有 Image（带 alpha）</td>
    </tr>
    <tr>
      <td><strong>ScrollView 默认用谁？</strong></td>
      <td><code class="language-plaintext highlighter-rouge">RectMask2D</code></td>
      <td>不是默认组件</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>Softness：控制边缘模糊程度，让裁剪区域的边缘不再是生硬的“硬切线”，而是具有渐隐的柔和效果，也就是软遮罩</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RectMask2D.softness = new Vector2(x, y);
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>分量</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">x</code></td>
      <td>左右边缘的模糊像素距离</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">y</code></td>
      <td>上下边缘的模糊像素距离</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>单位是像素数（会随Canvas的Pixel-Per-Unit放大缩小）</li>
  <li>值越大，模糊过渡越宽</li>
  <li>值为0时，表现为传统的硬遮罩</li>
</ul>

<h3 id="结构示例聊天滚动列表">结构示例：聊天滚动列表</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Scroll View
|——Viewport(RectMask2D)
      |__Content（垂直布局 + 自动扩展）
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Viewport</code>是可视区域，挂<code class="language-plaintext highlighter-rouge">RectMask2D</code></li>
  <li>子元素（Content）会被限制在Viewport范围内，超出部分不可见</li>
</ul>

<h3 id="工作原理">工作原理</h3>
<ul>
  <li>裁剪区域 = RectTransform可视区域</li>
  <li>所有超出这个矩形范围的子元素将不被渲染</li>
  <li>实现方式基于剪裁矩形，无需stencil buffer，比<code class="language-plaintext highlighter-rouge">Mask</code>性能更高</li>
  <li>不依赖图片、不使用alpha通道</li>
</ul>

<h2 id="sprite-mask">Sprite Mask</h2>
<p><code class="language-plaintext highlighter-rouge">Sprite Mask</code>时Unity中专为2D精灵系统设计的遮罩组件，用来让某些Sprite按遮罩的形状显示或隐藏，相比UI中的传统<code class="language-plaintext highlighter-rouge">Mask</code>和<code class="language-plaintext highlighter-rouge">RectMask2D</code>，它属于2D渲染层级遮罩机制，用于SpriteRenderer渲染对象的裁剪</p>

<p><code class="language-plaintext highlighter-rouge">Sprite Mask</code>是一个形状遮罩，允许受控的Sprite只在遮罩区域内渲染，超出部分将不可见</p>

<p>它通常用于：</p>
<ul>
  <li>地图”探索雾“</li>
  <li>道具高亮显示</li>
  <li>角色潜行、隐身剪影</li>
  <li>Sprite动画部分揭示</li>
  <li>类似”圆形裁剪头像“的2D实现</li>
</ul>

<h3 id="使用结构示例">使用结构示例</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SpriteMask (Mask 控制区域)
└── SpriteA (Renderer 被遮罩)
</code></pre></div></div>
<p>或者平行结构也可以</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SpriteMask
SpriteA (设置受 Sprite Mask 控制)
</code></pre></div></div>
<h3 id="使用方法-1">使用方法</h3>
<p>1.添加Sprite Mask</p>
<ul>
  <li>添加一个空物体，挂<code class="language-plaintext highlighter-rouge">Sprite Mask</code>组件</li>
  <li>设置遮罩图形：选择一个带alpha的Sprite（通常是圆形/自定义形状）</li>
</ul>

<p>2.被遮罩的Sprite设置：<br />
在<code class="language-plaintext highlighter-rouge">Sprite Renderer</code>上：</p>
<ul>
  <li>Mask Interaction设置为：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">None</code>：不受任何遮罩影响</li>
      <li><code class="language-plaintext highlighter-rouge">Visible Inside Mask</code>：仅在遮罩区域内可见</li>
      <li><code class="language-plaintext highlighter-rouge">Visible Outside Mask</code>：仅在遮罩区域外可见</li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Sprite</strong></td>
      <td>遮罩形状，使用 Sprite 的 alpha 通道</td>
    </tr>
    <tr>
      <td><strong>Alpha Cutoff</strong></td>
      <td>判定透明与非透明的阈值</td>
    </tr>
    <tr>
      <td><strong>Custom Range</strong></td>
      <td>设置可见层范围（Sorting Layer 和 Order）</td>
    </tr>
    <tr>
      <td><strong>Sprite Sort Point</strong></td>
      <td>以哪个点作为Sprite的排序基准点</td>
    </tr>
  </tbody>
</table>

<h3 id="示例">示例</h3>
<h4 id="地图探索雾系统">地图探索雾系统</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>地图遮罩 (SpriteMask：黑色圆形)
角色头顶 (Sprite：Visible Inside Mask)
→ 角色周围区域可见，其余为黑
</code></pre></div></div>

<h4 id="裁剪头像">裁剪头像</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>头像边框 (圆形 SpriteMask)
头像图片 (SpriteRenderer：Visible Inside Mask)
</code></pre></div></div>

<h4 id="潜行效果">潜行效果</h4>
<p>遮罩外隐藏角色：</p>
<ul>
  <li>SpriteRenderer设置为<code class="language-plaintext highlighter-rouge">Visible Inside Mask</code></li>
  <li>动画移动<code class="language-plaintext highlighter-rouge">SpriteMask</code>即可动态揭示角色</li>
</ul>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity Component" /><category term="Render" /><category term="Graphics" /><category term="UGUI" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Unity Invisible Trap</title><link href="http://localhost:4000/debug/2025/06/01/Unity-Invisible-Trap.html" rel="alternate" type="text/html" title="Unity Invisible Trap" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/debug/2025/06/01/Unity-Invisible-Trap</id><content type="html" xml:base="http://localhost:4000/debug/2025/06/01/Unity-Invisible-Trap.html"><![CDATA[<p>Unity实际开发中，有很多“看起来正常、实则容易出错”的<strong>奇怪问题</strong>（或称为<strong>隐形陷阱</strong>）</p>

<h1 id="quick-list">Quick List</h1>
<h2 id="class1-交互相关">Class1 交互相关</h2>

<table>
  <thead>
    <tr>
      <th>现象</th>
      <th>原因</th>
      <th>解决方式</th>
      <th>标签</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#1多个可交互物体输入触发多个">按下交互键时多个箱子同时打开</a></td>
      <td>范围内存在多个交互体，未判断距离</td>
      <td>使用 <code class="language-plaintext highlighter-rouge">OverlapSphere</code> + 计算最近距离</td>
      <td>输入、交互</td>
    </tr>
    <tr>
      <td>鼠标点击物体无反应</td>
      <td>被 UI 或透明物体挡住，Raycast 被拦截</td>
      <td>检查 UI 的 Raycast Target 设置</td>
      <td>输入、射线</td>
    </tr>
    <tr>
      <td>射线打不中目标</td>
      <td>射线层级错误或未设置 LayerMask</td>
      <td>使用正确 Layer 和 LayerMask</td>
      <td>输入、射线</td>
    </tr>
    <tr>
      <td>玩家进入 Trigger 区域被触发两次</td>
      <td>存在多个 Collider 重叠，重复触发</td>
      <td>判断 <code class="language-plaintext highlighter-rouge">other.gameObject</code> 是否重复</td>
      <td>触发器、碰撞</td>
    </tr>
  </tbody>
</table>

<h2 id="class2-动画控制">Class2 动画控制</h2>

<table>
  <thead>
    <tr>
      <th>现象</th>
      <th>原因</th>
      <th>解决方式</th>
      <th>标签</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SetTrigger</code> 后动画无反应</td>
      <td>没有关闭 <code class="language-plaintext highlighter-rouge">Has Exit Time</code> 或过渡设置错误</td>
      <td>调整 Animator Transition 设置</td>
      <td>动画、状态机</td>
    </tr>
    <tr>
      <td>动画状态切换卡顿</td>
      <td>切换时未等待上一状态结束</td>
      <td>使用 CrossFade，设置合理 transition duration</td>
      <td>动画</td>
    </tr>
    <tr>
      <td>动画参数更新后立即调用 <code class="language-plaintext highlighter-rouge">Play</code> 无效</td>
      <td>Animator 状态未刷新</td>
      <td>等待一帧或避免立即 <code class="language-plaintext highlighter-rouge">Play</code></td>
      <td>动画、代码时序</td>
    </tr>
    <tr>
      <td>动画过渡后恢复原始状态</td>
      <td>未使用 <code class="language-plaintext highlighter-rouge">Animator.ResetTrigger</code></td>
      <td>设置状态触发后重置 Trigger</td>
      <td>动画、状态机</td>
    </tr>
  </tbody>
</table>

<h2 id="class3-ui系统">Class3 UI系统</h2>

<table>
  <thead>
    <tr>
      <th>现象</th>
      <th>原因</th>
      <th>解决方式</th>
      <th>标签</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>UI 按钮点击无效</td>
      <td>被其他透明 UI 挡住</td>
      <td>检查 Canvas 层级，关闭遮挡物的 Raycast Target</td>
      <td>UI、输入</td>
    </tr>
    <tr>
      <td>Text 性能差、频繁 GC</td>
      <td>使用 <code class="language-plaintext highlighter-rouge">Text</code> 频繁更新</td>
      <td>使用 <code class="language-plaintext highlighter-rouge">TextMeshPro</code> + 对象池</td>
      <td>UI、性能</td>
    </tr>
    <tr>
      <td>UI 点击穿透到底部物体</td>
      <td>未正确使用 <code class="language-plaintext highlighter-rouge">CanvasGroup.blocksRaycasts</code></td>
      <td>设置为 false 阻止穿透</td>
      <td>UI、射线</td>
    </tr>
    <tr>
      <td>ScrollView 滚动方向错乱</td>
      <td>锚点、Pivot 设置错误</td>
      <td>调整 Content 和 Viewport 的锚点</td>
      <td>UI、布局</td>
    </tr>
  </tbody>
</table>

<h2 id="class4-物理系统">Class4 物理系统</h2>

<table>
  <thead>
    <tr>
      <th>现象</th>
      <th>原因</th>
      <th>解决方式</th>
      <th>标签</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>移动物体穿过墙体</td>
      <td>使用了 <code class="language-plaintext highlighter-rouge">transform.position</code> 移动刚体</td>
      <td>改用 <code class="language-plaintext highlighter-rouge">Rigidbody.MovePosition()</code></td>
      <td>物理、穿透</td>
    </tr>
    <tr>
      <td>刚体滑动不自然</td>
      <td>没有设置 Drag、Mass 等属性</td>
      <td>设置合理的阻力与摩擦系数</td>
      <td>物理</td>
    </tr>
    <tr>
      <td>触发器触发失效</td>
      <td>Collider 未勾选 isTrigger，或 Rigidbody 缺失</td>
      <td>确保至少一方含 Rigidbody 且 Collider 是触发器</td>
      <td>物理、触发器</td>
    </tr>
  </tbody>
</table>

<h2 id="class5-资源加载与管理">Class5 资源加载与管理</h2>

<table>
  <thead>
    <tr>
      <th>现象</th>
      <th>原因</th>
      <th>解决方式</th>
      <th>标签</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Resources.Load 的资源未释放</td>
      <td>Destroy 了物体但资源仍驻留内存</td>
      <td>调用 <code class="language-plaintext highlighter-rouge">Resources.UnloadUnusedAssets()</code></td>
      <td>内存、加载</td>
    </tr>
    <tr>
      <td>Addressables 资源释放失败</td>
      <td>未调用 <code class="language-plaintext highlighter-rouge">Release()</code></td>
      <td>每次加载后使用 <code class="language-plaintext highlighter-rouge">Addressables.Release(handle)</code></td>
      <td>Addressables</td>
    </tr>
    <tr>
      <td>AudioClip 提前中断</td>
      <td>多个 AudioSource 播放相同 Clip 被覆盖</td>
      <td>用 <code class="language-plaintext highlighter-rouge">PlayOneShot</code> 或动态创建 AudioSource</td>
      <td>音频、资源</td>
    </tr>
  </tbody>
</table>

<h2 id="class6-生命周期与协程">Class6 生命周期与协程</h2>

<table>
  <thead>
    <tr>
      <th>现象</th>
      <th>原因</th>
      <th>解决方式</th>
      <th>标签</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">WaitForSeconds()</code> 在暂停时不起作用</td>
      <td>依赖 <code class="language-plaintext highlighter-rouge">Time.timeScale</code>，暂停后为 0</td>
      <td>使用 <code class="language-plaintext highlighter-rouge">WaitForSecondsRealtime()</code></td>
      <td>协程、暂停</td>
    </tr>
    <tr>
      <td>Update 在隐藏物体时仍执行</td>
      <td>脚本和 GameObject 仍处于 enabled 状态</td>
      <td>手动控制 <code class="language-plaintext highlighter-rouge">enabled = false</code></td>
      <td>生命周期</td>
    </tr>
    <tr>
      <td>OnDisable 未被调用</td>
      <td>GameObject 被销毁不是禁用</td>
      <td>区分 <code class="language-plaintext highlighter-rouge">Destroy</code> 与 <code class="language-plaintext highlighter-rouge">SetActive(false)</code></td>
      <td>生命周期、事件</td>
    </tr>
  </tbody>
</table>

<h2 id="class7-性能优化相关">Class7 性能优化相关</h2>

<table>
  <thead>
    <tr>
      <th>现象</th>
      <th>原因</th>
      <th>解决方式</th>
      <th>标签</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>场景切换时卡顿</td>
      <td>同步加载资源或过多 Awake 初始化</td>
      <td>用 <code class="language-plaintext highlighter-rouge">LoadSceneAsync</code>，资源异步预加载</td>
      <td>性能、加载</td>
    </tr>
    <tr>
      <td>Update() 性能开销大</td>
      <td>多个脚本使用 Update，逻辑分散</td>
      <td>使用事件驱动 + 管理器合并 Update</td>
      <td>性能、架构</td>
    </tr>
    <tr>
      <td>GC Alloc 频繁</td>
      <td>每帧创建新对象（如字符串、new Vector3）</td>
      <td>复用变量、使用对象池</td>
      <td>性能、GC</td>
    </tr>
  </tbody>
</table>

<h2 id="class8-编译器-vs-构建行为差异">Class8 编译器 vs 构建行为差异</h2>

<table>
  <thead>
    <tr>
      <th>现象</th>
      <th>原因</th>
      <th>解决方式</th>
      <th>标签</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>编辑器正常，打包后报错</td>
      <td>使用了 <code class="language-plaintext highlighter-rouge">UnityEditor</code> API</td>
      <td>用 <code class="language-plaintext highlighter-rouge">#if UNITY_EDITOR</code> 包裹</td>
      <td>构建、平台差异</td>
    </tr>
    <tr>
      <td>场景中未勾选物体在运行时出现</td>
      <td>被代码运行时 Instantiate</td>
      <td>确认代码逻辑未动态生成</td>
      <td>构建、场景管理</td>
    </tr>
    <tr>
      <td>路径访问失败</td>
      <td>各平台 <code class="language-plaintext highlighter-rouge">persistentDataPath</code> 不一致</td>
      <td>使用平台判断封装路径</td>
      <td>IO、平台兼容</td>
    </tr>
  </tbody>
</table>

<h1 id="class1-交互相关-1">Class1 交互相关</h1>
<h2 id="1多个可交互物体输入触发多个">1.多个可交互物体，输入触发多个</h2>
<ul>
  <li>场景：靠近多个箱子同时按下<code class="language-plaintext highlighter-rouge">E</code>，多个箱子一起打开</li>
  <li>原因：所有物体监听<code class="language-plaintext highlighter-rouge">E</code>，没有加距离或唯一判定</li>
  <li>解决方案：只响应最近/朝向前方的一个对象</li>
</ul>

<h2 id="2trigger触发多次enterexit">2.Trigger触发多次Enter/Exit</h2>
<ul>
  <li>场景：一个对象靠近某个Trigger区域，<code class="language-plaintext highlighter-rouge">OnTriggerEnter</code>被触发两次</li>
  <li>原因：
    <ul>
      <li>可能身上挂有多个Collider</li>
      <li>或包含子物体的Collider也触发了</li>
    </ul>
  </li>
  <li>解决方案：确认是否是重复触发，加入<code class="language-plaintext highlighter-rouge">other.gameObject == expectedObject</code>判断</li>
</ul>

<h2 id="3button-ui点击两次才响应">3.Button UI点击两次才响应</h2>
<ul>
  <li>原因：
    <ul>
      <li>UI按钮背后有透明/未关闭的UI元素挡住射线</li>
      <li>或者EventSystem被禁用、Canvas未设置正确Sorting Order</li>
    </ul>
  </li>
  <li>解决方案：调试Graphic Raycaster、Canvas排序、Raycast Target勾选项</li>
</ul>

<h1 id="class2-物理系统相关">Class2 物理系统相关</h1>
<h2 id="1rigidbody设置position导致穿透">1.Rigidbody设置position导致穿透</h2>
<ul>
  <li>使用<code class="language-plaintext highlighter-rouge">transform.position = ...</code>设置刚体位置，会跳过物理引擎检测，导致穿墙</li>
  <li>正确做法：使用<code class="language-plaintext highlighter-rouge">Rigidbody.MovePosition()</code></li>
</ul>

<h2 id="2collider和rigidbody的组合错误">2.Collider和Rigidbody的组合错误</h2>
<ul>
  <li>常见错误组合
    <ul>
      <li>静态物体（如地面）用了非Kinematic的Rigidbody</li>
      <li>移动物体没加Rigidbody，靠transform移动导致物理行为异常</li>
    </ul>
  </li>
  <li>Unity的推荐：
    <ul>
      <li>静态物体（地面）用Collider，无Rigidbody</li>
      <li>动态物体加Rigidbody，控制用物理接口</li>
    </ul>
  </li>
</ul>

<h1 id="class3-生命周期相关">Class3 生命周期相关</h1>
<h2 id="1协程中的waitforseconds在timescale为0时失效">1.协程中的<code class="language-plaintext highlighter-rouge">WaitForSeconds</code>在TimeScale为0时失效</h2>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">StartCoroutine</span><span class="p">(</span><span class="nf">Example</span><span class="p">());</span>

<span class="n">IEnumerator</span> <span class="nf">Example</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">WaitForSeconds</span><span class="p">(</span><span class="m">2f</span><span class="p">);</span> <span class="c1">// 如果Time.timeScale == 0，不会等待</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>解决方案：用`WaitForSecondRealtime(2f);</li>
</ul>

<h2 id="2脚本的update仍被调用虽然物体不可见">2.脚本的<code class="language-plaintext highlighter-rouge">Update()</code>仍被调用，虽然物体不可见</h2>
<ul>
  <li>即使物体在摄像机外、隐藏或inactive子物体，只要GameObject时active的、脚本时enable的，Update就会继续执行</li>
</ul>

<h1 id="class4-动画系统相关">Class4 动画系统相关</h1>
<h2 id="1animator动画不能立即切换">1.Animator动画不能立即切换</h2>
<ul>
  <li>使用<code class="language-plaintext highlighter-rouge">SetTrigger</code>后动画没反应，原因是当前状态没有达到可以跳转的条件或冷却没完成</li>
  <li>解决方案：Animator控制器中正确配置Transition，并关闭<code class="language-plaintext highlighter-rouge">Has Exit Time</code>（除非需要完整播放）</li>
</ul>

<h2 id="2animator状态机切换卡顿或不触发">2.Animator状态机切换卡顿或不触发</h2>
<ul>
  <li>在代码里调用了：
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">animator</span><span class="p">.</span><span class="nf">SetBool</span><span class="p">(</span><span class="s">"isOpen"</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
<span class="n">animator</span><span class="p">.</span><span class="nf">Play</span><span class="p">(</span><span class="s">"Open"</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>原因：设置参数后马上<code class="language-plaintext highlighter-rouge">Play</code>，但Unity还没更新Animator的状态，应延迟一帧或合并状态逻辑</li>
</ul>

<h1 id="class5-资源加载与内存相关">Class5 资源加载与内存相关</h1>
<h2 id="1addressables或resourcesload的资源加载了但没释放">1.Addressables或Resources.Load的资源加载了但没释放</h2>
<ul>
  <li>开发中用完资源后<code class="language-plaintext highlighter-rouge">Destroy(obj)</code>了，却发现内存依然飙高</li>
  <li>原因：Unity对部分资源（如Texture、Mesh）会做缓存，要手动调用<code class="language-plaintext highlighter-rouge">Resources.UnloadUnusedAssets()</code>或<code class="language-plaintext highlighter-rouge">Addressables.Release(handle)</code></li>
</ul>

<h2 id="2audioclip播放一半没声音或提前中断">2.AudioClip播放一半没声音或提前中断</h2>
<ul>
  <li>多个<code class="language-plaintext highlighter-rouge">AudioSource</code>播放相同Clip时，其中一个会抢断另一个</li>
  <li>使用<code class="language-plaintext highlighter-rouge">PlayOneShot()</code>或实例化新的AudioSource</li>
</ul>

<h1 id="class6-编译器运行与构建差异">Class6 编译器运行与构建差异</h1>
<h2 id="1在editor模式下一切正常打包后就崩溃">1.在Editor模式下一切正常，打包后就崩溃</h2>
<ul>
  <li>原因：用了<code class="language-plaintext highlighter-rouge">AssetDatabase</code>、<code class="language-plaintext highlighter-rouge">EditorUtility</code>、<code class="language-plaintext highlighter-rouge">UnityEditor</code>命名空间代码</li>
  <li>加<code class="language-plaintext highlighter-rouge">#if UNITY_EDITOR</code>包裹相关逻辑</li>
</ul>

<h2 id="2场景中物体没勾选但运行中出现了">2.场景中物体没勾选但运行中出现了</h2>
<ul>
  <li>某些Prefab被脚本<code class="language-plaintext highlighter-rouge">Instantiate()</code>出来了，但在场景中没看到</li>
  <li>检查脚本逻辑力是否有运行时代码加载或启动对象</li>
</ul>]]></content><author><name>ljf12825</name></author><category term="Debug" /><category term="Unity" /><category term="Debug Log" /><summary type="html"><![CDATA[Unity实际开发中，有很多“看起来正常、实则容易出错”的奇怪问题（或称为隐形陷阱）]]></summary></entry><entry><title type="html">Behaviour Tree</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Behaviour-Tree.html" rel="alternate" type="text/html" title="Behaviour Tree" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Behaviour-Tree</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Behaviour-Tree.html"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><category term="AI" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Skybox</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Skybox.html" rel="alternate" type="text/html" title="Skybox" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Skybox</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Skybox.html"><![CDATA[<p>Skybox是一种渲染技术，用于在3D场景中创建远景背景，例如天空、宇宙、城市天际线等<br />
它本质上是一种把纹理图贴在一个立方体（或球体）内侧的技巧，玩家看不到边界，只能看到包裹在四周的“天空”</p>

<h2 id="skybox的类型">Skybox的类型</h2>

<p>Unity中支持几种常见类型的Skybox材质（Shader）：</p>

<table>
  <thead>
    <tr>
      <th>Shader 类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>6 Sided</strong></td>
      <td>使用六张图片分别贴在立方体六个面上（一般来自 HDRI 贴图拆分）</td>
    </tr>
    <tr>
      <td><strong>Cubemap</strong></td>
      <td>使用一个立方体贴图（.cubemap）进行渲染</td>
    </tr>
    <tr>
      <td><strong>Procedural</strong></td>
      <td>程序化天空（可设置太阳、云层、颜色渐变）</td>
    </tr>
    <tr>
      <td><strong>HDRI Skybox (PBR)</strong></td>
      <td>用于高清真实感环境的 HDR 渲染，常用于 Unity HDRP</td>
    </tr>
  </tbody>
</table>

<h2 id="设置skybox的方法">设置Skybox的方法</h2>
<h3 id="1通过lighting设置全局skybox">1.通过Lighting设置全局Skybox</h3>
<p>1.创建一个Skybox材质：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Assets</code>-&gt;右键-&gt;<code class="language-plaintext highlighter-rouge">Create &gt; Material</code></li>
  <li>Shader选择为<code class="language-plaintext highlighter-rouge">Skybox/6 Sided</code>或<code class="language-plaintext highlighter-rouge">Skybox/Cubemap</code>或<code class="language-plaintext highlighter-rouge">Skybox/Procedural</code></li>
</ul>

<p>2.在材质中设置贴图（textures）或参数</p>

<p>3.打开<code class="language-plaintext highlighter-rouge">Window &gt; Rendering &gt; Lighting</code>面板</p>

<p>4.在<code class="language-plaintext highlighter-rouge">Environment &gt; Skybox Material</code>中拖入刚刚的材质</p>

<p>这会将该Skybox应用于整个场景</p>

<h3 id="2通过摄像机设置局部skybox高级">2.通过摄像机设置局部Skybox（高级）</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RenderSettings</span><span class="p">.</span><span class="n">skybox</span> <span class="p">=</span> <span class="n">mySkyboxMaterial</span><span class="p">;</span>
</code></pre></div></div>
<p>或为相机设置<code class="language-plaintext highlighter-rouge">Skybox</code>组件并赋值</p>

<h3 id="skybox与lighting的关系">Skybox与Lighting的关系</h3>
<p>Skybox不只是视觉上的背景，它还影响了：</p>
<ul>
  <li>Ambient Lighting（环境光）</li>
  <li>Reflection Probe（反射探针）</li>
  <li>全局光照（GI）计算</li>
</ul>

<p>所以换Skybox后记得：</p>
<ul>
  <li>在Lighting界面点击“Generate Lighting”</li>
  <li>使用Reflection Probe重新采样环境反射</li>
</ul>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity Component" /><category term="Light" /><category term="Render" /><category term="Graphics" /><summary type="html"><![CDATA[Skybox是一种渲染技术，用于在3D场景中创建远景背景，例如天空、宇宙、城市天际线等 它本质上是一种把纹理图贴在一个立方体（或球体）内侧的技巧，玩家看不到边界，只能看到包裹在四周的“天空”]]></summary></entry><entry><title type="html">Unity Performance Tuning</title><link href="http://localhost:4000/posts/2025-06-13-Unity-Performance-Tuning/" rel="alternate" type="text/html" title="Unity Performance Tuning" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Unity-Performance-Tuning</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-13-Unity-Performance-Tuning/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Import Assets</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets.html" rel="alternate" type="text/html" title="Import Assets" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets.html"><![CDATA[<p>Unity支持多种格式的资源文件，并能自动识别并进行初步处理</p>

<h2 id="资源导入基本流程">资源导入基本流程</h2>
<p><strong>1.将资源文件拖入<code class="language-plaintext highlighter-rouge">Assets</code>目录中（Unity会自动导入）</strong><br />
<strong>2.在Inspector面板中查看导入设置</strong><br />
<strong>3.配置相关参数，比如压缩方式、贴图类型、是否生成碰撞体等</strong><br />
<strong>4.使用资源（拖到场景、作为材质贴图、挂到AudioSource等）</strong></p>

<h2 id="模型">模型</h2>

<h3 id="支持格式">支持格式</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.fbx</code>推荐</li>
  <li><code class="language-plaintext highlighter-rouge">.obj</code></li>
  <li><code class="language-plaintext highlighter-rouge">.dae</code>（Collada）</li>
  <li><code class="language-plaintext highlighter-rouge">.blend</code>（需要Blender）</li>
</ul>

<h3 id="导入流程">导入流程</h3>
<p>1.拖拽<code class="language-plaintext highlighter-rouge">.fbx</code>文件到<code class="language-plaintext highlighter-rouge">Assets</code>文件夹<br />
2.选中模型文件，查看<code class="language-plaintext highlighter-rouge">Inspector</code>的导入设置</p>
<ul>
  <li>Scale Factor：缩放（一般保持默认）</li>
  <li>Import Animations：是否导入动画</li>
  <li>Import Materials：是否导入材质</li>
  <li>Generate Colliders：是否自动生成碰撞体</li>
</ul>

<h3 id="导入后组成">导入后组成</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Model</code>: 3D网格</li>
  <li><code class="language-plaintext highlighter-rouge">Rig</code>（如果有骨骼）：用于动画绑定</li>
  <li><code class="language-plaintext highlighter-rouge">Animation</code>：包含的动画片段</li>
  <li><code class="language-plaintext highlighter-rouge">Materials</code>：自动生成或关联的材质</li>
</ul>

<h2 id="贴图">贴图</h2>

<h3 id="支持格式-1">支持格式</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.png</code>、<code class="language-plaintext highlighter-rouge">.jpg</code>、<code class="language-plaintext highlighter-rouge">.tga</code>、<code class="language-plaintext highlighter-rouge">.psd</code>（支持图层）等</li>
</ul>

<h3 id="导入流程-1">导入流程</h3>

<p>1.拖入图片文件
2.在Inspector中设置：</p>
<ul>
  <li>sRGB（Color Texture）：颜色贴图用，法线贴图需取消勾选</li>
  <li>Alpha Is Transparency：如果使用透明通道</li>
  <li>Wrap Mode：Repeat（平铺）或Clamp（拉伸）</li>
  <li>Filter Mode：Bilinear、Trilinear、Point（像素风）</li>
  <li>Compression：高压缩（小体积）还是高质量（清晰）</li>
  <li>Texture Type:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Default</code>（通用）</li>
      <li><code class="language-plaintext highlighter-rouge">Sprite</code>（用于UI）</li>
      <li><code class="language-plaintext highlighter-rouge">Normal map</code>（法线贴图）</li>
      <li><code class="language-plaintext highlighter-rouge">Lightmap</code>（光照图）</li>
    </ul>
  </li>
</ul>

<h2 id="音频">音频</h2>

<h3 id="支持格式-2">支持格式</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.mp3</code>（压缩）</li>
  <li><code class="language-plaintext highlighter-rouge">.wav</code>（无损）</li>
  <li><code class="language-plaintext highlighter-rouge">.ogg</code>（高效）</li>
  <li><code class="language-plaintext highlighter-rouge">.aiff</code></li>
</ul>

<h2 id="导入流程-2">导入流程</h2>

<p>1.拖入音频文件<br />
2.在<code class="language-plaintext highlighter-rouge">Inspector</code>中设置：</p>
<ul>
  <li>Load Type：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Decompress On Load</code>（加载时解压，适合短音效）</li>
      <li><code class="language-plaintext highlighter-rouge">Streaming</code>（边播放边加载，适合背景音乐）</li>
    </ul>
  </li>
  <li>Compression Format:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Vorbis</code>、<code class="language-plaintext highlighter-rouge">ADPCM</code>、<code class="language-plaintext highlighter-rouge">PCM</code></li>
    </ul>
  </li>
  <li>3D Sound：是否启用3D空间化</li>
  <li>Loop：是否循环播放</li>
</ul>

<blockquote>
  <p><strong>资源组织建议：</strong> 使用好的文件夹结构和命名习惯，可以极大提高开发效率</p>
</blockquote>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><summary type="html"><![CDATA[Unity支持多种格式的资源文件，并能自动识别并进行初步处理]]></summary></entry><entry><title type="html">Layer</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Layer.html" rel="alternate" type="text/html" title="Layer" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Layer</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Layer.html"><![CDATA[<p>在Unity中，Layer是要给非常重要的系统<br />
它主要用于：</p>
<ul>
  <li>控制物体的渲染与相机的可见性</li>
  <li>控制物理碰撞（配合Layer Collision Matrix）</li>
  <li>通过脚本进行物体分类和筛选</li>
</ul>

<h2 id="什么是layer">什么是Layer</h2>

<p>Layer是给GameObject打的“标签”，但它和<code class="language-plaintext highlighter-rouge">Tag</code>不一样，Layer是用于功能性控制的，特别在：</p>
<ul>
  <li>摄像机的Culling Mask</li>
  <li>光照影响（Light Culling）</li>
  <li>物理碰撞（Physics Layer）</li>
  <li>射线检测（Raycast Layer）</li>
</ul>

<h2 id="layer的使用场景">Layer的使用场景</h2>
<h3 id="1摄像机视野控制culling-mask">1.摄像机视野控制（Culling Mask）</h3>
<p>在Camera组件中，你可以设置</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Culling Mask -&gt; 选择哪些Layer可以被该相机看到
</code></pre></div></div>

<p><strong>用途：</strong></p>
<ul>
  <li>UI相机只看UI层</li>
  <li>小地图相机只看敌人层</li>
  <li>分屏镜头每个只看自己的部分</li>
</ul>

<h3 id="2物理碰撞控制layer-collision-matrix">2.物理碰撞控制（Layer Collision Matrix）</h3>
<p>在菜单中：</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Edit</span> <span class="s">-&gt;</span> <span class="s">Project</span> <span class="s">Settings</span> <span class="s">-&gt;</span> <span class="s">Physics</span>
</code></pre></div></div>

<p>你可以看到Layer Collision Matrix，它控制：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>哪些Layer和哪些Layer能发生物理碰撞
</code></pre></div></div>

<p><strong>用途：</strong></p>
<ul>
  <li>玩家层与敌人层可以碰撞，但不和自身碰撞</li>
  <li>子弹不撞自己</li>
  <li>角色不被UI的Collider打断</li>
</ul>

<h3 id="3射线检测">3.射线检测</h3>
<p>可以通过Layer来控制射线是否命中某个对象</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">layerMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Physics</span><span class="p">.</span><span class="nf">Raycast</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="k">out</span> <span class="n">hit</span><span class="p">,</span> <span class="m">100f</span><span class="p">,</span> <span class="n">layerMask</span><span class="p">))</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Hit enemy"</span><span class="p">);</span>
</code></pre></div></div>

<p>也可以多层合并：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">mask</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">))</span> <span class="p">|</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"NPC"</span><span class="p">));</span>
</code></pre></div></div>
<h2 id="内置与自定义layer">内置与自定义Layer</h2>

<h3 id="内置layerunity默认的">内置Layer（Unity默认的）</h3>

<table>
  <thead>
    <tr>
      <th>编号</th>
      <th>名称</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>Default</td>
      <td>默认层</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Water</td>
      <td>水体特效</td>
    </tr>
    <tr>
      <td>5</td>
      <td>UI</td>
      <td>UI 专用</td>
    </tr>
  </tbody>
</table>

<h3 id="自定义layer">自定义Layer</h3>
<p>Unity允许你最多使用32个Layer（编号 0~31），其中前几个是保留的<br />
自定义方式：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">选中</span> <span class="n">GameObject</span> <span class="o">-&gt;</span> <span class="n">Inspector</span> <span class="o">-&gt;</span> <span class="n">Layer</span> <span class="o">-&gt;</span> <span class="k">Add</span> <span class="n">Layer</span><span class="p">...</span>
</code></pre></div></div>
<p>添加后可为GameObject设置：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Layer</span> <span class="s">-&gt;</span> <span class="s">你刚添加的层名</span>
</code></pre></div></div>
<h2 id="layer与tag的区别">Layer与Tag的区别</h2>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>Layer</th>
      <th>Tag</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>数量限制</td>
      <td>最多 32 个</td>
      <td>无限制</td>
    </tr>
    <tr>
      <td>用于渲染控制</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>用于物理控制</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>用于分类查找</td>
      <td>有限制（用 LayerMask）</td>
      <td>✅（用 CompareTag 等）</td>
    </tr>
    <tr>
      <td>性能优化</td>
      <td>✅（用于剔除、射线过滤）</td>
      <td>❌</td>
    </tr>
  </tbody>
</table>

<h3 id="建议">建议</h3>
<ul>
  <li>给每种功能的对象分配专属Layer</li>
  <li>摄像机、光源、UI、Trigger检测都应依赖Layer控制逻辑</li>
</ul>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><summary type="html"><![CDATA[在Unity中，Layer是要给非常重要的系统 它主要用于： 控制物体的渲染与相机的可见性 控制物理碰撞（配合Layer Collision Matrix） 通过脚本进行物体分类和筛选]]></summary></entry></feed>