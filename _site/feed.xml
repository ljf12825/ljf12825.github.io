<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-07-18T22:22:48+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ljf12825’s Blog</title><subtitle>Efficient &amp; Elegant</subtitle><author><name>Jeff Lee</name><email>2548278761@qq.com</email></author><entry><title type="html">Unity Packaging and Building</title><link href="http://localhost:4000/posts/2025-07-18-Unity-Packaging-and-Building/" rel="alternate" type="text/html" title="Unity Packaging and Building" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Unity-Packaging-and-Building</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-18-Unity-Packaging-and-Building/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Build" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Layout</title><link href="http://localhost:4000/posts/2025-06-11-Layout/" rel="alternate" type="text/html" title="Layout" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Layout</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-11-Layout/"><![CDATA[<h2 id="layout-system">Layout System</h2>
<p><img src="/assets/images/LayoutSystem.jpg" alt="LayoutSystem" /></p>

<h3 id="layout-group">Layout Group</h3>
<p><code class="language-plaintext highlighter-rouge">Layout Group</code>是Unity UI自动布局系统的核心组件之一，用于在UI Canvas下自动排列其他子物体。它极大地简化了UI元素的排列和适配逻辑，让UI开发变得更结构化、响应式、更易维护</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Layout Group</code>是一类MonoBehaviour脚本，用于自动排列RectTransform子物体的位置与尺寸，不需要你手动拖动它们</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>说明</th>
      <th>用途示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HorizontalLayoutGroup</code></td>
      <td>子物体沿 <strong>水平方向排列</strong></td>
      <td>菜单栏、工具条、横向列表</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">VerticalLayoutGroup</code></td>
      <td>子物体沿 <strong>垂直方向排列</strong></td>
      <td>聊天记录、竖向按钮组</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GridLayoutGroup</code></td>
      <td>子物体按 <strong>网格排列</strong>（行列）</td>
      <td>背包格子、关卡选择界面</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LayoutGroup</code></td>
      <td>抽象基类</td>
      <td>不直接使用</td>
    </tr>
  </tbody>
</table>

<h4 id="horizontal--vertical-layout-group">Horizontal / Vertical Layout Group</h4>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Padding</code></td>
      <td>容器四周的边距</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Spacing</code></td>
      <td>子物体之间的间隔</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Child Alignment</code></td>
      <td>子物体在主轴上的对齐方式（左/中/右）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Reverse Arrangement</code></td>
      <td>排列方向反转：从上到下 → 从下到上</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Control Child Size</code></td>
      <td>控制子物体是否填满空间</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Use Child Scale</code></td>
      <td>是否使用子物体的缩放比例</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Child Force Expand</code></td>
      <td>启用时多个子物体会调整间距，以填充满Width或Height</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Horizontal Layout Group适用场景：菜单栏、Tab标签页、道具快捷栏等</p>
</blockquote>

<blockquote>
  <p>Vertical Layout Group适用场景：排行榜列表、聊天内容、选项按钮组等</p>
</blockquote>

<h4 id="grid-layout-group">Grid Layout Group</h4>
<p>用于将子物体排列成规则网格，每个格子的大小统一</p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Padding</code></td>
      <td>容器四周的边距</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Cell Size</code></td>
      <td>每个格子的宽高</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Spacing</code></td>
      <td>格子之间的间距</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Start Corner</code></td>
      <td>从哪个角开始排列</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Start Axis</code></td>
      <td>是优先横向填充还是纵向</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Child Alignment</code></td>
      <td>子物体整体对齐方式</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Constraint</code></td>
      <td>行数/列数限制（可固定行或列）</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>使用场景：背包系统、九宫格、商城道具、分页列表</p>
</blockquote>

<h4 id="常见问题">常见问题</h4>

<table>
  <thead>
    <tr>
      <th>问题</th>
      <th>原因 / 解决方式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>改了内容不刷新布局</td>
      <td>调用 <code class="language-plaintext highlighter-rouge">LayoutRebuilder.ForceRebuildLayoutImmediate()</code></td>
    </tr>
    <tr>
      <td>动态添加元素时抖动</td>
      <td>先 <code class="language-plaintext highlighter-rouge">SetActive(false)</code> 再添加，最后 <code class="language-plaintext highlighter-rouge">SetActive(true)</code></td>
    </tr>
    <tr>
      <td>动画或手动设置位置被覆盖</td>
      <td>LayoutGroup 会自动控制，需禁用 LayoutGroup 才能手动操作</td>
    </tr>
    <tr>
      <td>ContentSizeFitter + LayoutGroup 死循环</td>
      <td>不要放在同一个 GameObject 上</td>
    </tr>
  </tbody>
</table>

<h3 id="layout-element">Layout Element</h3>
<p><code class="language-plaintext highlighter-rouge">Layout Element</code>用于告诉布局系统如何排布当前UI元素，它本身不会影响UI的大小或位置，而是为其所在的<code class="language-plaintext highlighter-rouge">Layout Group</code>提供布局建议（尺寸、优先级等），从而参与整个UI的自动布局流程</p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>含义</th>
      <th>举例说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Ignore Layout</strong></td>
      <td>是否忽略布局系统</td>
      <td>设置为 <code class="language-plaintext highlighter-rouge">true</code> 会让 Layout Group 忽略它</td>
    </tr>
    <tr>
      <td><strong>Min Width / Height</strong></td>
      <td>最小宽高</td>
      <td>不小于这个尺寸</td>
    </tr>
    <tr>
      <td><strong>Preferred Width / Height</strong></td>
      <td>首选宽高</td>
      <td>想要的尺寸（如果有空间）</td>
    </tr>
    <tr>
      <td><strong>Flexible Width / Height</strong></td>
      <td>灵活宽高</td>
      <td>有多大就能占多大，类似“权重” ，多个元素剩余空间分配按权重计算</td>
    </tr>
    <tr>
      <td><strong>Layout Priority</strong></td>
      <td>优先级</td>
      <td>如果GameObject上有多个布局相关组件，按优先级顺序计算，优先级与数值成正比</td>
    </tr>
  </tbody>
</table>

<h4 id="常见用途">常见用途</h4>

<table>
  <thead>
    <tr>
      <th>场景</th>
      <th>使用方式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>某个按钮不想自动拉伸</td>
      <td>设置 <code class="language-plaintext highlighter-rouge">Flexible Width = 0</code></td>
    </tr>
    <tr>
      <td>聊天条自动增长宽度</td>
      <td>设置 <code class="language-plaintext highlighter-rouge">Preferred Width = Text 宽度</code></td>
    </tr>
    <tr>
      <td>图片强制保持比例</td>
      <td>设置 <code class="language-plaintext highlighter-rouge">Preferred Width/Height</code> 同步更新</td>
    </tr>
    <tr>
      <td>某个子元素不参与布局</td>
      <td>勾选 <code class="language-plaintext highlighter-rouge">Ignore Layout</code></td>
    </tr>
  </tbody>
</table>

<h3 id="content-size-fitter">Content Size Fitter</h3>
<p><code class="language-plaintext highlighter-rouge">Content Size Fitter</code>用于让UI元素根据其子元素或自身内容的大小，自动调整RectTransform的尺寸，是实现响应式UI的关键工具之一</p>

<p>比如：让聊天气泡、弹窗、按钮、文字背景根据内容自动扩展</p>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Horizontal Fit</strong></td>
      <td>enum</td>
      <td>控制横向尺寸的自动适配方式</td>
    </tr>
    <tr>
      <td><strong>Vertical Fit</strong></td>
      <td>enum</td>
      <td>控制纵向尺寸的自动适配方式</td>
    </tr>
  </tbody>
</table>

<p>每个方向的选项有三种：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Unconstrained</code>（不自动适配，默认）</li>
  <li><code class="language-plaintext highlighter-rouge">Min Size</code>（缩小到最小可用大小）</li>
  <li><code class="language-plaintext highlighter-rouge">Preferred Size</code>（扩展到推荐大小）</li>
</ul>

<h4 id="常见用途-1">常见用途</h4>

<table>
  <thead>
    <tr>
      <th>使用场景</th>
      <th>使用方式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>聊天气泡自动撑开</td>
      <td><code class="language-plaintext highlighter-rouge">Vertical Fit = Preferred Size</code>（文本高度）<br /><code class="language-plaintext highlighter-rouge">Horizontal Fit = Preferred Size</code>（文本宽度）</td>
    </tr>
    <tr>
      <td>按钮随文字自适应宽度</td>
      <td>按钮 Image + Text + <code class="language-plaintext highlighter-rouge">ContentSizeFitter</code></td>
    </tr>
    <tr>
      <td>ScrollView 内容自动撑开</td>
      <td>在 Content 上加 <code class="language-plaintext highlighter-rouge">ContentSizeFitter</code> + <code class="language-plaintext highlighter-rouge">Layout Group</code></td>
    </tr>
    <tr>
      <td>警告弹窗根据文本自动扩展大小</td>
      <td>Text + 背景图 + ContentSizeFitter</td>
    </tr>
  </tbody>
</table>

<h4 id="常见问题-1">常见问题</h4>

<table>
  <thead>
    <tr>
      <th>问题</th>
      <th>原因 &amp; 解决方案</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>和 LayoutGroup 冲突</td>
      <td><strong>不要把 ContentSizeFitter 和 LayoutGroup 放在同一个 GameObject 上</strong>，要分开：父挂 LayoutGroup，子挂 ContentSizeFitter</td>
    </tr>
    <tr>
      <td>内容变了但尺寸没变</td>
      <td>调用：<code class="language-plaintext highlighter-rouge">LayoutRebuilder.ForceRebuildLayoutImmediate(transform as RectTransform)</code> 手动刷新</td>
    </tr>
    <tr>
      <td>不生效</td>
      <td>子物体未使用 <code class="language-plaintext highlighter-rouge">LayoutElement</code> 或未正确设置 <code class="language-plaintext highlighter-rouge">Preferred Size</code></td>
    </tr>
    <tr>
      <td>UI 抖动</td>
      <td>动态内容更新太频繁，建议只在必要时刷新布局</td>
    </tr>
  </tbody>
</table>

<h4 id="示例">示例</h4>
<h5 id="动态文字撑开背景">动态文字撑开背景</h5>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">TextMeshProUGUI</span> <span class="n">messageText</span><span class="p">;</span>
<span class="k">public</span> <span class="n">RectTransform</span> <span class="n">bubble</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">SetMessage</span><span class="p">(</span><span class="kt">string</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">messageText</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">msg</span><span class="p">;</span>
  <span class="n">LayoutRebuilder</span><span class="p">.</span><span class="nf">ForceRebuildLayoutImmediate</span><span class="p">(</span><span class="n">bubble</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="聊天列表自动滚到底">聊天列表自动滚到底</h5>
<p>搭配<code class="language-plaintext highlighter-rouge">ScrollRect</code>：</p>
<ul>
  <li>在<code class="language-plaintext highlighter-rouge">Content</code>上加<code class="language-plaintext highlighter-rouge">VerticalLayoutGroup + ContentSizeFitter</code></li>
  <li>发送新消息后滚动到底部</li>
</ul>

<h3 id="aspect-ratio-fitter">Aspect Ratio Fitter</h3>
<p><code class="language-plaintext highlighter-rouge">Aspect Ratio Fitter</code>用于强制一个UI元素保持固定的宽高比（Aspect Ratio），无论父物体如何拉伸、屏幕怎么变化，它都能保持比例不变</p>

<p>通常用于：</p>
<ul>
  <li>图片防拉伸</li>
  <li>视频播放器窗口</li>
  <li>正方形/圆形按钮保持比例</li>
  <li>多分辨率适配中的UI统一性</li>
</ul>

<h4 id="属性说明">属性说明</h4>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>类型</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Aspect Mode</strong></td>
      <td>枚举</td>
      <td>控制哪个方向跟随调整以维持宽高比</td>
    </tr>
    <tr>
      <td><strong>Aspect Ratio</strong></td>
      <td>float</td>
      <td>目标宽高比（width / height）</td>
    </tr>
  </tbody>
</table>

<h5 id="aspect-mode">Aspect Mode</h5>

<table>
  <thead>
    <tr>
      <th>模式</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">None</code></td>
      <td>不启用比例适配</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Width Controls Height</code></td>
      <td>宽度不变，根据宽度调整高度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Height Controls Width</code></td>
      <td>高度不变，根据高度调整宽度</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Fit In Parent</code></td>
      <td>保持比例并完全包含在父物体内（不裁剪）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Envelope Parent</code></td>
      <td>保持比例并<strong>覆盖整个父物体</strong>（可能裁剪）</td>
    </tr>
  </tbody>
</table>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><category term="UGUI" /><summary type="html"><![CDATA[Layout System]]></summary></entry><entry><title type="html">Assets Import and Load</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Assets-Import-and-Load.html" rel="alternate" type="text/html" title="Assets Import and Load" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Assets-Import-and-Load</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Assets-Import-and-Load.html"><![CDATA[<p>如何将外部资源导入到Unity中并在运行时使用</p>

<h2 id="资源导入">资源导入</h2>
<p>资源导入是指Unity将外部资源文件（如.fbx、.png、.mp3等）转换为引擎可以使用的内部格式。导入过程不仅包括将资源放入Unity项目中，还涉及到Unity如何优化、压缩、管理这些资源</p>

<h3 id="资源导入的关键步骤">资源导入的关键步骤</h3>
<ul>
  <li>文件放置：在资源文件中放入Unity项目的<code class="language-plaintext highlighter-rouge">Assets</code>文件中。Unity会自动检测到这些文件，并开始导入流程</li>
  <li>导入设置：在Inspector面板中，选中资源文件后，可以看到不同类型资源的导入设置（如<code class="language-plaintext highlighter-rouge">Texture Type</code>、<code class="language-plaintext highlighter-rouge">Model Import Settings</code>等）。不同的资源类型有不同的设置，影响最终的导入结果
    <ul>
      <li>对于纹理，可以设置纹理的类型（如2D或Sprite），以及压缩选项（如DXT1、DXT5等）</li>
      <li>对于模型，可以设置模型的网格、骨骼、动画等导入选项</li>
      <li>对于音频，可以设置压缩类型、采样率等</li>
    </ul>
  </li>
  <li>资源优化：Unity会根据导入设置自动处理资源，可能会进行压缩、网格简化、生成多种LOD等优化操作</li>
  <li>Meta文件：Unity会为每个导入的资源创建一个<code class="language-plaintext highlighter-rouge">.meta</code>文件，用于保存资源的设置、ID等信息。这个文件对资源管理非常重要，尤其是在团队协作时，避免丢失资源链接</li>
</ul>

<h3 id="常见的资源类型导入">常见的资源类型导入</h3>
<ul>
  <li>
    <p>纹理（Texture）：Unity会自动识别常见的纹理文件类型，并提供压缩、过滤等选项
详见<a href="/posts/2025-06-29-Texture/">Texture 导入</a></p>
  </li>
  <li>
    <p>模型（Models）：Unity支持多种3D模型格式，尤其是<code class="language-plaintext highlighter-rouge">.fbx</code>，并支持自动生成碰撞体、网格和骨骼动画
详见<a href="/posts/2025-06-07-Model/">Model</a></p>
  </li>
  <li>
    <p>音频（Audio）：音频文件支持不同的压缩格式，可以设置为单声道、立体声等
详见<a href="/posts/2025-06-11-Audio-System/">Audio System</a></p>
  </li>
  <li>
    <p>动画（Animations）：可以通过<code class="language-plaintext highlighter-rouge">Animator</code>系统来管理和播放
详见<a href="/posts/2025-06-11-Animation-System/">Animation System</a></p>
  </li>
</ul>

<h2 id="资源加载">资源加载</h2>
<p>在游戏运行时，如何高效地加载和管理这些已经导入的资源至关重要，尤其是在需要加载大量资源时。Unity提供了多种加载资源的方式，以便优化性能和内存使用</p>

<h3 id="class-resources">class Resources</h3>
<p><code class="language-plaintext highlighter-rouge">Resources</code>类在Unity中提供了一种动态加载资产的方式，允许你访问存储在特定文件夹中的对象，如Texture，Prefab，Audio Clips等。这些文件必须存放在项目中名为“Resources”的文件夹内</p>

<h4 id="存放资产到resources文件夹">存放资产到Resources文件夹</h4>
<ul>
  <li>希望在运行时动态加载的所有资产必须存放在名为“Resources”的文件夹中。你可以在<code class="language-plaintext highlighter-rouge">Assets</code>目录下创建多个“Resources”文件夹</li>
  <li>存放在这些文件夹中的资产不会通过Inspector自动引用，因此Unity无法对它们进行优化，直接包含在最终构建中</li>
</ul>

<h4 id="加载方式">加载方式</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Resources.Load()</code>和<code class="language-plaintext highlighter-rouge">Resources.FindObjectsOfTypeAll()</code>函数可以用来加载和访问资产
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Resouces.Load()</code>：按路径加载单个资产</li>
      <li><code class="language-plaintext highlighter-rouge">Resouces.FindObjectsOfTypeAll()</code>：用于查找并访问场景中或<code class="language-plaintext highlighter-rouge">Resources</code>文件夹下的所有对象</li>
    </ul>
  </li>
  <li>使用路径加载资产时，所有存放在<code class="language-plaintext highlighter-rouge">Resources</code>文件夹中的资产会被纳入构建中，这可能导致构建大小增加</li>
</ul>

<h4 id="构建优化问题">构建优化问题</h4>
<p>通常，Unity 会通过 Inspector 曝露对资产的引用，这样在构建时它可以自动计算出哪些资产是实际使用的，从而避免不必要的资源被包含在最终构建中。但如果使用 <code class="language-plaintext highlighter-rouge">Resources</code> 文件夹，Unity 无法做到这一点，因此所有资产都会被包含在构建中，即使你没有使用它们</p>

<h4 id="不推荐过度使用路径加载">不推荐过度使用路径加载</h4>
<p>使用路径名来加载资产会导致代码不那么可复用，因为脚本会硬编码依赖于资产存放的位置。这不如通过Inspector暴露的引用直观和易于维护</p>

<h4 id="使用场景">使用场景</h4>
<p>在一些情况下，直接通过代码加载资产会更方便，特别是在你需要在运行时生成对象时。例如，程序化生成一个游戏物体并为其赋予纹理，或者加载动态生成的资源时，使用 Resources.Load() 会非常方便</p>

<h4 id="内存管理">内存管理</h4>
<p>使用 <code class="language-plaintext highlighter-rouge">Resources.Load()</code> 加载的资产，特别是纹理等资源，可能会占用内存，即使这些实例没有出现在场景中。为了释放内存，可以调用 <code class="language-plaintext highlighter-rouge">Resources.UnloadUnusedAssets()</code> 来卸载不再使用的资源。</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Resources</code>文件夹在创建项目时不会自动生成，需要手动创建这个文件夹才能使用</p>
</blockquote>

<h4 id="api">API</h4>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindObjectsOfTypeAll</code></td>
      <td>返回当前内存中所有指定类型 <code class="language-plaintext highlighter-rouge">T</code> 的对象列表。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstanceIDIsValid</code></td>
      <td>如果给定的实例 ID 对应一个有效的对象，则返回 <code class="language-plaintext highlighter-rouge">true</code>。该对象可能已经被删除或尚未加载到内存中。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstanceIDsToValidArray</code></td>
      <td>将实例 ID 数组转换为布尔数组，指示每个实例 ID 是否对应内存中的有效对象。对象可能已删除或未加载。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstanceIDToObject</code></td>
      <td>将实例 ID 转换为对象引用。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstanceIDToObjectList</code></td>
      <td>将实例 ID 数组转换为对象引用列表。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Load</code></td>
      <td>加载存储在 <code class="language-plaintext highlighter-rouge">Resources</code> 文件夹路径下的指定类型的资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAll</code></td>
      <td>加载 <code class="language-plaintext highlighter-rouge">Resources</code> 文件夹路径下的文件夹或文件中的所有资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAsync</code></td>
      <td>异步加载存储在 <code class="language-plaintext highlighter-rouge">Resources</code> 文件夹路径下的资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnloadAsset</code></td>
      <td>从内存中卸载指定的资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnloadUnusedAssets</code></td>
      <td>卸载未使用的资源，释放内存。</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.unity3d.com/ScriptReference/Resources.html">Unity Scripting Resources</a></p>

<h3 id="asset-bundles">Asset Bundles</h3>
<p>Asset Bundles是Unity的一个资源打包系统，允许开发者将游戏中的资源（如模型、纹理、音频等）打包成一个或多个独立的文件（称为Asset Bundles），以便按需加载。</p>

<p>这种方式适用于大规模资源的管理，尤其是当资源文件较大或需要动态加载时，Asset Bundles提供了比<code class="language-plaintext highlighter-rouge">Resources</code>文件夹更灵活的资源加载和内存管理方式</p>

<h4 id="asset-bundles的核心概念">Asset Bundles的核心概念</h4>
<ul>
  <li>打包：将游戏资源（如纹理、模型、音频等）打包成独立的文件，以便后期按需加载</li>
  <li>加载：通过代码加载Asset Bundles中的资源，而不是将所有资源一次性加载到内存中，从而优化内存使用和加载速度</li>
  <li>卸载：通过代码释放已加载的Asset Bundles资源，确保内存得到有效管理</li>
</ul>

<h4 id="创建asset-bundles">创建Asset Bundles</h4>
<p>创建Asset Bundles的过程涉及将资源打包成独立的文件，这些文件可以在运行时动态加载</p>

<p>打包资源步骤：</p>
<ol>
  <li>设置资源为Asset Bundle：
  在Unity编辑器中，选择资源（如纹理、模型、音频等），在<code class="language-plaintext highlighter-rouge">Inspector</code>面板中为资源分配一个Asset Bundles名称
    <ul>
      <li>在<code class="language-plaintext highlighter-rouge">Inspector</code>中的<code class="language-plaintext highlighter-rouge">Asset Bundle</code>选项设置中，给资源指定一个名字，例如：<code class="language-plaintext highlighter-rouge">MyBundle/Textures</code></li>
    </ul>
  </li>
  <li>构建Asset Bundles
  使用BuildPipeline API构建 Asset Bundles
  ```cs
  using UnityEditor;</li>
</ol>

<p>public class AssetBundleBuilder
  {
    [MenuItem(“Assets/Build Asset Bundles”)]
    static void BuildAllAssetBundles()
    {
      BuildPipeline.BuildAssetBundles(“Assets/AssetBundles”, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows);
    }
  }</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  这段代码会将所有标记为Asset Bundle的资源打包到`Assets/Bundles`目录中，并生成适用于Windows平台的Asset Bundle
    - `BuildAssetBundleOptionjs.None`：没有特殊选项，可以根据需要选择不同的选项（例如压缩、增量构建等）
    - `BuildTarget.StandaloneWindows`：指定构建目标平台，可以选择其他平台

3. 输出：
  构建后，Unity会在指定的目录中生成Asset Bundle文件

#### 加载Asset Bundles
在游戏运行时，可以通过以下方式加载和使用Asset Bundles

加载Asset Bundle：
加载Asset Bundle通常是异步的，避免阻塞主线程，保证游戏运行流畅
- 从文件系统加载Asset Bundle
  ```cs
  using UnityEngine;

  public class AssetBundleLoader : MonoBehaviour
  {
    AssetBundle myLoadedAssetBundle;

    void Start()
    {
      // 异步加载 Asset Bundle
      StartCoroutine(LoadAssetBundleAsync("Assets/AssetBundles/MyBundle"));
    }

    IEnumerator LoadAssetBundleAsync(string bundleUrl)
    {
      // 异步加载Asset Bundle
      AssetBundleCreateRequest bundleRequest = AssetBundle.LoadFromFileAsync(bundleUrl);
      yield return bundleRequest;

      myLoadedAssetBundle = bundleRequest.assetBundle;
      if (myLoadedAssetBundle == null)
      {
        Debug.LogError("Failed to load AssetBundle!");
        yield break;
      }

      // 加载资源
      AssetBundleRequest assetRequest = myLoadedAssetBundle.LoadAssetAsync&lt;Texture&gt;("MyTextrue");
      yield reutrn assetRequest;

      Texture texture = assetRequest.asset as Texture;
      // 使用加载的资源

    }
  }
</code></pre></div></div>

<ul>
  <li>从URL加载Asset Bundle（适用于远程资源）
  如果Asset Bundle存储在远程服务器上，可以使用<code class="language-plaintext highlighter-rouge">UnityWebRequest</code>从URL加载资源
  ```cs
  using UnityEngine;
  using UnityEngine.Networking;</li>
</ul>

<p>public class AssetBundleRemoteLoader : MonoBehaviour
  {
    AssetBundle myLoadedAssetBundle;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void Start()
{
  StartCoroutine(LoadAssetBundleFromURL("http://mycdn.com/assets/MyBundle"));
}

IEnumerator LoadAssetBundleFromURL(string url)
{
  UnityWebRequest www = UnityWebRequestAssetBundle.GetAssetBundle(url);
  yield return www.SendWebRequest();

  if (www.result != UnityWebRequest.Result.Success)
  {
    Debug.LogError("Failed to load AssetBundle from URL!");
    yield break;
  }

  myLoadedAssetBundle = DownloadHandlerAssetBundle.GetContent(www);
  AssetBundleRequest assetRequest = myLoadedAssetBundle.LoadAssetAsync&lt;Texture&gt;("MyTexture");
  yield return assetRequest;

  Texture texture = assetRequest.asset as Texture;
  // 使用加载的资源

}   }   ```
</code></pre></div></div>

<ul>
  <li>加载资源：通过<code class="language-plaintext highlighter-rouge">LoadAssetAsync()</code>或<code class="language-plaintext highlighter-rouge">LoadAsset()</code>方法加载Asset Bundle中的资源， <code class="language-plaintext highlighter-rouge">LoadAssetAsync()</code>更适合异步加载，可以避免阻塞主线程</li>
</ul>

<h4 id="卸载asset-bundle">卸载Asset Bundle</h4>
<p>加载后的Asset Bundle和资源可以通过<code class="language-plaintext highlighter-rouge">Unload()</code>方法释放，以防止内存泄露</p>
<ul>
  <li>卸载资源和Asset Bundle
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myLoadAssetBundle</span><span class="p">.</span><span class="nf">Unload</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
</code></pre></div>    </div>
    <p><code class="language-plaintext highlighter-rouge">false</code>参数意味着只卸载Asset Bundle，不会卸载已经加载的资源。如果设置为<code class="language-plaintext highlighter-rouge">true</code>，则会卸载资源和Asset Bundle</p>
  </li>
</ul>

<h4 id="asset-bundle的优点和缺点">Asset Bundle的优点和缺点</h4>
<p>优点：</p>
<ol>
  <li>按需加载：Asset Bundles 允许你将资源分离成不同的包，并且按需加载，这减少了内存的占用，并提高了加载速度。</li>
  <li>资源分组和优化：你可以将资源按类型或加载频率进行分组（例如，UI 资源、场景资源、远程资源），并根据需要加载，提高游戏性能。</li>
  <li>远程资源加载：Asset Bundles 支持从远程服务器加载资源，非常适合动态内容更新、DLC（可下载内容）和游戏数据包的分发。</li>
  <li>平台兼容性：你可以为不同的平台（Windows、Android、iOS）构建不同的 Asset Bundle，确保在不同平台上使用合适的资源格式。</li>
</ol>

<p>缺点：</p>
<ol>
  <li>管理复杂：随着游戏项目变得越来越大，Asset Bundles 的管理和维护可能变得更加复杂。你需要合理分配资源、管理多个 Asset Bundle、确保版本一致性等。</li>
  <li>版本控制：由于 Asset Bundles 是外部资源包，Unity 并不直接将它们与项目文件一起进行版本控制。你需要单独管理 Asset Bundles 的版本和依赖关系。</li>
  <li>构建时间：Asset Bundles 构建过程可能需要一些时间，尤其是当项目包含大量资源时。</li>
  <li>缓存管理：在远程加载资源时，可能会遇到缓存问题，需要合理设置 CDN 或服务器端的缓存策略，确保资源的最新版本被加载。</li>
</ol>

<h4 id="api-1">API</h4>
<p><strong>Static Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">memoryBudgetKB</code></td>
      <td>控制共享的 AssetBundle 加载缓存的大小，默认值为 1MB。</td>
    </tr>
  </tbody>
</table>

<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isStreamedSceneAssetBundle</code></td>
      <td>如果 AssetBundle 包含 Unity 场景文件，则返回 <code class="language-plaintext highlighter-rouge">true</code>。</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Contains</code></td>
      <td>检查 AssetBundle 是否包含特定的对象。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetAllAssetNames</code></td>
      <td>返回 AssetBundle 中所有资源的名称。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetAllScenePaths</code></td>
      <td>返回 AssetBundle 中所有场景的路径。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAllAssets</code></td>
      <td>同步加载 AssetBundle 中包含的所有资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAllAssetsAsync</code></td>
      <td>异步加载 AssetBundle 中包含的所有资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAsset</code></td>
      <td>同步加载 AssetBundle 中的某个资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAssetAsync</code></td>
      <td>异步加载 AssetBundle 中的某个资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAssetWithSubAssets</code></td>
      <td>同步加载 AssetBundle 中的资源及其子资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadAssetWithSubAssetsAsync</code></td>
      <td>异步加载 AssetBundle 中的资源及其子资源。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Unload</code></td>
      <td>卸载 AssetBundle，释放其占用的数据。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnloadAsync</code></td>
      <td>异步卸载 AssetBundle 中的资源。</td>
    </tr>
  </tbody>
</table>

<p><strong>Static Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetAllLoadedAssetBundles</code></td>
      <td>获取当前所有已加载的 AssetBundle 的枚举。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromFile</code></td>
      <td>从磁盘文件同步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromFileAsync</code></td>
      <td>从磁盘文件异步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromMemory</code></td>
      <td>从内存区域同步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromMemoryAsync</code></td>
      <td>从内存区域异步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromStream</code></td>
      <td>从托管流同步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LoadFromStreamAsync</code></td>
      <td>从托管流异步加载 AssetBundle。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">RecompressAssetBundleAsync</code></td>
      <td>异步将下载或存储的 AssetBundle 从一个构建压缩格式重新压缩到另一个。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnloadAllAssetBundles</code></td>
      <td>卸载所有当前加载的 AssetBundle。</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.html">Unity Scripting AssetBundle</a></p>

<h3 id="addressable-assets-system">Addressable Assets System</h3>
<p>这是Unity推荐的现代资源加载方式，通过Addressable Asset System，开发者可以将资源分组并动态加载，支持远程加载资源包，极大地提升了资源管理的灵活性和性能</p>

<h4 id="简介">简介</h4>
<p>Addressable Asset System允许开发者通过地址使用资产，一旦一个资产被标记为“addressable”，它便生成一个地址，可以在任何地方被调用；无论这个资产是在本地或远程，系统都会定位它和它的依赖，然后返回它</p>

<p>通过<code class="language-plaintext highlighter-rouge">Windows-&gt;Asset Management-&gt;Addressables</code>使用地址资源系统</p>

<p>Addressables使用异步加载技术，支持从任意位置加载任意依赖项集合。无论是使用直接引用、传统Asset Bundle还是Resources文件夹，Addressables都可以提供一种更简便的方法</p>

<p><a href="/posts/2025-06-05-Addressables/">Addressables</a></p>

<h2 id="资源卸载">资源卸载</h2>
<p>资源加载后，不及时释放也可能导致内存泄露</p>

<h2 id="资源优化">资源优化</h2>
<p>为了优化资源的加载与使用，Unity有多种工具和策略</p>
<ul>
  <li>Asset Bundles：Unity提供的Asset Bundles可以将资源打包成一个文件，支持按需加载，适合于游戏内容更新或者大规模的资源管理</li>
  <li>内存管理：Unity的内存管理非常关键，尤其是在移动设备或者内存受限的设备上。通过精确的资源加载和卸载策略，可以避免内存占用过多</li>
</ul>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Asset" /><summary type="html"><![CDATA[如何将外部资源导入到Unity中并在运行时使用]]></summary></entry><entry><title type="html">Unity Component Communication</title><link href="http://localhost:4000/posts/2025-07-15-Unity-Component-Communication/" rel="alternate" type="text/html" title="Unity Component Communication" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Unity-Component-Communication</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Unity-Component-Communication/"><![CDATA[<table>
  <thead>
    <tr>
      <th>通信方式</th>
      <th>类型</th>
      <th>是否推荐</th>
      <th>示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetComponent&lt;T&gt;()</code> 直接调用</td>
      <td>显式调用</td>
      <td>推荐</td>
      <td><code class="language-plaintext highlighter-rouge">GetComponent&lt;Health&gt;().TakeDamage(10);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnityEvent</code></td>
      <td>事件系统</td>
      <td>推荐</td>
      <td>在 Inspector 中绑定事件</td>
    </tr>
    <tr>
      <td>C# 委托/事件 (<code class="language-plaintext highlighter-rouge">delegate</code>, <code class="language-plaintext highlighter-rouge">event</code>)</td>
      <td>原生 C#</td>
      <td>推荐</td>
      <td><code class="language-plaintext highlighter-rouge">public event Action OnDead;</code></td>
    </tr>
    <tr>
      <td>接口调用（如 <code class="language-plaintext highlighter-rouge">IDamageable</code>）</td>
      <td>解耦方式</td>
      <td>推荐</td>
      <td><code class="language-plaintext highlighter-rouge">target.GetComponent&lt;IDamageable&gt;()?.TakeDamage()</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ScriptableObject</code> 事件</td>
      <td>高级数据驱动</td>
      <td>推荐</td>
      <td>Game-wide event bus</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">SendMessage()</code> / <code class="language-plaintext highlighter-rouge">BroadcastMessage()</code></strong></td>
      <td>反射调用</td>
      <td>不推荐</td>
      <td><code class="language-plaintext highlighter-rouge">SendMessage("Explode")</code></td>
    </tr>
  </tbody>
</table>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Syntax" /><category term="Unity Class" /><summary type="html"><![CDATA[通信方式 类型 是否推荐 示例 GetComponent&lt;T&gt;() 直接调用 显式调用 推荐 GetComponent&lt;Health&gt;().TakeDamage(10); UnityEvent 事件系统 推荐 在 Inspector 中绑定事件 C# 委托/事件 (delegate, event) 原生 C# 推荐 public event Action OnDead; 接口调用（如 IDamageable） 解耦方式 推荐 target.GetComponent&lt;IDamageable&gt;()?.TakeDamage() ScriptableObject 事件 高级数据驱动 推荐 Game-wide event bus SendMessage() / BroadcastMessage() 反射调用 不推荐 SendMessage("Explode")]]></summary></entry><entry><title type="html">Object</title><link href="http://localhost:4000/posts/2025-07-11-Object/" rel="alternate" type="text/html" title="Object" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Object</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-11-Object/"><![CDATA[<p>Object是Unity中所有内建物体的基类，实现在UnityEngine.CoreModule中，不同于C#中的<code class="language-plaintext highlighter-rouge">System.Object</code>，它是托管层（C#）和原生引擎层（C++）之间的桥梁，背后绑定着Unity C++引擎层的资源句柄</p>

<h2 id="object的特点unity的特有行为">Object的特点（Unity的特有行为）</h2>
<p><strong>引擎资源的绑定</strong></p>

<p>每个<code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>对象都对应一个C++层对象，它们通过一个<code class="language-plaintext highlighter-rouge">instance 2D</code>来关联，且资源的生命周期不由GC管理</p>

<p>比如：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">go</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">();</span>
<span class="n">Object</span><span class="p">.</span><span class="nf">Destroy</span><span class="p">(</span><span class="n">go</span><span class="p">);</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span> <span class="p">==</span> <span class="k">null</span><span class="p">);</span>  <span class="c1">// true</span>
</code></pre></div></div>
<p>这就是Object的“鬼行为”，此处的<code class="language-plaintext highlighter-rouge">go == null</code>并非等价于<code class="language-plaintext highlighter-rouge">object is null</code></p>

<p><strong>Unity的“fake null”机制</strong>
<code class="language-plaintext highlighter-rouge">fake null</code>是Unity中一个特有的概念，通常用来描述已经销毁的对象或者已经不再有效的对象的引用。尽管对象被销毁了，但它仍然存在一个“假”引用，这个引用就像是一个假的<code class="language-plaintext highlighter-rouge">null</code>，它指向的对象实际上已经不再有效，但在代码层面看起来却任然是一个对象。具体来说，<code class="language-plaintext highlighter-rouge">fake null</code>让你能够获得一个对象引用，但该对象的属性和方法无法被正常访问，或者会返回默认值，或者不会产生期望的结果</p>

<p>Unity重写了<code class="language-plaintext highlighter-rouge">==</code>操作符</p>

<p>如果一个<code class="language-plaintext highlighter-rouge">Object</code>对象在引擎层已经被销毁（Destroy过），但C#还保有托管引用，这时候：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span> <span class="p">==</span> <span class="k">null</span><span class="p">);</span> <span class="c1">// true</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="k">null</span><span class="p">));</span> <span class="c1">// false</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="nf">ReferenceEquals</span><span class="p">(</span><span class="n">go</span><span class="p">,</span> <span class="k">null</span><span class="p">));</span> <span class="c1">// false</span>
</code></pre></div></div>

<p>为什么需要fake null</p>
<ol>
  <li>
    <p>避免NullReferenceException
在传统的编程中，如果一个对象被销毁或设为<code class="language-plaintext highlighter-rouge">null</code>，而你还试图访问它的属性或方法，就会引发<code class="language-plaintext highlighter-rouge">NullReferenceException</code>错误。在Unity中，许多对象的销毁并不立即释放内存，尤其是当销毁了一个游戏对象或组件时。为了避免频繁的<code class="language-plaintext highlighter-rouge">null</code>检查和避免程序崩溃，Unity引入了<code class="language-plaintext highlighter-rouge">fake null</code></p>
  </li>
  <li>
    <p>内存管理的优化
Unity并不是立即销毁对象，而是将其“标记”为无效，保持它的引用存在，但无法访问。这使得Unity可以更高效地管理内存。内存的实际释放通常依赖于垃圾回收器，而不是对象销毁后立即释放内存，从而避免频繁的内存分配和释放造成的性能瓶颈</p>
  </li>
</ol>

<p><code class="language-plaintext highlighter-rouge">fake null</code>行为总结</p>
<ol>
  <li>引用存在，但对象无效</li>
  <li>不抛出异常</li>
  <li>确保内存管理不会立即释放内存</li>
</ol>

<h3 id="底层原理">底层原理</h3>
<p>Unity的<code class="language-plaintext highlighter-rouge">Object</code>在C#层其实只是一个代理，它对应的C++引擎层对象通过C#层的<code class="language-plaintext highlighter-rouge">IntPtr m_CachedPtr</code>与C++对象通信（该字段可以在反编译时看到）</p>

<p>资源对象（比如一个贴图）在编译器导入时会被转换为native object，保存在场景或资源文件中，加载时通过Unity自己的反序列化系统生成C#代理对象，并挂接<code class="language-plaintext highlighter-rouge">m_CachedPtr</code></p>

<p>Unity会使用C++引擎进行资源生命周期的管理，而不是C#的GC，所以Destroy调的是C++的释放接口</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sometimes an instance of Object can be in detached state, where there is no underlying native object. T
his can happen if the instance references an native object that has been destroyed, or a missing Asset or missing type. 
Detached objects retain their InstanceID, but the object cannot be used to call methods or access properties. 
An object in this state will appear to be null, because of special implementations of operator==, operator!= and Ojbect.bool.
Because the object is not truly null, a call to Object.ReferenceEquals(myobject, null) will return false.

The null-comditional operator(?.)and the null-coalescing operator(??)are not supported with Unity Object because they cannot be overridden to treat detached objects the same as null.
It is only safe to use those operators in your scripts if there is certainty that the objects being checked are never in a detached state.
</code></pre></div></div>

<h2 id="object-api">Object API</h2>
<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">name</code></td>
      <td><code class="language-plaintext highlighter-rouge">string</code></td>
      <td>对象名称（可读写）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hideFlags</code></td>
      <td><code class="language-plaintext highlighter-rouge">HideFlags</code></td>
      <td>控制对象是否可隐藏/可编辑/保存</td>
    </tr>
  </tbody>
</table>

<p><strong><code class="language-plaintext highlighter-rouge">hideFlags</code></strong><br />
常见用途：</p>
<ul>
  <li>隐藏对象</li>
  <li>防止误删或编辑</li>
  <li>不让对象随着场景保存（通常用于运行时生成的对象）</li>
</ul>

<p>常用枚举值</p>

<table>
  <thead>
    <tr>
      <th>枚举值</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.None</code></td>
      <td>默认行为，无隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideInHierarchy</code></td>
      <td>在 Hierarchy 视图中隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideInInspector</code></td>
      <td>在 Inspector 中隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.NotEditable</code></td>
      <td>不允许用户编辑（灰掉）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSave</code></td>
      <td>场景保存时不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSaveInBuild</code></td>
      <td>打包时不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSaveInEditor</code></td>
      <td>编辑器中不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideAndDontSave</code></td>
      <td>隐藏并不保存（临时对象）</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetInstanceID</code></td>
      <td>获得object的实例ID</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ToString</code></td>
      <td>返回<code class="language-plaintext highlighter-rouge">object.name</code></td>
    </tr>
  </tbody>
</table>

<p><strong>Static Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
      <th>示例/说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Destroy(Object obj)</code></td>
      <td>销毁一个对象，在当前帧结束时生效</td>
      <td><code class="language-plaintext highlighter-rouge">Destroy(gameObject);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Destroy(Object obj, float t)</code></td>
      <td>延迟 t 秒销毁对象</td>
      <td><code class="language-plaintext highlighter-rouge">Destroy(gameObject, 2.0f);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DestroyImmediate(Object obj)</code></td>
      <td>立刻销毁对象，<strong>只推荐在编辑器中使用</strong></td>
      <td><code class="language-plaintext highlighter-rouge">DestroyImmediate(gameObject);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DontDestroyOnLoad(Object target)</code></td>
      <td>场景切换时不销毁该对象</td>
      <td>常用于单例或管理器类</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindAnyObjectByType&lt;T&gt;()</code></td>
      <td>获取任何已加载的指定类型对象（不保证顺序）</td>
      <td>替代旧版 <code class="language-plaintext highlighter-rouge">FindObjectOfType</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindFirstObjectByType&lt;T&gt;()</code></td>
      <td>获取第一个找到的指定类型对象（可能更快）</td>
      <td>常用于初始化查找</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindObjectsByType&lt;T&gt;()</code></td>
      <td>获取所有已加载的指定类型对象</td>
      <td><code class="language-plaintext highlighter-rouge">var allEnemies = FindObjectsByType&lt;Enemy&gt;();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(Object original)</code></td>
      <td>克隆一个对象（创建副本）</td>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(prefab);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(Object original, Vector3 position, Quaternion rotation)</code></td>
      <td>在指定位置和旋转创建克隆</td>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(prefab, pos, rot);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstantiateAsync(Object original)</code></td>
      <td>异步克隆对象，返回 <code class="language-plaintext highlighter-rouge">AsyncInstantiateOperation</code></td>
      <td>用于 Addressables 或大型对象，节省主线程开销</td>
    </tr>
  </tbody>
</table>

<p><strong>Operators</strong></p>

<table>
  <thead>
    <tr>
      <th>操作符</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否存在</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator!=</code></td>
      <td>比较两个object是否引用不同的物体</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator==</code></td>
      <td>是否引用相同</td>
    </tr>
  </tbody>
</table>

<h2 id="object与资源的关系">Object与资源的关系</h2>
<p>几乎所有资源类型（包括预制体、贴图、材质、音频、动画等）都继承自<code class="language-plaintext highlighter-rouge">Object</code></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Texture</span> <span class="n">tex</span> <span class="p">=</span> <span class="n">Resources</span><span class="p">.</span><span class="n">Load</span><span class="p">&lt;</span><span class="n">Texture</span><span class="p">&gt;(</span><span class="s">"MyTexture"</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Resources.Load&lt;T&gt;()</code>返回的其实就是一个<code class="language-plaintext highlighter-rouge">Object</code>的子类（这里是Texture）</p>

<h2 id="继承关系">继承关系</h2>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Object
  ├── GameObject
  └── Component
        ├── MonoBehaviour
        └── Transform / Collider / Renderer / ...
</code></pre></div></div>
<p>所以可以有：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">go</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">();</span>
<span class="n">Object</span> <span class="n">obj</span> <span class="p">=</span> <span class="n">go</span><span class="p">;</span> <span class="c1">// legal</span>
<span class="n">Component</span> <span class="n">comp</span> <span class="p">=</span> <span class="n">go</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
<span class="n">Object</span> <span class="n">o2</span> <span class="p">=</span> <span class="n">comp</span><span class="p">;</span> <span class="c1">// legal</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">new</code>出来的<code class="language-plaintext highlighter-rouge">GameObject</code>是合法的，但不能<code class="language-plaintext highlighter-rouge">new</code> <code class="language-plaintext highlighter-rouge">Transform</code>或<code class="language-plaintext highlighter-rouge">Renderer</code>，必须用<code class="language-plaintext highlighter-rouge">AddComponent</code>等引擎API创建</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Syntax" /><category term="Unity Class" /><summary type="html"><![CDATA[Object是Unity中所有内建物体的基类，实现在UnityEngine.CoreModule中，不同于C#中的System.Object，它是托管层（C#）和原生引擎层（C++）之间的桥梁，背后绑定着Unity C++引擎层的资源句柄]]></summary></entry><entry><title type="html">Loose Coupling</title><link href="http://localhost:4000/posts/2025-07-15-Loose-Coupling/" rel="alternate" type="text/html" title="Loose Coupling" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Loose-Coupling</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Loose-Coupling/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Architecture" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Native Layer to Script Layer</title><link href="http://localhost:4000/posts/2025-07-15-Native-Layer-to-Script-Layer/" rel="alternate" type="text/html" title="Native Layer to Script Layer" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Native-Layer-to-Script-Layer</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Native-Layer-to-Script-Layer/"><![CDATA[<h2 id="the-bridge-between-native-layer-and-script-layer">The Bridge between Native Layer and Script Layer</h2>
<p>Unity引擎运行时，本质上是一个C++引擎内核 + C#脚本层的结构</p>

<p>所写的<code class="language-plaintext highlighter-rouge">MonoBehaviour</code>只是在C#中的一个代理对象，真正控制游戏运行的逻辑、渲染、物理等是C++层在执行</p>

<p>所以从<code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>开始，Unity构建了一个“双向映射体系”</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C++对象（native） &lt;--- instance ID --- UnityEngine.Object（C#托管对象）
        ↑                                       ↑
    内存资源                                   脚本代理
</code></pre></div></div>

<h3 id="从object到monobehaviour的完整继承链">从Object到MonoBehaviour的完整继承链</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.Object （纯托管）
└── UnityEngine.Object （托管对象，桥梁类）
    ├── GameObject（托管对象）
    └── Component
        ├── Transform / Renderer / Collider...（托管对象）
        └── MonoBehaviour （托管行为对象，支持生命周期方法）
</code></pre></div></div>
<p>它们都不是普通的C#对象，它们都与C++侧的“实体”挂钩，甚至生命周期也是引擎控制的</p>

<h3 id="native-layer-与-script-layer的绑定方式">native layer 与 script layer的绑定方式</h3>
<p>Unity会通过一套机制将C++层对象暴露给C#层，这其中最关键的桥梁是：<code class="language-plaintext highlighter-rouge">instance ID + GCHandle + m_CachedPtr</code></p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">m_CachedPtr</code></td>
      <td><code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>中保留的指针，指向C++对象的地址（Unsafe）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GCHandle</code></td>
      <td>Unity用于保持托管对象不被GC收走，native端持有</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Instance ID</code></td>
      <td>每个 C++ native 对象的唯一标识，Unity使用它查找C#代理对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ScriptingObject</code></td>
      <td>C++对象的基类，用于和C#对象绑定（runtime下存在）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MonoObject*</code></td>
      <td>指向 C# 对象的原生指针（Mono环境时）</td>
    </tr>
  </tbody>
</table>

<p>流程图：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C++对象 (ScriptingObject)
   ↕ instance ID
C#对象（UnityEngine.Object） ← GCHandle ← C++
         ↑
      m_CachedPtr → C++对象
</code></pre></div></div>

<h3 id="instance-id">instance ID</h3>
<p>Unity通过使用<code class="language-plaintext highlighter-rouge">instance ID</code>统一管理对象</p>

<p>每个在C++层的Unity对象都有一个唯一的标识符，即<code class="language-plaintext highlighter-rouge">instance ID</code>，它用于区分不同的C++对象。这个标识符的作用类似于内存中的指针</p>
<ul>
  <li>在C#中，可以通过<code class="language-plaintext highlighter-rouge">UnityEngine.Object.GetInstanceID()</code>获取该对象的<code class="language-plaintext highlighter-rouge">instance ID</code></li>
  <li>在C++中，通过这个<code class="language-plaintext highlighter-rouge">instance ID</code>可以找到实际的对象。所有Unity引擎的原生对象都会被注册到一个全局的对象管理器中，这个管理器会维护<code class="language-plaintext highlighter-rouge">instance ID</code>和对象之间的映射</li>
</ul>

<p>可以把<code class="language-plaintext highlighter-rouge">instance ID</code>想象成一个类似于数据库中的“主键”，它指向C++层中的实际属性。在C#层，Unity通过<code class="language-plaintext highlighter-rouge">m_CachedPtr</code>或类似机制与C++对象建立联系。C#调用一个方法或访问一个属性时，实际上就是通过这个<code class="language-plaintext highlighter-rouge">instance ID</code>去C++层查找并操作相应对象的</p>

<h3 id="c层对象的生命周期管理">C++层对象的生命周期管理</h3>
<p>在Unity中，C++层的对象生命周期是由引擎控制的，而不是像普通的C#对象那样由GC自动回收。也就是说，C++对象在被销毁时，并不会立即被C#垃圾处理器回收，而是由Unity引擎自己管理</p>

<p>关键点：</p>
<ul>
  <li>C++层对象的创建和销毁：Unity引擎在创建或销毁对象时，会在C#层为这些C++对象创建对应的托管代理。当你调用<code class="language-plaintext highlighter-rouge">Destroy()</code>或<code class="language-plaintext highlighter-rouge">DestroyImmediate()</code>时，Unity会标记这个对象为待销毁，但实际销毁操作会发生在引擎的下一帧</li>
  <li>GCHandle和<code class="language-plaintext highlighter-rouge">instance ID</code>：为了防止C#垃圾回收器误回收正在被引擎使用的对象，Unity会使用<code class="language-plaintext highlighter-rouge">GCHandle</code>来防止C#层的对象被GC销毁。<code class="language-plaintext highlighter-rouge">GCHandle</code>是一个特定的标记，它告诉C#的垃圾回收器，这个对象在native层还有引用，不应该被回收</li>
  <li>内存管理：一旦<code class="language-plaintext highlighter-rouge">GameObject</code>或其他对象在C++层销毁，Unity会通过管理器从托管层移除该对象，确保其不再被访问。此时，C#层的引用会变成<code class="language-plaintext highlighter-rouge">null</code>，也就无法再访问该对象了。若访问，C#层会返回<code class="language-plaintext highlighter-rouge">null</code>，这便是Unity的<code class="language-plaintext highlighter-rouge">fake null</code>行为</li>
</ul>

<h3 id="c和c的指针交互">C#和C++的指针交互</h3>
<p>在C#和C++之间，<code class="language-plaintext highlighter-rouge">m_CachedPtr</code>是Unity使用的一个关键字段，它保存了C++对象的指针。这个指针并不会直接暴露，而是通过<code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>的方法间接访问</p>

<p>例如，当使用<code class="language-plaintext highlighter-rouge">Instantiate()</code>克隆一个对象时，C#层会创建一个新的对象，并将其<code class="language-plaintext highlighter-rouge">m_CachedPtr</code>指向一个新的C++对象。这种机制确保了C#和C++层可以同步管理对象的创建、销毁和引用</p>

<p>为什么不直接使用C++指针</p>
<ul>
  <li>安全性：如果C#直接操作C++指针，那么内存管理将变得非常复杂，容易发生野指针错误（例如访问已销毁的对象）</li>
  <li>跨平台：Unity需要支持多个平台，如果直接操作原始指针，会导致平台之间的不兼容</li>
</ul>

<h3 id="内存和资源管理native与managed内存">内存和资源管理：Native与Managed内存</h3>
<p>Unity对内存的管理通常分为两类：托管内存（Managed Memory）和原生内存（Native Memory）</p>

<p>托管内存：</p>
<ul>
  <li>这是C#层的内存，由.NET的垃圾回收器负责管理。Unity中的许多类都在托管内存中分配</li>
  <li>例如，通过<code class="language-plaintext highlighter-rouge">new GameObject()</code>创建一个对象时，它实际上是在托管内存中创建了一个<code class="language-plaintext highlighter-rouge">GameObject</code>代理类，该类最终通过<code class="language-plaintext highlighter-rouge">instance ID</code>和C++对象绑定</li>
</ul>

<p>原生内存：</p>
<ul>
  <li>这是C++层的内存。Unity对这些内存进行严格管理，确保它们被正确地分配和释放</li>
  <li>对于一个<code class="language-plaintext highlighter-rouge">GameObject</code>，它在C++层的实际数据都存在原生内存中。C#只能通过指针和绑定方法访问这些内存数据，而不能直接操作它</li>
</ul>

<h3 id="资源的加载与卸载的底层机制">资源的加载与卸载的底层机制</h3>
<p>Unity的资源管理在C++层也有对应的资源对象，它们通过资源路径和资源管理系统来加载和卸载</p>

<p>当使用<code class="language-plaintext highlighter-rouge">Resource.Load()</code>或<code class="language-plaintext highlighter-rouge">Addressables</code>加载资源时，Unity会在C++层将资源加载到内存中，并返回一个C#层的代理对象。这些资源的引用计数会由C++层管理，当没有对象再引用这些资源时，C++层会负责销毁这些内存并释放内存</p>

<h3 id="性能和优化">性能和优化</h3>

<ol>
  <li>
    <p>频繁的资源加载和卸载：如果你在每帧都调用 Resources.Load() 或频繁销毁对象，可能会导致性能瓶颈。推荐使用 Addressables 或 Object Pooling 技术来优化资源管理。</p>
  </li>
  <li>
    <p>避免大量无效对象：例如，创建大量的 GameObject、MonoBehaviour，然后频繁销毁。这样不仅会增加垃圾回收的负担，还会在 C++ 层产生频繁的对象创建和销毁开销。可以使用对象池来减少这种开销。</p>
  </li>
  <li>
    <p>内存泄漏问题：如果对象在 C++ 层没有正确销毁，可能导致内存泄漏。特别是 MonoBehaviour 等绑定对象，它们的销毁需要确保在 C# 层正确解除引用，否则即使对象在 C++ 层销毁，C# 层的引用仍会阻止 GC 回收。</p>
  </li>
</ol>

<h3 id="对象创建过程">对象创建过程</h3>
<p>以创建一个<code class="language-plaintext highlighter-rouge">GameObject</code>为例：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">go</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">(</span><span class="s">"Hero"</span><span class="p">);</span>
</code></pre></div></div>
<p>在背后发生了：</p>
<ol>
  <li>C#调用UnityEngine的构造方法</li>
  <li>Unity C#层调用了内部绑定的native构造函数（通过<code class="language-plaintext highlighter-rouge">[NativeMethod]</code>或<code class="language-plaintext highlighter-rouge">extern</code>实现）</li>
  <li>C++中创建了一个<code class="language-plaintext highlighter-rouge">GameObject</code>对象，并注册<code class="language-plaintext highlighter-rouge">instance ID</code></li>
  <li>Unity C++层为这个对象创建一个C#代理，分配内存，绑定<code class="language-plaintext highlighter-rouge">m_CachedPtr</code></li>
  <li>如果启用脚本（MonoBehaviour），则Unity会通过反射或运行时代码绑定，自动挂载脚本（生成MonoObject，绑定）</li>
</ol>

<h2 id="monobehaviour的生命周期的控制">MonoBehaviour的生命周期的控制</h2>
<p>生命周期函数是Unity引擎每帧自动调度的：</p>
<ul>
  <li>Unity在每帧中，遍历所有激活的<code class="language-plaintext highlighter-rouge">GameObject</code>和<code class="language-plaintext highlighter-rouge">Component</code></li>
  <li>检查是否存在重写的生命周期函数</li>
  <li>调用托管对象中的方法（通过反射或自动生成的绑定）</li>
</ul>

<h2 id="monobehaviour是怎么挂载的">MonoBehaviour是怎么挂载的</h2>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gameObject</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">MyScript</span><span class="p">&gt;();</span>
</code></pre></div></div>
<p>内部流程：</p>
<ol>
  <li>C#调用泛型方法<code class="language-plaintext highlighter-rouge">AddComponent&lt;T&gt;()</code></li>
  <li>UnityC#层调用底层<code class="language-plaintext highlighter-rouge">AddComponent(Type t)</code>(native bridge)</li>
  <li>引擎C++层创建一个<code class="language-plaintext highlighter-rouge">MonoBehaviour</code>实例（C++对象）</li>
  <li>引擎创建对应的C#代理对象，并调用构造函数</li>
  <li>将代理对象挂到该<code class="language-plaintext highlighter-rouge">GameObject</code>下，并添加到调度列表中</li>
  <li>引擎在适当时机调用<code class="language-plaintext highlighter-rouge">Awake() -&gt; Start() -&gt; Update()</code></li>
</ol>

<p>所以不能用<code class="language-plaintext highlighter-rouge">new MyScript()</code>创建MonoBehaviour，它不是纯托管类，是托管↔native绑定类</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Underlying Principle" /><summary type="html"><![CDATA[The Bridge between Native Layer and Script Layer Unity引擎运行时，本质上是一个C++引擎内核 + C#脚本层的结构]]></summary></entry><entry><title type="html">Interface Oriented Design</title><link href="http://localhost:4000/posts/2025-07-15-Interface-Oriented-Design/" rel="alternate" type="text/html" title="Interface Oriented Design" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Interface-Oriented-Design</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-15-Interface-Oriented-Design/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Architecture" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Layer</title><link href="http://localhost:4000/posts/2025-06-01-Layer/" rel="alternate" type="text/html" title="Layer" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Layer</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-01-Layer/"><![CDATA[<p>在Unity中，Layer是要给非常重要的系统<br />
它主要用于：</p>
<ul>
  <li>控制物体的渲染与相机的可见性</li>
  <li>控制物理碰撞（配合Layer Collision Matrix）</li>
  <li>通过脚本进行物体分类和筛选</li>
</ul>

<h2 id="什么是layer">什么是Layer</h2>

<p>Layer是给GameObject打的“标签”，但它和<code class="language-plaintext highlighter-rouge">Tag</code>不一样，Layer是用于功能性控制的，特别在：</p>
<ul>
  <li>摄像机的Culling Mask</li>
  <li>光照影响（Light Culling）</li>
  <li>物理碰撞（Physics Layer）</li>
  <li>射线检测（Raycast Layer）</li>
</ul>

<h2 id="layer的使用场景">Layer的使用场景</h2>
<h3 id="1摄像机视野控制culling-mask">1.摄像机视野控制（Culling Mask）</h3>
<p>在Camera组件中，你可以设置</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Culling Mask -&gt; 选择哪些Layer可以被该相机看到
</code></pre></div></div>

<p><strong>用途：</strong></p>
<ul>
  <li>UI相机只看UI层</li>
  <li>小地图相机只看敌人层</li>
  <li>分屏镜头每个只看自己的部分</li>
</ul>

<p>Layer不仅能控制每个物体是否被摄像机看到，还能与多个摄像机协作实现更加复杂的视图效果</p>

<p>例如，在多人游戏中，你可以为每个玩家设置独立的摄像机，每个摄像机通过不同的Culling Mask来渲染不同的场景部分</p>

<p>示例：多摄像头分屏控制</p>

<p>在分屏游戏中，可以设置多个摄像机，每个摄像机只渲染属于特定玩家的物体</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">camera1</span><span class="p">.</span><span class="n">cullingMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Player1"</span><span class="p">);</span>
<span class="n">camera2</span><span class="p">.</span><span class="n">cullingMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LaeryMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Player2"</span><span class="p">);</span>
</code></pre></div></div>
<p>通过这种方式，你能够在同一个场景中显示不同的物体，仅限于特定玩家的视野</p>

<h3 id="2物理碰撞控制layer-collision-matrix">2.物理碰撞控制（Layer Collision Matrix）</h3>
<p>在菜单中：</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Edit</span> <span class="s">-&gt;</span> <span class="s">Project</span> <span class="s">Settings</span> <span class="s">-&gt;</span> <span class="s">Physics</span>
</code></pre></div></div>

<p>你可以看到Layer Collision Matrix，它控制哪些Layer和哪些Layer能发生物理碰撞</p>

<p>如果在游戏中有多个物体不需要彼此发生碰撞，可以通过Layer来减少不必要的碰撞检测，提高性能</p>

<p><strong>用途：</strong></p>
<ul>
  <li>玩家层与敌人层可以碰撞，但不和自身碰撞</li>
  <li>子弹不撞自己</li>
  <li>角色不被UI的Collider打断</li>
</ul>

<h3 id="3射线检测">3.射线检测</h3>
<p>可以通过Layer来控制射线是否命中某个对象</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">layerMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Physics</span><span class="p">.</span><span class="nf">Raycast</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="k">out</span> <span class="n">hit</span><span class="p">,</span> <span class="m">100f</span><span class="p">,</span> <span class="n">layerMask</span><span class="p">))</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Hit enemy"</span><span class="p">);</span>
</code></pre></div></div>

<p>也可以多层合并：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">mask</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">))</span> <span class="p">|</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"NPC"</span><span class="p">));</span>
</code></pre></div></div>
<h2 id="内置与自定义layer">内置与自定义Layer</h2>

<h3 id="内置layerunity默认的">内置Layer（Unity默认的）</h3>

<table>
  <thead>
    <tr>
      <th>编号</th>
      <th>名称</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>Default</td>
      <td>默认层</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Water</td>
      <td>水体特效</td>
    </tr>
    <tr>
      <td>5</td>
      <td>UI</td>
      <td>UI 专用</td>
    </tr>
  </tbody>
</table>

<h3 id="自定义layer">自定义Layer</h3>
<p>Unity允许你最多使用32个Layer（编号 0~31），其中前几个是保留的<br />
自定义方式：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">选中</span> <span class="n">GameObject</span> <span class="o">-&gt;</span> <span class="n">Inspector</span> <span class="o">-&gt;</span> <span class="n">Layer</span> <span class="o">-&gt;</span> <span class="k">Add</span> <span class="n">Layer</span><span class="p">...</span>
</code></pre></div></div>
<p>添加后可为GameObject设置：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Layer</span> <span class="s">-&gt;</span> <span class="s">你刚添加的层名</span>
</code></pre></div></div>
<h2 id="layer与tag的区别">Layer与Tag的区别</h2>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>Layer</th>
      <th>Tag</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>数量限制</td>
      <td>最多 32 个</td>
      <td>无限制</td>
    </tr>
    <tr>
      <td>用于渲染控制</td>
      <td>是</td>
      <td>否</td>
    </tr>
    <tr>
      <td>用于物理控制</td>
      <td>是</td>
      <td>否</td>
    </tr>
    <tr>
      <td>用于分类查找</td>
      <td>有限制（用 LayerMask）</td>
      <td>可以（用 CompareTag 等）</td>
    </tr>
    <tr>
      <td>性能优化</td>
      <td>优化（用于剔除、射线过滤）</td>
      <td>无优化</td>
    </tr>
  </tbody>
</table>

<h3 id="建议">建议</h3>
<ul>
  <li>给每种功能的对象分配专属Layer</li>
  <li>摄像机、光源、UI、Trigger检测都应依赖Layer控制逻辑</li>
</ul>

<h2 id="layer性能优化与管理">Layer性能优化与管理</h2>
<h3 id="layer管理的最佳实践">Layer管理的最佳实践</h3>
<ul>
  <li>避免过多的Layer：虽然Unity最多允许32个Layer，但不建议频繁使用大量的Layer。过多的Layer会增加管理和维护的难度，且可能会影响性能。建议将层次结构设计得尽量简洁，避免无谓的冗余</li>
  <li>分层管理：根据物体的功能将其分配到不同的Layer中，例如：
    <ul>
      <li>游戏角色：<code class="language-plaintext highlighter-rouge">Player</code>,<code class="language-plaintext highlighter-rouge">Enemy</code></li>
      <li>UI界面：<code class="language-plaintext highlighter-rouge">UI</code>,<code class="language-plaintext highlighter-rouge">Menu</code></li>
      <li>特效：<code class="language-plaintext highlighter-rouge">PerticleEffects</code></li>
      <li>背景：<code class="language-plaintext highlighter-rouge">Background</code></li>
    </ul>
  </li>
</ul>

<p>通过合理的分层，既能提高渲染效率，也便于后期维护</p>

<h3 id="动态控制layer">动态控制Layer</h3>
<p>在一些场景中，可能需要根据物体的状态动态改变其Layer。比如，当玩家接触到某个特殊的物体时，可以改变其Layer，使其在某些摄像机的视野中不可见或不可碰撞</p>

<p>示例：动态更改Layer：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gameObject</span><span class="p">.</span><span class="n">layer</span> <span class="p">=</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Invisible"</span><span class="p">);</span>
</code></pre></div></div>
<p>通过动态修改Layer，能够灵活控制物体的行为和渲染效果</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><summary type="html"><![CDATA[在Unity中，Layer是要给非常重要的系统 它主要用于： 控制物体的渲染与相机的可见性 控制物理碰撞（配合Layer Collision Matrix） 通过脚本进行物体分类和筛选]]></summary></entry><entry><title type="html">Tag</title><link href="http://localhost:4000/posts/2025-06-01-Tag/" rel="alternate" type="text/html" title="Tag" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Tag</id><content type="html" xml:base="http://localhost:4000/posts/2025-06-01-Tag/"><![CDATA[<p>在Unity中，Tag是用来标记和分类GameObject的一种轻量级方法，主要用于在代码中查找和判断物体的类型或身份</p>

<h2 id="tag的核心作用">Tag的核心作用</h2>

<table>
  <thead>
    <tr>
      <th>功能</th>
      <th>示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>分类物体</td>
      <td>Player、Enemy、Item、UI 等</td>
    </tr>
    <tr>
      <td>逻辑判断</td>
      <td>判断一个物体是不是玩家</td>
    </tr>
    <tr>
      <td>查找特定对象</td>
      <td><code class="language-plaintext highlighter-rouge">GameObject.FindWithTag()</code></td>
    </tr>
    <tr>
      <td>触发器/碰撞器逻辑判断</td>
      <td><code class="language-plaintext highlighter-rouge">if (other.CompareTag("Enemy"))</code></td>
    </tr>
  </tbody>
</table>

<h2 id="tag的使用方法">Tag的使用方法</h2>

<h3 id="1设置tag">1.设置Tag</h3>
<p>1.选中一个 GameObject
2.Inspector 面板 → 上方的 “Tag” 下拉菜单
3.如果没有想要的标签 → 点击 Add Tag… → 添加一个新的字符串
4.回到物体，设置为刚才新建的 Tag</p>
<blockquote>
  <p><strong>注意：</strong> Tag是字符串类型，但Unity会为你管理列表，不用硬编码</p>
</blockquote>

<h3 id="2使用tag查找对象">2.使用Tag查找对象</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">player</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">FindWithTag</span><span class="p">(</span><span class="s">"Player"</span><span class="p">);</span>
</code></pre></div></div>
<p>或者查找多个对象：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span><span class="p">[]</span> <span class="n">enemies</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">FindGameObjectsWithTag</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="3在触发器或碰撞中判断tag">3.在触发器或碰撞中判断Tag</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">OnTriggerEnter</span><span class="p">(</span><span class="n">Collider</span> <span class="n">other</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">))</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"撞到敌人了！"</span><span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>推荐使用CompareTag()，而不是<code class="language-plaintext highlighter-rouge">other.tag == "Enemy"</code>，性能更好，也可避免拼写错误引发异常</p>
</blockquote>

<h2 id="示例">示例</h2>
<h3 id="标记玩家">标记玩家</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="s">"Player"</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">PlayerHealth</span> <span class="n">hp</span> <span class="p">=</span> <span class="n">other</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">PlayerHealth</span><span class="p">&gt;();</span>
    <span class="n">hp</span><span class="p">.</span><span class="nf">TakeDamage</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="标记子弹敌人道具等">标记子弹、敌人、道具等</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="s">"Projectile"</span><span class="p">))</span> <span class="nf">Destroy</span><span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">);</span>
</code></pre></div></div>
<h3 id="用于全局查找对象比如ui控件">用于全局查找对象（比如UI控件）</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">healthBar</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">FindWithTag</span><span class="p">(</span><span class="s">"HealthBar"</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="建议">建议</h2>
<ul>
  <li>Tag符合逻辑判断</li>
  <li>不适合控制物理、渲染行为，应交由Layer完成</li>
  <li>避免硬编码字符串，建议自定义一个Tag常量类</li>
</ul>

<h2 id="tag-vs-layer">Tag vs Layer</h2>
<h3 id="主要功能">主要功能</h3>
<ul>
  <li>
    <p>Tag：
用于标记和分类物体。Tag是要给字符串类型，主要用于逻辑上的分类，帮助在代码中识别不同的物体。它适用于标记物体的类型或身份</p>
  </li>
  <li>
    <p>Layer：
用于物理和渲染的分类。Layer用于将物体分配到不同的物理层或渲染层。它通常用于碰撞检测、摄像机的渲染、遮挡剔除等方面</p>
  </li>
</ul>

<h3 id="应用场景">应用场景</h3>

<table>
  <thead>
    <tr>
      <th>功能</th>
      <th>Tag</th>
      <th>Layer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>逻辑分类</strong></td>
      <td>逻辑上的分类（如<code class="language-plaintext highlighter-rouge">Player</code>、<code class="language-plaintext highlighter-rouge">Enemy</code>、<code class="language-plaintext highlighter-rouge">NPC</code>等）</td>
      <td>不适合做逻辑分类</td>
    </tr>
    <tr>
      <td><strong>物理交互</strong></td>
      <td>无直接影响</td>
      <td>控制物体与物理系统的交互（如碰撞、触发）</td>
    </tr>
    <tr>
      <td><strong>渲染控制</strong></td>
      <td>无直接影响</td>
      <td>控制哪些物体由摄像机渲染，或者被物理引擎处理</td>
    </tr>
    <tr>
      <td><strong>代码查找</strong></td>
      <td>可以通过代码查找特定标签的物体（<code class="language-plaintext highlighter-rouge">FindWithTag()</code>）</td>
      <td>不支持通过代码直接查找物体</td>
    </tr>
    <tr>
      <td><strong>数量限制</strong></td>
      <td>默认有7个内置标签，可自由添加自定义标签</td>
      <td>内置5个层，支持最多32个层（Layer）</td>
    </tr>
  </tbody>
</table>

<h2 id="性能优化">性能优化</h2>
<p><code class="language-plaintext highlighter-rouge">GameObject.FindWithTag()</code>和<code class="language-plaintext highlighter-rouge">GameObject.Find()</code>性能差异</p>

<h3 id="1gameobjectfind">1.GameObject.Find()</h3>
<p>`GameObject.Find()用于根据物体的名字查找游戏对象。它的工作原理时遍历当前场景中的所有游戏对象，并检查它们的名字是否与给定的字符串匹配。由于它们是基于字符串的比较来查找物体，查找过程中需要遍历所有场景中的物体，并逐一比较名字，性能相对较低，尤其是在场景中有大量物体时</p>

<p>性能特点：</p>
<ul>
  <li>遍历所有物体：它会遍历场景中的每个物体并进行字符串比较，直到找到匹配的物体</li>
  <li>性能消耗大：尤其在场景中物体数量较多时，<code class="language-plaintext highlighter-rouge">Find()</code>的性能较差。每次调用都会产生额外的性能开销</li>
  <li>不建议在Update中频繁使用：如果你在<code class="language-plaintext highlighter-rouge">Update()</code>或其他频繁调用的函数中使用<code class="language-plaintext highlighter-rouge">Find()</code>，会导致帧率下降</li>
</ul>

<p>适用场景：<br />
适用于场景中物体不多，或者物体名字是唯一且不需要频繁查找的场景</p>

<h3 id="2gameobjectfindwithtag">2.GameObject.FindWithTag()</h3>
<p><code class="language-plaintext highlighter-rouge">GameObject.FindWithTag()</code>是根据物体的Tag查找物体。Unity内部对标签进行了优化处理，标签通常是通过整数索引来管理，而不是字符串比较，因此比<code class="language-plaintext highlighter-rouge">Find()</code>更高效</p>

<p>性能特点：</p>
<ul>
  <li>标签优化：Unity通过内部索引表来管理标签，查找时直接使用整数值进行对比，性能比<code class="language-plaintext highlighter-rouge">Find()</code>要好</li>
  <li>只查找有特定标签的物体：<code class="language-plaintext highlighter-rouge">FindWithTag()</code>只会查找那些拥有特定标签的物体，这减少了查找范围，避免了遍历所有物体</li>
  <li>更高效：相比<code class="language-plaintext highlighter-rouge">Find()</code>，<code class="language-plaintext highlighter-rouge">FindWithTag()</code>的性能开销要小得多，尤其在场景中有大量物体时，它仍能保持较好的性能</li>
</ul>

<p>适用场景：<br />
适用于当你需要按类型查找物体时，比如查找所有敌人、玩家或道具等。尤其当场景中有大量物体时，<code class="language-plaintext highlighter-rouge">FindWithTag()</code>能显著提高查找效率</p>

<h2 id="高级tag管理方法">高级Tag管理方法</h2>
<p>在大型项目中，游戏对象的数量通常非常庞大，简单的Tag管理可能会导致代码混乱、性能瓶颈等问题。因此，合理的Tag管理变得尤为重要</p>

<h3 id="避免硬编码tag字符串">避免硬编码Tag字符串</h3>
<p>虽然Unity允许在<code class="language-plaintext highlighter-rouge">Inspector</code>中设置Tag，但使用字符串类型的Tag容易导致代码中出现硬编码，导致在后期修改时很不方便。</p>

<p>硬编码（Hardcoding）是指在程序代码中直接使用固定值，而不是通过变量、常量、配置文件等灵活方式配置。这种做法会导致编码的可维护性差，一旦需要修改这些值，开发者就需要修改代码本身，甚至重新编译程序</p>

<p>示例：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">gameObject</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">))</span> <span class="c1">// Enemry就是硬编码</span>
<span class="p">{</span>
    <span class="c1">// 做一些敌人的处理</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了解决这个问题，可以使用常量类来管理所有的Tag</p>

<p>示例：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Tags</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">Player</span> <span class="p">=</span> <span class="s">"Player"</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">Enemy</span> <span class="p">=</span> <span class="s">"Enemy"</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">Item</span> <span class="p">=</span> <span class="s">"Item"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>使用常量类可以避免拼写错误，并使代码更具可维护性。例如：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">player</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">FindWithTag</span><span class="p">(</span><span class="n">Tags</span><span class="p">.</span><span class="n">Player</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="统一的tag命名规则">统一的Tag命名规则</h3>
<p>在多人开发的项目中，多个开发者可能会使用不同的命名方式来为物体指定Tag，这容易造成命名冲突或不一致的情况。为了避免这种情况，可以提前指定一个统一的Tag命名规则。<br />
例如，可以按照功能、类型等进行分类：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Player</code>,<code class="language-plaintext highlighter-rouge">Enemy</code>等可以归类为“角色”</li>
  <li><code class="language-plaintext highlighter-rouge">Projectile</code>,<code class="language-plaintext highlighter-rouge">Item</code>等可以归类为“道具”</li>
  <li><code class="language-plaintext highlighter-rouge">UI</code>，<code class="language-plaintext highlighter-rouge">Background</code>等可以归类为“UI”或“场景”元素</li>
</ul>

<p>通过规范化命名，能够提高项目的可读性和协作效率</p>

<h2 id="tag与其他unity功能的结合">Tag与其他Unity功能的结合</h2>
<h3 id="tag与事件系统结合">Tag与事件系统结合</h3>
<p>在游戏开发中，很多逻辑需要根据物体的类型来触发不同的事件。使用Tag可以帮助我们快速识别不同类型的物体，并在适当的时候触发事件</p>

<p>示例：使用Tag触发事件</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">OnCollisionEnter</span><span class="p">(</span><span class="n">Collision</span> <span class="n">collision</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="n">Tags</span><span class="p">.</span><span class="n">Player</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// 触发玩家碰撞事件</span>
        <span class="n">EventManager</span><span class="p">.</span><span class="nf">TriggerEvent</span><span class="p">(</span><span class="s">"PlayerHit"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="n">Tags</span><span class="p">.</span><span class="n">Enemy</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// 触发敌人碰撞事件</span>
        <span class="n">EventManager</span><span class="p">.</span><span class="nf">TriggerEvent</span><span class="p">(</span><span class="s">"EnemyHit"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这种方法不仅能提高代码的可读性，还能使事件管理更加灵活</p>

<h3 id="tag与layer结合使用">Tag与Layer结合使用</h3>
<p>有时，Unity中需要将物体分类以控制它们与物理引擎的交互，或者控制它们的渲染。通过将Tag和Layer结合使用，可以达到更精细的控制</p>

<p>示例：使用Layer控制物理交互</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">OnCollisionEnter</span><span class="p">(</span><span class="n">Collision</span> <span class="n">collision</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果碰撞对象是敌人，并且它属于特定的Layer</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="nf">CompareTag</span><span class="p">(</span><span class="n">Tags</span><span class="p">.</span><span class="n">Enemy</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="n">layer</span> <span class="p">==</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"EnemyLayer"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// 执行敌人的死亡逻辑</span>
        <span class="nf">Destroy</span><span class="p">(</span><span class="n">collision</span><span class="p">.</span><span class="n">gameObject</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>通过这种方式，可以使用Layer来精确控制物体的碰撞检测和物理交互，而使用Tag来区分物体的身份和类型</p>

<h2 id="tag的性能优化">Tag的性能优化</h2>
<h3 id="避免频繁调用find和findwithtag">避免频繁调用Find()和FindWithTag()</h3>
<p>在大型项目中，频繁调用<code class="language-plaintext highlighter-rouge">GameObject.Find()</code>和<code class="language-plaintext highlighter-rouge">GameObject.FindWithTag()</code>会对性能造成不小的影响。尤其是在<code class="language-plaintext highlighter-rouge">Update()</code>中反复调用这些方法时，可能会导致游戏的帧率大幅下降</p>

<p>解决方案：缓存查找结果
如果某个物体会被频繁访问，可以考虑将其引用存储在一个变量中，从而避免每次都进行查找</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">GameObejct</span> <span class="n">palyer</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">palyer</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">FindWithTag</span><span class="p">(</span><span class="n">Tags</span><span class="p">.</span><span class="n">Player</span><span class="p">);</span> <span class="c1">// 缓存查找结果</span>

<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">player</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 在这里使用缓存的player引用</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="使用对象池object-pooling优化查找性能">使用对象池（Object Pooling）优化查找性能</h3>
<p>对于需要频繁查找的物体，使用对象池是要给不错的选择。对象池能够避免频繁地实例化和销毁对象，减少性能开销，同时提高代码的可复用性</p>

<p>示例：对象池模式</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">EnemyPool</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">GameObject</span> <span class="n">enemyPrefab</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">GameObject</span><span class="p">&gt;</span> <span class="n">enemyPool</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">GameObject</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">GameObject</span> <span class="nf">GetEnemy</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">enemy</span> <span class="k">in</span> <span class="n">enemyPool</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">enemy</span><span class="p">.</span><span class="n">activeInHierarchy</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">enemy</span><span class="p">.</span><span class="nf">SetActive</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">enemy</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">var</span> <span class="n">newEnemy</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">enemyPrefab</span><span class="p">);</span>
        <span class="n">enemyPool</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">newEnemy</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">newEnemy</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>对象池能够使得<code class="language-plaintext highlighter-rouge">FindWithTag()</code>等查找操作不再频繁发生，从而提升性能</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><summary type="html"><![CDATA[在Unity中，Tag是用来标记和分类GameObject的一种轻量级方法，主要用于在代码中查找和判断物体的类型或身份]]></summary></entry></feed>