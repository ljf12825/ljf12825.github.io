<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-07-15T18:37:02+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ljf12825’s Blog</title><subtitle>Efficient &amp; Elegant</subtitle><author><name>Jeff Lee</name><email>2548278761@qq.com</email></author><entry><title type="html">Object</title><link href="http://localhost:4000/posts/2025-07-11-Object/" rel="alternate" type="text/html" title="Object" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Object</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-11-Object/"><![CDATA[<p>Object是Unity中所有内建物体的基类，实现在UnityEngine.CoreModule中，不同于C#中的<code class="language-plaintext highlighter-rouge">System.Object</code>，它是托管层（C#）和原生引擎层（C++）之间的桥梁，背后绑定着Unity C++引擎层的资源句柄</p>

<h2 id="object的特点unity的特有行为">Object的特点（Unity的特有行为）</h2>
<p><strong>引擎资源的绑定</strong></p>

<p>每个<code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>对象都对应一个C++层对象，它们通过一个<code class="language-plaintext highlighter-rouge">instance 2D</code>来关联，且资源的生命周期不由GC管理</p>

<p>比如：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">go</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">();</span>
<span class="n">Object</span><span class="p">.</span><span class="nf">Destroy</span><span class="p">(</span><span class="n">go</span><span class="p">);</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span> <span class="p">==</span> <span class="k">null</span><span class="p">);</span>  <span class="c1">// true</span>
</code></pre></div></div>
<p>这就是Object的“鬼行为”，此处的<code class="language-plaintext highlighter-rouge">go == null</code>并非等价于<code class="language-plaintext highlighter-rouge">object is null</code></p>

<p><strong>Unity的“fake null”机制</strong></p>

<p>Unity重写了<code class="language-plaintext highlighter-rouge">==</code>操作符</p>

<p>如果一个<code class="language-plaintext highlighter-rouge">Object</code>对象在引擎层已经被销毁（Destroy过），但C#还保有托管引用，这时候：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span> <span class="p">==</span> <span class="k">null</span><span class="p">);</span> <span class="c1">// true</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">go</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="k">null</span><span class="p">));</span> <span class="c1">// false</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="nf">ReferenceEquals</span><span class="p">(</span><span class="n">go</span><span class="p">,</span> <span class="k">null</span><span class="p">));</span> <span class="c1">// false</span>
</code></pre></div></div>
<p>这是Unity为了安全做的改动行为，防止对已经销毁的对象操作，引起native崩溃</p>

<h3 id="底层原理">底层原理</h3>
<p>Unity的<code class="language-plaintext highlighter-rouge">Object</code>在C#层其实只是一个代理，它对应的C++引擎层对象通过C#层的<code class="language-plaintext highlighter-rouge">IntPtr m_CachedPtr</code>与C++对象通信（该字段可以在反编译时看到）</p>

<p>资源对象（比如一个贴图）在编译器导入时会被转换为native object，保存在场景或资源文件中，加载时通过Unity自己的反序列化系统生成C#代理对象，并挂接<code class="language-plaintext highlighter-rouge">m_CachedPtr</code></p>

<p>Unity会使用C++引擎进行资源生命周期的管理，而不是C#的GC，所以Destroy调的是C++的释放接口</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sometimes an instance of Object can be in detached state, where there is no underlying native object. T
his can happen if the instance references an native object that has been destroyed, or a missing Asset or missing type. 
Detached objects retain their InstanceID, but the object cannot be used to call methods or access properties. 
An object in this state will appear to be null, because of special implementations of operator==, operator!= and Ojbect.bool.
Because the object is not truly null, a call to Object.ReferenceEquals(myobject, null) will return false.

The null-comditional operator(?.)and the null-coalescing operator(??)are not supported with Unity Object because they cannot be overridden to treat detached objects the same as null.
It is only safe to use those operators in your scripts if there is certainty that the objects being checked are never in a detached state.
</code></pre></div></div>

<h2 id="object-api">Object API</h2>
<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">name</code></td>
      <td><code class="language-plaintext highlighter-rouge">string</code></td>
      <td>对象名称（可读写）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hideFlags</code></td>
      <td><code class="language-plaintext highlighter-rouge">HideFlags</code></td>
      <td>控制对象是否可隐藏/可编辑/保存</td>
    </tr>
  </tbody>
</table>

<p><strong><code class="language-plaintext highlighter-rouge">hideFlags</code></strong><br />
常见用途：</p>
<ul>
  <li>隐藏对象</li>
  <li>防止误删或编辑</li>
  <li>不让对象随着场景保存（通常用于运行时生成的对象）</li>
</ul>

<p>常用枚举值</p>

<table>
  <thead>
    <tr>
      <th>枚举值</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.None</code></td>
      <td>默认行为，无隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideInHierarchy</code></td>
      <td>在 Hierarchy 视图中隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideInInspector</code></td>
      <td>在 Inspector 中隐藏</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.NotEditable</code></td>
      <td>不允许用户编辑（灰掉）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSave</code></td>
      <td>场景保存时不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSaveInBuild</code></td>
      <td>打包时不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.DontSaveInEditor</code></td>
      <td>编辑器中不保存该对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HideFlags.HideAndDontSave</code></td>
      <td>隐藏并不保存（临时对象）</td>
    </tr>
  </tbody>
</table>

<p><strong>Public Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">GetInstanceID</code></td>
      <td>获得object的实例ID</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ToString</code></td>
      <td>返回<code class="language-plaintext highlighter-rouge">object.name</code></td>
    </tr>
  </tbody>
</table>

<p><strong>Static Methods</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
      <th>示例/说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Destroy(Object obj)</code></td>
      <td>销毁一个对象，在当前帧结束时生效</td>
      <td><code class="language-plaintext highlighter-rouge">Destroy(gameObject);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Destroy(Object obj, float t)</code></td>
      <td>延迟 t 秒销毁对象</td>
      <td><code class="language-plaintext highlighter-rouge">Destroy(gameObject, 2.0f);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DestroyImmediate(Object obj)</code></td>
      <td>立刻销毁对象，<strong>只推荐在编辑器中使用</strong></td>
      <td><code class="language-plaintext highlighter-rouge">DestroyImmediate(gameObject);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DontDestroyOnLoad(Object target)</code></td>
      <td>场景切换时不销毁该对象</td>
      <td>常用于单例或管理器类</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindAnyObjectByType&lt;T&gt;()</code></td>
      <td>获取任何已加载的指定类型对象（不保证顺序）</td>
      <td>替代旧版 <code class="language-plaintext highlighter-rouge">FindObjectOfType</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindFirstObjectByType&lt;T&gt;()</code></td>
      <td>获取第一个找到的指定类型对象（可能更快）</td>
      <td>常用于初始化查找</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FindObjectsByType&lt;T&gt;()</code></td>
      <td>获取所有已加载的指定类型对象</td>
      <td><code class="language-plaintext highlighter-rouge">var allEnemies = FindObjectsByType&lt;Enemy&gt;();</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(Object original)</code></td>
      <td>克隆一个对象（创建副本）</td>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(prefab);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(Object original, Vector3 position, Quaternion rotation)</code></td>
      <td>在指定位置和旋转创建克隆</td>
      <td><code class="language-plaintext highlighter-rouge">Instantiate(prefab, pos, rot);</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">InstantiateAsync(Object original)</code></td>
      <td>异步克隆对象，返回 <code class="language-plaintext highlighter-rouge">AsyncInstantiateOperation</code></td>
      <td>用于 Addressables 或大型对象，节省主线程开销</td>
    </tr>
  </tbody>
</table>

<p><strong>Operators</strong></p>

<table>
  <thead>
    <tr>
      <th>操作符</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是否存在</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator!=</code></td>
      <td>比较两个object是否引用不同的物体</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">operator==</code></td>
      <td>是否引用相同</td>
    </tr>
  </tbody>
</table>

<h2 id="object与资源的关系">Object与资源的关系</h2>
<p>几乎所有资源类型（包括预制体、贴图、材质、音频、动画等）都继承自<code class="language-plaintext highlighter-rouge">Object</code></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Texture</span> <span class="n">tex</span> <span class="p">=</span> <span class="n">Resources</span><span class="p">.</span><span class="n">Load</span><span class="p">&lt;</span><span class="n">Texture</span><span class="p">&gt;(</span><span class="s">"MyTexture"</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Resources.Load&lt;T&gt;()</code>返回的其实就是一个<code class="language-plaintext highlighter-rouge">Object</code>的子类（这里是Texture）</p>

<h2 id="继承关系">继承关系</h2>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Object
  ├── GameObject
  └── Component
        ├── MonoBehaviour
        └── Transform / Collider / Renderer / ...
</code></pre></div></div>
<p>所以可以有：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GameObject</span> <span class="n">go</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">();</span>
<span class="n">Object</span> <span class="n">obj</span> <span class="p">=</span> <span class="n">go</span><span class="p">;</span> <span class="c1">// legal</span>
<span class="n">Component</span> <span class="n">comp</span> <span class="p">=</span> <span class="n">go</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
<span class="n">Object</span> <span class="n">o2</span> <span class="p">=</span> <span class="n">comp</span><span class="p">;</span> <span class="c1">// legal</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">new</code>出来的<code class="language-plaintext highlighter-rouge">GameObject</code>是合法的，但不能<code class="language-plaintext highlighter-rouge">new</code> <code class="language-plaintext highlighter-rouge">Transform</code>或<code class="language-plaintext highlighter-rouge">Renderer</code>，必须用<code class="language-plaintext highlighter-rouge">AddComponent</code>等引擎API创建</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Syntax" /><category term="Unity Class" /><summary type="html"><![CDATA[Object是Unity中所有内建物体的基类，实现在UnityEngine.CoreModule中，不同于C#中的System.Object，它是托管层（C#）和原生引擎层（C++）之间的桥梁，背后绑定着Unity C++引擎层的资源句柄]]></summary></entry><entry><title type="html">Frame</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Frame.html" rel="alternate" type="text/html" title="Frame" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Frame</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Frame.html"><![CDATA[<p>在Unity中，Frame（帧）是游戏运行的基本时间单位</p>

<h2 id="什么是frame">什么是Frame</h2>
<blockquote>
  <p>Frame：指游戏每渲染并更新一次画面所经历的完整周期
一个Frame包含了物理模拟、逻辑更新、渲染提交等多个阶段</p>
  <ul>
    <li>游戏每秒运行多个帧，成为FPS（Frame Per Second），帧率越高越流畅</li>
    <li>如果帧率是60FPS，表示每秒执行60次完整的Frame逻辑</li>
  </ul>
</blockquote>

<h2 id="frame的生命周期">Frame的生命周期</h2>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">Input</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">Physics</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">Update</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">AI</span><span class="o">/</span><span class="nt">Animator</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">LateUpdate</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">Rendering</span><span class="o">]</span> <span class="nt">-</span><span class="o">&gt;</span> <span class="o">[</span><span class="nt">Present</span><span class="o">]</span>
</code></pre></div></div>
<p>详见<a href="/posts/2025-06-02-Scripts/">Scripts</a></p>

<h2 id="不同帧的分类">不同帧的分类</h2>

<table>
  <thead>
    <tr>
      <th>帧类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>逻辑帧（Update 帧）</strong></td>
      <td>每帧都会执行的脚本逻辑</td>
    </tr>
    <tr>
      <td><strong>物理帧（FixedUpdate）</strong></td>
      <td>固定时间调用一次，与帧率无关</td>
    </tr>
    <tr>
      <td><strong>渲染帧</strong></td>
      <td>Unity 渲染一次画面</td>
    </tr>
  </tbody>
</table>

<h2 id="frame与多线程">Frame与多线程</h2>
<p>Unity中每一帧可以大致分为如下几个阶段：</p>
<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Frame</span><span class="w"> </span><span class="err">开始</span><span class="w">
</span><span class="err">│</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Script</span><span class="w"> </span><span class="nb">Update</span><span class="err">（</span><span class="nv">MonoBehaviour</span><span class="w"> </span><span class="nb">Update</span><span class="err">）</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">FixedUpdate</span><span class="err">（每</span><span class="w"> </span><span class="nb">N</span><span class="w"> </span><span class="err">帧触发）</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Animation</span><span class="w"> </span><span class="nb">Update</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Physics</span><span class="w"> </span><span class="nb">Update</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">AI</span><span class="w"> </span><span class="nv">Navigation</span><span class="w"> </span><span class="nb">Update</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Culling</span><span class="err">（剔除）</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Rendering</span><span class="w"> </span><span class="nv">Setup</span><span class="w">
</span><span class="err">│</span><span class="w">
</span><span class="err">├─</span><span class="w"> </span><span class="nv">Rendering</span><span class="err">（提交</span><span class="w"> </span><span class="nv">DrawCalls</span><span class="w"> </span><span class="err">到</span><span class="w"> </span><span class="nv">GPU</span><span class="err">）</span><span class="w">
</span><span class="err">│</span><span class="w">
</span><span class="err">└─</span><span class="w"> </span><span class="nv">EndFrame</span><span class="w">
</span></code></pre></div></div>
<p>这些阶段会部分并行执行（也就是说，并非所有都是主线程执行的）</p>

<h3 id="多线程的参与">多线程的参与</h3>

<table>
  <thead>
    <tr>
      <th>线程</th>
      <th>作用</th>
      <th>举例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>主线程（Main Thread）</strong></td>
      <td>执行大部分脚本、生命周期函数、UI、调度渲染</td>
      <td>Update、LateUpdate、OnGUI、Animator</td>
    </tr>
    <tr>
      <td><strong>Job System 线程池</strong></td>
      <td>执行并行任务，如变换更新、骨骼动画、AI、路径查找</td>
      <td>DOTS Jobs、Transform System</td>
    </tr>
    <tr>
      <td><strong>渲染线程（Render Thread）</strong></td>
      <td>独立线程打包渲染命令给 GPU</td>
      <td>Draw Call 打包、CommandBuffer</td>
    </tr>
    <tr>
      <td><strong>Worker Threads（如音频）</strong></td>
      <td>异步加载资源、播放音频、网络等</td>
      <td>Audio Thread、Loading Thread</td>
    </tr>
    <tr>
      <td><strong>GPU（设备线程）</strong></td>
      <td>执行实际绘制、后处理、粒子等并行任务</td>
      <td>Shader、Compute Shader、VFX Graph</td>
    </tr>
  </tbody>
</table>

<h3 id="一帧中多线程协同的流程图">一帧中多线程协同的流程图</h3>
<pre><code class="language-less">             [一帧开始]
                   │
      ┌────────────┴─────────────┐
      │                          │
[Main Thread]              [Job System Threads]
      │                          │
 MonoBehaviour.Update()     DOTS Job: 动画、物理、AI计算等
      │                          │
 LateUpdate() ←───────────────┘（主线程同步 Job 结果）
      │
[开始渲染准备]
      │
      └─→ [Render Thread] → 提交 GPU 渲染命令
                          │
                          ↓
                   [GPU 渲染这一帧]
</code></pre>

<h3 id="线程同步与一帧的边界">线程同步与一帧的边界</h3>
<ul>
  <li>Job在当前帧内启动，也要在当前帧内完成，结果才能同步回主线程</li>
  <li>Unity不允许Job修改UnityEngine.Object</li>
  <li><code class="language-plaintext highlighter-rouge">JobHandle.Complete()</code>会阻塞等待Job完成，要合理使用</li>
</ul>

<h2 id="frame性能调优">Frame性能调优</h2>
<p>Frame Optimization是游戏性能优化的核心工作之一，目标是在每一帧内把CPU、GPU、内存、线程、渲染等资源使用最大化、冗余最小化，从而达到稳定的帧率</p>

<h3 id="一帧的性能结构大脑图">一帧的性能结构（大脑图）</h3>
<p>Unity中一帧的总耗时通常来自这几个方面：</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">一帧时间</span><span class="err">（</span><span class="nt">Frame</span> <span class="nt">Time</span><span class="err">）</span> <span class="err">≈</span>
  <span class="nt">CPU</span> <span class="nt">脚本逻辑开销</span> <span class="o">+</span>
  <span class="nt">Physics</span> <span class="nt">运算</span> <span class="o">+</span>
  <span class="nt">Animation</span> <span class="nt">采样</span><span class="o">/</span><span class="nt">骨骼</span> <span class="o">+</span>
  <span class="nt">Renderer</span> <span class="nt">准备</span><span class="o">/</span><span class="nt">剔除</span> <span class="o">+</span>
  <span class="nt">渲染线程开销</span><span class="err">（</span><span class="nt">Render</span> <span class="nt">Thread</span><span class="err">）</span><span class="o">+</span>
  <span class="nt">GPU</span> <span class="nt">渲染耗时</span>
</code></pre></div></div>
<p>目标是：让这些总和 小于 1 / FPS</p>

<h3 id="调优的目标谁卡就调谁">调优的目标：谁卡，就调谁</h3>

<table>
  <thead>
    <tr>
      <th>调优对象</th>
      <th>优化目的</th>
      <th>工具</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CPU 主线程</td>
      <td>减少逻辑卡顿</td>
      <td>Profiler、Timeline</td>
    </tr>
    <tr>
      <td>Job 多线程</td>
      <td>减少不必要的等待</td>
      <td>Profiler、JobDebugger</td>
    </tr>
    <tr>
      <td>Render Thread</td>
      <td>减少 DrawCall 和渲染命令量</td>
      <td>Frame Debugger、Stats</td>
    </tr>
    <tr>
      <td>GPU 渲染</td>
      <td>降低 Shader/像素复杂度</td>
      <td>GPU Profiler、RenderDoc</td>
    </tr>
    <tr>
      <td>内存使用</td>
      <td>减少 GC 和加载卡顿</td>
      <td>Memory Profiler、Deep Profiler</td>
    </tr>
  </tbody>
</table>

<h3 id="常见瓶颈与优化方法大致思路">常见瓶颈与优化方法（大致思路）</h3>
<h4 id="1脚本逻辑太重主线程占满">1.脚本逻辑太重（主线程占满）</h4>

<table>
  <thead>
    <tr>
      <th>症状</th>
      <th>优化手段</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Update() 每帧循环太多对象</td>
      <td>改为 Job 或事件驱动、UpdateGroup</td>
    </tr>
    <tr>
      <td>大量使用 <code class="language-plaintext highlighter-rouge">Find</code>, <code class="language-plaintext highlighter-rouge">GetComponent</code>, LINQ</td>
      <td>改成缓存引用、避免动态分配</td>
    </tr>
    <tr>
      <td>高频调用 GC</td>
      <td>使用对象池、Span、少用 string 拼接</td>
    </tr>
  </tbody>
</table>

<h4 id="2draw-call太多--batching失效">2.Draw Call太多 / Batching失效</h4>

<table>
  <thead>
    <tr>
      <th>症状</th>
      <th>优化方法</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>每帧几千次 DrawCall</td>
      <td>开启 SRP Batching 或 GPU Instancing</td>
    </tr>
    <tr>
      <td>动态物体频繁改变材质</td>
      <td>合并材质、使用 Texture Atlas</td>
    </tr>
    <tr>
      <td>UGUI 每个按钮都独立绘制</td>
      <td>使用 Canvas 分层、合批策略优化（静态 Canvas）</td>
    </tr>
  </tbody>
</table>

<h4 id="3渲染管线太重--gpu满载">3.渲染管线太重 / GPU满载</h4>

<table>
  <thead>
    <tr>
      <th>症状</th>
      <th>优化手段</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Shader 复杂 / 光照太多</td>
      <td>降低 Shader 复杂度，合并 Pass</td>
    </tr>
    <tr>
      <td>每像素灯光多 / 阴影开销大</td>
      <td>减少实时光源数量，Bake 灯光</td>
    </tr>
    <tr>
      <td>后处理堆叠太多</td>
      <td>合并效果、调低分辨率、关闭没必要的 PostFX</td>
    </tr>
  </tbody>
</table>

<h4 id="物理模拟耗时长">物理模拟耗时长</h4>

<table>
  <thead>
    <tr>
      <th>症状</th>
      <th>优化方法</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>大量 Collider / Rigidbody</td>
      <td>简化碰撞体、使用 Layer 避免不必要检测</td>
    </tr>
    <tr>
      <td>FixedUpdate 太频繁</td>
      <td>调整 Fixed Timestep（如 0.02 → 0.033）</td>
    </tr>
    <tr>
      <td>不必要的物理交互</td>
      <td>设置 isKinematic、启用睡眠</td>
    </tr>
  </tbody>
</table>

<h4 id="资源加载卡顿--gc卡顿">资源加载卡顿 / GC卡顿</h4>

<table>
  <thead>
    <tr>
      <th>症状</th>
      <th>优化方法</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>使用 <code class="language-plaintext highlighter-rouge">Resources.Load()</code> 或 <code class="language-plaintext highlighter-rouge">Instantiate()</code> 卡顿</td>
      <td>使用 Addressables 异步加载</td>
    </tr>
    <tr>
      <td>不断产生临时对象</td>
      <td>对象池、避免 foreach/ToList/Lambda</td>
    </tr>
    <tr>
      <td>大量 UI 弹窗频繁创建销毁</td>
      <td>UI 预加载 + 缓存 + 对象池化管理</td>
    </tr>
  </tbody>
</table>

<p><strong>详见 <a href="/posts/2025-06-13-Unity-Performance-Tuning/">Unity Performance Tuning</a></strong></p>

<h2 id="帧的底层原理">帧的底层原理</h2>
<p>从底层角度说：</p>
<blockquote>
  <p>一帧 = CPU逻辑执行 + 渲染命令提交 + GPU图像输出 + 系统显示刷新</p>
</blockquote>

<h3 id="一帧在底层的完整生命周期">一帧在底层的完整生命周期</h3>

<table>
  <thead>
    <tr>
      <th>阶段</th>
      <th>描述</th>
      <th>涉及模块</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>时间触发</td>
      <td>到了下一帧时间，Unity 开始执行 Update</td>
      <td>操作系统定时器 / 游戏主循环</td>
    </tr>
    <tr>
      <td>逻辑更新</td>
      <td>执行脚本逻辑（如移动、AI、物理）</td>
      <td>CPU，主线程，Mono</td>
    </tr>
    <tr>
      <td>资源准备</td>
      <td>加载纹理、动画数据、Mesh 等</td>
      <td>CPU + 内存 + IO</td>
    </tr>
    <tr>
      <td>渲染命令生成</td>
      <td>调用 Graphics API：DrawMesh、DrawCall</td>
      <td>Unity C++ 层、RenderThread</td>
    </tr>
    <tr>
      <td>渲染命令提交</td>
      <td>传给 GPU 渲染管线（如 Vulkan、OpenGL）</td>
      <td>RenderThread → GPU</td>
    </tr>
    <tr>
      <td>GPU 执行渲染管线</td>
      <td>顶点着色 → 光栅化 → 像素着色 → 输出到帧缓冲</td>
      <td>GPU Pipeline</td>
    </tr>
    <tr>
      <td>vsync 同步</td>
      <td>等待下一次显示器刷新（如 60Hz）</td>
      <td>SwapChain、VSync</td>
    </tr>
    <tr>
      <td>显示图像</td>
      <td>当前帧图像输出到屏幕</td>
      <td>显示设备、操作系统</td>
    </tr>
  </tbody>
</table>

<h3 id="图形api如何控制帧">图形API：如何控制帧</h3>
<p>Unity底层是通过图形API驱动的，这些API控制：</p>
<ul>
  <li>帧缓冲区 FrameBuffer</li>
  <li>渲染管线</li>
  <li>命令缓冲区 CommandBuffer</li>
  <li>交换链 SwapChain</li>
</ul>

<p><strong>Vulkan或DX中的一帧</strong></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BeginFrame</span><span class="p">();</span> <span class="c1">// 开始新的一帧（获取缓冲区）</span>
<span class="n">RecordRenderCommands</span><span class="p">();</span> <span class="c1">// 录制渲染命令</span>
<span class="n">SubmitToGPU</span><span class="p">();</span> <span class="c1">// 提交到GPU</span>
<span class="n">PresentFrame</span><span class="p">();</span> <span class="c1">// 显示渲染结果（同步vsync）</span>
</code></pre></div></div>
<p>Unity在底层封装了这些过程，开发者只看到<code class="language-plaintext highlighter-rouge">Update()</code>、<code class="language-plaintext highlighter-rouge">LateUpdate()</code>、<code class="language-plaintext highlighter-rouge">Render()</code></p>

<h3 id="帧率和显示器刷新率之间的关系">帧率和显示器刷新率之间的关系</h3>

<table>
  <thead>
    <tr>
      <th>显示器刷新率</th>
      <th>理想帧率</th>
      <th>VSync</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>60Hz 显示器</td>
      <td>60 FPS</td>
      <td>每 16.67ms 输出一帧</td>
    </tr>
    <tr>
      <td>120Hz 显示器</td>
      <td>120 FPS</td>
      <td>每 8.33ms 输出一帧</td>
    </tr>
    <tr>
      <td>帧生成慢</td>
      <td>掉帧、卡顿</td>
      <td>GPU 没赶上显示器刷新节奏</td>
    </tr>
    <tr>
      <td>帧生成太快</td>
      <td>撕裂（Tearing）</td>
      <td>若无 vsync</td>
    </tr>
  </tbody>
</table>

<h3 id="一帧中关键的底层数据引擎角度">一帧中关键的底层数据（引擎角度）</h3>

<table>
  <thead>
    <tr>
      <th>结构/模块</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GameLoop</td>
      <td>每帧驱动所有系统的核心循环</td>
    </tr>
    <tr>
      <td>MonoBehaviourSystem</td>
      <td>驱动 C# 脚本的系统</td>
    </tr>
    <tr>
      <td>RenderLoop</td>
      <td>构建和提交渲染指令</td>
    </tr>
    <tr>
      <td>CommandBuffer</td>
      <td>存储一帧的渲染命令</td>
    </tr>
    <tr>
      <td>SwapChain</td>
      <td>管理图像缓冲与 vsync 交换</td>
    </tr>
    <tr>
      <td>GfxDevice</td>
      <td>抽象的 GPU 设备接口</td>
    </tr>
    <tr>
      <td>NativeContainer</td>
      <td>管理底层数据容器（如 Transform）</td>
    </tr>
  </tbody>
</table>

<h3 id="每帧中资源怎么流转">每帧中资源怎么流转</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">C# 代码 -&gt; C++ 引擎 -&gt; GfxDevice -&gt; GPU Pipeline -&gt; 帧缓冲 -&gt; 显示器</code></li>
  <li>Unity做了大量C# &lt;-&gt; C++ &lt;-&gt; GPU间的数据传输</li>
</ul>

<h2 id="unity的高效框架优化">Unity的高效框架优化</h2>
<blockquote>
  <p>这些操作能在一帧时间内完成，是因为Unity通过了“并行化 + 最小化处理 + GPU卸载 + 帧缓冲机制”等一套高效框架优化，最大程度压缩了每一帧的工作流程</p>
</blockquote>

<h3 id="为什么一帧能做这么多事">为什么一帧能做这么多事</h3>

<table>
  <thead>
    <tr>
      <th>原因</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>并行处理</strong></td>
      <td>利用多个线程同时处理物理、动画、渲染准备等</td>
    </tr>
    <tr>
      <td><strong>GPU 异步渲染</strong></td>
      <td>渲染任务交给 GPU，CPU 继续处理逻辑，不等待</td>
    </tr>
    <tr>
      <td><strong>渲染缓存机制</strong></td>
      <td>当前帧 CPU 和上一帧 GPU 同时工作</td>
    </tr>
    <tr>
      <td><strong>分帧处理</strong></td>
      <td>大任务（如寻路、加载）分帧执行，避免卡帧</td>
    </tr>
    <tr>
      <td><strong>批处理 + 合批</strong></td>
      <td>合并多个渲染对象为一次提交，减少 GPU 压力</td>
    </tr>
    <tr>
      <td><strong>剔除（Culling）优化</strong></td>
      <td>只渲染玩家能看到的东西</td>
    </tr>
    <tr>
      <td><strong>时间预算模型</strong></td>
      <td>每帧只做预算时间内的任务，多余的等下一帧</td>
    </tr>
  </tbody>
</table>

<h3 id="多线程并行架构">多线程并行架构</h3>
<p>Unity实际上一帧涉及多个并行线程</p>

<table>
  <thead>
    <tr>
      <th>线程</th>
      <th>负责内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>主线程</td>
      <td>脚本、GameObject 生命周期、逻辑</td>
    </tr>
    <tr>
      <td>渲染线程</td>
      <td>提交 DrawCall，生成 GPU 命令</td>
    </tr>
    <tr>
      <td>Job System</td>
      <td>并发处理物理、动画、AI 等任务</td>
    </tr>
    <tr>
      <td>GPU 线程</td>
      <td>执行渲染（光栅化、着色器等）</td>
    </tr>
  </tbody>
</table>

<p><strong>多线程图示（简化）</strong></p>
<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">帧</span> <span class="nn">#N</span>
<span class="err">主线程：</span>   <span class="err">─────►</span> <span class="nt">Update</span><span class="o">()</span> <span class="err">──►</span> <span class="nt">PrepareRender</span> <span class="err">─►</span> <span class="nt">Present</span>
<span class="err">渲染线程：</span>           <span class="err">─────►</span> <span class="nt">Submit</span> <span class="nt">Commands</span>
<span class="nt">GPU</span> <span class="err">线程：</span>                     <span class="err">─────►</span> <span class="err">渲染执行</span>
</code></pre></div></div>
<p>每个线程在同时工作，不是等待某个线程跑完再开始</p>

<h3 id="最小化处理">最小化处理</h3>
<p>Unity在每一帧中，只处理真正必要、真正可见、真正变化的内容，而不是对所有对象、组件、资源都进行全量遍历和更新<br />
这是一种性能优化策略，目的是</p>
<ul>
  <li>减少CPU和内存的使用</li>
  <li>减少主线程压力</li>
  <li>减少渲染压力</li>
  <li>保证帧率稳定</li>
</ul>

<h4 id="最小化处理的核心原则">最小化处理的核心原则</h4>

<table>
  <thead>
    <tr>
      <th>原则</th>
      <th>举例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>只更新<strong>变化</strong>的对象</td>
      <td>静止物体不会触发动画或物理</td>
    </tr>
    <tr>
      <td>只渲染<strong>可见</strong>的物体</td>
      <td>被遮挡或不在视野内的对象被剔除（Culling）</td>
    </tr>
    <tr>
      <td>只处理<strong>在场景中激活</strong>的对象</td>
      <td>非激活 GameObject 不调用生命周期函数</td>
    </tr>
    <tr>
      <td>只计算<strong>必要精度</strong>的数据</td>
      <td>LOD 降级，简化远处模型</td>
    </tr>
    <tr>
      <td>按需执行<strong>系统模块</strong></td>
      <td>关闭未使用系统，如 NavMesh、布料、粒子</td>
    </tr>
  </tbody>
</table>

<h4 id="unity常见的最小化处理机制">Unity常见的“最小化处理”机制</h4>
<h5 id="1剔除culling">1.剔除（Culling）</h5>
<p>Unity会自动或手动剔除无用物体，跳过渲染或逻辑更新</p>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Frustum Culling</td>
      <td>相机视锥外的物体不渲染</td>
    </tr>
    <tr>
      <td>Occlusion Culling</td>
      <td>被遮挡的物体不渲染</td>
    </tr>
    <tr>
      <td>LOD Group</td>
      <td>距离远时使用低面数模型</td>
    </tr>
    <tr>
      <td>Static Batching</td>
      <td>静态物体合批减少绘制指令</td>
    </tr>
  </tbody>
</table>

<h5 id="2非激活物体不处理">2.非激活物体不处理</h5>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gameObject</span><span class="p">.</span><span class="nf">SetActive</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>不会执行<code class="language-plaintext highlighter-rouge">Update()</code></li>
  <li>不会被物理系统检测</li>
  <li>不参与渲染</li>
  <li>节省计算资源</li>
</ul>

<h5 id="3脚本生命周期函数的懒执行">3.脚本生命周期函数的懒执行</h5>
<p>Unity不会在每一帧中调用所有函数，只有对应条件满足才会触发<br />
比如：</p>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>条件</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Update()</code></td>
      <td>每帧调用（激活物体）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FixedUpdate()</code></td>
      <td>只在固定帧率更新（物理开启）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnBecameVisible()</code></td>
      <td>物体刚出现在相机里时</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LateUpdate()</code></td>
      <td>Update之后才调</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnTriggerEnter()</code></td>
      <td>只有碰撞才调</td>
    </tr>
  </tbody>
</table>

<h5 id="4jobsystem--burst的细粒度任务调度">4.JobSystem / Burst的细粒度任务调度</h5>
<ul>
  <li>Job System会把数据分片并发处理，并自动分配到空闲进程</li>
  <li>Burst编译器会将运算变成SIMD、无分支命令，极致压缩计算量</li>
</ul>

<p>目标：尽量避免主线程阻塞和不必要的处理</p>

<h5 id="5实例化和资源加载的最小化">5.实例化和资源加载的最小化</h5>

<table>
  <thead>
    <tr>
      <th>技术</th>
      <th>优化点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对象池（Object Pool）</td>
      <td>重用对象，避免频繁 Instantiate/Destroy</td>
    </tr>
    <tr>
      <td>Addressables 异步加载</td>
      <td>只在用到时加载资源</td>
    </tr>
    <tr>
      <td>场景流（Scene Streaming）</td>
      <td>只加载玩家附近区域的场景</td>
    </tr>
    <tr>
      <td>延迟加载（Lazy Init）</td>
      <td>某些组件在用到时再初始化</td>
    </tr>
  </tbody>
</table>

<h3 id="gpu卸载">GPU卸载</h3>
<p>GPU卸载，是指将计算密集、并行性强的工作从CPU转交给GPU来完成，以释放CPU的压力，从而提升整帧执行效率</p>

<h3 id="原因">原因</h3>
<ul>
  <li>GPU并行能力极强：GPU内部拥有成千上万个核心，能同时处理大量数据（如像素、顶点）</li>
  <li>CPU是瓶颈：Unity主线程常因逻辑繁忙，成为帧率瓶颈</li>
  <li>渲染任务天然适合GPU：像素计算、顶点变换、光照、后处理等可并行处理</li>
  <li>渲染和逻辑可并行执行</li>
</ul>

<h3 id="哪些任务会被卸载到gpu">哪些任务会被卸载到GPU</h3>

<table>
  <thead>
    <tr>
      <th>卸载内容</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>顶点变换</td>
      <td>模型的顶点坐标变换（MVP矩阵）</td>
    </tr>
    <tr>
      <td>光照计算</td>
      <td>每像素 / 顶点光照、反射、阴影等</td>
    </tr>
    <tr>
      <td>像素着色</td>
      <td>Color blending、贴图、Fog、后期特效等</td>
    </tr>
    <tr>
      <td>后处理</td>
      <td>Bloom、AO、DOF、MotionBlur 等</td>
    </tr>
    <tr>
      <td>GPU Instancing</td>
      <td>一次性绘制成千上万相同模型</td>
    </tr>
    <tr>
      <td>Compute Shader</td>
      <td>通用并行任务，如粒子模拟、布料、体积雾等</td>
    </tr>
  </tbody>
</table>

<h3 id="unity如何实现gpu卸载">Unity如何实现GPU卸载</h3>
<p>主线程构建渲染命令 -&gt; 渲染线程提交 -&gt; GPU异步执行</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Unity C#层伪流程</span>
<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">UpdateLogic</span><span class="p">();</span> <span class="c1">// 脚本逻辑运行（CPU）</span>
    <span class="nf">UpdateAnimaion</span><span class="p">();</span> <span class="c1">// 动画采样（CPU或Job）</span>
    <span class="nf">PrepareDrawCalls</span><span class="p">();</span> <span class="c1">// 构建绘制命令</span>
    <span class="c1">// 提交给GPU渲染线程 </span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">PrepareDrawCalls()</code>把数据交给GPU（通过command buffer）</li>
  <li>GPU异步处理，不阻塞主线程</li>
</ul>

<h3 id="gpu着色器">GPU着色器</h3>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Vertex Shader</td>
      <td>每个顶点执行一次，变换模型到裁剪空间</td>
    </tr>
    <tr>
      <td>Fragment (Pixel) Shader</td>
      <td>每像素执行一次，计算最终颜色</td>
    </tr>
    <tr>
      <td>Geometry / Tessellation Shader</td>
      <td>细分曲面或生成额外几何体</td>
    </tr>
    <tr>
      <td>Compute Shader</td>
      <td>并行通用计算，不限于渲染任务（如粒子模拟）</td>
    </tr>
  </tbody>
</table>

<p><strong>Unity Standard Shader如何借助GPU完成渲染</strong>
当你使用Unity内置Shader，如Standard Shader，它会自动在GPU上执行如下操作：</p>
<ul>
  <li>变换每个顶点位置（MVP）</li>
  <li>对每个像素计算光照、纹理贴图、法线贴图</li>
  <li>对半透明物体进行混合</li>
  <li>对反射、环境光遮蔽等做实时计算</li>
</ul>

<blockquote>
  <p>如果这些都在CPU上完成，一帧可能要跑1分钟</p>
</blockquote>

<p><strong>图示：Unity渲染流程（CPU -&gt; GPU）</strong></p>
<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">C</span><span class="nn">#</span> <span class="err">脚本逻辑</span> <span class="nt">Update</span><span class="o">()]</span>        <span class="err">┐</span>
<span class="o">[</span><span class="err">动画采样</span><span class="o">/</span><span class="err">物理运算</span><span class="o">]</span>          <span class="err">├─</span> <span class="nt">CPU</span> <span class="o">(</span><span class="err">主线程</span><span class="o">)</span>
<span class="o">[</span><span class="err">构建</span> <span class="nt">DrawCall</span> <span class="err">命令</span><span class="o">]</span>         <span class="err">┘</span>
         <span class="err">↓</span>
<span class="o">[</span><span class="err">渲染线程打包命令</span><span class="o">]</span> <span class="err">─→</span> <span class="nt">CommandBuffer</span>
         <span class="err">↓</span>
<span class="o">[</span><span class="nt">GFX</span> <span class="nt">Device</span> <span class="err">发给</span> <span class="nt">GPU</span><span class="o">]</span>
         <span class="err">↓</span>
<span class="o">[</span><span class="nt">GPU</span> <span class="err">执行：</span><span class="nt">Shader</span> <span class="err">➜</span> <span class="nt">Raster</span> <span class="err">➜</span> <span class="nt">PostFX</span><span class="o">]</span>
</code></pre></div></div>

<h3 id="cpu与gpu的帧缓冲双缓冲机制">CPU与GPU的帧缓冲双缓冲机制</h3>
<p>Unity会将“本帧CPU逻辑”和上一帧“GPU渲染”并行进行</p>
<ul>
  <li>当前帧：CPU构建渲染命令</li>
  <li>上一帧：GPU正在执行渲染</li>
</ul>

<p>这样就不会阻塞CPU，也不会GPU空转</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Renderer" /><category term="Graphic" /><summary type="html"><![CDATA[在Unity中，Frame（帧）是游戏运行的基本时间单位]]></summary></entry><entry><title type="html">Unity Test Runner</title><link href="http://localhost:4000/posts/2025-07-12-Unity-Test-Runner/" rel="alternate" type="text/html" title="Unity Test Runner" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Unity-Test-Runner</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-12-Unity-Test-Runner/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity Tool" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Unity Memory Profiler</title><link href="http://localhost:4000/posts/2025-07-12-Unity-Memory-Profiler/" rel="alternate" type="text/html" title="Unity Memory Profiler" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Unity-Memory-Profiler</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-12-Unity-Memory-Profiler/"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity Tool" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Unity Debug</title><link href="http://localhost:4000/posts/2025-07-12-Debug/" rel="alternate" type="text/html" title="Unity Debug" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/Unity-Debug</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-12-Debug/"><![CDATA[<p>Unity调试时游戏开发中非常重要的一环，能够帮助开发者快速定位和解决问题。Unity提供了多种调试工具和方法，主要包括日志输出、断点调试、内存和性能分析等</p>

<h2 id="日志输出logging">日志输出（Logging）</h2>
<p>在Unity中，最常用的调试方法时通过输入日志，查看游戏运行时的状态。这些日志通常包括错误、警告和信息</p>

<h3 id="class-debug">class Debug</h3>
<p><code class="language-plaintext highlighter-rouge">Debug</code>类是Unity中的一个非常重要的工具类，用于在开发过程中输出调试信息、记录错误、警告以及其他状态信息。它位于<code class="language-plaintext highlighter-rouge">UnityEngine</code>命名空间下，提供了几个常用的方法，帮助开发者在运行时查看日志、跟踪错误以及确保游戏的逻辑正确性</p>

<h3 id="api">API</h3>
<h4 id="static-properties">Static Properties</h4>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">developerConsoleEnabled</code></td>
      <td>允许启用或禁用开发者控制台。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">developerConsoleVisible</code></td>
      <td>控制开发者控制台是否可见。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isDebugBuild</code></td>
      <td>检查当前是否为开发构建（Development Build）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">unityLogger</code></td>
      <td>获取默认的调试日志记录器。</td>
    </tr>
  </tbody>
</table>

<h4 id="static-methods">Static Methods</h4>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Assert()</code></td>
      <td>断言条件，如果条件为假，记录错误信息。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AssertFormat()</code></td>
      <td>断言条件并记录格式化的错误信息。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Break()</code></td>
      <td>暂停编辑器的执行，通常用于调试时暂停游戏。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CheckIntegrity()</code></td>
      <td>执行当前进程的完整性检查并返回发现的错误。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ClearDeveloperConsole()</code></td>
      <td>清除开发者控制台中的所有日志。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DrawLine()</code></td>
      <td>在场景中绘制一条线段。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DrawRay()</code></td>
      <td>在场景中绘制一条射线。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ExtractStackTraceNoAlloc()</code></td>
      <td>提取当前调用栈并将其填充到未管理的缓冲区中，不会分配GC内存。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IsValidationLevelEnabled()</code></td>
      <td>返回指定的验证级别是否已启用。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Log()</code></td>
      <td>记录常规日志消息到控制台。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LogAssertion()</code></td>
      <td>记录断言日志消息到控制台。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LogAssertionFormat()</code></td>
      <td>记录格式化的断言日志消息到控制台。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LogError()</code></td>
      <td>记录错误日志消息到控制台。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LogErrorFormat()</code></td>
      <td>记录格式化的错误日志消息到控制台。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LogException()</code></td>
      <td>记录异常信息到控制台。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LogFormat()</code></td>
      <td>记录格式化的日志消息到控制台。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LogWarning()</code></td>
      <td>记录警告日志消息到控制台。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LogWarningFormat()</code></td>
      <td>记录格式化的警告日志消息到控制台。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">RetrieveStartupLogs()</code></td>
      <td>返回捕获的启动日志信息。</td>
    </tr>
  </tbody>
</table>

<h2 id="断点调试breakpoint-debugging">断点调试（Breakpoint Debugging）</h2>
<p>Unity与Visual Studio等IDE集成，支持断点调试。可以通过设置断点来暂停程序的执行，查看变量值、调用栈等信息</p>
<ul>
  <li>在Visual Studio中，打开需要调试的脚本，然后点击行号旁边的空白处，设置断点</li>
  <li>在Visual Studio中，点击”Attach to Unity”按钮，这将把Visual Studio与Unity连接</li>
  <li>在Unity运行时，程序会在断点处暂停，可以查看当前的变量、堆栈信息等，帮助定位问题</li>
</ul>

<h2 id="visual-studio调试插件">Visual Studio调试插件</h2>
<p>Unity默认支持与Visual Studio的集成，在Visual Studio中可以使用许多调试功能：</p>
<ul>
  <li>Watch变量：在断点停下时，可以通过”Watch”窗口观察指变量的实时值</li>
  <li>调用栈（Call Stack）：查看当前执行路径，帮助定位错误的来源</li>
  <li>本地变量（Locals）：查看当前函数的局部变量，检查它们的状态是否符合预期</li>
</ul>

<h2 id="profiler性能分析器">Profiler（性能分析器）</h2>
<p><a href="/posts/2025-06-11-Unity-Profiler/">Unity Profiler</a></p>

<h2 id="memory-profiler-内存分析器">Memory Profiler （内存分析器）</h2>
<p><a href="/posts/2025-07-12-Unity-Memory-Profiler/">Unity Memory Profiler</a></p>

<h2 id="unity-console">Unity Console</h2>
<p>Unity的控制台时查看日志的主要地方</p>

<ul>
  <li>
    <p>过滤日志：通过控制台顶部的过滤器，你可以选择只显示<code class="language-plaintext highlighter-rouge">Error</code>、<code class="language-plaintext highlighter-rouge">Warning</code>或<code class="language-plaintext highlighter-rouge">Info</code>，让你更专注于当前需要的日志信息</p>
  </li>
  <li>
    <p>双击日志：在控制台中，双击日志信息，会自动跳转到日志触发的代码行，便于快速定位问题</p>
  </li>
</ul>

<h2 id="输入模拟input-simulation">输入模拟（Input Simulation）</h2>
<p>如果你要调试控制器或输入相关的代码，Unity提供了输入模拟工具。你可以使用Unity编辑器内的<code class="language-plaintext highlighter-rouge">Input</code>工具进行模拟和测试。例如，测试不同设备的控制器输入，模拟键盘、鼠标或触摸事件</p>

<h2 id="test-runner单元测试">Test Runner（单元测试）</h2>
<p><a href="/posts/2025-07-12-Unity-Test-Runner/">Unity Test Runner</a></p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="UnityTool" /><summary type="html"><![CDATA[Unity调试时游戏开发中非常重要的一环，能够帮助开发者快速定位和解决问题。Unity提供了多种调试工具和方法，主要包括日志输出、断点调试、内存和性能分析等]]></summary></entry><entry><title type="html">ScriptableObject</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/ScriptableObject.html" rel="alternate" type="text/html" title="ScriptableObject" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/ScriptableObject</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/ScriptableObject.html"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Syntax" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">ScriptedImporter</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/ScriptedImporter.html" rel="alternate" type="text/html" title="ScriptedImporter" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/ScriptedImporter</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/ScriptedImporter.html"><![CDATA[]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Syntax" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MonoBehaviour</title><link href="http://localhost:4000/posts/2025-07-11-MonoBehaviour/" rel="alternate" type="text/html" title="MonoBehaviour" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/posts/MonoBehaviour</id><content type="html" xml:base="http://localhost:4000/posts/2025-07-11-MonoBehaviour/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">MonoBehaviour</code>是Unity中最重要的基类之一，它是所有挂载到GameObject上的脚本的基础。每当在Unity编译器中创建也给C#脚本，并将其附加到一个GameObject时，这个脚本默认会继承<code class="language-plaintext highlighter-rouge">MonoBehaviour</code></p>

<p><code class="language-plaintext highlighter-rouge">MonoBehaviour</code>提供了一些非常强大的功能，尤其是在场景生命周期和事件处理方面</p>

<p><code class="language-plaintext highlighter-rouge">MonoBehaviour</code>继承自<code class="language-plaintext highlighter-rouge">Behaviour</code></p>

<h2 id="behaviour"><code class="language-plaintext highlighter-rouge">Behaviour</code></h2>
<p><code class="language-plaintext highlighter-rouge">Behaviour</code>继承自<code class="language-plaintext highlighter-rouge">Component</code>，是<code class="language-plaintext highlighter-rouge">MonoBehaviour</code>、<code class="language-plaintext highlighter-rouge">Renderer</code>、<code class="language-plaintext highlighter-rouge">Collider</code>等类的基类，它为所有脚本提供了一些通用的启用/禁用功能和调度机制</p>

<h3 id="api">API</h3>
<p><strong>Properties</strong></p>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">enabled</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>决定了当前<code class="language-plaintext highlighter-rouge">Behaviour</code>是否启用，当启用时，该组件会响应更新（如<code class="language-plaintext highlighter-rouge">Update()</code>等声明周期方法），禁用则不会</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isActiveAndEnable</code></td>
      <td><code class="language-plaintext highlighter-rouge">bool</code></td>
      <td>是一个只读属性，返回当前组件是否被启用并且它的GameObject也启用</td>
    </tr>
  </tbody>
</table>

<p><strong>示例</strong><br />
<code class="language-plaintext highlighter-rouge">enable</code>用法</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 禁用这个脚本</span>
    <span class="k">this</span><span class="p">.</span><span class="n">enabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 如果脚本启用，这部分代码才会执行</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Script is enabled."</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">enable</code>在继承时的行为<br />
如果你继承自<code class="language-plaintext highlighter-rouge">Behaviour</code>，并且禁用该组件，那么Unity会停止调用该组件的方法。但是，如果<code class="language-plaintext highlighter-rouge">Behaviour</code>的父类被禁用，你仍然可以控制<code class="language-plaintext highlighter-rouge">enable</code>属性来启用或禁用某些组件行为</p>

<h4 id="启用和禁用的实际应用">启用和禁用的实际应用</h4>
<h5 id="控制游戏对象的行为">控制游戏对象的行为</h5>
<ul>
  <li>动态启用/禁用：你可以根据游戏的状态动态启用或禁用脚本、组件或整个GameObject</li>
</ul>

<p>例如在游戏中按下按钮时禁用某些功能或暂停某些操作</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">GameController</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">GameObject</span> <span class="n">player</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">PauseGame</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 禁用玩家脚本，暂停玩家控制</span>
        <span class="n">player</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">PlayerController</span><span class="p">&gt;().</span><span class="n">enabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">ResumeGame</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 启用玩家脚本，恢复玩家控制</span>
        <span class="n">player</span><span class="p">.</span><span class="n">GetComponenet</span><span class="p">&lt;</span><span class="n">PlayerController</span><span class="p">&gt;().</span><span class="n">enabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="控制物体动画与行为">控制物体动画与行为</h5>
<ul>
  <li>暂停和恢复：在游戏中，可能会遇到暂停菜单时，禁用和启用某些脚本或动画</li>
</ul>

<h5 id="控制物理行为">控制物理行为</h5>
<ul>
  <li>禁用物理计算：在某些情况下，你可能只希望在特定条件下启用物理计算</li>
</ul>

<h2 id="monobehaviour"><code class="language-plaintext highlighter-rouge">MonoBehaviour</code></h2>
<p><code class="language-plaintext highlighter-rouge">MonoBehaviour</code>是Unity中最核心的类之一，它为游戏开发者提供了许多功能和特性，使得脚本能够与Unity引擎进行交互<br />
通过继承<code class="language-plaintext highlighter-rouge">MonoBehaviour</code>，可以让自定义类称为Unity组件，并使用Unity引擎提供的生命周期方法、事件处理、协程支持等功能</p>

<p><strong><code class="language-plaintext highlighter-rouge">MonoBehaviour</code>会提供以下特性：</strong></p>

<h3 id="1生命周期方法">1.生命周期方法</h3>
<p><code class="language-plaintext highlighter-rouge">MonoBehaviour</code>提供了多个生命周期方法，让你能够在合适的时机执行代码。这些方法涵盖了Unity引擎中的许多重要事件，包括初始化、更新、碰撞检测等</p>

<p><a href="/assets/images/monobehaviour_flowchart.svg">生命周期函数示意图</a></p>

<h4 id="初始化阶段只执行一次">初始化阶段（只执行一次）</h4>

<p>初始化阶段的生命周期函数是游戏对象创建并激活后、正式开始游戏逻辑之前自动调用的一系列函数，主要用于初始化变量、加载资源、设置状态等操作</p>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>调用时机</th>
      <th>用途</th>
      <th>特点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Awake()</code></td>
      <td>脚本实例被 <strong>加载</strong> 后立刻调用（即使对象未启用也会调用）</td>
      <td>初始化数据、引用等（最早）</td>
      <td>初始化非依赖其他组件的逻辑</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnEnable()</code></td>
      <td>对象启用时调用（<strong>每次启用都会调用</strong>）</td>
      <td>脚本激活可以多次触发</td>
      <td>常用于注册事件</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Start()</code></td>
      <td>所有对象的<code class="language-plaintext highlighter-rouge">Awake()</code>调用完后，在对象启用的第一帧调用一次</td>
      <td>初始化逻辑，如加载资源、启动协程</td>
      <td>初始化依赖其他组件/对象的逻辑</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Awake()</code>
    <ul>
      <li>在脚本实例被加载时调用（即使对象未激活）</li>
      <li>多个脚本中Awake的调用顺序是不确定的</li>
      <li>通常用于
        <ul>
          <li>分配资源</li>
          <li>设置初始状态</li>
          <li>创建单例</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">OnEnable()</code>
    <ul>
      <li>当对象或脚本被启用时调用</li>
      <li>会在每次启用时重复调用</li>
      <li>通常用于：
        <ul>
          <li>注册事件</li>
          <li>启动协程</li>
          <li>绑定输入</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Start()</code>
    <ul>
      <li>在启用的组件第一帧更新前调用，且只调用一次</li>
      <li>所有<code class="language-plaintext highlighter-rouge">Awake()</code>执行完后才调用<code class="language-plaintext highlighter-rouge">Start()</code></li>
      <li>通常用于
        <ul>
          <li>获取其他组件</li>
          <li>设置UI、初始化依赖关系</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="运行时循环阶段重复执行">运行时循环阶段（重复执行）</h4>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>调用频率</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FixedUpdate()</code></td>
      <td>每固定时间（如 0.02 秒）</td>
      <td>物理计算、施加力、碰撞检测等</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Update()</code></td>
      <td>每帧</td>
      <td>常规逻辑、输入处理、状态更新</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">LateUpdate()</code></td>
      <td>每帧</td>
      <td>摄像机追踪、骨骼动画等需要晚一点处理的逻辑</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnGUI()</code></td>
      <td>每帧多次</td>
      <td>IMGUI 绘图接口，用于旧 GUI 系统（已不推荐）</td>
    </tr>
  </tbody>
</table>

<h5 id="关于update">关于<code class="language-plaintext highlighter-rouge">Update()</code></h5>
<ul>
  <li>适合做需要实时响应和更新的逻辑，例如输入检测、动画控制、AI决策等</li>
</ul>

<p><strong>在Update()中实现“时间无关”逻辑</strong>
由于帧率变化，直接写逻辑会导致游戏表现不同步<br />
解决方法：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">moveSpeed</span> <span class="p">=</span> <span class="m">5f</span><span class="p">;</span>
    <span class="n">transform</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">moveSpeed</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Time.deltaTime</code>是上一帧到当前帧的时间差</li>
  <li>乘以<code class="language-plaintext highlighter-rouge">deltaTime</code>可以保证无论帧率多少，运动速度都一样</li>
</ul>

<p><strong>常见用法</strong>
1.键盘输入控制移动</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">h</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">v</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>
    <span class="n">Vector3</span> <span class="n">dir</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">transform</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="n">dir</span> <span class="p">*</span> <span class="m">5f</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>2.每帧检测条件触发事件</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="nf">GetKeyDown</span><span class="p">(</span><span class="n">KeyCode</span><span class="p">.</span><span class="n">Space</span><span class="p">))</span> <span class="nf">Jump</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>性能注意事项</strong></p>
<ul>
  <li>频繁且复杂的操作放在<code class="language-plaintext highlighter-rouge">Update()</code>中会影响帧率</li>
  <li>可以考虑
    <ul>
      <li>减少<code class="language-plaintext highlighter-rouge">Update()</code>中的耗时计算</li>
      <li>合理使用事件驱动替代轮询</li>
      <li>利用<code class="language-plaintext highlighter-rouge">Coroutine</code>或<code class="language-plaintext highlighter-rouge">InvokeRepeating</code>控制调用频率</li>
      <li>对复杂逻辑分帧处理或异步处理</li>
    </ul>
  </li>
</ul>

<p><strong>当关闭或禁用脚本时，Update()不会被调用，当GameObejct被禁用时，所有附加脚本的Update()都停止调用</strong></p>

<h4 id="关于lateupdate">关于<code class="language-plaintext highlighter-rouge">LateUpdate()</code></h4>
<ul>
  <li>每帧调用一次，但始终在所有<code class="language-plaintext highlighter-rouge">Update()</code>函数调用之后调用</li>
  <li>用于需要在所有<code class="language-plaintext highlighter-rouge">Update()</code>完成后再处理的逻辑</li>
</ul>

<h5 id="典型用途">典型用途</h5>
<p><strong>1.摄像机跟随</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">FollowTarget</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Transform</span> <span class="n">target</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">LateUpdate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">target</span><span class="p">.</span><span class="n">position</span> <span class="p">+</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="p">-</span><span class="m">10</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>假设主角的位置在<code class="language-plaintext highlighter-rouge">Update()</code>中移动</li>
  <li>如果摄像机在<code class="language-plaintext highlighter-rouge">Update()</code>中跟随，就会比角色“慢一帧”</li>
  <li>用<code class="language-plaintext highlighter-rouge">LateUpdate()</code>可以确保摄像机总是跟着角色最终的位置</li>
</ul>

<p><strong>2.骨骼/动画后处理</strong></p>
<ul>
  <li>动画系统也会在<code class="language-plaintext highlighter-rouge">Update()</code>后更新状态</li>
  <li>用<code class="language-plaintext highlighter-rouge">LateUpdate()</code>来处理动画附属物的位置，如武器、特效等</li>
</ul>

<p><strong>3.平滑插值（Smooth Follow）</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">LateUpdate</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="nf">Lerp</span><span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">target</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span> <span class="p">*</span> <span class="m">5</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>放在<code class="language-plaintext highlighter-rouge">LateUpdate()</code>可以让插值始终作用在最终位置上
    <blockquote>
      <p><code class="language-plaintext highlighter-rouge">LateUpdate()</code>是在每帧所有逻辑处理完之后调用的函数，适合做跟随、补偿、视觉同步、动画后处理等操作</p>
    </blockquote>
  </li>
</ul>

<h4 id="关于fixedupdate">关于<code class="language-plaintext highlighter-rouge">FixedUpdate()</code></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">FixedUpdate()</code>是MonoBehaviour提供的生命周期函数</li>
  <li>以固定的时间间隔执行，默认每0.02s，而不是每帧执行一次</li>
  <li>适用于物理引擎相关的逻辑（刚体、碰撞器、重力等）</li>
  <li>使用<code class="language-plaintext highlighter-rouge">Time.fixedDeltaTime</code>进行时间控制
    <blockquote>
      <p><code class="language-plaintext highlighter-rouge">FixedUpdate()</code>不一定每帧都调用，也可能在一帧内被调用多次（为了补上落后时间）</p>
    </blockquote>
  </li>
</ul>

<h5 id="为什么物理逻辑必须放在fixedupdate">为什么物理逻辑必须放在<code class="language-plaintext highlighter-rouge">FixedUpdate()</code></h5>
<p>Unity的物理系统（Rigidbody、Collider等）是在物理引擎中执行的，它以固定步长（Fixed Timestep）计算模拟</p>

<p>如果你在<code class="language-plaintext highlighter-rouge">Update()</code>中对刚体施加力</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">rb</span><span class="p">.</span><span class="nf">AddForce</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>每帧调用一次，但帧率变化会导致模拟不准确</li>
  <li>如果FPS降低，你的物体就加速慢了</li>
</ul>

<p>正确做法：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">FixedUpdate</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">rb</span><span class="p">.</span><span class="nf">AddForce</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>固定时间模拟，物理表现就一致</li>
</ul>

<h5 id="时间控制">时间控制</h5>
<p>默认情况下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Time.fixedDeltaTime = 0.02f(每秒调用50次)
</code></pre></div></div>
<p>可以通过<code class="language-plaintext highlighter-rouge">Edit &gt; Project Setting &gt; Time</code>修改</p>

<p><strong>示例：让角色持续向前移动（基于物理）</strong></p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Rigidbody</span> <span class="n">rb</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">rb</span> <span class="p">=</span> <span class="n">GetComponenet</span><span class="p">&lt;</span><span class="n">Rigidbody</span><span class="p">&gt;();</span>

<span class="k">void</span> <span class="nf">FixedUpdate</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">rb</span><span class="p">.</span><span class="nf">MovePosition</span><span class="p">(</span><span class="n">rb</span><span class="p">.</span><span class="n">position</span> <span class="p">+</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="m">5f</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">fixedDeltaTime</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>用<code class="language-plaintext highlighter-rouge">MovePosition()</code>更适合刚体控制</li>
  <li><code class="language-plaintext highlighter-rouge">Time.fixedDeltaTime</code>保持匀速</li>
</ul>

<p><strong>注意事项</strong>
1.不要在<code class="language-plaintext highlighter-rouge">FixedUpdate()</code>中检测<code class="language-plaintext highlighter-rouge">Input.GetKey()</code><br />
因为输入每帧更新，可能miss</p>

<p>2.与物理系统交互统一放在<code class="language-plaintext highlighter-rouge">FixedUpdate()</code><br />
避免不一致和jitter</p>

<p>3.可能一帧内调用多次<code class="language-plaintext highlighter-rouge">FixedUpdate()</code>
这是为了追上物理时间进度</p>

<h4 id="碰撞触发事件">碰撞/触发事件</h4>

<p>发生在物理更新阶段（即<code class="language-plaintext highlighter-rouge">FixedUpdate()</code>阶段）之后调用，调用频率和FixedUpdate()一致，不受帧率的影响</p>

<p><strong>Rigidbody + Collider才能触发以下函数</strong></p>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnCollisionEnter(Collision col)</code></td>
      <td>碰撞开始</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnCollisionStay(Collision col)</code></td>
      <td>碰撞持续</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnCollisionExit(Collision col)</code></td>
      <td>碰撞结束</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnTriggerEnter(Collider col)</code></td>
      <td>触发器进入</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnTriggerStay(Collider col)</code></td>
      <td>触发器内持续</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnTriggerExit(Collider col)</code></td>
      <td>触发器离开</td>
    </tr>
  </tbody>
</table>

<p><a href="/posts/2025-06-03-Physics-System/">Unity物理系统</a></p>

<h4 id="渲染阶段">渲染阶段</h4>

<table>
  <thead>
    <tr>
      <th>阶段</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnPreRender()</code></td>
      <td>摄像机开始渲染前</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnRenderObject()</code></td>
      <td>所有对象渲染时</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnPostRender()</code></td>
      <td>摄像机完成渲染后</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnWillRenderObject()</code></td>
      <td>对象将被摄像机渲染前</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnDrawGizmos()</code> / <code class="language-plaintext highlighter-rouge">OnDrawGizmosSelected()</code></td>
      <td>编辑器中画 Gizmos</td>
    </tr>
  </tbody>
</table>

<h4 id="禁用销毁阶段">禁用/销毁阶段</h4>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnDisable()</code></td>
      <td>脚本被禁用时调用（如 <code class="language-plaintext highlighter-rouge">enabled = false</code> 或 <code class="language-plaintext highlighter-rouge">SetActive(false)</code>）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnDestroy()</code></td>
      <td>脚本被销毁前调用，用于释放资源、停止协程等</td>
    </tr>
  </tbody>
</table>

<h4 id="应用生命周期事件">应用生命周期事件</h4>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnApplicationPause(bool pause)</code></td>
      <td>应用暂停/恢复时调用（如手机切后台）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnApplicationFocus(bool focus)</code></td>
      <td>是否获得焦点（如切到其他应用）</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">OnApplicationQuit()</code></td>
      <td>应用关闭前调用</td>
    </tr>
  </tbody>
</table>

<h2 id="自定义生命周期顺序">自定义生命周期顺序</h2>
<p>Unity默认调用顺序无法改变（例如A的Awake总在B前），但可以手动更改执行顺序</p>

<h3 id="方法一inspector设置执行顺序">方法一：Inspector设置执行顺序</h3>
<p>菜单栏：<code class="language-plaintext highlighter-rouge">Edit &gt; Project Settings &gt; Script Execution Order</code><br />
把关键脚本设置为更早或更晚执行</p>

<h3 id="方法二代码显示调用推荐">方法二：代码显示调用（推荐）</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">manager</span> <span class="p">=</span> <span class="n">FindObjectOfType</span><span class="p">&lt;</span><span class="n">GameManager</span><span class="p">&gt;();</span>
    <span class="n">manager</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2协程coroutine">2.协程（Coroutine）</h3>
<p><code class="language-plaintext highlighter-rouge">MonoBehaviour</code>提供了对协程的支持，协程允许你在多个帧之间暂停执行某些代码，而不会阻塞主线程。使用协程，你可以轻松实现延迟、定时任务、动画过渡等功能
<a href="/posts/2025-06-03-Coroutine/">Coroutine</a></p>

<h3 id="3输入处理">3.输入处理</h3>
<p><a href="/posts/2025-06-03-Input-System/">Input-System</a></p>

<h3 id="4物理与碰撞">4.物理与碰撞</h3>
<p><a href="/posts/2025-06-03-Physics-System/">Physics-System</a></p>

<h3 id="5组件管理">5.组件管理</h3>
<p>可以使用<code class="language-plaintext highlighter-rouge">GetComponent</code>和<code class="language-plaintext highlighter-rouge">AddComponent</code>等方法来访问和控制其他组件。例如，获取物体的Rigidbody`组件或添加新的组件</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Rigidbody</span> <span class="n">rb</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Rigidbody</span><span class="p">&gt;();</span> <span class="c1">// 获取组件</span>
<span class="n">rb</span><span class="p">.</span><span class="nf">AddForce</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="m">10f</span><span class="p">);</span> <span class="c1">// 应用力</span>

<span class="c1">// 动态添加组件</span>
<span class="n">gameObject</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">BoxCollider</span><span class="p">&gt;();</span>
</code></pre></div></div>

<h3 id="6monobehaviour特性">6.<code class="language-plaintext highlighter-rouge">MonoBehaviour</code>特性</h3>
<ul>
  <li>附加到GameObject上：通过<code class="language-plaintext highlighter-rouge">MonoBehaviour</code>，你可以将脚本附加到GameObject上，从而使该GameObject拥有行为</li>
  <li>可在Inspector中配置：<code class="language-plaintext highlighter-rouge">MonoBehaviour</code>的公共字段（如<code class="language-plaintext highlighter-rouge">public</code>变量）可以在Unity编辑器的Inspector面板中查看和修改</li>
  <li>生命周期管理：提供了许多生命周期方法，如<code class="language-plaintext highlighter-rouge">Awake</code>、 <code class="language-plaintext highlighter-rouge">Start</code>、<code class="language-plaintext highlighter-rouge">Update</code>，以及与物理和碰撞相关的方法</li>
</ul>

<h3 id="7其他功能">7.其他功能</h3>
<ul>
  <li>场景管理:<a href="/posts/2025-06-08-Scene-System/">Scene-System</a></li>
  <li>日志输出：<a href="/posts/2025-07-12-Debug/">Debug</a></li>
</ul>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Syntax" /><category term="Unity Class" /><summary type="html"><![CDATA[MonoBehaviour是Unity中最重要的基类之一，它是所有挂载到GameObject上的脚本的基础。每当在Unity编译器中创建也给C#脚本，并将其附加到一个GameObject时，这个脚本默认会继承MonoBehaviour]]></summary></entry><entry><title type="html">Import Assets</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets.html" rel="alternate" type="text/html" title="Import Assets" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Import-Assets.html"><![CDATA[<p>Unity支持多种格式的资源文件，并能自动识别并进行初步处理</p>

<h2 id="资源导入基本流程">资源导入基本流程</h2>
<p><strong>1.将资源文件拖入<code class="language-plaintext highlighter-rouge">Assets</code>目录中（Unity会自动导入）</strong><br />
<strong>2.在Inspector面板中查看导入设置</strong><br />
<strong>3.配置相关参数，比如压缩方式、贴图类型、是否生成碰撞体等</strong><br />
<strong>4.使用资源（拖到场景、作为材质贴图、挂到AudioSource等）</strong></p>

<h2 id="模型">模型</h2>

<h3 id="支持格式">支持格式</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.fbx</code>推荐</li>
  <li><code class="language-plaintext highlighter-rouge">.obj</code></li>
  <li><code class="language-plaintext highlighter-rouge">.dae</code>（Collada）</li>
  <li><code class="language-plaintext highlighter-rouge">.blend</code>（需要Blender）</li>
</ul>

<h3 id="导入流程">导入流程</h3>
<p>1.拖拽<code class="language-plaintext highlighter-rouge">.fbx</code>文件到<code class="language-plaintext highlighter-rouge">Assets</code>文件夹<br />
2.选中模型文件，查看<code class="language-plaintext highlighter-rouge">Inspector</code>的导入设置</p>
<ul>
  <li>Scale Factor：缩放（一般保持默认）</li>
  <li>Import Animations：是否导入动画</li>
  <li>Import Materials：是否导入材质</li>
  <li>Generate Colliders：是否自动生成碰撞体</li>
</ul>

<h3 id="导入后组成">导入后组成</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Model</code>: 3D网格</li>
  <li><code class="language-plaintext highlighter-rouge">Rig</code>（如果有骨骼）：用于动画绑定</li>
  <li><code class="language-plaintext highlighter-rouge">Animation</code>：包含的动画片段</li>
  <li><code class="language-plaintext highlighter-rouge">Materials</code>：自动生成或关联的材质</li>
</ul>

<h2 id="贴图">贴图</h2>

<h3 id="支持格式-1">支持格式</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.png</code>、<code class="language-plaintext highlighter-rouge">.jpg</code>、<code class="language-plaintext highlighter-rouge">.tga</code>、<code class="language-plaintext highlighter-rouge">.psd</code>（支持图层）等</li>
</ul>

<h3 id="导入流程-1">导入流程</h3>

<p>1.拖入图片文件
2.在Inspector中设置：</p>
<ul>
  <li>sRGB（Color Texture）：颜色贴图用，法线贴图需取消勾选</li>
  <li>Alpha Is Transparency：如果使用透明通道</li>
  <li>Wrap Mode：Repeat（平铺）或Clamp（拉伸）</li>
  <li>Filter Mode：Bilinear、Trilinear、Point（像素风）</li>
  <li>Compression：高压缩（小体积）还是高质量（清晰）</li>
  <li>Texture Type:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Default</code>（通用）</li>
      <li><code class="language-plaintext highlighter-rouge">Sprite</code>（用于UI）</li>
      <li><code class="language-plaintext highlighter-rouge">Normal map</code>（法线贴图）</li>
      <li><code class="language-plaintext highlighter-rouge">Lightmap</code>（光照图）</li>
    </ul>
  </li>
</ul>

<h2 id="音频">音频</h2>

<h3 id="支持格式-2">支持格式</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.mp3</code>（压缩）</li>
  <li><code class="language-plaintext highlighter-rouge">.wav</code>（无损）</li>
  <li><code class="language-plaintext highlighter-rouge">.ogg</code>（高效）</li>
  <li><code class="language-plaintext highlighter-rouge">.aiff</code></li>
</ul>

<h2 id="导入流程-2">导入流程</h2>

<p>1.拖入音频文件<br />
2.在<code class="language-plaintext highlighter-rouge">Inspector</code>中设置：</p>
<ul>
  <li>Load Type：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Decompress On Load</code>（加载时解压，适合短音效）</li>
      <li><code class="language-plaintext highlighter-rouge">Streaming</code>（边播放边加载，适合背景音乐）</li>
    </ul>
  </li>
  <li>Compression Format:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Vorbis</code>、<code class="language-plaintext highlighter-rouge">ADPCM</code>、<code class="language-plaintext highlighter-rouge">PCM</code></li>
    </ul>
  </li>
  <li>3D Sound：是否启用3D空间化</li>
  <li>Loop：是否循环播放</li>
</ul>

<blockquote>
  <p><strong>资源组织建议：</strong> 使用好的文件夹结构和命名习惯，可以极大提高开发效率</p>
</blockquote>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><summary type="html"><![CDATA[Unity支持多种格式的资源文件，并能自动识别并进行初步处理]]></summary></entry><entry><title type="html">Layer</title><link href="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Layer.html" rel="alternate" type="text/html" title="Layer" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Layer</id><content type="html" xml:base="http://localhost:4000/%E7%AC%94%E8%AE%B0/2025/06/01/Layer.html"><![CDATA[<p>在Unity中，Layer是要给非常重要的系统<br />
它主要用于：</p>
<ul>
  <li>控制物体的渲染与相机的可见性</li>
  <li>控制物理碰撞（配合Layer Collision Matrix）</li>
  <li>通过脚本进行物体分类和筛选</li>
</ul>

<h2 id="什么是layer">什么是Layer</h2>

<p>Layer是给GameObject打的“标签”，但它和<code class="language-plaintext highlighter-rouge">Tag</code>不一样，Layer是用于功能性控制的，特别在：</p>
<ul>
  <li>摄像机的Culling Mask</li>
  <li>光照影响（Light Culling）</li>
  <li>物理碰撞（Physics Layer）</li>
  <li>射线检测（Raycast Layer）</li>
</ul>

<h2 id="layer的使用场景">Layer的使用场景</h2>
<h3 id="1摄像机视野控制culling-mask">1.摄像机视野控制（Culling Mask）</h3>
<p>在Camera组件中，你可以设置</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Culling Mask -&gt; 选择哪些Layer可以被该相机看到
</code></pre></div></div>

<p><strong>用途：</strong></p>
<ul>
  <li>UI相机只看UI层</li>
  <li>小地图相机只看敌人层</li>
  <li>分屏镜头每个只看自己的部分</li>
</ul>

<p>Layer不仅能控制每个物体是否被摄像机看到，还能与多个摄像机协作实现更加复杂的视图效果</p>

<p>例如，在多人游戏中，你可以为每个玩家设置独立的摄像机，每个摄像机通过不同的Culling Mask来渲染不同的场景部分</p>

<p>示例：多摄像头分屏控制</p>

<p>在分屏游戏中，可以设置多个摄像机，每个摄像机只渲染属于特定玩家的物体</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">camera1</span><span class="p">.</span><span class="n">cullingMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Player1"</span><span class="p">);</span>
<span class="n">camera2</span><span class="p">.</span><span class="n">cullingMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LaeryMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Player2"</span><span class="p">);</span>
</code></pre></div></div>
<p>通过这种方式，你能够在同一个场景中显示不同的物体，仅限于特定玩家的视野</p>

<h3 id="2物理碰撞控制layer-collision-matrix">2.物理碰撞控制（Layer Collision Matrix）</h3>
<p>在菜单中：</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Edit</span> <span class="s">-&gt;</span> <span class="s">Project</span> <span class="s">Settings</span> <span class="s">-&gt;</span> <span class="s">Physics</span>
</code></pre></div></div>

<p>你可以看到Layer Collision Matrix，它控制哪些Layer和哪些Layer能发生物理碰撞</p>

<p>如果在游戏中有多个物体不需要彼此发生碰撞，可以通过Layer来减少不必要的碰撞检测，提高性能</p>

<p><strong>用途：</strong></p>
<ul>
  <li>玩家层与敌人层可以碰撞，但不和自身碰撞</li>
  <li>子弹不撞自己</li>
  <li>角色不被UI的Collider打断</li>
</ul>

<h3 id="3射线检测">3.射线检测</h3>
<p>可以通过Layer来控制射线是否命中某个对象</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">layerMask</span> <span class="p">=</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Physics</span><span class="p">.</span><span class="nf">Raycast</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="k">out</span> <span class="n">hit</span><span class="p">,</span> <span class="m">100f</span><span class="p">,</span> <span class="n">layerMask</span><span class="p">))</span> <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Hit enemy"</span><span class="p">);</span>
</code></pre></div></div>

<p>也可以多层合并：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">mask</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Enemy"</span><span class="p">))</span> <span class="p">|</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"NPC"</span><span class="p">));</span>
</code></pre></div></div>
<h2 id="内置与自定义layer">内置与自定义Layer</h2>

<h3 id="内置layerunity默认的">内置Layer（Unity默认的）</h3>

<table>
  <thead>
    <tr>
      <th>编号</th>
      <th>名称</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>Default</td>
      <td>默认层</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Water</td>
      <td>水体特效</td>
    </tr>
    <tr>
      <td>5</td>
      <td>UI</td>
      <td>UI 专用</td>
    </tr>
  </tbody>
</table>

<h3 id="自定义layer">自定义Layer</h3>
<p>Unity允许你最多使用32个Layer（编号 0~31），其中前几个是保留的<br />
自定义方式：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">选中</span> <span class="n">GameObject</span> <span class="o">-&gt;</span> <span class="n">Inspector</span> <span class="o">-&gt;</span> <span class="n">Layer</span> <span class="o">-&gt;</span> <span class="k">Add</span> <span class="n">Layer</span><span class="p">...</span>
</code></pre></div></div>
<p>添加后可为GameObject设置：</p>
<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Layer</span> <span class="s">-&gt;</span> <span class="s">你刚添加的层名</span>
</code></pre></div></div>
<h2 id="layer与tag的区别">Layer与Tag的区别</h2>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>Layer</th>
      <th>Tag</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>数量限制</td>
      <td>最多 32 个</td>
      <td>无限制</td>
    </tr>
    <tr>
      <td>用于渲染控制</td>
      <td>是</td>
      <td>否</td>
    </tr>
    <tr>
      <td>用于物理控制</td>
      <td>是</td>
      <td>否</td>
    </tr>
    <tr>
      <td>用于分类查找</td>
      <td>有限制（用 LayerMask）</td>
      <td>可以（用 CompareTag 等）</td>
    </tr>
    <tr>
      <td>性能优化</td>
      <td>优化（用于剔除、射线过滤）</td>
      <td>无优化</td>
    </tr>
  </tbody>
</table>

<h3 id="建议">建议</h3>
<ul>
  <li>给每种功能的对象分配专属Layer</li>
  <li>摄像机、光源、UI、Trigger检测都应依赖Layer控制逻辑</li>
</ul>

<h2 id="layer性能优化与管理">Layer性能优化与管理</h2>
<h3 id="layer管理的最佳实践">Layer管理的最佳实践</h3>
<ul>
  <li>避免过多的Layer：虽然Unity最多允许32个Layer，但不建议频繁使用大量的Layer。过多的Layer会增加管理和维护的难度，且可能会影响性能。建议将层次结构设计得尽量简洁，避免无谓的冗余</li>
  <li>分层管理：根据物体的功能将其分配到不同的Layer中，例如：
    <ul>
      <li>游戏角色：<code class="language-plaintext highlighter-rouge">Player</code>,<code class="language-plaintext highlighter-rouge">Enemy</code></li>
      <li>UI界面：<code class="language-plaintext highlighter-rouge">UI</code>,<code class="language-plaintext highlighter-rouge">Menu</code></li>
      <li>特效：<code class="language-plaintext highlighter-rouge">PerticleEffects</code></li>
      <li>背景：<code class="language-plaintext highlighter-rouge">Background</code></li>
    </ul>
  </li>
</ul>

<p>通过合理的分层，既能提高渲染效率，也便于后期维护</p>

<h3 id="动态控制layer">动态控制Layer</h3>
<p>在一些场景中，可能需要根据物体的状态动态改变其Layer。比如，当玩家接触到某个特殊的物体时，可以改变其Layer，使其在某些摄像机的视野中不可见或不可碰撞</p>

<p>示例：动态更改Layer：</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gameObject</span><span class="p">.</span><span class="n">layer</span> <span class="p">=</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"Invisible"</span><span class="p">);</span>
</code></pre></div></div>
<p>通过动态修改Layer，能够灵活控制物体的行为和渲染效果</p>]]></content><author><name>ljf12825</name></author><category term="笔记" /><category term="Unity" /><category term="Unity System" /><summary type="html"><![CDATA[在Unity中，Layer是要给非常重要的系统 它主要用于： 控制物体的渲染与相机的可见性 控制物理碰撞（配合Layer Collision Matrix） 通过脚本进行物体分类和筛选]]></summary></entry></feed>