<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Logic Circuits and Digital System</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/leftbrain/>★</a></li><li><a href=/leftbrain/lab/>Lab</a></li><li><a href=/leftbrain/lib/>Lib</a></li><li><a href=/leftbrain/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /             <a class=nav-item data-path=/engine/ href=/engine/>Engine</a>         |
|                             |  /                 |           |
|                             | /                  |           |
|                             |/                   |           |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/framework/ href=/framework/>Framework</a>       |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Logic Circuits and Digital System<div class=meta>Modified: 2025-12-31
| Author：ljf12825</div></div><div class=content><p>逻辑电路与数字系统是计算机硬件和电子学的基础，涉及信号的处理、存储和运算等基本操作<br>它们由一系列的逻辑门、寄存器、时序逻辑单元等构成，通过逻辑运算实现特定功能</p><h2 id=逻辑电路>逻辑电路</h2><p>逻辑电路由基本的逻辑门组成，这些门接受输入信号并根据特定的规则产生输出</p><h3 id=逻辑门>逻辑门</h3><table><thead><tr><th>名称</th><th>描述</th><th>真值表</th></tr></thead><tbody><tr><td>与门（AND Gate）</td><td>只有所有输入都是1时，输出才为1</td><td><code>A AND B = A * B</code></td></tr><tr><td>或门（OR Gate）</td><td>只要有一个输入为1, 输出就为1</td><td><code>A OR B = A + B</code></td></tr><tr><td>非门（NOT Gate）</td><td>对输入信号进行反转，0变1, 1变0</td><td><code>NOT A = A'</code></td></tr><tr><td>异或门（XOR Gate）</td><td>只有输入不同才输入1, 相同则输出0</td><td><code>A XOR B = A ⊕ B</code></td></tr><tr><td>与非门（NAND Gate）</td><td>与门输出取反</td><td><code>A NAND B = (A * B)'</code></td></tr><tr><td>或非门（NOR Gate）</td><td>或门输出取反</td><td><code>A NOR B = (A + B)'</code></td></tr></tbody></table><h2 id=组合逻辑电路>组合逻辑电路</h2><p>组合逻辑电路是指其输出只与当前输入相关的电路，不依赖于先前的输入。常见的组合逻辑电路有</p><ul><li>加法器：二进制加法器，如半加器和全加器，用于二进制加法运算<ul><li>半加器：两位二进制数相加</li><li>全加器：两个半加器</li></ul></li><li>乘法器：二进制乘法器，可以通过加法器和位移操作实现</li><li>比较器：比较输入值的大小，输出相应的比较结果</li></ul><h3 id=加法器>加法器</h3><p>加法器是数字电路中最基本、最重要的运算单元之一，它的核心功能是执行两个二进制数的算术加法。它是CPU中算术逻辑单元（ALU）的基石</p><h4 id=半加器>半加器</h4><p>想象一下，我们只计算两个1位的二进制数相加，比如0+0, 1+1, 0+1, 1+0 这需要两个输出</p><ul><li>和：当前位的计算结果</li><li>进位：如果结果大于1,就需要向更高位进位</li></ul><p>能完成这个功能的电路就叫半加器</p><ul><li>输入：两个1位二进制数，通常称为A和B</li><li>输出：<ul><li>和：通常用S表示</li><li>进位：通常用C_out表示</li></ul></li></ul><p><strong>真值表</strong></p><table><thead><tr><th>A</th><th>B</th><th>S</th><th>C_out</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>观察真值表，可以发现</p><ul><li>S的输出和异或门一模一样。所以<code>S = A XOR B</code></li><li>C_out 的输出和与门一模一样。所以<code>C_out = A AND B</code></li></ul><p><strong>电路图</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>A ──┐
</span></span><span style=display:flex><span>    │ XOR ──&gt; S
</span></span><span style=display:flex><span>B ──┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A ──┐
</span></span><span style=display:flex><span>    │ AND ──&gt; C_out
</span></span><span style=display:flex><span>B ──┘
</span></span></code></pre></div><blockquote><p>为什么叫半加器，因为它只能处理两个输入，无法处理来自低位的进位。在真正的多位加法中，每一位的计算都需要考虑三个输入：A, B和来自低位的而进位</p></blockquote><h4 id=全加器>全加器</h4><p>为了解决半加器的缺陷，引入了全加器。全加器是构建任何多位加法器的核心模块</p><ul><li>输入：三个1位二进制数<ul><li>A（被加数的一位）</li><li>B（加数的一位）</li><li>C_in（来自低位的进位）</li></ul></li><li>输出<ul><li>S(本位的和)</li><li>C_out（向高位的进位）</li></ul></li></ul><p><strong>真值表</strong></p><table><thead><tr><th>A</th><th>B</th><th>C_in</th><th>S</th><th>C_out</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p><strong>实现方式</strong>
全加器可以用两个半加器和一个或门来构建</p><ol><li>第一个半加器计算A和B的和与进位</li></ol><ul><li><code>S1 = A XOR B</code></li><li><code>C1 = A AND B</code></li></ul><ol start=2><li>第二个半加器计算S1和C_in的和与进位</li></ol><ul><li><code>S = S1 XOR C_in</code>（这就是最终的和）</li><li><code>C2 = S1 AND C_in</code></li></ul><ol start=3><li>最终的进位输出是C1或C2任何一个为真即可</li></ol><ul><li><code>C_out = C1 OR C2</code></li></ul><p><strong>电路图（由两个半加器构成）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>        ┌──────────┐
</span></span><span style=display:flex><span>A ──────┤          │      ┌──────────┐
</span></span><span style=display:flex><span>        │  半加器1 ├─S1───┤          │
</span></span><span style=display:flex><span>B ──────┤          │      │  半加器2 ├─── S (最终和)
</span></span><span style=display:flex><span>        └──────────┘      │          │
</span></span><span style=display:flex><span>            │ C1      C_in└──────────┘
</span></span><span style=display:flex><span>            │              │
</span></span><span style=display:flex><span>            │              │ C2
</span></span><span style=display:flex><span>            └──────────────┼────┐
</span></span><span style=display:flex><span>                           │    │ OR ─── C_out (最终进位)
</span></span><span style=display:flex><span>                           └────┘
</span></span></code></pre></div><h4 id=多位加法器串联全加器>多位加法器：串联全加器</h4><p>可以用全加器来构建计算多位二进制数（比如4位、8位、32位、64位）的加法器<br>最直接的方式是行波进位加法器</p><p><strong>结构</strong></p><ul><li>将n个全加器串联起来</li><li>第一个全加器的C_in接地（表示0）</li><li>每一个全加器的C_out连接到下一个全加器的C_in</li></ul><p><strong>4位行波进位加法器示意图</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>    A3 B3        A2 B2        A1 B1        A0 B0
</span></span><span style=display:flex><span>     │  │         │  │         │  │         │  │
</span></span><span style=display:flex><span>    ┌▼──▼┐       ┌▼──▼┐       ┌▼──▼┐       ┌▼──▼┐
</span></span><span style=display:flex><span>C_in│    │   C_in│    │   C_in│    │   C_in│    │
</span></span><span style=display:flex><span>◄───┤ FA ├──────►┤ FA ├──────►┤ FA ├──────►┤ FA ├───► C_final
</span></span><span style=display:flex><span>    │    │C_out  │    │C_out  │    │C_out  │    │C_out 
</span></span><span style=display:flex><span>    └──┬─┘       └──┬─┘       └──┬─┘       └──┬─┘
</span></span><span style=display:flex><span>       S3           S2           S1           S0
</span></span></code></pre></div><p><strong>缺点</strong></p><ul><li>速度慢：进位信号必须像波浪一样从最低位（FAO）传递到最高位(FA3）。如果FA0产生了进位，这个进位必须等待它经过FA1、FA2，才能最终影响FA3的结果。这被称为进位传播延迟</li><li>对于32位或64位的CPU来说，这种延迟是不可接受的</li></ul><h4 id=现代高速加法器超前进位加法器>现代高速加法器：超前进位加法器</h4><p>超前进位加法器的设计为了解决行波进位的速度问题</p><h5 id=核心思想>核心思想</h5><p>与其等待进位信号一步步传递，不如提前计算每一位的进位<br>它通过一个复杂的逻辑电路，直接根据所有位的输入（A0, B0, A1, B1, &mldr;）和最初的C_in, 并行地计算出每一位的进位（C1, C2, C3, &mldr;）</p><h5 id=实现原理>实现原理</h5><p>它利用了“进位生成”和“进位传播”的概念</p><ul><li>生成：如果A和B都是1, 那么这一位一定会产生进位<ul><li><code>G = A AND B</code></li></ul></li><li>传播：如果A或B是1, 那么来自低位的进位将会传递到高位<ul><li><code>P = A XOR B</code></li></ul></li></ul><p>那么，每一位的进位可以表示为：</p><ul><li><code>C0 = C_in</code>（已知）</li><li><code>C1 = G0 OR (P0 AND C0)</code></li><li><code>C2 = G1 OR (P1 AND G0) OR (P1 AND P0 AND C0)</code></li><li><code>C3 = G2 OR (P2 AND G1) OR (P2 AND P1 AND G0) OR (P2 AND P1 AND P0 AND C0)</code></li><li>&mldr; &mldr;</li></ul><p>可以看到，只要有了A0<del>A3, B0</del>B3和C_in，通过一层多输入的逻辑门（与或门），就可以同时算出C1, C2, C3, 而不需要等待前一级的结果</p><h5 id=优缺点>优缺点</h5><ul><li>优点：速度极快，延迟基本固定，与位数关系不大。是现代CPU的首选</li><li>缺点：电路非常复杂，位数越高，进位计算逻辑的输入就越多，电路规模呈指数级增长。因此，在实际中通常采用折中方案（如分组超前进位）</li></ul><blockquote><p>从简单的半加器到复杂的超前进位加法器，这个演进过程完美地体现了计算机工程中的一个核心权衡：在速度、复杂度和成本之间做出取舍。而这一切，都始于对"1 + 1 = 10" 这个二进制运算的深刻理解</p></blockquote><blockquote><p>一句话概括超前进位加法器核心思想：水到渠成</p></blockquote><h4 id=总结>总结</h4><table><thead><tr><th>类型</th><th>功能</th><th>关键输入</th><th>关键输出</th><th>特点</th></tr></thead><tbody><tr><td>半加器</td><td>两个1位二进制数相加</td><td>A, B</td><td>S, C_out</td><td>基础单元，无法处理进位输入</td></tr><tr><td>全加器</td><td>三个1位二进制数相加</td><td>A, B, C_in</td><td>S, C_out</td><td>构建任何加法器的核心模块</td></tr><tr><td>行波进位加法器</td><td>多位二进制数相加</td><td>A[n], B[n]</td><td>S[n]</td><td>结构简单，速度慢，有进位延迟</td></tr><tr><td>超前进位加法器</td><td>多位二进制数相加</td><td>A[n], B[n]</td><td>S[n]</td><td>结构复杂，速度极快，无进位延迟</td></tr></tbody></table><h3 id=乘法器>乘法器</h3><p>乘法的基础是”位移与加法“<br>以两个4位二进制数<code>A(A3 A2 A1 A0)</code>和<code>B(B3 B2 B1 B0)</code>为例，其计算过程类似于十进制乘法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>         A3 A2 A1 A0  (被乘数)
</span></span><span style=display:flex><span>       x B3 B2 B1 B0  (乘数)
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>         A3 A2 A1 A0  &lt;-- B0为1时，这是第一行部分积
</span></span><span style=display:flex><span>       A3 A2 A1 A0    &lt;-- B1为1时，这是第二行部分积（左移1位）
</span></span><span style=display:flex><span>     A3 A2 A1 A0      &lt;-- B2为1时，这是第三行部分积（左移2位）
</span></span><span style=display:flex><span>   A3 A2 A1 A0        &lt;-- B3为1时，这是第四行部分积（左移3位）
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>P7 P6 P5 P4 P3 P2 P1 P0  (最终乘积)
</span></span></code></pre></div><p>乘法器的核心任务就是高效地生成这些部分积，并将它们相加</p><h4 id=移位加法乘法器>移位加法乘法器</h4><p>这是最直观、最容易理解的方法，直接模拟上述手算过程</p><h5 id=工作原理以4位为例>工作原理（以4位为例）</h5><ol><li>初始化：将一个8位的乘积寄存器<code>P</code>清零</li><li>循环检查：从最低位开始，依次检查乘数<code>B</code>的每一位<code>B[i]</code></li><li>判断与加法：如果<code>B[i] == 1</code>，则将被乘数<code>A</code>左移<code>i</code>位后的值，加到乘积寄存器<code>P</code></li><li>循环：重复步骤2和3,直到检查完乘数<code>B</code>的所有位</li></ol><h5 id=结构示意图>结构示意图</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>    被乘数 A (4位) ────┐
</span></span><span style=display:flex><span>                       │
</span></span><span style=display:flex><span>    乘数 B (4位) ──&gt; [控制逻辑] ──&gt; (检查当前位B[i]是否为1)
</span></span><span style=display:flex><span>                       │
</span></span><span style=display:flex><span>    乘积 P (8位) &lt;── [加法器] &lt;── (左移器，根据i移位A)
</span></span><span style=display:flex><span>                       │
</span></span><span style=display:flex><span>                    [移位控制] (控制左移位数)
</span></span></code></pre></div><h5 id=优缺点-1>优缺点</h5><ul><li>优点：电路结构非常简单，占用资源少</li><li>缺点：速度非常慢。对于一个n位乘法，需要大约n个时钟周期（检查n位），并且每个周期都可能进行一次n位的加法。延迟是O(n)量级</li></ul><h4 id=阵列乘法器>阵列乘法器</h4><p>为了提升速度，采用”空间换时间“，将多个加法器组织成一个阵列，以便并行地计算部分积的和</p><p><strong>核心思想：同时生成所有部分积，并用一个加法器阵列一次性将它们加起来</strong></p><h5 id=结构以4位无符号数为例>结构（以4位无符号数为例）</h5><ol><li>部分积生成：通过一排与门阵列实现。<code>B0</code>和<code>A</code>的每一位相与，生成第一行部分积；<code>B1</code>和<code>A</code>的每一位相与，生成第二行（左移1位），以此类推。这样就得到了四个部分积</li><li>加法器阵列：使用全加器作为基本单元，以类似”人工计算“时按列相加的方式，将部分积斜向对齐后，一层一层地加起来</li></ol><h5 id=简化示意图体现按列相加的思想>简化示意图（体现按列相加的思想）</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>        A3   A2   A1   A0
</span></span><span style=display:flex><span>      x B3   B2   B1   B0
</span></span><span style=display:flex><span>-------------------------
</span></span><span style=display:flex><span>      P03  P02  P01  P00  (B0 &amp; A) &lt;- 第一行部分积
</span></span><span style=display:flex><span>   P13  P12  P11  P10     (B1 &amp; A) &lt;- 第二行部分积
</span></span><span style=display:flex><span>P23  P22  P21  P20        (B2 &amp; A) &lt;- 第三行部分积
</span></span><span style=display:flex><span>P33  P32  P31  P30        (B3 &amp; A) &lt;- 第四行部分积
</span></span><span style=display:flex><span>-------------------------
</span></span><span style=display:flex><span>[全加器阵列，按斜线连接的列进行加法，并传递进位]
</span></span><span style=display:flex><span>-------------------------
</span></span><span style=display:flex><span>P7   P6   P5   P4   P3   P2   P1   P0
</span></span></code></pre></div><h5 id=优缺点-2>优缺点</h5><ul><li>优点：速度比移位加法法快得多。因为它是一个纯组合逻辑电路，信号从输入到输出一波流，不需要时钟控制。延迟主要由关键路径上的加法器链决定，约为O(n)，但常数因子远小于移位加法法</li><li>缺点：需要大量的逻辑门（与门和全加器），硬件成本高。对于32位或64为乘法，电路规模会非常庞大</li></ul><h4 id=现代高性能乘法器沃里斯树>现代高性能乘法器：沃里斯树</h4><p>对于CPU中的高性能乘法器，单纯的行波进位阵列仍然不够快。于是引入了更先进的结构————沃里斯树</p><p><strong>核心思想：使用一种树形结构来快速压缩部分积的数量</strong></p><ul><li>第一步：部分积生成-与传统阵列乘法器相同</li><li>第二步：部分积压缩-这是关键。WT使用一种名为”进位保留加法器“的单元（通常是3:2压缩器或4:2压缩器），以树形结构将多个部分积快速压缩为两个数（例如，<code>Sum</code>和<code>Carry</code>)<ul><li>3:2压缩器：输入3个二进制数，输出2个二进制数（一个和向量，一个进位向量），其数值综合等于三个输入数之和</li><li>通过多层这样的压缩，可以迅速将16个、32个部分减少到最后的2个</li></ul></li><li>第三步：最终相加-将树形结构输出的两个数（<code>Sum</code>和<code>Carry</code>），通过一个超前进位加法器进行最终相加，得到乘积结果</li></ul><h5 id=工作流程比喻>工作流程比喻</h5><p>要把一大堆（比如16堆）硬币数清楚</p><ol><li>阵列乘法器：像银行新手，两堆两堆地数，数完合一起再和下一堆数，效率低</li><li>沃里斯树：像经验丰富的团队</li></ol><ul><li>压缩阶段：先把16堆硬币，每3堆分给一个小组（3:2）压缩器。每个小组快速地数出”本地和“与”需要进位的整摞硬币“，输出为两堆。这样16堆就变成了～11堆</li><li>重复这个过程，11堆-> 8堆-> 6堆 -> 4堆 -> 2堆</li><li>最终相加：最后剩下的两堆，交给一个”神算手“（超前进位加法器）做最后一次精确计算，得出总数</li></ul><h5 id=优缺点-3>优缺点</h5><ul><li>优点：速度极快。部分积压缩的延迟是O(log n)，这是数量级的提升。是现代高性能CPU和DSP（数字信号处理器）的首选</li><li>缺点：电路结构非常复杂，布局布线困难，功耗和面积都很大</li></ul><h4 id=总结-1>总结</h4><table><thead><tr><th>类型</th><th>核心原理</th><th>速度</th><th>硬件成本</th><th>应用场景</th></tr></thead><tbody><tr><td>移位加法乘法器</td><td>串行、迭代、移位加</td><td>慢（O(n)）</td><td>低</td><td>对面积和功耗及其敏感，速度要求不高的嵌入式系统</td></tr><tr><td>阵列乘法器</td><td>并行、组合逻辑、加法器阵列</td><td>中（O(n)）</td><td>中</td><td>早期处理，对速度有一定要求但不需要极致的场景</td></tr><tr><td>沃里斯树</td><td>并行、树形结构、部分积压缩</td><td>快（O(log n)）</td><td>高</td><td>现代高性能CPU、GPU、DSP</td></tr></tbody></table><blockquote><p>从乘法器的发展可以看出，计算机工程始终在速度、面积（成本）、功耗这个”不可能三角“中进行权衡和优化</p></blockquote><h3 id=比较器>比较器</h3><p>比较器是数字电路中用于比较两个数字大小的基本组件，其核心功能是判断两个二进制数A和B的大小关系，并输出三个可能的结果之一：<code>A > B</code>, <code>A &lt; B</code>, 或<code>A = B</code></p><h4 id=1位比较器>1位比较器</h4><p>比较两个1位的二进制数A和B</p><h5 id=真值表>真值表</h5><table><thead><tr><th>A</th><th>B</th><th>A > B</th><th><code>A &lt; B</code></th><th>A = B</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p>根据真值表，可以直接写出逻辑表达式</p><ul><li><code>A > B</code>: <code>A AND (NOT B)</code></li><li><code>A &lt; B</code>: <code>(NOT A) AND B</code></li><li><code>A = B</code>: <code>A XNOR B</code>（即<code>(A AND B) OR ((NOT A) AND (NOT B))</code>）</li></ul><h5 id=电路图>电路图</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>A ──┐
</span></span><span style=display:flex><span>    │ AND ────&gt; A &gt; B
</span></span><span style=display:flex><span>B ──┘ NOT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A ──┐ NOT
</span></span><span style=display:flex><span>    │ AND ────&gt; A &lt; B
</span></span><span style=display:flex><span>B ──┘
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A ──┐
</span></span><span style=display:flex><span>    │ XNOR ───&gt; A = B
</span></span><span style=display:flex><span>B ──┘
</span></span></code></pre></div><p>这个1位比较器是构建更复杂比较器的基础模块</p><h4 id=多位比较器级联比较器>多位比较器：级联比较器</h4><p>如何比较两个多位数（例如4位）<code>A3 A2 A1 A0</code>和<code>B3 B2 B1 B0</code><br>最直观的方法是从最高位开始逐位比较，就像比较两个十进制数一样\</p><h5 id=工作原理以4位为例-1>工作原理（以4位为例）</h5><ol><li>比较最高位（A3, B3）</li></ol><ul><li>如果<code>A3 > B3</code>，那么毫无疑问，<code>A > B</code></li><li>如果<code>A3 &lt; B3</code>，那么毫无疑问，<code>A &lt; B</code></li><li>如果<code>A3 = B3</code>，那么还不能下结论，需要继续比较下一位</li></ul><ol start=2><li>比较次高位（A2, B2）：规则同上，但前提是更高位都相等</li><li>这个过程一直持续到最低位。如果所有位都相等，则A = B</li></ol><p>这种设计需要一个级联或串联的结构</p><h5 id=结构示意图-1>结构示意图</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>        ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐
</span></span><span style=display:flex><span>A3,B3 ─&gt;│ 1位   │    │ 1位   │    │ 1位   │    │ 1位   │
</span></span><span style=display:flex><span>        │比较器 │───&gt;│比较器 │───&gt;│比较器 │───&gt;│比较器 │─&gt; A = B
</span></span><span style=display:flex><span>A2,B2 ─&gt;│       │    │       │    │       │    │       │
</span></span><span style=display:flex><span>        └───────┘    └───────┘    └───────┘    └───────┘
</span></span><span style=display:flex><span>           │             │             │             │
</span></span><span style=display:flex><span>           ▼             ▼             ▼             ▼
</span></span><span style=display:flex><span>         A &gt; B         A &gt; B         A &gt; B         A &gt; B
</span></span><span style=display:flex><span>         A &lt; B         A &lt; B         A &lt; B         A &lt; B
</span></span></code></pre></div><blockquote><p>实际级联时，需要将高位的”相等“输出连接到低位的”使能“输入，表示”只有当我相等时，你下一位的比较结果才有效“</p></blockquote><h5 id=优缺点-4>优缺点</h5><ul><li>优点：结构清晰，易于理解，电路规模相对较小</li><li>缺点：速度慢。比较结果需要从最高位”传播“到最低位才能最终确定。最坏情况下（A == B），信号需要穿过所有位。延迟是O(n)</li></ul><h4 id=现代高速比较器并行比较器查找表式比较器>现代高速比较器：并行比较器/查找表式比较器</h4><p>为了解决级联比较器的速度瓶颈，现代高性能电路通常采用并行方法<br><strong>核心思想：利用一个庞大的”与-或“逻辑阵列，直接根据所有位的输入，同时（并行地）产生三个输出信号（<code>A>B</code>, <code>A &lt; B</code>, <code>A = B</code>）</strong></p><h5 id=工作原理>工作原理</h5><p>它不进行逐位比较，而是直接”查找“最终结果。以2位比较器为例，其逻辑可以直接从真值表推导出来<br>对于<code>A (A1 A0)</code>和<code>B (B1 B0)</code></p><ul><li><code>A = B</code>的条件是：<code>(A1 XNOR B1) AND (A0 XNOR B0)</code></li><li><code>A > B</code>的条件是：<ul><li><code>(A1 > B1)</code> OR <code>(A1 == B1) AND (A0 > B0)</code></li><li>展开后就是<code>(A1 AND NOT B1) OR ( (A1 XNOR B1) AND (A0 AND NOT B0) )</code></li></ul></li><li><code>A &lt; B</code>的条件是：<ul><li><code>(A1 &lt; B1)</code> OR <code>(A1 == B1) AND (A0 &lt; B0)</code></li><li>展开后就是<code>(NOT A1 AND B1) OR ( (A1 XNOR B1) AND (NOT A0 AND B0) )</code></li></ul></li></ul><h5 id=电路实现>电路实现</h5><p>上述每一个输出（<code>A>B</code>, <code>A&lt;B</code>, <code>A=B</code>）都可以用一个多输出的组合逻辑电路（与或门阵列）来实现。一旦输入<code>A1, A0, B1, B0</code>就位，这三个输出信号几乎同时产生</p><h5 id=优缺点-5>优缺点</h5><ul><li>优点：速度极快。延迟基本固定，只经过少数几级门电路（通常是2-3级），与数值位数<code>n</code>关系不大，可以认为是<code>O(1)</code>的延迟</li><li>缺点：电路复杂度随位数指数级增长。对于n位比较器，其逻辑表达式的项数会非常多，需要大量的与门和或门。对于32位或64位的比较，这样的电路在面积和功耗上都是巨大的</li></ul><h5 id=实践中的权衡>实践中的权衡</h5><p>在实际的CPU设计中，对于超宽位（如64位）的比较，通常会采用分组并行的混合方法。例如，将一个64位比较器分成4个16位的并行比较器，然后再用一个快速的逻辑层来整合这4个16位的结果，从而在速度和电路复杂度之间取得一个良好的平衡</p><h4 id=总结-2>总结</h4><table><thead><tr><th>类型</th><th>核心原理</th><th>速度</th><th>硬件成本</th><th>应用场景</th></tr></thead><tbody><tr><td>1位比较器</td><td>基本逻辑门直接实现</td><td>快</td><td>极低</td><td>构建模块</td></tr><tr><td>级联比较器</td><td>从高位到低位串行比较</td><td>慢 (O(n))</td><td>低</td><td>对速度要求不高的简单控制逻辑</td></tr><tr><td>并行比较器</td><td>用组合逻辑阵列直接得出结果</td><td>极快 (~O(1))</td><td>高</td><td>现代高性能CPU、ALU中的比较操作</td></tr></tbody></table><h2 id=时序逻辑电路>时序逻辑电路</h2><p>时序逻辑电路的输出不仅取决于当前的输入，还与历史输入（即过去的状态）有关。时序逻辑电路中常常使用“触发器”来存储状态。常见的时序逻辑电路包括：</p><ul><li>触发器（Flip-Flop）：用来存储一位二进制数据。常见的触发器有D触发器、T触发器、JK触发器等</li><li>寄存器：寄存器是多个触发器的组合，用来存储多位二进制数据</li><li>计数器：可以按顺序计数的电路，通常由触发器和逻辑门构成</li><li>移位寄存器：将寄存器中存储的数据逐位向左或向右移动</li><li>存储器（RAM）：大规模存储数据</li><li>有限状态机：这是时序逻辑电路中最核心、最抽象的概念。它描述了一个系统在不同“状态”之间转移的行为</li></ul><h3 id=触发器>触发器</h3><p>时序逻辑电路能够“记忆”的关键，在与它包含了存储元件，最主要的就是触发器</p><p>触发器是一种具有两种稳定状态（0和1）的电路，可以长期保持其中一种状态，直到特定的输入信号（通常是始终信号）让它改变</p><h4 id=ddata触发器>D(Data)触发器</h4><p>D触发器是一种具有记忆功能的时序逻辑单元，它能存储一位二进制数据（0或1）</p><h5 id=关键特性与工作原理>关键特性与工作原理</h5><p>D触发器的核心工作机制可以概括为：在时钟信号的特定边沿，将输入端D的当前值捕获，并成为输出端Q的新值，并保持这个值直到下一个时钟边沿</p><ol><li>基本端口：</li></ol><ul><li>D（数据输入端）：这是你想要存储的数据</li><li>CLK（时钟输入端）：这是控制数据何时被存入的“指挥官”</li><li>Q（数据输出端）：这是存储的数据</li><li>Q&rsquo;（反相输出端）：这是Q的相反信号（即Q=1时，Q&rsquo;=0,反之亦然）。这个端口并非总是需要</li></ul><ol start=2><li>时钟边沿触发
这是D触发器的最关键的特性。它不是持续地响应D端的变化，而是只在时钟信号一个非常短暂的瞬间进行采样</li></ol><ul><li>上升沿触发：在时钟信号CLK从0跳变到1的瞬间，D触发器动作。在电路图中，通常在CLK端用一个小三角形表示</li><li>下降沿触发：在时钟信号CLK从1跳变到0的瞬间，D触发器动作。在电路图中，通常在CLK端用小三角形加一个气泡表示</li></ul><p>在时钟沿之外的时间，无论D端输入如何变化，Q端的输出都始终保持不变。这个“保持不变”的特性，就是“锁存”或“记忆”功能的体现
3. 时序要求
为了让D触发器可靠地工作，数据输入D必须在时钟边沿附近满足一定的稳定性要求</p><ul><li>建立时间：在时钟边沿到来之前，输入信号D必须保持稳定的一小段时间</li><li>保持时间：在时钟边沿过去之后，输入信号D必须继续保持稳定的一小段时间</li></ul><p>如果违反了这两个时序要求，触发器可能会进入一个不稳定的“亚稳态”，导致输出无法预测</p><h5 id=真值表-1>真值表</h5><table><thead><tr><th>CLK</th><th>D</th><th>Q（下一刻）</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>0</td><td>0</td><td>时钟上升沿时，若D=0, 则Q变为0</td></tr><tr><td>^</td><td>1</td><td>1</td><td>时钟上升沿时，若D=1, 则Q变为1</td></tr><tr><td>0/1/v</td><td>X</td><td>Q（保持）</td><td>非上升沿时，D的任何变化都不影响Q</td></tr></tbody></table><ul><li>^表示时钟上升沿</li><li>X表示“无关项”，可以是0或1</li></ul><h5 id=增强型d触发器>增强型D触发器</h5><p>在实际应用中，基本的D触发器通常会增加一些控制输入端，使其功能更强大</p><ul><li>复位端<ul><li>同步复位：只有在时钟边沿到来时，如果复位信号有效，才将Q强制清零。复位与时钟同步</li><li>异步复位：只要复位信号有效，立即将Q强制清零，完全无视时钟信号。这是最高优先级的控制信号，在电路图中通常在R端加一个小气泡表示低电平有效</li></ul></li><li>置位端<ul><li>与复位端相反，它用于将Q强制置1。同样分为同步置位和异步置位</li></ul></li></ul><h6 id=带有异步复位和置位的d触发器真值表假设低电平有效>带有异步复位和置位的D触发器真值表（假设低电平有效）</h6><table><thead><tr><th>RST（复位）</th><th>SET（置位）</th><th>CLK</th><th>D</th><th>Q</th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>X</td><td>X</td><td>0</td><td>（异步复位，最高优先级）</td></tr><tr><td>1</td><td>0</td><td>X</td><td>X</td><td>1</td><td>（异步置位，最高优先级）</td></tr><tr><td>1</td><td>1</td><td>^</td><td>0</td><td>0</td><td>（正常采样：D=0 -> Q=0</td></tr><tr><td>1</td><td>1</td><td>^</td><td>1</td><td>1</td><td>（正常采样：D=1 -> Q=1</td></tr><tr><td>1</td><td>1</td><td>非^</td><td>X</td><td>Q（保持）</td><td>（保持状态）</td></tr></tbody></table><h5 id=内部结构>内部结构</h5><p>一个主从D触发器通常由两个电平触发的D锁存器级联而成</p><ol><li>当CLK=0时：</li></ol><ul><li>主锁存器打开，它跟随着输入D的变化</li><li>从锁存器关闭，保持原来的值，将主锁存器刚锁存的值传递到最终输出Q</li></ul><ol start=2><li>当CLK从0跳变为1时（上升沿）：</li></ol><ul><li>主锁存器瞬间关闭，锁存住跳变前一刻的D值</li><li>从锁存器瞬间打开，将主锁存器刚锁存的值传递到最终输出Q</li></ul><ol start=3><li>当CLK=1时：</li></ol><ul><li>主锁存器关闭，完全不受D端变化的影响</li><li>从锁存器打开，但其输入来自一个稳定的值，因此Q端输出稳定</li></ul><p>这种“主-从”结构，通过两个锁存器交替开关，实现了在边沿瞬间采样并锁存数据的功能</p><h4 id=ttoggle触发器>T(Toggle)触发器</h4><p>核心功能：当T输入为1时，每个有效的时钟边缘都会使输出状态反转；当T输入为0时，输出状态保持不变<br>简单来说，它是一个受控的反转开关</p><h5 id=关键特性与工作原理-1>关键特性与工作原理</h5><ol><li>基本端口</li></ol><ul><li>T（反转控制器）：控制输出是否要反转</li><li>CLK（时钟输入端）：控制反转发生的时刻</li><li>Q（数据输出端）：当前的存储状态</li><li>Q&rsquo;（反相输出端）：Q的反相</li></ul><ol start=2><li>工作模式
T触发器的功能可以用一个非常简单的规则来描述</li></ol><ul><li>如果T = 1：在时钟边沿到来时，输出Q反转（即<code>Q(next) = NOT Q(current)</code>）</li><li>如果T = 0：在时钟边沿到来时，输出Q保持（即<code>Q(next) = Q(current)</code>）</li></ul><h5 id=真值表-2>真值表</h5><table><thead><tr><th>CLK</th><th>T</th><th>Q（当前）</th><th>Q（下一刻）</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>0</td><td>0</td><td>0</td><td>T=0,保持状态</td></tr><tr><td>^</td><td>0</td><td>1</td><td>1</td><td>T=0,保持状态</td></tr><tr><td>^</td><td>1</td><td>0</td><td>1</td><td>T=1,翻转状态（0->1）</td></tr><tr><td>^</td><td>1</td><td>1</td><td>0</td><td>T=1,翻转状态（1->0）</td></tr><tr><td>非^</td><td>X</td><td>Q</td><td>Q</td><td>无时钟边缘，永远保持</td></tr></tbody></table><h5 id=一个重要的特例t恒为1>一个重要的特例：T恒为1</h5><p>如果将T触发器的T输入端永久接高电平（逻辑1），那么它变成了一个二进制分频器或2分频计数器</p><ul><li>每个时钟边沿到来时，因为<code>T=1</code>，输出Q都会翻转一次</li><li>这意味着Q变化的频率正好是时钟频率的一半</li></ul><p>这就是“分频”概念的由来，它是构成计数器的基础</p><h5 id=t触发器的实现>T触发器的实现</h5><p>在标准的集成电路芯片中，并不存在一个名为“T触发器”的独立元件<br>这是因为T触发器通常由D触发器转换而来。通过添加一个简单的组合逻辑电路，就可以让D触发器表现出T触发器的行为<br>将D触发器的输出Q和输入D通过一个异或门连接起来，T信号作为异或门的另一个输入</p><p><strong>逻辑推导</strong></p><ul><li>期望：<code>Q(next) = Q XOR T</code><ul><li>当<code>T=0</code>时，<code>Q(next) = Q XOR 0 = Q</code>（保持）</li><li>当<code>T=1</code>时，<code>Q(next) = Q XOR 1 = NOT Q</code>（翻转）</li></ul></li><li>对于D触发器，在时钟边沿有<code>Q(next) = D</code></li><li>因此，只需要让<code>D = Q XOR T</code></li></ul><p>这样，就用D触发器和一个异或门“搭建”出了一个T触发器</p><h4 id=jk触发器>JK触发器</h4><p>JK触发器是一种具有记忆功能的基本逻辑单元，它有一个时钟输入端（CLK）、两个数据输入端（J和K）、以及至少一个输出端（Q）。它的核心特性是</p><ul><li>双稳态：可以稳定在“0”或“1”两种状态之一，用于存储1比特的信息</li><li>边沿触发（主流）：其状态变化通常发生在时钟信号（CLK）的上升沿或下降沿，而不是整个高电平或低电平期间。这使得电路在时序上更容易同步和控制</li></ul><h5 id=符号与引脚>符号与引脚</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>     ┌───┐
</span></span><span style=display:flex><span>  J ─┤   │
</span></span><span style=display:flex><span>     │   ├── Q
</span></span><span style=display:flex><span>CLK ─┤&gt;  │
</span></span><span style=display:flex><span>     │   ├── /Q(Q非)
</span></span><span style=display:flex><span>  K ─┤   │
</span></span><span style=display:flex><span>     └───┘
</span></span></code></pre></div><ul><li>J.K：数据输入端。它们的状态组合决定了在下一个有效时钟边沿到来时，输出Q将如何变化</li><li>CLK：时钟输入端。箭头">&ldquo;通常表示边沿触发。如果没有圆圈，通常是上升沿触发；如果有圆圈（CLK），则表示下降沿触发</li><li>Q：输出端。存储的数据</li><li>/Q：反相输出端。总是与Q的电平相反</li><li>可选引脚：<ul><li>Sd（Set，置位）：异步置位，低电平有效时，立即将Q置为1,不受时钟控制</li><li>Rd（Reset,复位）：异步复位，低电平有效时，立即将Q置为0,不受时钟控制</li></ul></li></ul><h5 id=真值表-3>真值表</h5><table><thead><tr><th>CLK</th><th>J</th><th>K</th><th>Qn+1（下一个状态）</th><th>功能描述</th></tr></thead><tbody><tr><td>^</td><td>0</td><td>0</td><td>Qn</td><td>保持：输出保持不变</td></tr><tr><td>^</td><td>0</td><td>1</td><td>0</td><td>复位：输出被置为0</td></tr><tr><td>^</td><td>1</td><td>0</td><td>1</td><td>置位：输出被置为1</td></tr><tr><td>^</td><td>1</td><td>1</td><td>/Qn</td><td>反转：输出取反</td></tr></tbody></table><h5 id=四种工作模式>四种工作模式</h5><p>可以根据J、K的四种输入组合，将JK触发器的工作分为四种模式</p><ol><li>保持（Hold）- J=0,K=0</li></ol><ul><li>当时钟边沿到来时，触发器“无视”时钟信号，保持原来的状态不变。这是实现数据存储的基础</li></ul><ol start=2><li>复位（Reset）- J=0,K=1</li></ol><ul><li>无论当前输出Q是什么，当时钟边沿到来时，输出Q都会被清零（Reset为0）</li></ul><ol start=3><li>置位（Set）- J=1,K=0</li></ol><ul><li>无论当前输出Q是什么，当时钟边沿到来时，输出Q都会被置一（Set为1）</li></ul><ol start=4><li>翻转（Toggle）- J=1,K=1</li></ol><ul><li>当时钟边沿到来时，输出Q会取反</li></ul><h3 id=寄存器>寄存器</h3><h3 id=有限状态机>有限状态机</h3><p>有限状态机（Final State Machine, FSM）是一种数学模型，用于描述具有有限个状态的系统以及状态之间的转移过程<br>有限状态机在实际中用来建模系统的行为，可以用于表示一系列输入条件下系统的变化过程</p><h4 id=fsm的基本组成>FSM的基本组成</h4><p>有限状态机由以下几部分组成</p><ul><li>状态（State）：系统在某一个时刻所处的状态。每个状态代表系统的一种特定情况或模式</li><li>输入（Input）：外部输入信号，它会驱动系统状态的变化</li><li>转移（Transition）：状态之间的转换规则，定义了在何种输入下，系统从一个状态转移到另一个状态</li><li>初始状态（Initial State）：系统启动时的起始状态</li><li>终止状态（Final State）（可选）：某些FSM设计为在达到终止状态后停止</li></ul><h4 id=fsm的分类>FSM的分类</h4><p>有限状态机通常分为两种主要类型</p><ul><li>Moore型有限状态机：输出仅依赖于当前状态，与输入无关<ul><li>例如：某个系统可能有多个状态，但在每个状态下，输出是固定的</li></ul></li><li>Mealy型有限状态机：输出依赖于当前状态和当前输入<ul><li>例如：某个状态机的输出会根据当前的输入值变化</li></ul></li></ul><h4 id=fsm的工作原理>FSM的工作原理</h4><p>FSM的工作过程可以概括为</p><ol><li>接收输入：FSM接收到一个外部输入信号</li><li>状态转移：根据当前状态和输入信号，FSM决定是否发生状态转移</li><li>产生输出：在Mealy型FSM中，输出受当前状态和输入状态的影响；在Moore型FSM中，输出仅受当前状态的影响</li></ol><h4 id=fsm的状态转移图>FSM的状态转移图</h4><p>FSM通常用状态转移图（State Transition Diagram）来表示，其中</p><ul><li>圆点表示状态</li><li>箭头表示状态之间的转移，箭头上标注的是输入条件</li><li>双圆点表示初始状态</li><li>在Mealy型FSM中，箭头上可能还会标注输出</li></ul><h4 id=fsm的状态转移表>FSM的状态转移表</h4><p>状态转移表是FSM的另一种常见表示方法，它列出了所有状态以及在不同输入下的状态转移和输出</p><table><thead><tr><th>当前状态</th><th>输入</th><th>下一状态</th><th>输出</th></tr></thead><tbody><tr><td>50</td><td>0</td><td>50</td><td>0</td></tr><tr><td>50</td><td>1</td><td>51</td><td>1</td></tr><tr><td>51</td><td>0</td><td>52</td><td>0</td></tr><tr><td>51</td><td>1</td><td>50</td><td>1</td></tr></tbody></table><h4 id=设计一个fsm>设计一个FSM</h4><p>设计FSM的步骤通常包括</p><ol><li>定义状态：确定系统的所有可能状态</li><li>定义输入：确定会影响状态变化的输入</li><li>定义状态转移规则：指定在不同输入下如何从一个状态转移到另一个状态</li><li>确定输出规则：根据FSM的类型，定义输出与状态或输入的关系</li><li>绘制状态转移图：用图形的方式表示所有状态及其转移关系</li></ol><p>FSM可以通过编程语言进行实现，通常的实现方式有</p><ul><li>状态机数组：通过二维数组表示状态转移</li><li>switch-case语句：通过条件语句表示不同输入条件下的状态转移</li></ul><h2 id=数字系统>数字系统</h2><p>数字系统是由多个逻辑电路组合而成，能够执行更复杂的任务。数字系统通常包括以下几个部分</p><ul><li>输入单元：将外部信息转化为适合数字系统处理的信号</li><li>处理单元：通常是算术逻辑单元（ALU），负责进行运算和逻辑操作</li><li>存储单元：存储数据和程序。常见的存储单元有RAM、ROM等</li><li>输出单元：将处理结果转化为可用的输出信息</li></ul><h2 id=数字电路设计方法>数字电路设计方法</h2><p>数字电路的设计可以采用两种主要方法</p><ul><li>真值表法：根据输入输出的关系，列出所有可能的组合，并设计相应的逻辑电路</li><li>卡诺图法：通过绘制卡诺图来简化逻辑表达式，进而设计最简化的逻辑电路</li></ul><h2 id=fsm在逻辑电路中的应用>FSM在逻辑电路中的应用</h2><h3 id=计数器>计数器</h3><h3 id=序列检测>序列检测</h3><h3 id=数字时钟>数字时钟</h3></div><nav class=post-nav><a href=/leftbrain/file/computerarchitecture/cpu_isa/ class=hover:underline>pre: CPU ISA</a>
<a href=/leftbrain/file/computerarchitecture/microarchitecture/ class=hover:underline>next: Micro Architecture</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#逻辑电路>逻辑电路</a><ul><li><a href=#逻辑门>逻辑门</a></li></ul></li><li><a href=#组合逻辑电路>组合逻辑电路</a><ul><li><a href=#加法器>加法器</a><ul><li><a href=#半加器>半加器</a></li><li><a href=#全加器>全加器</a></li><li><a href=#多位加法器串联全加器>多位加法器：串联全加器</a></li><li><a href=#现代高速加法器超前进位加法器>现代高速加法器：超前进位加法器</a><ul><li><a href=#核心思想>核心思想</a></li><li><a href=#实现原理>实现原理</a></li><li><a href=#优缺点>优缺点</a></li></ul></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#乘法器>乘法器</a><ul><li><a href=#移位加法乘法器>移位加法乘法器</a><ul><li><a href=#工作原理以4位为例>工作原理（以4位为例）</a></li><li><a href=#结构示意图>结构示意图</a></li><li><a href=#优缺点-1>优缺点</a></li></ul></li><li><a href=#阵列乘法器>阵列乘法器</a><ul><li><a href=#结构以4位无符号数为例>结构（以4位无符号数为例）</a></li><li><a href=#简化示意图体现按列相加的思想>简化示意图（体现按列相加的思想）</a></li><li><a href=#优缺点-2>优缺点</a></li></ul></li><li><a href=#现代高性能乘法器沃里斯树>现代高性能乘法器：沃里斯树</a><ul><li><a href=#工作流程比喻>工作流程比喻</a></li><li><a href=#优缺点-3>优缺点</a></li></ul></li><li><a href=#总结-1>总结</a></li></ul></li><li><a href=#比较器>比较器</a><ul><li><a href=#1位比较器>1位比较器</a><ul><li><a href=#真值表>真值表</a></li><li><a href=#电路图>电路图</a></li></ul></li><li><a href=#多位比较器级联比较器>多位比较器：级联比较器</a><ul><li><a href=#工作原理以4位为例-1>工作原理（以4位为例）</a></li><li><a href=#结构示意图-1>结构示意图</a></li><li><a href=#优缺点-4>优缺点</a></li></ul></li><li><a href=#现代高速比较器并行比较器查找表式比较器>现代高速比较器：并行比较器/查找表式比较器</a><ul><li><a href=#工作原理>工作原理</a></li><li><a href=#电路实现>电路实现</a></li><li><a href=#优缺点-5>优缺点</a></li><li><a href=#实践中的权衡>实践中的权衡</a></li></ul></li><li><a href=#总结-2>总结</a></li></ul></li></ul></li><li><a href=#时序逻辑电路>时序逻辑电路</a><ul><li><a href=#触发器>触发器</a><ul><li><a href=#ddata触发器>D(Data)触发器</a><ul><li><a href=#关键特性与工作原理>关键特性与工作原理</a></li><li><a href=#真值表-1>真值表</a></li><li><a href=#增强型d触发器>增强型D触发器</a><ul><li><a href=#带有异步复位和置位的d触发器真值表假设低电平有效>带有异步复位和置位的D触发器真值表（假设低电平有效）</a></li></ul></li><li><a href=#内部结构>内部结构</a></li></ul></li><li><a href=#ttoggle触发器>T(Toggle)触发器</a><ul><li><a href=#关键特性与工作原理-1>关键特性与工作原理</a></li><li><a href=#真值表-2>真值表</a></li><li><a href=#一个重要的特例t恒为1>一个重要的特例：T恒为1</a></li><li><a href=#t触发器的实现>T触发器的实现</a></li></ul></li><li><a href=#jk触发器>JK触发器</a><ul><li><a href=#符号与引脚>符号与引脚</a></li><li><a href=#真值表-3>真值表</a></li><li><a href=#四种工作模式>四种工作模式</a></li></ul></li></ul></li><li><a href=#寄存器>寄存器</a></li><li><a href=#有限状态机>有限状态机</a><ul><li><a href=#fsm的基本组成>FSM的基本组成</a></li><li><a href=#fsm的分类>FSM的分类</a></li><li><a href=#fsm的工作原理>FSM的工作原理</a></li><li><a href=#fsm的状态转移图>FSM的状态转移图</a></li><li><a href=#fsm的状态转移表>FSM的状态转移表</a></li><li><a href=#设计一个fsm>设计一个FSM</a></li></ul></li></ul></li><li><a href=#数字系统>数字系统</a></li><li><a href=#数字电路设计方法>数字电路设计方法</a></li><li><a href=#fsm在逻辑电路中的应用>FSM在逻辑电路中的应用</a><ul><li><a href=#计数器>计数器</a></li><li><a href=#序列检测>序列检测</a></li><li><a href=#数字时钟>数字时钟</a></li></ul></li></ul></li></ul></nav></aside><script defer src=/js/scrollspy.js></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>