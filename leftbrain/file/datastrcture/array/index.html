<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Array</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/leftbrain/>★</a></li><li><a href=/leftbrain/lab/>Lab</a></li><li><a href=/leftbrain/log/>Log</a></li><li><a href=/leftbrain/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/ target=_blank>lua.org</a>
<a href=https://www.luarocks.org/ target=_blank>luarocks.org</a>
<a href=https://www.luajit.org/ target=_blank>luajit.org</a></p><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Array<div class=meta>Modified: 2025-12-31
| Author：ljf12825</div></div><div class=content><h1 id=array>Array</h1><p>数组是一种线性结构，由连续内存空间存储相同类型元素的集合</p><p>Array = 一段连续内存 + 固定步长 + 常数时间寻址</p><p>首元素索引为0</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>address(i) = base_address + i * element_size
</span></span></code></pre></div><p>Cache友好</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>  [0]   [1]   [2]   [3]   [4]  
</span></span><span style=display:flex><span>├─────┼─────┼─────┼─────┼─────┤
</span></span><span style=display:flex><span>│  10 │  20 │  30 │  40 │  50 │
</span></span><span style=display:flex><span>└─────┴─────┴─────┴─────┴─────┘
</span></span><span style=display:flex><span> 1000   1004  1008  1012  1016
</span></span></code></pre></div><h2 id=fixed-array>Fixed Array</h2><p>长度在编译期或创建时就确定，之后永远不变的内存块</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>1024</span>];
</span></span></code></pre></div><p>特点：</p><ul><li>长度不可变</li><li>地址永远不变</li><li>零额外开销</li><li>行为完全可预测</li><li>Cache/SIMD/DMA友好</li></ul><p>性能特点：</p><table><thead><tr><th>操作</th><th>成本</th><th>说明</th></tr></thead><tbody><tr><td>随机访问</td><td>O(1)</td><td>通过索引</td></tr><tr><td>增删（尾部）</td><td>O(1)</td><td>无开销</td></tr><tr><td>增删（中间）</td><td>O(n)</td><td>需要移动后方元素</td></tr><tr><td>查找（有序）</td><td>O(log n)</td><td>二分查找</td></tr><tr><td>查找（无序）</td><td>O(n)</td><td>遍历</td></tr></tbody></table><p>致命代价：</p><ul><li>长度不可变：不确定最大规模会导致要么浪费内存，要么直接炸</li><li>越界</li><li>不适合动态数据</li></ul><p>适用场景：</p><ul><li>数据规模确定</li><li>实时系统</li><li>内存布局敏感</li><li>高频访问</li></ul><p>不适合：</p><ul><li>数据规模未知</li><li>CRUD型业务</li><li>频繁增删</li></ul><p>哲学意义：放弃灵活性，换取绝对可控</p><h2 id=dynamic-array>Dynamic Array</h2><p>动态数组，在静态数组的基础上实现了扩容</p><p>核心</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>┌──────────────┐
</span></span><span style=display:flex><span>│ data*        │ -&gt; 指向一段连续内存
</span></span><span style=display:flex><span>├──────────────┤
</span></span><span style=display:flex><span>│ size         │ -&gt; 当前元素个数
</span></span><span style=display:flex><span>├──────────────┤
</span></span><span style=display:flex><span>│ capacity     │ -&gt; 已分配容量
</span></span><span style=display:flex><span>└──────────────┘
</span></span></code></pre></div><h3 id=扩容>扩容</h3><p>扩容的核心问题：内存连续性<br>数组在内存中必须是连续存储的，这是其O(1)随机访问的基础，但也正是扩容昂贵的主要原因</p><p>内存示意图</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>初始数组（已满）：
</span></span><span style=display:flex><span>┌───┬───┬───┬───┐
</span></span><span style=display:flex><span>│ 1 │ 2 │ 3 │ 4 │
</span></span><span style=display:flex><span>└───┴───┴─┬─┴───┘
</span></span><span style=display:flex><span>地址:1000-1015      16字节
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>想要扩容到8个元素，但1000-1023地址可能已被占用：
</span></span><span style=display:flex><span>┌───┬───┬───┬───┬───┬───┬───┬───┐
</span></span><span style=display:flex><span>│ 1 │ 2 │ 3 │ 4 │ ? │ ? │ ? │ ? │
</span></span><span style=display:flex><span>└───┴───┴───┴───┴───┴───┴───┴───┘
</span></span><span style=display:flex><span>     无法原地扩展
</span></span></code></pre></div><h4 id=扩容过程>扩容过程</h4><p>伪代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>expand_array</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>**</span> arr, <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> capacity) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 重新计算容量（通常翻倍）
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> new_capacity <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>capacity <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 申请新的连续内存空间
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> new_array <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(new_capacity <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 检查分配是否成功
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (new_arr <span style=color:#f92672>=</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 内存不足，扩容失败
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. 复制所有元素（O(n)操作）
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#f92672>*</span>capacity; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        new_arr[i] <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>arr)[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5. 释放旧内存
</span></span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(<span style=color:#f92672>*</span>arr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 6. 更新指针和容量
</span></span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>arr <span style=color:#f92672>=</span> new_arr;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>capacity <span style=color:#f92672>=</span> new_capacity;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>总成本 = 分配内存 + 复制n个元素 + 释放内存</p><h4 id=成本分析>成本分析</h4><h5 id=1-内存分配成本>1. 内存分配成本</h5><ul><li>操作系统查找足够大的连续空闲内存块（可能需要遍历空闲链表）</li><li>分割内存块（如果找到的块比需要的大）</li><li>更新内存分配表</li><li>如果物理内存不足，可能触发缺页中断、页面置换</li><li>如果找不到连续块，可能触发内存碎片整理</li></ul><p>频繁扩容会导致大量内存碎片，小碎片无法被利用，总空闲内存虽然很多，但没有连续的大块内存</p><h5 id=2-数据复制成本>2. 数据复制成本</h5><p>假设数组有100万个元素，每个元素8字节<br>初始数组大小为8MB</p><p>需要扩容时</p><ol><li>分配新内存：16MB</li><li>复制8MB数据</li></ol><p>即使现代CPU很快，这也是显著的延迟</p><p>内存带宽限制<br>如果内存带宽是20GB/s, 复制8MB的数据大约为0.4ms</p><p>但实际还要考虑</p><ul><li>缓存未命中</li><li>TLB未命中</li><li>内存控制器排队</li></ul><h5 id=3-缓存不友好>3. 缓存不友好</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 复制大数组会污染缓存
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> old_array <span style=color:#f92672>=</span> ...; <span style=color:#75715e>// 在缓存中
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> new_array <span style=color:#f92672>=</span> malloc(new_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 复制过程
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> old_size; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 从old_array[i]读取（可能缓存命中）
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 写入new_array[i]（新内存，肯定缓存未命中）
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 这会逐出缓存中的其他有用数据
</span></span></span><span style=display:flex><span>    new_array[i] <span style=color:#f92672>=</span> old_array[i];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=扩容策略>扩容策略</h4><h5 id=翻倍扩容常用>翻倍扩容（常用）</h5><p><code>capacity *= 2</code><br>插入n个元素的摊还分析：<br>总复制次数 = 1 + 2 + 4 + &mldr; + n/2 约等于 n<br>平均每个元素复制约2次<br>摊还时间复杂度 = O(1)</p><h5 id=固定增量扩容>固定增量扩容</h5><p><code>capacity += 10</code>
插入n个元素的复制次数：<br>总复制约等于 10 + 20 + 30 + &mldr; 约为 O(n^2)<br>平均每个元素复制O(n)次，性能差</p><h5 id=对比>对比</h5><p>插入1,000,000个元素</p><table><thead><tr><th>策略</th><th>总复制次数</th><th>平均每个元素复制次数</th></tr></thead><tbody><tr><td>固定 +10</td><td>～50,000,000,000</td><td>～50,000</td></tr><tr><td>固定 +100</td><td>~5,000,000,000</td><td>~5,000</td></tr><tr><td>x2</td><td>~2,000,000</td><td>~2</td></tr><tr><td>x1.5</td><td>~3,000,000</td><td>~3</td></tr></tbody></table><p>翻倍策略虽然会浪费一些空间，但时间效率最高</p><h4 id=扩容的摊还分析amortized-analysis>扩容的摊还分析（Amortized Analysis）</h4><p>为什么说摊还时间复杂度是O(1)？<br>示例：<br>插入序列：第1,2,3,&mldr;,n个元素<br>扩容发生时刻：容量=1,2,4,8,&mldr;,直到>=n<br>复制成本：<br>插入第1个元素：复制0个（初始容量1）<br>插入第2个元素：复制1个（扩容到2）<br>插入第3个元素：复制2个（扩容到4）<br>插入第5个元素：复制4个（扩容到8）<br>&mldr;<br>插入第2^(k+1)个元素：复制2^k个（扩容到2^(k+1)）</p><p>总复制次数 = 1 + 2 + 4 + &mldr; + 2^k <code>&lt;</code> 2n<br>平均每个元素复制 <code>&lt;</code> 2 次</p><p>所以即使单次扩容是O(n)，n次插入的平摊成本是O(1)</p><h4 id=优化策略>优化策略</h4><ol><li>预分配：一次性分配，不存在扩容问题</li><li>使用更合适的数据结构：如果频繁增删，数组不是最优选择</li><li>批量操作：避免多次单元素插入，这会触发多次扩容；批量添加，一次扩展</li></ol><h3 id=动态数组的代价>动态数组的代价</h3><ul><li><p>指针/引用失效</p><p>动态数组在扩容时会重新分配内存，原内存被释放，所有指向旧内存的指针/引用全部失效<br>这是动态数组导致的一种特性，最好的做法就是避免碰它，不要妄图使用或修补它</p></li><li><p>实时系统不友好</p></li><li><p>内存浪费（trade-off）</p></li></ul><h2 id=multidimensional-array>Multidimensional Array</h2><p>多维数组在逻辑上是多维的，但在物理内存中始终是一维连续存储的</p><ul><li>逻辑视图（三维数组）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> cube[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>3</span>][<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    {{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>}, {<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>8</span>}, {<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>11</span>,<span style=color:#ae81ff>12</span>}},
</span></span><span style=display:flex><span>    {{<span style=color:#ae81ff>13</span>,<span style=color:#ae81ff>14</span>,<span style=color:#ae81ff>15</span>,<span style=color:#ae81ff>16</span>}, {<span style=color:#ae81ff>17</span>,<span style=color:#ae81ff>18</span>,<span style=color:#ae81ff>19</span>,<span style=color:#ae81ff>20</span>}, {<span style=color:#ae81ff>21</span>,<span style=color:#ae81ff>22</span>,<span style=color:#ae81ff>23</span>,<span style=color:#ae81ff>24</span>}}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li>物理视图（内存中连续存储）</li></ul><p>内存地址：[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]</p><h3 id=内存布局模式>内存布局模式</h3><ul><li>Row Major</li><li>Column Major</li></ul><p>二维数组<code>A[M][N]</code>可以想象成一个<code>M</code>行<code>N</code>列的表格</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>A</span><span style=color:#f92672>[</span><span style=color:#f92672>0</span><span style=color:#f92672>][</span><span style=color:#f92672>0</span><span style=color:#f92672>]</span>  <span style=color:#f92672>A</span><span style=color:#f92672>[</span><span style=color:#f92672>0</span><span style=color:#f92672>][</span><span style=color:#f92672>1</span><span style=color:#f92672>]</span>  <span style=color:#f92672>A</span><span style=color:#f92672>[</span><span style=color:#f92672>0</span><span style=color:#f92672>][</span><span style=color:#f92672>2</span><span style=color:#f92672>]</span> <span style=color:#f92672>...</span> <span style=color:#f92672>A</span><span style=color:#f92672>[</span><span style=color:#f92672>0</span><span style=color:#f92672>][</span><span style=color:#f92672>N-1</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>A</span><span style=color:#f92672>[</span><span style=color:#f92672>1</span><span style=color:#f92672>][</span><span style=color:#f92672>0</span><span style=color:#f92672>]</span>  <span style=color:#f92672>A</span><span style=color:#f92672>[</span><span style=color:#f92672>1</span><span style=color:#f92672>][</span><span style=color:#f92672>1</span><span style=color:#f92672>]</span>  <span style=color:#f92672>A</span><span style=color:#f92672>[</span><span style=color:#f92672>1</span><span style=color:#f92672>][</span><span style=color:#f92672>2</span><span style=color:#f92672>]</span> <span style=color:#f92672>...</span> <span style=color:#f92672>A</span><span style=color:#f92672>[</span><span style=color:#f92672>1</span><span style=color:#f92672>][</span><span style=color:#f92672>N-1</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>A</span><span style=color:#f92672>[</span><span style=color:#f92672>M-1</span><span style=color:#f92672>][</span><span style=color:#f92672>0</span><span style=color:#f92672>]</span> <span style=color:#f92672>...</span>          <span style=color:#f92672>A</span><span style=color:#f92672>[</span><span style=color:#f92672>M-1</span><span style=color:#f92672>][</span><span style=color:#f92672>N-1</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>内存是线性的，所以二维数组必须展开成一维存储。这就是 Row Major 和 Column Major的区别</p><h4 id=row-major-行优先行主序>row-major 行优先/行主序</h4><p>C/C++/Python等大多数语言使用</p><p>按行存储，先把第一行存完，再存第二行&mldr;</p><p>二维数组示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> matrix[<span style=color:#ae81ff>3</span>][<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>},
</span></span><span style=display:flex><span>    {<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>},
</span></span><span style=display:flex><span>    {<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>内存布局</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
</span></span><span style=display:flex><span>│00   │01   │02   │03   │10   │11   │12   │13   │20   │21   │ 22  │23   │
</span></span><span style=display:flex><span>├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
</span></span><span style=display:flex><span>│  1  │  2  │  3  │  4  │  5  │  6  │  7  │  8  │  9  │  10 │  11 │  12 │
</span></span><span style=display:flex><span>└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
</span></span></code></pre></div><p>地址计算公式：对于<code>A[M][N]</code>，元素<code>A[i][j]</code>的线性地址计算：<br>$addr(A[i][j])=base_addr+(i*N+j)*element_size$</p><p>优点：遍历数组时按行顺序访问缓存友好（CPU缓存行连续）</p><h4 id=column-major-列优先列主序>column-major 列优先/列主序</h4><p>Fortran/Matlab/Julia使用</p><p>按列存储，先存第一列，再存第二列&mldr;</p><ul><li>Fortran示例</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>INTEGER</span> <span style=color:#66d9ef>::</span> matrix(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>) <span style=color:#f92672>=</span> RESHAPE([<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>11</span>,<span style=color:#ae81ff>12</span>], [<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>])
</span></span></code></pre></div><ul><li>内存布局（按列展开）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
</span></span><span style=display:flex><span>│00   │10   │20   │01   │11   │21   │02   │12   │22   │03   │13   │23   │
</span></span><span style=display:flex><span>├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
</span></span><span style=display:flex><span>│  1  │  2  │  3  │  4  │  5  │  6  │  7  │  8  │  9  │  10 │  11 │  12 │
</span></span><span style=display:flex><span>└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
</span></span></code></pre></div><p>地址计算公式：<br>$addr(A[i][j])=base_addr+(j*M+i)*element_size$</p><p>优点：对按列遍历的算法更高效，比如矩阵乘法的某些实现</p><h4 id=为什么行主序更缓存友好>为什么行主序更“缓存友好”</h4><ol><li>CPU的特点<ul><li>cache line 机制</li><li>局部性</li></ul></li><li>行主序的优势<ul><li>二维数组在C/C++中是行主序排列的</li><li>当按行遍历数组时，逻辑访问和内存物理顺序一致</li><li>结果：缓存命中率高，CPU一次加载一个cache line, 就可以顺序访问多个元素</li></ul></li><li>列主序的劣势（在行主序语言中）<ul><li>如果按列遍历二维数组，访问的元素在内存中不是连续的</li><li>每次访问可能跨越多个cache line, 导致频繁的缓存未命中</li><li>CPU必须不断从主存加载数据，速度大幅下降</li></ul></li></ol><h4 id=不同维度的地址计算>不同维度的地址计算</h4><p>通用公式推导</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>对于n维数组：arr[d₁][d₂]...[dₙ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>行主序：
</span></span><span style=display:flex><span>元素arr[i₁][i₂]...[iₙ]的偏移量：
</span></span><span style=display:flex><span>offset = ((...((i₁ × d₂ + i₂) × d₃ + i₃)...) × dₙ + iₙ) × element_size
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>列主序：
</span></span><span style=display:flex><span>offset = ((...((iₙ × dₙ₋₁ + iₙ₋₁) × dₙ₋₂ + iₙ₋₂)...) × d₁ + i₁) × element_size
</span></span></code></pre></div></div><nav class=post-nav><a href=/leftbrain/file/datastrcture/binarytree/ class=hover:underline>next: Binary Tree</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><a href=#array>Array</a><ul><li><a href=#fixed-array>Fixed Array</a></li><li><a href=#dynamic-array>Dynamic Array</a><ul><li><a href=#扩容>扩容</a><ul><li><a href=#扩容过程>扩容过程</a></li><li><a href=#成本分析>成本分析</a><ul><li><a href=#1-内存分配成本>1. 内存分配成本</a></li><li><a href=#2-数据复制成本>2. 数据复制成本</a></li><li><a href=#3-缓存不友好>3. 缓存不友好</a></li></ul></li><li><a href=#扩容策略>扩容策略</a><ul><li><a href=#翻倍扩容常用>翻倍扩容（常用）</a></li><li><a href=#固定增量扩容>固定增量扩容</a></li><li><a href=#对比>对比</a></li></ul></li><li><a href=#扩容的摊还分析amortized-analysis>扩容的摊还分析（Amortized Analysis）</a></li><li><a href=#优化策略>优化策略</a></li></ul></li><li><a href=#动态数组的代价>动态数组的代价</a></li></ul></li><li><a href=#multidimensional-array>Multidimensional Array</a><ul><li><a href=#内存布局模式>内存布局模式</a><ul><li><a href=#row-major-行优先行主序>row-major 行优先/行主序</a></li><li><a href=#column-major-列优先列主序>column-major 列优先/列主序</a></li><li><a href=#为什么行主序更缓存友好>为什么行主序更“缓存友好”</a></li><li><a href=#不同维度的地址计算>不同维度的地址计算</a></li></ul></li></ul></li></ul></li></ul></nav></aside><script defer src=/js/scrollspy.js></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>