<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Linked List</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/leftbrain/>★</a></li><li><a href=/leftbrain/lab/>Lab</a></li><li><a href=/leftbrain/lib/>Lib</a></li><li><a href=/leftbrain/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Linked List<div class=meta>Modified: 2025-12-31
| Author：ljf12825</div></div><div class=content><p>链表是一种线性数据结构，其中的元素（节点）不是通过物理顺序存储，而是通过指针（或引用）连接在一起</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>data</span> <span style=color:#f92672>|</span> <span style=color:#f92672>next</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data</span> <span style=color:#f92672>|</span> <span style=color:#f92672>next</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data</span> <span style=color:#f92672>|</span> <span style=color:#f92672>next</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>核心特点</p><ul><li>动态内存分配：不需要预先知道数据量大小</li><li>非连续存储：节点在内存中可以是分散的</li><li>顺序访问：不能像数组一样直接通过索引访问</li></ul><p>缺点</p><ul><li>访问速度慢：需要遍历才能访问特定元素</li><li>内存开销大：需要额外的空间存储指针</li><li>缓存不友好：非连续存储，CPU缓存命中率低</li></ul><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>遍历</td><td>O(n)</td></tr><tr><td>查找</td><td>O(n)</td></tr><tr><td>插入</td><td>O(1)*</td></tr><tr><td>删除</td><td>O(1)*</td></tr></tbody></table><p><code>*</code>前提是已知节点</p><h2 id=single-linkedlist>Single LinkedList</h2><h3 id=结构>结构</h3><p>节点结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>data</span><span style=color:#f92672>|</span><span style=color:#f92672>next</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li><code>data</code>：实际存储的数据</li><li><code>next</code>：指向后一个节点的地址</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>data</span><span style=color:#f92672>|</span><span style=color:#f92672>next</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data</span><span style=color:#f92672>|</span><span style=color:#f92672>next</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data</span><span style=color:#f92672>|</span><span style=color:#f92672>next</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>null</span>
</span></span></code></pre></div><ul><li>每个节点只能指向下一个节点（<code>next</code>）</li><li>单链表只能向前遍历，无法回溯</li></ul><h3 id=适用场景>适用场景</h3><ol><li>需要频繁插入/删除的场景</li><li>内存受限或数据规模不确定的场景</li><li>只需要单向遍历</li><li>实现栈/队列</li></ol><h3 id=不适用场景>不适用场景</h3><ol><li>频繁随机访问</li><li>需要双向遍历</li><li>数据量大：指针占用空间</li><li>需要快速查找</li><li>缓存性能重要</li></ol><h3 id=应用案例>应用案例</h3><p>LRU缓存淘汰算法</p><h3 id=实现>实现</h3><h4 id=遍历>遍历</h4><p>时间复杂度O(n)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>traverse</span>(ListNode<span style=color:#f92672>*</span> head) {
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> current <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (current <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> current<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>        current <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=查找>查找</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>search</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> current <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (current <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (current<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> target) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> current;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        current <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=插入>插入</h4><p>1.头插（O(1)）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>insertAtHead</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(val);
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> newNode;  <span style=color:#75715e>// 新节点成为新的头节点
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>2.在指定位置后插入（O(1)）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insertAfter</span>(ListNode<span style=color:#f92672>*</span> prevNode, <span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (prevNode <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span>) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(val);
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> prevNode<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    prevNode<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=删除>删除</h4><p>1.删除指定值的节点</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>deleteNode</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理头节点就是要删除的节点
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (head <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span> <span style=color:#f92672>&amp;&amp;</span> head<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> val) {
</span></span><span style=display:flex><span>        ListNode<span style=color:#f92672>*</span> temp <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>delete</span> temp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理中间节点
</span></span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> current <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (current <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span> <span style=color:#f92672>&amp;&amp;</span> current<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (current<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> val) {
</span></span><span style=display:flex><span>            ListNode<span style=color:#f92672>*</span> temp <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            current<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> temp;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            current <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>2.删除指定位置的节点</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deleteNode</span>(ListNode<span style=color:#f92672>*</span> node) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 假设node不是尾节点
</span></span></span><span style=display:flex><span>    node<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>val;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> temp <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> temp;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=哨兵节点sentineldummy-node>哨兵节点(sentinel/dummy node)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (head <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span>) { ... }
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (pos <span style=color:#f92672>==</span> head) { ... }
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (head<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> val) { ... }
</span></span></code></pre></div><p>这些判断有几个共同点</p><ul><li>逻辑分叉多</li><li>易错（边界条件）</li><li>代码重复</li><li>插入/删除要“特判头节点”</li></ul><p>因此哨兵节点的目标只有一个：让头节点变成普通节点</p><p>哨兵节点 = 永远存在的“假节点”，不存放有效数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>sentinel</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data1</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data2</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>nullptr</span>
</span></span></code></pre></div><ul><li><code>sentinel</code>不算链表元素</li><li><code>sentinel->next</code>才是真正的第一个节点</li><li>链表永远非空（至少有哨兵）</li></ul><h4 id=产生变化>产生变化</h4><h5 id=结构变化>结构变化</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>head</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data</span><span style=color:#f92672>|</span><span style=color:#f92672>next</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data</span><span style=color:#f92672>|</span><span style=color:#f92672>next</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data</span><span style=color:#f92672>|</span><span style=color:#f92672>next</span><span style=color:#f92672>]</span> <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>null</span>
</span></span></code></pre></div><p>传统单链表<code>head</code>指向第一个有效节点或nullptr，若有哨兵节点，永远指向哨兵节点</p><p>初始化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>head <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(T{});
</span></span><span style=display:flex><span>head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span></code></pre></div><ul><li><code>T{}</code>：C++11 列表初始化语法（brace-init），表示用类型T的默认值来构造一个对象</li></ul><p>判空</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isEmpty</span>() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>头节点特判不复存在，退化为普通节点处理</p><p>哨兵节点在工程实践中是一种强烈推荐的做法，广泛应用于Linux内核/STL/各种容器中</p><h2 id=double-linkedlist>Double LinkedList</h2><p>节点结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>prev</span><span style=color:#f92672>|</span><span style=color:#f92672>data</span><span style=color:#f92672>|</span><span style=color:#f92672>next</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li><code>prev</code>：指向前一个节点的地址</li><li><code>data</code>：实际存储的数据</li><li><code>next</code>：指向后一个节点的地址</li></ul><p>链表结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>NULL</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data</span><span style=color:#f92672>|</span><span style=color:#f92672>next</span><span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data</span><span style=color:#f92672>|</span><span style=color:#f92672>next</span><span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>data</span><span style=color:#f92672>|</span><span style=color:#f92672>next</span><span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>NULL</span>
</span></span></code></pre></div><h3 id=双向的好处>双向的好处</h3><p>单向链表有一个致命缺陷：无法O(1)从当前节点回到前一个节点<br>只能沿着next的方向遍历，想要倒退需要重新遍历<br>双向链表解决了这个问题，任意节点都能O(1)前进/后退<br>即用空间换时间<br>这直接带来了几个重要能力</p><ul><li>删除当前节点不需要“前驱节点”</li><li>支持双向遍历</li><li>非常适合LRU/Undo/双端操作</li></ul><h3 id=核心操作>核心操作</h3><h4 id=插入节点中间插入>插入节点（中间插入）</h4><p>假设结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>A</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>B</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>C</span>
</span></span></code></pre></div><p>要在B和C之间插入X<br>需要修改的指针（4个）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>X.prev = B
</span></span><span style=display:flex><span>X.next = C
</span></span><span style=display:flex><span>B.next = X
</span></span><span style=display:flex><span>C.prev = X
</span></span></code></pre></div><p>顺序很重要，错一个就断链</p><h4 id=删除节点>删除节点</h4><p>删除节点<code>B</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>A</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>B</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>C</span>
</span></span></code></pre></div><p>操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>A.next = C
</span></span><span style=display:flex><span>C.prev = A
</span></span></code></pre></div><p>不需要从head找前驱，O(1), 这正是双向链表存在的核心理由之一</p><h4 id=遍历-1>遍历</h4><p>正向遍历</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>for (node = head; node != null; node = node.next)
</span></span></code></pre></div><p>反向遍历</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>for (node = tail; node != null; node = node.prev)
</span></span></code></pre></div><p>时间复杂度</p><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>随机访问</td><td>O(n)</td></tr><tr><td>头部插入</td><td>O(1)</td></tr><tr><td>中间插入</td><td>O(1)</td></tr><tr><td>删除节点</td><td>O(1)</td></tr></tbody></table><h3 id=哨兵节点对比>哨兵节点对比</h3><p>哨兵节点通过引入一个（或多个）永远存在的特殊节点，将链表在头尾处的边界情况统一为普通节点，从而消除插入和删除时对<code>nullptr</code>的分支判断<br>循环哨兵节点进一步通过将头尾连接成环，把“前边界”和“后边界”合并为同一个哨兵节点，使所有节点在结构上完全等价</p><table><thead><tr><th>类型</th><th>结构示意</th><th>空链表状态</th></tr></thead><tbody><tr><td><strong>No Sentinel</strong></td><td><code>nullptr &lt;- A &lt;-> B &lt;-> C -> nullptr</code></td><td><code>head = nullptr</code>, <code>tail = nullptr</code></td></tr><tr><td><strong>Normal Sentinel</strong></td><td><code>[HEAD] &lt;-> A &lt;-> B &lt;-> C &lt;-> [TAIL]</code></td><td><code>HEAD.next = TAIL</code>, <code>TAIL.prev = HEAD</code></td></tr><tr><td><strong>Circular Sentinel</strong></td><td><code>[SENTINEL] &lt;-> A &lt;-> B &lt;-> C &lt;-> [SENTINEL]</code></td><td><code>sentinel.next = sentinel.prev = sentinel</code></td></tr></tbody></table><h4 id=边界处理对比>边界处理对比</h4><table><thead><tr><th>操作</th><th>No Sentinel</th><th>Normal Sentinel</th><th>Circular Sentinel</th></tr></thead><tbody><tr><td>插入头</td><td>要判断 head 是否为空</td><td>直接插在 head 后，无需判断</td><td>直接插在 sentinel 后，无需判断</td></tr><tr><td>插入尾</td><td>要判断 tail 是否为空</td><td>直接插在 tail 前，无需判断</td><td>直接插在 sentinel 前，无需判断</td></tr><tr><td>删除头</td><td>要判断 head 是否为空</td><td>直接删除 node，无需判断</td><td>直接删除 node，无需判断</td></tr><tr><td>删除尾</td><td>要判断 tail 是否为空</td><td>同上</td><td>同上</td></tr><tr><td>空链表判断</td><td><code>head == nullptr</code></td><td><code>head->next == tail</code></td><td><code>sentinel.next == sentinel</code></td></tr></tbody></table><h4 id=节点数量与存储开销>节点数量与存储开销</h4><table><thead><tr><th>类型</th><th>每条链表额外节点</th></tr></thead><tbody><tr><td>No Sentinel</td><td>0</td></tr><tr><td>Normal Sentinel</td><td>2（head & tail）</td></tr><tr><td>Circular Sentinel</td><td>1（sentinel）</td></tr></tbody></table><h4 id=操作复杂度对比>操作复杂度对比</h4><table><thead><tr><th>操作</th><th>No Sentinel</th><th>Normal Sentinel</th><th>Circular Sentinel</th></tr></thead><tbody><tr><td>push_front/back</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>remove</td><td>需要判断 prev/next 是否 nullptr</td><td>不需判断</td><td>不需判断</td></tr><tr><td>empty</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h4 id=安全性对比>安全性对比</h4><table><thead><tr><th>类型</th><th>UB / 崩溃风险</th><th>指针错误概率</th></tr></thead><tbody><tr><td>No Sentinel</td><td>边界判断少写就 UB</td><td>高</td></tr><tr><td>Normal Sentinel</td><td>sentinel 管控了头尾</td><td>中</td></tr><tr><td>Circular Sentinel</td><td>sentinel + 循环保证安全</td><td>低</td></tr></tbody></table><p>循环哨兵节点是工业级链表的首选，如Linux<code>list_head</code>, STL内部<code>_List_node_base</code></p><h2 id=circular-linkedlist>Circular LinkedList</h2><p>循环链表是最后一个节点指向头节点的链表<br>从任意节点出发，都能转一圈回到自己</p><h3 id=单向循环链表>单向循环链表</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>┌──────────┐</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>v</span>          <span style=color:#960050;background-color:#1e0010>│</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>A</span><span style=color:#f92672>]</span><span style=color:#f92672>-</span><span style=color:#f92672>&gt;[</span><span style=color:#f92672>B</span><span style=color:#f92672>]</span><span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span><span style=color:#f92672>C</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>head</span>       <span style=color:#f92672>tail</span>
</span></span></code></pre></div><ul><li><code>tail->next = head</code></li></ul><h4 id=设计理念>设计理念</h4><ul><li><code>tail</code> base （推荐）</li></ul><p>因为是next 单链表<br><code>tail</code>永远是最后一个节点<br><code>tail->next</code>永远是头节点<br>这是工程中常见的做法</p><ul><li><code>head</code> base</li></ul><p><code>head</code>永远指向头节点<br>尾节点的<code>next == head</code><br>如果不关心尾插，只需要从头遍历，从头取元素，可以这样写<br>但工程中几乎永远不会这样做</p><table><thead><tr><th>操作</th><th><code>head</code> base</th><th><code>tail</code> base</th></tr></thead><tbody><tr><td>头插</td><td>O(1)</td><td>O(1)</td></tr><tr><td>尾插</td><td>O(n)</td><td>O(1)</td></tr><tr><td>删除头</td><td>O(n) 要找尾</td><td>O(1)</td></tr><tr><td>删除尾</td><td>O(n)</td><td>O(n)</td></tr><tr><td>任意插入</td><td>O(n)</td><td>O(n)</td></tr><tr><td>遍历</td><td>一样</td><td>一样</td></tr></tbody></table><p>简而言之，<code>tail</code>能很快找到<code>head</code>，<code>head</code>找<code>tail</code>需要遍历</p><h3 id=双向循环链表>双向循环链表</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span>      <span style=color:#960050;background-color:#1e0010>↖─────────────↗</span>
</span></span><span style=display:flex><span><span style=color:#f92672>head</span> <span style=color:#960050;background-color:#1e0010>↔</span> <span style=color:#f92672>[</span><span style=color:#f92672>A</span><span style=color:#f92672>]</span> <span style=color:#960050;background-color:#1e0010>↔</span> <span style=color:#f92672>[</span><span style=color:#f92672>B</span><span style=color:#f92672>]</span> <span style=color:#960050;background-color:#1e0010>↔</span> <span style=color:#f92672>[</span><span style=color:#f92672>C</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li><code>head->prev = tail</code></li><li><code>tail->next = head</code></li></ul><h2 id=链表相关算法>链表相关算法</h2><ol><li>链表反转（Reverse Linked List）</li><li>快慢指针（Floyd思想）</li><li>删除倒数第N各节点</li><li>合并两个有序链表</li><li>判断链表是否回文</li><li>两两交换节点（Swap Nodes in Pairs）</li><li>K个一组反转链表</li><li>LRU Cache（链表 + 哈希表）</li><li>侵入式链表（Intrusive List）</li><li>空闲链表（Free List）</li><li>链表排序</li><li>链表相交判断</li><li>判断链表是否有环</li></ol></div><nav class=post-nav><a href=/leftbrain/file/datastrcture/hashtable/ class=hover:underline>pre: Hash Table</a>
<a href=/leftbrain/file/datastrcture/m-arytree/ class=hover:underline>next: M-ary Tree</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#single-linkedlist>Single LinkedList</a><ul><li><a href=#结构>结构</a></li><li><a href=#适用场景>适用场景</a></li><li><a href=#不适用场景>不适用场景</a></li><li><a href=#应用案例>应用案例</a></li><li><a href=#实现>实现</a><ul><li><a href=#遍历>遍历</a></li><li><a href=#查找>查找</a></li><li><a href=#插入>插入</a></li><li><a href=#删除>删除</a></li></ul></li><li><a href=#哨兵节点sentineldummy-node>哨兵节点(sentinel/dummy node)</a><ul><li><a href=#产生变化>产生变化</a><ul><li><a href=#结构变化>结构变化</a></li></ul></li></ul></li></ul></li><li><a href=#double-linkedlist>Double LinkedList</a><ul><li><a href=#双向的好处>双向的好处</a></li><li><a href=#核心操作>核心操作</a><ul><li><a href=#插入节点中间插入>插入节点（中间插入）</a></li><li><a href=#删除节点>删除节点</a></li><li><a href=#遍历-1>遍历</a></li></ul></li><li><a href=#哨兵节点对比>哨兵节点对比</a><ul><li><a href=#边界处理对比>边界处理对比</a></li><li><a href=#节点数量与存储开销>节点数量与存储开销</a></li><li><a href=#操作复杂度对比>操作复杂度对比</a></li><li><a href=#安全性对比>安全性对比</a></li></ul></li></ul></li><li><a href=#circular-linkedlist>Circular LinkedList</a><ul><li><a href=#单向循环链表>单向循环链表</a><ul><li><a href=#设计理念>设计理念</a></li></ul></li><li><a href=#双向循环链表>双向循环链表</a></li></ul></li><li><a href=#链表相关算法>链表相关算法</a></li></ul></li></ul></nav></aside><script defer src=/js/scrollspy.js></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>