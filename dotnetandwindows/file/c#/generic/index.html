<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Generic</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-lua.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-rust.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/log/>Log</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a> |
<a href=https://isocpp.org/ target=_blank>isocpp</a> |
<a href=https://open-std.org target=_blank>open-std</a></p><p><a href=https://cmake.com/ target=_blank>cmake.org</a></p><p><a href=https://llvm.org/ target=_blank>llvm.org</a></p><p><a href=https://www.boost.org/ target=_blank>boost.org</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/ target=_blank>lua.org</a> |
<a href=https://www.luarocks.org/ target=_blank>luarocks.org</a> |
<a href=https://www.luajit.org/ target=_blank>luajit.org</a></p><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a></p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a></p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Generic<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><p>简单来说，泛型允许在编写类、接口、方法时，使用“类型参数”来代替具体的类型。这个类型参数在编译时或运行时才被指定</p><h2 id=为什么需要>为什么需要</h2><p>在泛型出现之前，如果想创建一个可以存放任意类型数据的集合（比如一个盒子），通常会使用<code>object</code>类型，因为C#中所有类型都继承自<code>object</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 一个只能存放整数的盒子</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>IntBox</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> Data { <span style=color:#ff79c6>get</span>; <span style=color:#ff79c6>set</span>; }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 一个只能存放字符串的盒子</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>StringBox</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>string</span> Data { <span style=color:#ff79c6>get</span>; <span style=color:#ff79c6>set</span>; }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 为了存放任意类型，使用object</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>ObjectBox</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>object</span> Data { <span style=color:#ff79c6>get</span>; <span style=color:#ff79c6>set</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用<code>objectBox</code>时会出现两个问题</p><ol><li>性能损失（拆箱装箱）：当存放值类型（如<code>int</code>, <code>struct</code>）时，会发生装箱（Boxing）和拆箱（Unboxing）操作，影响性能</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>ObjectBox box = <span style=color:#ff79c6>new</span> ObjectBox();
</span></span><span style=display:flex><span>box.Data = <span style=color:#bd93f9>42</span>; <span style=color:#6272a4>// 装箱：将值类型int包装为object引用类型</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> data = (<span style=color:#8be9fd>int</span>)box.Data; <span style=color:#6272a4>// 拆箱：将object转换回值类型int</span>
</span></span></code></pre></div><ol start=2><li>类型不安全：编译器无法在编译时保证类型安全，容易在运行时引发<code>InvalidCastException</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>ObjectBox box = <span style=color:#ff79c6>new</span> ObjectBox();
</span></span><span style=display:flex><span>box.Data = <span style=color:#f1fa8c>&#34;Hello World&#34;</span>; <span style=color:#6272a4>// 存放一个字符串</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> data = (<span style=color:#8be9fd>int</span>)box.Data; <span style=color:#6272a4>// 运行时错误！无法将字符串转换为整数</span>
</span></span></code></pre></div><h3 id=泛型如何解决这些问题>泛型如何解决这些问题</h3><p>用泛型重新写这个“盒子”</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// T 是一个整数参数，它只是一个占位符</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>GenericBox</span>&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> T Data { <span style=color:#ff79c6>get</span>; <span style=color:#ff79c6>set</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用这个泛型类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 创建一个专门存放int的盒子</span>
</span></span><span style=display:flex><span>GenericBox&lt;<span style=color:#8be9fd>int</span>&gt; intBox = <span style=color:#ff79c6>new</span> GenericBox&lt;<span style=color:#8be9fd>int</span>&gt;();
</span></span><span style=display:flex><span>intBox.Data = <span style=color:#bd93f9>42</span>; <span style=color:#6272a4>// 类型安全，只能是int</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> intData = intBox.Data; <span style=color:#6272a4>// 无需类型转换和拆箱，性能高</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 创建一个专门存放string的盒子</span>
</span></span><span style=display:flex><span>GenericBox&lt;<span style=color:#8be9fd>string</span>&gt; stringBox = <span style=color:#ff79c6>new</span> GenericBox&lt;<span style=color:#8be9fd>string</span>&gt;();
</span></span><span style=display:flex><span>stringBox.Data = <span style=color:#f1fa8c>&#34;Hello&#34;</span>; <span style=color:#6272a4>// 类型安全，只能是string</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>string</span> stringData = stringBox.Data; <span style=color:#6272a4>// 无需类型转换</span>
</span></span></code></pre></div><p>优势：</p><ul><li>类型安全：编译器在编译时就能确保你使用的是正确的类型</li><li>性能提升：消除了对于值类型的装箱和拆箱操作</li><li>代码复用：只需编写一次<code>GenericBox&lt;T></code>，就可以用于创建无数种特定类型的盒子</li></ul><h2 id=语法>语法</h2><ul><li>泛型类</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Box</span>&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> T Value { <span style=color:#ff79c6>get</span>; <span style=color:#ff79c6>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> Box(T <span style=color:#ff79c6>value</span>) =&gt; Value = <span style=color:#ff79c6>value</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>用法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>var</span> intBox = <span style=color:#ff79c6>new</span> Box&lt;<span style=color:#8be9fd>int</span>&gt;(<span style=color:#bd93f9>42</span>);
</span></span><span style=display:flex><span><span style=color:#8be9fd>var</span> strBox = <span style=color:#ff79c6>new</span> Box&lt;<span style=color:#8be9fd>string</span>&gt;(<span style=color:#f1fa8c>&#34;hello&#34;</span>);
</span></span></code></pre></div><ul><li>泛型方法
方法也可以是泛型的，即时它所属的类不是泛型类</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Utility</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Generic Method</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Swap&lt;T&gt;(<span style=color:#ff79c6>ref</span> T a, <span style=color:#ff79c6>ref</span> T b)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        T temp = a;
</span></span><span style=display:flex><span>        a = b;
</span></span><span style=display:flex><span>        b = temp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 使用</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> x = <span style=color:#bd93f9>1</span>, y = <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>Utility.Swap&lt;<span style=color:#8be9fd>int</span>&gt;(<span style=color:#ff79c6>ref</span> x, <span style=color:#ff79c6>ref</span> y); <span style=color:#6272a4>// 显式指定类型</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 或者更常见的，让编译器推断</span>
</span></span><span style=display:flex><span>Utility.Swap(<span style=color:#ff79c6>ref</span> x, <span style=color:#ff79c6>ref</span> y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>string</span> s1 = <span style=color:#f1fa8c>&#34;foo&#34;</span>, s2 = <span style=color:#f1fa8c>&#34;bar&#34;</span>;
</span></span><span style=display:flex><span>Utility.Swap(<span style=color:#ff79c6>ref</span> s1, <span style=color:#ff79c6>ref</span> s2); <span style=color:#6272a4>// 同样适用于string</span>
</span></span></code></pre></div><ul><li>泛型接口</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 泛型接口</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>interface</span> <span style=color:#50fa7b>IRepository</span>&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>void</span> Add(T entity);
</span></span><span style=display:flex><span>    T GetById(<span style=color:#8be9fd>int</span> id);
</span></span><span style=display:flex><span>    IEnumerable&lt;T&gt; GetAll();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 实现泛型接口</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>ProductRepository</span> : IRepository&lt;Product&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> Add(Product entity) { <span style=color:#6272a4>/* ... */</span> }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> Product GetById(<span style=color:#8be9fd>int</span> id) { <span style=color:#6272a4>/* ... */</span> }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> IEnumeralbe&lt;Product&gt; GetAll() { <span style=color:#6272a4>/* ... */</span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>UserRepository</span> : IRepository&lt;User&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> Add(User entity) { <span style=color:#6272a4>/* ... */</span> }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> User GetById(<span style=color:#8be9fd>int</span> id) { <span style=color:#6272a4>/* ... */</span> }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> IEnumerable&lt;User&gt; GetAll() { <span style=color:#6272a4>/* ... */</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>泛型集合
.NET Framework在<code>System.Collections.Generic</code>命名空间中提供了丰富的泛型集合类，它们完全取代了旧的<code>ArrayList</code>, <code>Hashtable</code>等非泛型集合</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 旧的非泛型集合（不推荐）</span>
</span></span><span style=display:flex><span>ArrayList list = <span style=color:#ff79c6>new</span> ArrayList();
</span></span><span style=display:flex><span>list.Add(<span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>list.Add(<span style=color:#f1fa8c>&#34;string&#34;</span>); <span style=color:#6272a4>// 可以混合类型，危险！</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> i = (<span style=color:#8be9fd>int</span>)list[<span style=color:#bd93f9>0</span>]; <span style=color:#6272a4>// 需要强制转换</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 新的泛型集合（推荐）</span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#8be9fd>int</span>&gt; intList = <span style=color:#ff79c6>new</span> List&lt;<span style=color:#8be9fd>int</span>&gt;();
</span></span><span style=display:flex><span>intList.Add(<span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// inList.Add(&#34;string&#34;); // 编译错误！类型安全</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> i = intList[<span style=color:#bd93f9>0</span>]; <span style=color:#6272a4>// 无需强制转换</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Dictionary&lt;<span style=color:#8be9fd>string</span>, <span style=color:#8be9fd>int</span>&gt; keyValuePairs = <span style=color:#ff79c6>new</span> Dictionary&lt;<span style=color:#8be9fd>string</span>, <span style=color:#8be9fd>int</span>&gt;();
</span></span><span style=display:flex><span>keyValuePairs.Add(<span style=color:#f1fa8c>&#34;Alice&#34;</span>, <span style=color:#bd93f9>95</span>);
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> score = keyValuePairs[<span style=color:#f1fa8c>&#34;Alice&#34;</span>]; <span style=color:#6272a4>// 类型安全，键是string，值是int</span>
</span></span></code></pre></div><h2 id=泛型约束where>泛型约束（<code>where</code>）</h2><p>有时需要对类型参数<code>T</code>施加一些限制，比如要求<code>T</code>必须是一个类，或者必须实现某个接口。这就是泛型约束</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>GenericClass</span>&lt;T&gt; <span style=color:#ff79c6>where</span> T : class, <span style=color:#ff79c6>new</span>() <span style=color:#6272a4>// T 必须是引用类型，并且有无参构造函数</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> T CreateInstance()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> T(); <span style=color:#6272a4>// 因为有了 new() 约束，所以可以 new T()</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Calculator</span>&lt;T&gt; <span style=color:#ff79c6>where</span> T : IComparable&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> T Max(T a, T b)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> a.CompareTo(b) &gt; <span style=color:#bd93f9>0</span> ? a : b; <span style=color:#6272a4>// 因为有了 IComparable约束，所以可以调用 CompareTo方法</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>常见的约束类型</p><ul><li><code>where T : class</code>——引用类型</li><li><code>where T : struct</code>——值类型（非可空）</li><li><code>where T : new()</code>——必须有public无参构造函数（通常和<code>Activator.CreateInstance&lt;T>()</code>替代）</li><li><code>where T : BaseClass</code>——继承约束</li><li><code>where T : IInterface</code>——实现接口</li><li><code>where T : unmanaged</code>——非托管类型（C#7.3+）</li><li><code>where T : notnull</code>——不能为null（C#8.0+的场景）</li><li><code>where T : System.Enum</code>/<code>where T : System.Delegate</code>——枚举/委托（C#7.3+）</li></ul><p>约束可以组合<code>where T : Base, IMyInterface, new()</code>顺序不限，但通常把<code>new()</code>放在最后</p><h3 id=方差>方差</h3><p>方差是C#类型系统中一个非常重要但稍显复杂的概念，它关乎泛型类型参数的继承关系如何影响泛型类型本身的继承关系<br><strong>核心思想：协变（Convariance）与逆变（Contravariance）</strong><br>为了更好地理解，首先需要明确一个基础：在面向对象编程中，存在一种“里氏替换原则”。即，如果<code>Dog</code>继承自<code>Animal</code>，那么在任何需要<code>Animal</code>的地方，我们都可以安全地使用<code>Dog</code>。我们把这个关系记作：<code>Dog</code> -> <code>Animal</code>（Dog可以替换Animal）</p><p>假设有两个类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Animal</span> { }
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Dog</span> : Animal { }
</span></span></code></pre></div><p>显然：</p><ul><li><code>Dog</code>是<code>Animal</code>的子类</li><li>换句话说：<code>Dog</code>可以被当作<code>Animal</code>来用</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Animal a = <span style=color:#ff79c6>new</span> Dog(); <span style=color:#6272a4>// 合法</span>
</span></span></code></pre></div><p>这就是正常的继承兼容（subtyping）</p><p>泛型类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;Animal&gt; animals = <span style=color:#ff79c6>new</span> List&lt;Dog&gt;(); <span style=color:#6272a4>// 编译错误</span>
</span></span></code></pre></div><p>因为<code>List&lt;Dog></code>不是<code>List&lt;Animal></code><br>虽然<code>Dog</code>是<code>Animal</code>的子类，但“装着狗的列表”不是“装着动物的列表”</p><p>原因很简单：<br>如果允许这样写，那就可能往<code>animal</code>里加一只<code>Cat</code>，而者实际上塞进了一个<code>List&lt;Dog></code>，逻辑崩溃</p><h4 id=协变>协变</h4><ul><li>定义：如果泛型类型参数<code>T</code>的继承关系，与泛型类型<code>I&lt;T></code>的继承关系方向一致，则称为协变</li><li>关键字：<code>out</code></li><li>含义：它表示<code>T</code>只从接口/委托中输出（作为返回值、属性获取器等），而不被输入（作为参数）</li></ul><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 使用 &#39;out&#39; 关键字声明协变接口</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>interface</span> <span style=color:#50fa7b>IReadOnlyCollection</span>&lt;<span style=color:#ff79c6>out</span> T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    T GetItem(<span style=color:#8be9fd>int</span> index);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> Count { <span style=color:#ff79c6>get</span>; }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Animal</span> { }
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Dog</span> : Animal { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 因为Dog -&gt; Animal，并且接口是协变的</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 所以 IReadOnlyCollection&lt;Dog&gt; -&gt; IReadOnlyCollection&lt;Animal&gt;</span>
</span></span><span style=display:flex><span>IReadOnlyCollection&lt;Dog&gt; dogs = GetSomeDogs();
</span></span><span style=display:flex><span>IReadOnlyCollection&lt;Animal&gt; animal = dogs; <span style=color:#6272a4>// 这是合法的！协变允许这样赋值</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// IReadOnlyCollection&lt;T&gt;只用作输出，Dog当Animal输出，不写入</span>
</span></span></code></pre></div><h5 id=为什么这是安全的>为什么这是安全的</h5><p>因为<code>IReadOnlyCollection&lt;Animal></code>的消费者只期望从它哪里获取<code>Animal</code>对象。而我们的<code>dogs</code>集合里装的虽然是<code>Dog</code>，但每一个<code>Dog</code>都是一个<code>Animal</code>。所以，把<code>Dog</code>当作<code>Animal</code>返完全是安全的。<code>T</code>只输出，不会写入，编译器知道不会往里加别的动物，保证了不会有“把Cat塞进Dog集合”的风险，所以是安全的</p><h5 id=net中的实际例子>.NET中的实际例子</h5><p><code>IEnumerable&lt;T></code>接口就是协变的，因为它只有一个方法<code>GetEnumerator()</code>返回<code>IEnumerator&lt;T></code>，而<code>IEnumerator&lt;T></code>的核心是<code>T Current { get; }</code>属性，<code>T</code>只用于输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerable&lt;Dog&gt; dogs = <span style=color:#ff79c6>new</span> List&lt;Dog&gt;();
</span></span><span style=display:flex><span>IEnumerable&lt;Animal&gt; animals = dogs; <span style=color:#6272a4>// 合法，因为 IEnumerable&lt;out T&gt;</span>
</span></span></code></pre></div><h4 id=逆变>逆变</h4><ul><li>定义：如果泛型类型参数<code>T</code>的继承关系，与泛型类型<code>I&lt;T></code>的继承关系方向相反，则称为逆变</li><li>关键字：<code>in</code></li><li>含义：它表示<code>T</code>只向接口/委托中输入（作为参数）而不被输出</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 使用 &#39;in&#39; 关键字声明逆变接口</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>interface</span> <span style=color:#50fa7b>IComparer</span>&lt;<span style=color:#ff79c6>in</span> T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> Compare(T x, T y);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Animal</span> { }
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Dog</span> : Animal { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 因为 Dog -&gt; Animal，并且接口是可逆的</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 所以 ICompare&lt;Animal&gt; -&gt; IComparer&lt;Dog&gt; (变为反向)</span>
</span></span><span style=display:flex><span>IComparer&lt;Animal&gt; animalComparer = GetAnimalComparer();
</span></span><span style=display:flex><span>IComparer&lt;Dog&gt; dogComparer = animalComparer; <span style=color:#6272a4>// 这是合法的！逆变允许这样赋值</span>
</span></span></code></pre></div><h5 id=为什么这是安全的-1>为什么这是安全的</h5><p><code>IComparer&lt;Dog></code>的消费者需要的是一个能比较两个Dog对象的比较器。而我们有一个<code>animalComparer</code>，它声称自己能比较任何Animal（包括Dog）。既然它能比较任何动物，那么它当然也能比较两个特定的Dog。所以，把一个“更通用的”比较器当作一个“更具体的”比较器来使用是安全的。<code>T</code>只出现在输出位置，保证了比较器不会要求返回一个具体的<code>Dog</code></p><h5 id=net中的实际例子-1>.NET中的实际例子</h5><p><code>IComparer&lt;T></code>和<code>Action&lt;T></code>委托都是逆变的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Action&lt;Animal&gt; actOnAnimal = (animal) =&gt; Console.WriteLine(animal.Name);
</span></span><span style=display:flex><span>Action&lt;Dog&gt; actOnDog = actOnAnimal; <span style=color:#6272a4>// 合法，因为 Action&lt;in T&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 现在调用 actOnDog(someDog)</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 实际上是执行actOnAnimal(someDog)</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 而 actOnAnimal 可以处理任何 Animal，所以处理一个Dog是安全的</span>
</span></span></code></pre></div><h4 id=不变>不变</h4><ul><li>定义：如果泛型类型参数<code>T</code>既不协变也不逆变，则称为不变。这是大多数泛型类型的默认行为</li><li>含义：<code>T</code>既用于输入，也用于输出。此时，<code>I&lt;Dog></code>和<code>I&lt;Animal></code>之间没有任何继承关系</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 没有 &#39;in&#39; 或 &#39;out&#39; 关键字，是不变接口</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>interface</span> <span style=color:#50fa7b>IList</span>&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    T GetItem(<span style=color:#8be9fd>int</span> index); <span style=color:#6272a4>// T 用于输出</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>void</span> Add(T item);     <span style=color:#6272a4>// T 用于输入</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Animal</span> { }
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Dog</span> : Animal { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>IList&lt;Dog&gt; dogs = <span style=color:#ff79c6>new</span> List&lt;Dog&gt;();
</span></span><span style=display:flex><span>IList&lt;Animal&gt; animals = dogs; <span style=color:#6272a4>// 编译错误！不允许！</span>
</span></span></code></pre></div><h5 id=为什么不安全>为什么不安全</h5><p>假设上面的赋值是合法的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 假设合法</span>
</span></span><span style=display:flex><span>animals.Add(<span style=color:#ff79c6>new</span> Cat()); <span style=color:#6272a4>// 因为 animals 是 IList&lt;Animal&gt;，添加 Cat 从它的角度看是合法的。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 但 animals 实际上指向的是一个 List&lt;Dog&gt; dogs!</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 现在，我们试图把一只 Cat 放进一个 Dog 的列表里！这会导致类型不安全，运行时可能会崩溃。</span>
</span></span></code></pre></div><p>因此，对于像<code>IList&lt;T></code>这样同时进行输入和输出的类型，C#强制其不变，以保障类型安全</p><h4 id=重要规则>重要规则</h4><ol><li>仅限接口和委托：方差（<code>in</code>/ <code>out</code>修饰符）只能用于接口和委托的泛型参数，不能用于类和结构体</li><li>类型安全是前提：C#的方差系统是在编译时和CLR层面严格检查的，其根本目的是提供灵活性的同时，100%保证安全</li></ol><blockquote><p>方差本质上就是让泛型类型系统具备类似“继承”的能力，从而解决泛型代码的复用问题</p></blockquote><h2 id=底层实现>底层实现</h2><h3 id=编译阶段>编译阶段</h3><p>当写下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Box</span>&lt;T&gt; { <span style=color:#8be9fd;font-style:italic>public</span> T Value; }
</span></span></code></pre></div><p>编译器不会生成多个类型副本<br>它只在元数据（metadata）中生成一个定义模板</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#ff79c6>.</span><span style=color:#ff79c6>class</span> public auto ansi beforefieldinit Box`<span style=color:#bd93f9>1</span><span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>//</span> `<span style=color:#bd93f9>1</span>表示有一个泛型参数
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>extends</span> [System<span style=color:#ff79c6>.</span>Runtime]System<span style=color:#ff79c6>.</span>Object
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>.</span>field public <span style=color:#ff79c6>!</span><span style=color:#bd93f9>0</span> Value
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译器生成的是“开放泛型类型定义（open generic type definition），这是一种模板。真正的类型要到运行时才“实例化”（instantiation）</p><h3 id=clr类型系统中的泛型机制>CLR类型系统中的泛型机制</h3><p>.NET的CLR实现了真正的泛型（reified generics），这和Java的类型擦除机制不同。<br>这意味着：</p><ul><li>泛型参数在运行时仍然存在</li><li>可以用反射拿到真实参数（<code>typeof(List&lt;int>).GetGenericArguments()</code>）</li><li>值类型不会被装箱成<code>object</code></li></ul><p>CLR中两种泛型类型</p><ol><li>开放泛型（open generic）：像<code>List&lt;T></code>、<code>Dictionary&lt;Tkey, TValue></code> 还没绑定具体类型</li><li>封闭泛型（closed generic）：比如<code>List&lt;int></code>、<code>List&lt;string></code> 类型参数已被具体化</li></ol><p>运行时首次遇到<code>List&lt;int></code>时，会“构造”出一个新的类型实例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>System.Collections.Generic.List&lt;Int32&gt;
</span></span></code></pre></div><p>CLR把这当成一个真正的新类型，有独立的元数据和方法表（vtable）</p><h3 id=jit编译>JIT编译</h3><p>当CLR JIT编译泛型方法或类时，它会根据类型参数决定是“复用”还是“重新生成代码”</p><table><thead><tr><th>类型参数</th><th>JIT行为</th><th>原因</th></tr></thead><tbody><tr><td>引用类型</td><td>共享代码（code sharing）</td><td>所有引用类型的IL/JIT实现一样，只操作引用</td></tr><tr><td>值类型</td><td>特化代码（code specialization）</td><td>值类型大小和布局不同，不能共享</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;<span style=color:#8be9fd>int</span>&gt; a = <span style=color:#ff79c6>new</span>();
</span></span><span style=display:flex><span>List&lt;<span style=color:#8be9fd>string</span>&gt; b = <span style=color:#ff79c6>new</span>();
</span></span></code></pre></div><ul><li>对<code>List&lt;string></code>和<code>List&lt;object></code>：JIT只生成一份机器码</li><li>对<code>List&lt;int></code>：JIT生成一份新的专用代码，直接操作<code>int</code>（无装箱）</li></ul><p>这就是泛型性能强大的原因</p><h3 id=元数据与类型句柄typehandle>元数据与类型句柄（TypeHandle）</h3><p>每个封闭泛型类型在运行时都有唯一的RuntimeTypeHandle<br>这意味着CLR知道<code>List&lt;int></code>和<code>List&lt;string></code>是不同的<br>这种机制确保了</p><ul><li>类型安全：JIT编译器知道确切的类型布局</li><li>反射友好：<code>typeof(List&lt;int>) != typeof(List&lt;string>)</code></li><li>性能高：值类型直接在栈上操作</li></ul><h3 id=il层观察>IL层观察</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>var</span> list = <span style=color:#ff79c6>new</span> List&lt;<span style=color:#8be9fd>int</span>&gt;();
</span></span><span style=display:flex><span>    list.Add(<span style=color:#bd93f9>42</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>反编译IL</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>IL_0000: newobj instance void class [System.Collections]System.Collections.Generic.List`1&lt;int32&gt;::.ctor()
</span></span><span style=display:flex><span>IL_0005: ldc.i4.s 42
</span></span><span style=display:flex><span>IL_0007: callvirt instance void class [System.Collections]System.Collections.Generic.List`1&lt;int32&gt;::Add(!0)
</span></span></code></pre></div><p>注意<code>!0</code>————它代表第一个泛型参数<code>T</code><br>CLR看到<code>List&lt;int></code>时，会将<code>!0</code>替换成实际类型<code>int32</code>，在生成的机器码中直接操作32位整数</p><h3 id=值类型与装箱对比实验>值类型与装箱对比实验</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;<span style=color:#8be9fd>int</span>&gt; list1 = <span style=color:#ff79c6>new</span> List&lt;<span style=color:#8be9fd>int</span>&gt;();
</span></span><span style=display:flex><span>List&lt;<span style=color:#8be9fd>object</span>&gt; list2 = <span style=color:#ff79c6>new</span> List&lt;<span style=color:#8be9fd>object</span>&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>list1.Add(<span style=color:#bd93f9>123</span>); <span style=color:#6272a4>// 无装箱</span>
</span></span><span style=display:flex><span>list2.Add(<span style=color:#bd93f9>123</span>); <span style=color:#6272a4>// 发生装箱</span>
</span></span></code></pre></div><p>原因：</p><ul><li><code>List&lt;int></code>直接操作<code>int</code>内存</li><li><code>List&lt;object></code>要把<code>123</code>装箱成<code>System.Int32</code>对象引用</li></ul><p>所以泛型的好处：避免频繁的堆分配与GC压力</p><h3 id=运行时缓存机制type-instantiation-cache>运行时缓存机制（Type Instantiation Cache）</h3><p>CLR内部有一张“泛型实例化缓存表”</p><ul><li>当第一次构造<code>List&lt;int></code>时，CLR会生成新的类型句柄并缓存</li><li>下次再用相同类型参数，就直接复用</li></ul><p>这部分逻辑在<code>MethodTableBuilder</code>与<code>Generics::CreateTypeInstantiation</code>内部完成（CLR源码可查）</p><h3 id=协变与逆变的运行时原理接口委托>协变与逆变的运行时原理（接口/委托）</h3><p>协变（out）和逆变（in）只在编译器和运行时的类型检查层有效<br>CLR在方法签名元数据中标记这些参数的方差属性<br>运行时验证时允许安全的替换（如<code>IEnumerable&lt;string></code> -> <code>IEnumerable&lt;object></code>）<br>但在方法表布局上仍是独立类型，没有动态类型转换</p><h3 id=泛型静态成员隔离机制>泛型静态成员隔离机制</h3><p>每个封闭泛型类型都有独立的静态字段副本</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Counter</span>&lt;T&gt; { <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>int</span> Count; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Counter&lt;<span style=color:#8be9fd>int</span>&gt;.Count = <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>Counter&lt;<span style=color:#8be9fd>string</span>&gt;.Count = <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>Console.WriteLine(Counter&lt;<span style=color:#8be9fd>int</span>&gt;.Count); <span style=color:#6272a4>// 1</span>
</span></span></code></pre></div><p>CLR在创建封闭类型时，独立分配静态区块<br>底层就是每个RuntimeTypeHandle拥有独立静态存储区</p><h2 id=activatorcreateinstancet与new约束><code>Activator.CreateInstance&lt;T>()</code>与<code>new()</code>约束</h2><h3 id=new约束机制与特点><code>new()</code>约束机制与特点</h3><p>语法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Factory</span>&lt;T&gt; <span style=color:#ff79c6>where</span> T : <span style=color:#ff79c6>new</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> T Create() =&gt; <span style=color:#ff79c6>new</span> T();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译层面：</p><ul><li><code>where T : new()</code>告诉编译器：类型参数T必须有一个public的无参构造函数</li><li>编译器因此允许你写<code>new T()</code>
否则这行代码连编译都过不了</li></ul><blockquote><p>注意：没有<code>new()</code>约束，写<code>new T()</code>会报错：
CS0304: Cannot create an instance of the variable type &lsquo;T&rsquo; because it does not have the new() constraint</p></blockquote><p>运行时层面：<br><code>new T()</code>是内联构造，编译器会在IL中直接生成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>newobj instance void !0::.ctor()
</span></span></code></pre></div><p>JIT时，这会被特化成对T的构造函数直接调用，没有任何反射</p><p>性能层面：<br><code>new T()</code>和直接<code>new MyClass()</code>一样快，没有额外开销</p><h3 id=activatorcreateinstancet><code>Activator.CreateInstance&lt;T>()</code></h3><p>基本用法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>T obj = Activator.CreateInstance&lt;T&gt;()
</span></span></code></pre></div><p>机制：</p><ul><li>由System.Activator类提供，内部使用反射</li><li>它通过运行时的类型信息（<code>typeof(T)</code>）找到对应的构造函数并调用</li><li>不要求<code>T</code>有<code>new()</code>约束，编译器不会限制</li></ul><p>IL表现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>call !!0 [System.Private.CoreLib]System.Activator::CreateInstance&lt;!!0&gt;()
</span></span></code></pre></div><p>这其实是泛型方法调用，内部最终会调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Acticator.CreateInstance(Type type)
</span></span></code></pre></div><p>这个方法执行时走的是反射路径</p><ol><li>查询类型句柄（TypeHandle）</li><li>取构造函数信息</li><li>通过<code>RuntimeMethodHandle.InvokeMethod()</code>调用</li></ol><p>性能层面：<br>因为走了反射，速度大约是<code>new()</code>的20~50倍慢（取决于JIT优化与类型缓存）<br>不过<code>Activator.CreateInstance&lt;T>()</code>比<code>Activator.CreateInstance(Type)</code>稍快一点，因为它缓存了泛型参数信息</p><h3 id=使用场景>使用场景</h3><ol><li>业务逻辑工厂（推荐<code>new()</code>）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>ObjectPool</span>&lt;T&gt; <span style=color:#ff79c6>where</span> T : <span style=color:#ff79c6>new</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>readonly</span> Stack&lt;T&gt; _pool = <span style=color:#ff79c6>new</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> T Get() =&gt; _pool.Count &gt; <span style=color:#bd93f9>0</span> ? _pool.Pop() : <span style=color:#ff79c6>new</span> T();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> Release(T item) =&gt; _pool.Push(item);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>性能关键场景下，应始终用<code>new()</code>约束</p><ol start=2><li>动态类型加载（必须用<code>Activator</code>）
如果类型在编译时未知，只能运行时从字符串或配置加载</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Type type = Type.GetType(<span style=color:#f1fa8c>&#34;MyNamespace.MyClass, MyAssembly&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#8be9fd>object</span> instance = Activator.CreateInstance(type);
</span></span></code></pre></div><p>或者在泛型方法中实例化不满足<code>new()</code>的类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> T Create&lt;T&gt;()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> (T)Activator.CreateInstance(<span style=color:#ff79c6>typeof</span>(T), nonPublic: <span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>例如T的构造函数是<code>private</code>或带参数时，这就是唯一办法</p><ol start=3><li>结合依赖注入（反射创建 + 缓存）
现代框架（如ASP.NET Core）在底层就是用类似<code>ActivatorUtilities</code>的机制，反射创建实例后缓存构造函数委托，提高性能</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>var</span> ctor = <span style=color:#ff79c6>typeof</span>(T).GetConstructors().First();
</span></span><span style=display:flex><span><span style=color:#8be9fd>var</span> lambda = Expression.Lambda&lt;Func&lt;T&gt;&gt;(Expression.New(ctor)).Compile();
</span></span><span style=display:flex><span>T obj = lambda(); <span style=color:#6272a4>// 比 Activator 快很多</span>
</span></span></code></pre></div><p>这属于“动态生成构造函数委托”的优化版</p><h3 id=内部机制>内部机制</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-scss data-lang=scss><span style=display:flex><span><span style=color:#ff79c6>[</span><span style=color:#ff79c6>编译阶段</span><span style=color:#ff79c6>]</span>
</span></span><span style=display:flex><span>   ↓
</span></span><span style=display:flex><span> <span style=color:#ff79c6>new</span> <span style=color:#ff79c6>T</span><span style=color:#ff79c6>()</span>  → <span style=color:#ff79c6>编译器检查</span> <span style=color:#ff79c6>new</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>约束</span> → <span style=color:#ff79c6>生成</span> <span style=color:#ff79c6>newobj</span> <span style=color:#ff79c6>IL</span> → <span style=color:#ff79c6>直接调用构造函数</span>
</span></span><span style=display:flex><span>   ↓
</span></span><span style=display:flex><span> <span style=color:#ff79c6>Activator</span><span style=color:#50fa7b>.CreateInstance</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>T</span><span style=color:#ff79c6>&gt;()</span> → <span style=color:#ff79c6>调用反射API</span> → <span style=color:#ff79c6>查找构造函数</span> → <span style=color:#ff79c6>调用MethodHandle</span><span style=color:#50fa7b>.Invoke</span>
</span></span></code></pre></div><h3 id=最佳实践>最佳实践</h3><ol><li>能用<code>new()</code>就绝不要用<code>Activator</code><ul><li>编译期安全</li><li>性能极高</li><li>可被JIT优化与内联</li></ul></li><li>仅当类型在编译期未知时才用<code>Activator</code><ul><li>如插件系统、反射加载模块、序列化框架</li></ul></li><li>避免在循环或性能关键路径中使用<code>Activaotr</code><ul><li>如果一定要用，创建后缓存委托（<code>Func&lt;T></code>）复用</li></ul></li><li>不要再泛型工具类里随意使用<code>Activator</code>代替约束<ul><li>它会破坏类型安全和调试可预测性</li></ul></li></ol><h2 id=运行时类型信息与反射>运行时类型信息与反射</h2><p>运行时类型信息（RTTI, Run-Time Type Infomation）是“类型信息存在于运行时”的机制；反射是“利用RTTI在运行时查询或操作类型”的手段</p><h3 id=rtti>RTTI</h3><p>当写下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>object</span> obj = <span style=color:#ff79c6>new</span> List&lt;<span style=color:#8be9fd>int</span>&gt;();
</span></span></code></pre></div><p>编译器并不知道<code>obj</code>实际上是一个<code>List&lt;int></code>，但在运行时，CLR会保存每个对象的“类型描述符”信息，也就是RTTI</p><p>在C#中，每个对象在内存中其实带着一个指向它的<code>TypeHandle</code>的指针，这个句柄告诉CLR</p><ul><li>这个对象的类型名</li><li>它继承自哪个基类</li><li>它实现了哪些接口</li><li>它有哪些字段、属性、方法</li><li>它的泛型参数是什么</li><li>它的元数据在程序集（Assembly）中的位置</li></ul><p>换句话说：每个对象都知道自己是谁</p><h3 id=反射>反射</h3><p>反射（Reflection）就是CLR提供的一组API，可以在运行时</p><ul><li>获取类型信息</li><li>动态创建实例</li><li>调用方法</li><li>访问字段和属性</li><li>获取自定义特性（Attribute）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Type t = <span style=color:#ff79c6>typeof</span>(List&lt;<span style=color:#8be9fd>int</span>&gt;);
</span></span><span style=display:flex><span>Console.WriteLine(t.FullName); <span style=color:#6272a4>// System.Collections.Generic.List`1[System.Int32]</span>
</span></span></code></pre></div><p><code>typeof()</code>、<code>GetType()</code>、<code>Type.GetMethod()</code>这些都是反射的入口<br>再比如动态创建对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>object</span> list = Activator.CreateInstance(<span style=color:#ff79c6>typeof</span>(List&lt;<span style=color:#8be9fd>int</span>&gt;));
</span></span></code></pre></div><p>这是反射的常见用途之一：动态加载类，这意味着：</p><ul><li>可以在不知道类型的情况下实例化它</li><li>可以从插件或配置文件中加载类型</li><li>可以实现通用框架、依赖注入容器</li></ul><h3 id=反射与泛型的结合>反射与泛型的结合</h3><p>C#的泛型是“真实泛型（reified generics）”，也就是说：</p><ul><li>泛型参数不会在编译时擦除（不像Java的类型擦除机制）</li><li>CLR在运行时能区分<code>List&lt;int></code>和<code>List&lt;string></code></li><li>每个封闭类型（closed generic type）都会生成独立的运行时类型描述</li></ul><p>所以可以</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Type t1 = <span style=color:#ff79c6>typeof</span>(List&lt;<span style=color:#8be9fd>int</span>&gt;);
</span></span><span style=display:flex><span>Type t2 = <span style=color:#ff79c6>typeof</span>(List&lt;<span style=color:#8be9fd>string</span>&gt;);
</span></span><span style=display:flex><span>Console.WriteLine(t1 == t2); <span style=color:#6272a4>// false</span>
</span></span></code></pre></div><h2 id=泛型和nullnullable-reference-types>泛型和NULL（nullable reference types）</h2><p>在C#中，<code>null</code>是引用类型（reference type）或可空值类型（nullable value type）的默认值<br>而泛型类型参数<code>T</code>的行为取决于它被“约束（constraint）”成什么样</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Foo&lt;T&gt;(T <span style=color:#ff79c6>value</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>value</span> == <span style=color:#ff79c6>null</span>) <span style=color:#6272a4>// 可能报错</span>
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>&#34;Null!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面这段代码编译不通过，因为编译器不知道<code>T</code>是引用类型还是值类型\</p><ul><li>如果<code>Foo&lt;string>(null)</code>，没有问题</li><li>如果<code>Foo&lt;int>(0)</code>时，<code>0</code>不是<code>null</code></li></ul><p>编译器无法保证<code>value == null</code>是合法的比较</p><h3 id=通过约束告诉编译器t可以为null>通过约束告诉编译器<code>T</code>可以为<code>null</code></h3><p>C#的约束系统可以明确告诉编译器<code>T</code>是哪一类</p><ol><li><code>where T : class</code><ul><li>说明 <code>T</code> 必须是引用类型</li><li>此时就可以写<code>if (value == null)</code></li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Foo&lt;T&gt;(T <span style=color:#ff79c6>value</span>) <span style=color:#ff79c6>where</span> T : <span style=color:#ff79c6>class</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>value</span> == <span style=color:#ff79c6>null</span>) Console.WriteLine(<span style=color:#f1fa8c>&#34;Null!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li><code>where T : struct</code><ul><li>说明 <code>T</code> 必须是值类型</li><li>此时 <code>T</code> 不可能为<code>null</code></li><li>但可以用<code>Nullable&lt;T></code>来允许null值</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Foo&lt;T&gt;(T? <span style=color:#ff79c6>value</span>) <span style=color:#ff79c6>where</span> T : <span style=color:#ff79c6>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>value</span> == <span style=color:#ff79c6>null</span>) Console.WriteLine(<span style=color:#f1fa8c>&#34;Null&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li><code>where T : unmanaged</code><ul><li>说明 <code>T</code> 必须是非托管类型（纯值类型，没有引用字段）</li><li>同样，不能为null</li><li>常用于底层内存操作、指针、Span<t>等结合</li></ul></li></ol><h3 id=defaultt><code>default&lt;T></code></h3><p>当不知道 <code>T</code> 是值类型还是引用类时，不能直接写<code>null</code>，但可以写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>T <span style=color:#ff79c6>value</span> = <span style=color:#ff79c6>default</span>;
</span></span></code></pre></div><p>或者</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>T <span style=color:#ff79c6>value</span> = <span style=color:#ff79c6>default</span>(T);
</span></span></code></pre></div><p>这在泛型里是万能解法，编译器会根据类型自动选择默认值<br><code>default(T)</code>在泛型中就像一把“万能钥匙”，无论T是什么类型，都能安全获得“空值”或“默认初始状态”</p><h3 id=可空值类型>可空值类型</h3><p>当希望值类型也能用<code>null</code>时</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int?</span> x = <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>Nullable&lt;<span style=color:#8be9fd>int</span>&gt; = <span style=color:#ff79c6>default</span>;
</span></span></code></pre></div><p><code>Nullable&lt;T></code>是一个特殊的泛型结构体，定义大致是这样的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Nullable</span>&lt;T&gt; <span style=color:#ff79c6>where</span> T : <span style=color:#ff79c6>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>bool</span> hasValue;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> T <span style=color:#ff79c6>value</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这让<code>int?</code>, <code>bool?</code>, <code>float?</code>等拥有了“null状态”，编译器对<code>?.</code>, <code>??</code>, <code>== null</code>等操作都内置了特殊支持</p><h3 id=可空引用类型>可空引用类型</h3><p>从C#8.0起，语言引入了一个语义层的“null检查系统”</p><ul><li><code>string</code>表示非空</li><li><code>string?</code>表示可空</li><li>这样并不会改变运行时行为，但能让编译器在静态分析时警告潜在的<code>NullReferenceException</code></li></ul><p>所以在泛型中，如果启用了可空上下文</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Foo&lt;T&gt;(T? <span style=color:#ff79c6>value</span>)
</span></span></code></pre></div><p>就意味着在声明：<code>value</code>可以是null————不管<code>T</code>是值类型还是引用类型</p><h2 id=泛型静态成员>泛型静态成员</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Generic</span>&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>int</span> Count;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Generic&lt;<span style=color:#8be9fd>int</span>&gt;.Count = <span style=color:#bd93f9>10</span>;
</span></span><span style=display:flex><span>Generic&lt;<span style=color:#8be9fd>string</span>&gt;.Count = <span style=color:#bd93f9>20</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(Generic&lt;<span style=color:#8be9fd>int</span>&gt;.Count); <span style=color:#6272a4>// 10</span>
</span></span><span style=display:flex><span>Console.WriteLine(Generic&lt;<span style=color:#8be9fd>string</span>&gt;.Count); <span style=color:#6272a4>// 20</span>
</span></span></code></pre></div><p>虽然它们是“同一个泛型类”，但不同的<code>T</code>会生成不同的静态副本<br>也就是说</p><blockquote><p>对于每个封闭泛型类型（如<code>Generic&lt;int></code>、<code>Generic&lt;string></code>），CLR都会为它生成独立的静态数据区</p></blockquote><p>C#的泛型是真实泛型，这意味着在CLR层面，每个具体的<code>Generic&lt;T></code>都会被“实例化”成一个独立的运行时类型描述</p><ul><li><code>Generic&lt;int></code> != <code>Generic&lt;string></code></li><li>它们在运行时是两个不同的TypeHandle</li><li>每个都有自己的静态字段表和类型初始化逻辑</li></ul><p>这不是语法糖，而是真实的类型区分</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>typeof</span>(Generic&lt;<span style=color:#8be9fd>int</span>&gt;) == <span style=color:#ff79c6>typeof</span>(Generic&lt;<span style=color:#8be9fd>string</span>&gt;) <span style=color:#6272a4>// false</span>
</span></span></code></pre></div><h3 id=静态构造函数static-ctor>静态构造函数（<code>static ctor</code>）</h3><p>每个封闭类型在第一次使用时，都会运行自己的静态构造函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Generic</span>&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>static</span> Generic()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>$&#34;Static ctor for {typeof(T)}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>new</span> Generic&lt;<span style=color:#8be9fd>int</span>&gt;();
</span></span><span style=display:flex><span><span style=color:#ff79c6>new</span> Generic&lt;<span style=color:#8be9fd>string</span>&gt;();
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Static ctor <span style=color:#ff79c6>for</span> System.Int32
</span></span><span style=display:flex><span>Static ctor <span style=color:#ff79c6>for</span> System.String
</span></span></code></pre></div><p>可以看到，CLR会为每个封闭类型单独触发一次初始化<br>这是非常关键的行为，意味着泛型的静态成员可以安全地缓存类型相关的全局信息，而互不干扰</p><h3 id=利用这一特性类型级缓存器>利用这一特性：类型级缓存器</h3><p>这个特性被许多框架、序列化器、ORM用来做“类型级缓存器”</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>TypeCache</span>&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>readonly</span> <span style=color:#8be9fd>string</span> TypeName = <span style=color:#ff79c6>typeof</span>(T).FullName;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>static</span> TypeCache()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>$&#34;Cache built for {TypeName}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 初始化多个类型</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>var</span> a = TypeCache&lt;<span style=color:#8be9fd>int</span>&gt;.TypeName;
</span></span><span style=display:flex><span><span style=color:#8be9fd>var</span> b = TypeCache&lt;<span style=color:#8be9fd>string</span>&gt;.TypeName;
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Cache built <span style=color:#ff79c6>for</span> System.Int32
</span></span><span style=display:flex><span>Cache built <span style=color:#ff79c6>for</span> System.String
</span></span></code></pre></div><p>这种设计可以让每个类型都有自己的缓存，而不用用字典去手动区分类型，性能极高，而且线程安全<br>这在诸如：</p><ul><li>JSON序列化器（如Newtonsoft.Json）</li><li>ORM（如Dapper、EF Core）</li><li>反射缓存框架</li></ul><p>中都是非常经典的优化模式</p><h3 id=泛型静态成员的jit编译逻辑>泛型静态成员的JIT编译逻辑</h3><p>当JIT编译器遇到一个泛型类型时，它的行为是这样的</p><ul><li>对于引用类型参数（class），多个封闭类型可能共享一份代码</li><li>对于值类型参数（struct），每个类型参数都会生成新的机器码</li><li>但无论共享代码与否，静态字段总是独立的</li></ul><p>共享JIT代码 != 共享静态数据</p><h2 id=陷阱与建议>陷阱与建议</h2><ol><li>不要把泛型当万能替代：类型安全没了约束时仍会出错。合理加<code>where</code>约束</li><li>方差只在接口/委托上：尝试对<code>List&lt;T></code>使用<code>out</code>/<code>in</code>时不可能的</li><li>注意装箱：如果把泛型值类型赋给非泛型接口/<code>object</code>就会装箱。尽量使用泛型接口</li><li>过度复杂的泛型层次会降低可读性：泛型设计要平衡灵活性与易用性</li><li><code>new()</code>约束：若仅为创建实例就加<code>new()</code>，考虑是否更好地注入工厂以便测试与解耦</li><li>不要用反射做泛型的常态逻辑：反射慢、复杂。只在必要时用</li></ol><hr><ul><li>仓储/服务层：用泛型接口 + 具体实现（<code>IRepository&lt;T></code>）能减少重复代码，但要避免把业务逻辑放在无法约束的泛型层</li><li>工具库：算法和数据结构实现用泛型几乎是必须的（例如泛型堆、泛型树）</li><li>API设计：如果方法接受/返回不同类型但逻辑一致，使用泛型；但若有类型特异行为，别勉强用泛型</li><li>限制泛型的可视化：写文档和注释，给出常见T应当满足的接口/契约说明</li></ul></div><nav class=post-nav><a href=/dotnetandwindows/file/c%23/function/ class=hover:underline>pre: Function</a>
<a href=/dotnetandwindows/file/c%23/indexer/ class=hover:underline>next: Indexer</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#为什么需要>为什么需要</a><ul><li><a href=#泛型如何解决这些问题>泛型如何解决这些问题</a></li></ul></li><li><a href=#语法>语法</a></li><li><a href=#泛型约束where>泛型约束（<code>where</code>）</a><ul><li><a href=#方差>方差</a><ul><li><a href=#协变>协变</a><ul><li><a href=#为什么这是安全的>为什么这是安全的</a></li><li><a href=#net中的实际例子>.NET中的实际例子</a></li></ul></li><li><a href=#逆变>逆变</a><ul><li><a href=#为什么这是安全的-1>为什么这是安全的</a></li><li><a href=#net中的实际例子-1>.NET中的实际例子</a></li></ul></li><li><a href=#不变>不变</a><ul><li><a href=#为什么不安全>为什么不安全</a></li></ul></li><li><a href=#重要规则>重要规则</a></li></ul></li></ul></li><li><a href=#底层实现>底层实现</a><ul><li><a href=#编译阶段>编译阶段</a></li><li><a href=#clr类型系统中的泛型机制>CLR类型系统中的泛型机制</a></li><li><a href=#jit编译>JIT编译</a></li><li><a href=#元数据与类型句柄typehandle>元数据与类型句柄（TypeHandle）</a></li><li><a href=#il层观察>IL层观察</a></li><li><a href=#值类型与装箱对比实验>值类型与装箱对比实验</a></li><li><a href=#运行时缓存机制type-instantiation-cache>运行时缓存机制（Type Instantiation Cache）</a></li><li><a href=#协变与逆变的运行时原理接口委托>协变与逆变的运行时原理（接口/委托）</a></li><li><a href=#泛型静态成员隔离机制>泛型静态成员隔离机制</a></li></ul></li><li><a href=#activatorcreateinstancet与new约束><code>Activator.CreateInstance&lt;T>()</code>与<code>new()</code>约束</a><ul><li><a href=#new约束机制与特点><code>new()</code>约束机制与特点</a></li><li><a href=#activatorcreateinstancet><code>Activator.CreateInstance&lt;T>()</code></a></li><li><a href=#使用场景>使用场景</a></li><li><a href=#内部机制>内部机制</a></li><li><a href=#最佳实践>最佳实践</a></li></ul></li><li><a href=#运行时类型信息与反射>运行时类型信息与反射</a><ul><li><a href=#rtti>RTTI</a></li><li><a href=#反射>反射</a></li><li><a href=#反射与泛型的结合>反射与泛型的结合</a></li></ul></li><li><a href=#泛型和nullnullable-reference-types>泛型和NULL（nullable reference types）</a><ul><li><a href=#通过约束告诉编译器t可以为null>通过约束告诉编译器<code>T</code>可以为<code>null</code></a></li><li><a href=#defaultt><code>default&lt;T></code></a></li><li><a href=#可空值类型>可空值类型</a></li><li><a href=#可空引用类型>可空引用类型</a></li></ul></li><li><a href=#泛型静态成员>泛型静态成员</a><ul><li><a href=#静态构造函数static-ctor>静态构造函数（<code>static ctor</code>）</a></li><li><a href=#利用这一特性类型级缓存器>利用这一特性：类型级缓存器</a></li><li><a href=#泛型静态成员的jit编译逻辑>泛型静态成员的JIT编译逻辑</a></li></ul></li><li><a href=#陷阱与建议>陷阱与建议</a></li></ul></li></ul></nav></aside><script defer src=/js/scrollspy.js></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>