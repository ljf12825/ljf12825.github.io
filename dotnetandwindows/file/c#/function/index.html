<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Function</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-lua.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-rust.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/log/>Log</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a> |
<a href=https://isocpp.org/ target=_blank>isocpp</a> |
<a href=https://open-std.org target=_blank>open-std</a></p><p><a href=https://cmake.com/ target=_blank>cmake.org</a></p><p><a href=https://llvm.org/ target=_blank>llvm.org</a></p><p><a href=https://www.boost.org/ target=_blank>boost.org</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/ target=_blank>lua.org</a> |
<a href=https://www.luarocks.org/ target=_blank>luarocks.org</a> |
<a href=https://www.luajit.org/ target=_blank>luajit.org</a></p><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a></p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a></p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Function<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><p>在C#中，函数通常被称为方法（Method）\</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 基本结构</span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>[修饰符]</span> [返回类型] 方法名([参数列表])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 方法体</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=参数传递>参数传递</h2><ol><li>值传递（默认）
传入的是参数的副本，方法内修改不影响外部</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Change(<span style=color:#8be9fd>int</span> x) { x = <span style=color:#bd93f9>10</span>; }
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> a = <span style=color:#bd93f9>5</span>;
</span></span><span style=display:flex><span>Change(a); <span style=color:#6272a4>// a 还是 5</span>
</span></span></code></pre></div><ol start=2><li>引用传递<code>ref</code>
传入的是变量的引用，方法内修改会影响外部，传入时必须已经赋值</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Change(<span style=color:#ff79c6>ref</span> <span style=color:#8be9fd>int</span> x) { x = <span style=color:#bd93f9>10</span>; }
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> a = <span style=color:#bd93f9>5</span>;
</span></span><span style=display:flex><span>Change(<span style=color:#ff79c6>ref</span> a); <span style=color:#6272a4>// a 变成 10</span>
</span></span></code></pre></div><ol start=3><li>输出参数<code>out</code>
必须在方法内赋值，用来返回多个结果，传入时可以不赋值</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Divide(<span style=color:#8be9fd>int</span> a, <span style=color:#8be9fd>int</span> b, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>int</span> result, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>int</span> remainder)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    result = a / b;
</span></span><span style=display:flex><span>    remainder = a % b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> res, rem;
</span></span><span style=display:flex><span>Devide(<span style=color:#bd93f9>10</span>, <span style=color:#bd93f9>3</span>, <span style=color:#ff79c6>out</span> res, <span style=color:#ff79c6>out</span> rem); <span style=color:#6272a4>// res = 3, rem = 1</span>
</span></span></code></pre></div><ol start=4><li>只读引用<code>in</code>(C# 7.2+)
方法内只能读取，不可更改（只读保证），传入时必须已经赋值<br>避免大对象复制，提升性能，同时保证只读安全</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Change(<span style=color:#ff79c6>in</span> <span style=color:#8be9fd>int</span> x) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(x);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// x = 8; // error</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=5><li>可选参数(Optional Parameters)
在定义方法时，给参数一个默认值，调用方法时，如果不传这个参数，就使用默认值<br>默认值必须是编译时常量或者<code>default(T)</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Greet(<span style=color:#8be9fd>string</span> name = <span style=color:#f1fa8c>&#34;Guest&#34;</span>, <span style=color:#8be9fd>int</span> times = <span style=color:#bd93f9>1</span>) =&gt; <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>0</span>; i &lt; times; ++i) Console.WriteLine(<span style=color:#f1fa8c>$&#34;Hello, {name}!&#34;</span>);
</span></span><span style=display:flex><span>Greet(); <span style=color:#6272a4>// Hello, Guest!(使用默认)</span>
</span></span><span style=display:flex><span>Greet(<span style=color:#f1fa8c>&#34;Alice&#34;</span>); <span style=color:#6272a4>// Hello, Alice!</span>
</span></span><span style=display:flex><span>Greet(<span style=color:#f1fa8c>&#34;Bob&#34;</span>, <span style=color:#bd93f9>3</span>); <span style=color:#6272a4>// Hello, Bob（输出三次）</span>
</span></span></code></pre></div><p>注意：</p><ul><li>可选参数必须放在参数列表的末尾，否则调用时会产生歧义</li><li>默认值必须是常量表达式或<code>default(T)</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Print(<span style=color:#8be9fd>int</span> x = <span style=color:#bd93f9>10</span>, <span style=color:#8be9fd>string</span> y = <span style=color:#f1fa8c>&#34;hello&#34;</span>, <span style=color:#8be9fd>object</span> obj = <span style=color:#ff79c6>null</span>, <span style=color:#8be9fd>int</span> z = <span style=color:#ff79c6>default</span>(T)) {}
</span></span></code></pre></div><ol start=6><li>命名参数(Named Parameters)
调用方法时，可以显式写出参数名，而不是按顺序传参，可以提高可读性，尤其是参数很多的时候，可以和可选参数结合使用</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> CreateUser(<span style=color:#8be9fd>string</span> username, <span style=color:#8be9fd>int</span> age, <span style=color:#8be9fd>bool</span> isAdmin = <span style=color:#ff79c6>false</span>) =&gt; Console.WriteLine(<span style=color:#f1fa8c>$&#34;{username}, {age}, Admin={isAdmin}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 常规调用</span>
</span></span><span style=display:flex><span>CreateUser(<span style=color:#f1fa8c>&#34;Tom&#34;</span>, <span style=color:#bd93f9>20</span>, <span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 命名参数调用（顺序可变）</span>
</span></span><span style=display:flex><span>CreateUser(age: <span style=color:#bd93f9>25</span>, username: <span style=color:#f1fa8c>&#34;Alice&#34;</span>, isAdmin: <span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 结合可选参数</span>
</span></span><span style=display:flex><span>CreateUser(username: <span style=color:#f1fa8c>&#34;Bob&#34;</span>, age: <span style=color:#bd93f9>30</span>); <span style=color:#6272a4>// isAdmin使用默认值</span>
</span></span></code></pre></div><p><strong>可选参数和命名参数结合的优势</strong><br>减少方法重载<br>使用重载支持多种调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Log(<span style=color:#8be9fd>string</span> message) { ... }
</span></span><span style=display:flex><span><span style=color:#ff79c6>void</span> Log(<span style=color:#8be9fd>string</span> message, <span style=color:#8be9fd>int</span> level) { ... }
</span></span></code></pre></div><p>可以直接写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Log(<span style=color:#8be9fd>string</span> message, <span style=color:#8be9fd>int</span> level = <span style=color:#bd93f9>1</span>) { ... }
</span></span></code></pre></div><p>提升可读性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 不易读</span>
</span></span><span style=display:flex><span>SendEmail(<span style=color:#f1fa8c>&#34;test@example.com&#34;</span>, <span style=color:#f1fa8c>&#34;hi&#34;</span>, <span style=color:#ff79c6>true</span>, <span style=color:#ff79c6>false</span>, <span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 易读</span>
</span></span><span style=display:flex><span>SendEmail(to: <span style=color:#f1fa8c>&#34;test@example.com&#34;</span>, subject: <span style=color:#f1fa8c>&#34;hi&#34;</span>, cc: <span style=color:#ff79c6>true</span>, bcc: <span style=color:#ff79c6>false</span>, isImportant: <span style=color:#ff79c6>true</span>);
</span></span></code></pre></div><p><strong>注意事项</strong>\</p><ul><li>命名参数必须在位置参数之后</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Greet(<span style=color:#f1fa8c>&#34;Alice&#34;</span>, times: <span style=color:#bd93f9>3</span>); <span style=color:#6272a4>// 正确</span>
</span></span><span style=display:flex><span>Greet(name: <span style=color:#f1fa8c>&#34;Alice&#34;</span>, <span style=color:#bd93f9>3</span>); <span style=color:#6272a4>// 错误</span>
</span></span></code></pre></div><ul><li>不要随意修改默认值：因为默认值在编译时就确定，如果API发布后改了默认值，调用方法没重新编译的话，还是用老值</li><li>慎用太多可选参数：过多的可选参数会导致方法签名复杂，建议拆分成配置类</li></ul><ol start=7><li><code>params</code>参数
<code>params</code>修饰符允许方法接收数量不定的参数<br>调用方法时可以传入：0个参数，多个参数，或者一个数组<br>编译器会自动把多个参数打包成一个数组传给方法</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> PrintNumbers(<span style=color:#ff79c6>params</span> <span style=color:#8be9fd>int</span>[] numbers) =&gt; <span style=color:#ff79c6>foreach</span> (<span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>in</span> numbers) Console.WriteLine(n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 调用方式</span>
</span></span><span style=display:flex><span>PrintNumbers(); <span style=color:#6272a4>// 什么都不打印</span>
</span></span><span style=display:flex><span>PrintNumbers(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>); <span style=color:#6272a4>// 打印 1 2 3 4</span>
</span></span><span style=display:flex><span>PrintNumbers(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>int</span>[] {<span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>7</span>}); <span style=color:#6272a4>// 打印 5 6 7</span>
</span></span></code></pre></div><p>等价于写了一个接收<code>int[]</code>的函数，但调用时更灵活</p><p><strong>限制条件</strong><br>只能有一个<code>params</code>参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Foo(<span style=color:#ff79c6>params</span> <span style=color:#8be9fd>int</span>[] a, <span style=color:#ff79c6>params</span> <span style=color:#8be9fd>string</span>[] b); <span style=color:#6272a4>// 错误</span>
</span></span></code></pre></div><p>必须是方法参数列表中的最后一个</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Foo(<span style=color:#8be9fd>int</span> x , <span style=color:#ff79c6>params</span> <span style=color:#8be9fd>int</span>[] numbers); <span style=color:#6272a4>// 正确</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>void</span> Bar(<span style=color:#ff79c6>params</span> <span style=color:#8be9fd>int</span>[] numbers, <span style=color:#8be9fd>int</span> x); <span style=color:#6272a4>// 错误</span>
</span></span></code></pre></div><p><code>params</code>可以是任意类型的数组(<code>int[]</code>、<code>string[]</code>、<code>object[]</code>等)<br>示例：使用<code>pramas</code> + <code>object</code> 传入不同类型参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> PrintAll(<span style=color:#ff79c6>params</span> <span style=color:#8be9fd>object</span>[] items) =&gt; <span style=color:#ff79c6>foreach</span> (<span style=color:#8be9fd>var</span> item <span style=color:#ff79c6>in</span> items) Console.WriteLine(item);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PrintAll(<span style=color:#bd93f9>1</span>, <span style=color:#f1fa8c>&#34;hello&#34;</span>, <span style=color:#bd93f9>3.14</span>, <span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 输出：1 hello 3.14 Ture</span>
</span></span></code></pre></div><p>这种方式常见于日志系统，类似<code>Console.WriteLine</code>的实现</p><p>示例：和其他参数混用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Log(<span style=color:#8be9fd>string</span> tag, <span style=color:#ff79c6>params</span> <span style=color:#8be9fd>string</span>[] messages) =&gt; Console.WriteLine(<span style=color:#f1fa8c>$&#34;[{tag}]&#34;</span> + <span style=color:#8be9fd>string</span>.Join(<span style=color:#f1fa8c>&#34;, &#34;</span>, message));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Log(<span style=color:#f1fa8c>&#34;INFO&#34;</span>, <span style=color:#f1fa8c>&#34;Game Start&#34;</span>, <span style=color:#f1fa8c>&#34;Player Joined&#34;</span>);
</span></span><span style=display:flex><span>Log(<span style=color:#f1fa8c>&#34;ERROR&#34;</span>); <span style=color:#6272a4>// 没有消息也行</span>
</span></span></code></pre></div><p><strong>注意事项</strong><br>每次调用带<code>params</code>的方法，都会分配一个数组（哪怕只传1个参数）<br>如果方法在性能敏感的地方（比如游戏循环内）频繁调用，可能会导致GC压力<br>优化方案：提供带数组的重载，避免数组分配</p><h2 id=main-function>Main Function</h2><p>在C#程序中，必须有一个<code>Main</code>方法作为入口。它通常写在一个类或结构体内</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main(<span style=color:#8be9fd>string</span>[] args)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>&#34;Hello World&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>static</code>：<code>Main</code>必须是静态方法，因为在程序启动时还没有对象的实例，必须通过类来调用</li><li>返回值：返回值类型可以是<code>void</code>或<code>int</code>，返回值会作为程序的退出码</li><li><code>string[] args</code>：命令行参数，可选</li></ul><p><code>Main</code>函数的几种有效签名</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main();                <span style=color:#6272a4>// 无返回值，无参数</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main(<span style=color:#8be9fd>string</span>[] args);   <span style=color:#6272a4>// 无返回值，有参数</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>int</span> Main();                 <span style=color:#6272a4>// 有返回值，无参数</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>int</span> Main(<span style=color:#8be9fd>string</span>[] args);    <span style=color:#6272a4>// 有返回值，有参数</span>
</span></span></code></pre></div><h3 id=命令行参数>命令行参数</h3><p>假设编译成<code>MyApp.exe</code>，然后运行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>MyApp.exe hello world 123
</span></span></code></pre></div><p>在代码里</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main(<span style=color:#8be9fd>string</span>[] args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>foreach</span> (<span style=color:#8be9fd>var</span> arg <span style=color:#ff79c6>in</span> args) Console.WriteLine(arg);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>命令行参数的作用时允许用户在启动应用程序时，从外部向程序传递配置信息或数据，从而让程序的行为可以根据输入动态改变，而无需修改代码本身。这极大地提高了程序的灵活性和可重用性<br>常见场景：</p><ol><li>配置程序运行模式
允许用户指定程序以不同的模式运行，例如开启调试模式、详细输出模式或指定使用哪种算法</li></ol><ul><li>示例：<code>MyApp.exe --debug --verbose</code><ul><li>程序接收到<code>--debug</code>和<code>--verbose</code>参数后，可以输出更详细的日志信息</li></ul></li></ul><ol start=2><li>传递输入/输出文件路径
这是最常见的用途之一。程序本身不硬编码文件路径，而是由用户通过参数指定要处理的文件以及结果输出的位置</li></ol><ul><li>示例：<code>MyApp.exe -input data.txt -output report.pdf</code><ul><li>程序会读取<code>data.txt</code>文件，处理后将结果生成到<code>report.pdf</code></li></ul></li></ul><ol start=3><li>设置程序选项和标志
用于开启或关闭特定功能，或者设置一些简单的值</li></ol><ul><li>示例：<code>MyApp.exe -level 5 -name "John Doe" -force</code><ul><li><code>-level</code>后面跟了一个值<code>5</code></li><li><code>-name</code>后面跟了一个字符串值</li><li><code>-force</code>是一个标志（flag），通常表示“强制执行”，它本身不需要值，它的存在即代表<code>true</code></li></ul></li></ul><ol start=4><li><p>自动化脚本和任务
在批处理文件(.bat)、PowerShell脚本或CI/CD流程中，经常通过命令行参数来调用和控制应用程序，实现自动化</p></li><li><p>开发与调试
开发者可以在IDE中预设命令行参数，方便在调试时测试程序对不同参数的处理逻辑</p></li></ol><ul><li>在Visual Studio中设置<ul><li>右键点击项目 -> “属性”</li><li>选择“调试”选项卡</li><li>在“命令行参数”文本框中输入你的参数（例如：-input test.txt）</li><li>这样每次从Visual Studio启动调试时，都会自动带上这些参数。</li></ul></li></ul><h4 id=在程序中获取命令行参数>在程序中获取命令行参数</h4><ol><li>使用<code>Main</code>方法的参数（最常用）
<code>Main</code>方法是C#应用程序的入口点，它可以被定义为一个接受字符串数组参数的方法，这个数组就是命令行参数</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>namespace</span> CommandLineArgsDemo
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Program</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// Main 方法的参数 string[] args 就是命令行参数数组</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main(<span style=color:#8be9fd>string</span>[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#f1fa8c>&#34;Number of command line arguments: &#34;</span> + args.Length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>0</span>; i &lt; args.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#f1fa8c>$&#34;Arg[{i}] = {args[i]}&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 简单的参数处理示例</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (args.Length &gt; <span style=color:#bd93f9>0</span> &amp;&amp; args[<span style=color:#bd93f9>0</span>] == <span style=color:#f1fa8c>&#34;--help&#34;</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#f1fa8c>&#34;This is the help message.&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>编译运行</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>dotnet run -- arg1 arg2 <span style=color:#f1fa8c>&#34;third argument&#34;</span> --help
</span></span></code></pre></div><pre><code>- 注意：在`dotnet run`命令中，`--`之后的参数才会传递给程序。`args`数组将包含：`[&quot;arg1&quot;, &quot;arg2&quot;, &quot;third argument&quot;， &quot;--help&quot;]`
</code></pre><ul><li>直接运行EXE:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>.<span style=color:#f1fa8c>\C</span>ommandLineArgsDemo.exe arg1 arg2 <span style=color:#f1fa8c>&#34;third argument&#34;</span> --help
</span></span></code></pre></div><ol start=2><li>使用<code>Environment.GetCommandLineArgs</code>
这个方法返回一个字符串数组，其中也包含了命令行参数。与<code>Main</code>方法的参数不同的是</li></ol><ul><li>数组的第一个元素（索引<code>[0]</code>）是当前程序的可执行文件路径</li><li>从第二个元素（索引<code>[1]</code>）开始才是用户传入的参数</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>namespace</span> CommandLineArgsDemo
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Program</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main() <span style=color:#6272a4>// Main 方法可以不接受参数</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 使用 Environment.GetCommandLineArgs</span>
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>string</span>[] allArgs = Environment.GetCommandLineArgs();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#f1fa8c>&#34;Executable path: &#34;</span> + allArgs[<span style=color:#bd93f9>0</span>]);
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#f1fa8c>&#34;Arguments:&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>1</span>; i &lt; allArgs.Length; i++) <span style=color:#6272a4>// 从1开始，跳过exe路径</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#f1fa8c>$&#34;  [{i}] {allArgs[i]}&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=复杂命令行参数>复杂命令行参数</h4><p>对于简单的<code>-flag value</code>格式，自己写循环和逻辑判断就足够了。但如果参数非常复杂，例如支持<code>--long-option</code>、<code>-s</code>（短选项）、可选参数等，手动解析就非常麻烦<br>可以使用专门的命令行参数解析库，它们可以自动处理各种复杂的场景，并提供<code>--help</code>帮助文档生成等功能
流行的NuGet包有</p><ol><li>System.CommandLine(.NET推荐)</li></ol><ul><li>这是微软官方推出的新一代命令行解析库，功能强大，集成度高，是未来的方向</li></ul><ol start=2><li>CommandLineParser</li></ol><ul><li>一个非常流行且成熟的库，通过属性（Attribute）来定义参数模型，非常直观</li></ul><h2 id=lambda>Lambda</h2><p>Lambda表达式本质上是匿名函数（没有名字的函数），可以用来简化委托和表达式树的写法。它的形式是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>(参数列表) =&gt; 表达式或语句块
</span></span></code></pre></div><p><code>=></code>读作goes to 左边是输入参数，右边是返回结果或逻辑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>x =&gt; x * x
</span></span></code></pre></div><p>这是一个接收一个参数<code>x</code>并返回<code>x * x</code>的函数</p><h3 id=基础用法>基础用法</h3><ol><li>单参数表达式</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>&gt; square = x =&gt; x * x;
</span></span><span style=display:flex><span>Console.WriteLine(square(<span style=color:#bd93f9>5</span>)); <span style=color:#6272a4>// 25</span>
</span></span></code></pre></div><p>这里<code>Func&lt;int, int></code>代表输入<code>int</code>，返回<code>int</code></p><ol start=2><li>多参数表达式</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>&gt; <span style=color:#ff79c6>add</span> = (a, b) =&gt; a + bl
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#ff79c6>add</span>(<span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>)); <span style=color:#6272a4>// 7</span>
</span></span></code></pre></div><ol start=3><li>无参数</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;<span style=color:#8be9fd>int</span>&gt; getRandom = () =&gt; <span style=color:#ff79c6>new</span> Random().Next(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>10</span>);
</span></span><span style=display:flex><span>Console.WriteLine(getRandom());
</span></span></code></pre></div><ol start=4><li>Lambda的语句块写法
如果逻辑复杂，可以用花括号写多条语句</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>&gt; multiplyAndAdd = (a, b) =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>int</span> product = a * b;
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> product + <span style=color:#bd93f9>10</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>Console.WriteLine(multiplyAndAdd(<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>)); <span style=color:#6272a4>// 16</span>
</span></span></code></pre></div><ol start=5><li>Lambda与委托
传统写法（委托 + 匿名方法）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>&gt; square = <span style=color:#ff79c6>delegate</span> (<span style=color:#8be9fd>int</span> x) { <span style=color:#ff79c6>return</span> x * x; };
</span></span></code></pre></div><p>Lambda简化后</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>&gt; square = x =&gt; x * x;
</span></span></code></pre></div><ol start=6><li>LINQ中使用</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int</span>[] nums = { <span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>5</span> };;
</span></span><span style=display:flex><span><span style=color:#8be9fd>var</span> evenNums = nums.Where(n =&gt; n % <span style=color:#bd93f9>2</span> == <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>foreach</span> (<span style=color:#8be9fd>var</span> n <span style=color:#ff79c6>in</span> evenNums) Console.WriteLine(n); <span style=color:#6272a4>// 2, 4</span>
</span></span></code></pre></div><p>排序</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;<span style=color:#8be9fd>string</span>&gt; names = <span style=color:#ff79c6>new</span>() { <span style=color:#f1fa8c>&#34;Tom&#34;</span>, <span style=color:#f1fa8c>&#34;Jerry&#34;</span>, <span style=color:#f1fa8c>&#34;Alice&#34;</span> };
</span></span><span style=display:flex><span>names.Sort((a, b) =&gt; a.Length.CompareTo(b.Length));
</span></span></code></pre></div><ol start=7><li>Lambda的类型推断
C#会根据上下文推断参数和返回类型，不用显式写类型</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>var</span> list = <span style=color:#ff79c6>new</span> List&lt;<span style=color:#8be9fd>int</span>&gt; {<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>};
</span></span><span style=display:flex><span>list.ForEach(n =&gt; Console.WriteLine(n));
</span></span></code></pre></div><p>这里<code>n</code>自动推断为<code>int</code></p><ol start=8><li>Lambda捕获外部变量（闭包）
Lambda可以“记住”它定义时的上下文变量</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int</span> factor = <span style=color:#bd93f9>10</span>;
</span></span><span style=display:flex><span>Func&lt;<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>int</span>&gt; multiplier = x =&gt; x * factor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(multiplier(<span style=color:#bd93f9>5</span>)); <span style=color:#6272a4>// 50</span>
</span></span></code></pre></div><p>注意：<code>factor</code>是捕获变量，如果后面改<code>factor</code>，Lambda内的值也会改变</p><ol start=9><li>Action与Func</li></ol><ul><li>Func：有返回值的Lambda
例如<code>Func&lt;int, int, int></code>表示接收两个<code>int</code>，返回一个<code>int</code></li><li>Action：无返回值的Lambda
例如<code>Action&lt;string></code>表示接收一个<code>string</code>参数但没有返回值</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Action&lt;<span style=color:#8be9fd>string</span>&gt; greet = name =&gt; Console.WriteLine(<span style=color:#f1fa8c>$&#34;Hello {name}&#34;</span>);
</span></span><span style=display:flex><span>greet(<span style=color:#f1fa8c>&#34;World&#34;</span>);
</span></span></code></pre></div><ol start=10><li>Lambda与事件
Lambda可以简化事件订阅</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>button.Click += (sender, e) =&gt; MessageBox.Show(<span style=color:#f1fa8c>&#34;Button clicked!&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 传统方法需要定义一个单独的方法</span>
</span></span></code></pre></div><ol start=11><li>表达式树（Expression Trees）
高级用法：Lambda不仅可以编译成委托，还可以编译成数据结构（表达式树），允许在运行时分析、转换或翻译代码<br>例如LINQ to SQL将C#代码翻译成SQL语句</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 这是一个表达式Lambda，它被编译器识别为表达式树</span>
</span></span><span style=display:flex><span>System.Linq.Expressions.Expression&lt;Func&lt;<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>bool</span>&gt;&gt; isEvenExpression = n =&gt; n % <span style=color:#bd93f9>2</span> == <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 这只是一个普通的委托</span>
</span></span><span style=display:flex><span>Func&lt;<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>bool</span>&gt; isEvenDelegate = n =&gt; n % <span style=color:#bd93f9>2</span> == <span style=color:#bd93f9>0</span>;
</span></span></code></pre></div><p><code>isEvenExpression</code>不是一个可执行的方法，而是一个描述<code>n => n % 2 == 0</code>这个逻辑的树形数据结构，可以被其他组件（如ORM框架）解析</p><h2 id=局部函数c-70>局部函数（C# 7.0+）</h2><p>局部函数就是定义在方法（或属性、构造函数等）内部的函数<br>它只在当前方法作用域内可见，外部不能之际调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Calculator</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> SumToN(<span style=color:#8be9fd>int</span> n)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> Add(<span style=color:#8be9fd>int</span> x, <span style=color:#8be9fd>int</span> y) =&gt; x + y; <span style=color:#6272a4>// 局部函数</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> total = <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>1</span>; i &lt;= n; ++i)
</span></span><span style=display:flex><span>      total = Add(total, i);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> total;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里的<code>Add</code>是个局部函数，只能在<code>SumToN</code>内使用</p><h3 id=局部函数的优势>局部函数的优势</h3><ol><li><p>封装性更强
避免只把方法内部用的小逻辑暴露成类的公有/私有方法</p></li><li><p>可读性更好
把复杂逻辑拆成小块，但又不会污染类的命名空间</p></li><li><p>性能比匿名函数更优</p></li></ol><ul><li>匿名函数（Lambda）如果捕获外部变量，会生成闭包对象，增加分配</li><li>局部函数是编译期就确定的，不需要额外分配对象，性能更高</li></ul><h3 id=局部函数的特性>局部函数的特性</h3><ol><li>可访问外部变量</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> PrintSquares(<span style=color:#8be9fd>int</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>int</span> counter = <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>void</span> PrintOne(<span style=color:#8be9fd>int</span> x) <span style=color:#6272a4>// 局部函数</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    counter++;
</span></span><span style=display:flex><span>    Console.WriteLine(x * x);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>1</span>; i &lt;= n; ++i) PrintOne(i);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Console.WriteLine(<span style=color:#f1fa8c>$&#34;调用了{counter}次&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>支持递归</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int</span> Factorial(<span style=color:#8be9fd>int</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>int</span> Inner(<span style=color:#8be9fd>int</span> x)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (x &lt;= <span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> x * Inner(x - <span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> Inner(n);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>可以是异步函数</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>async</span> Task&lt;<span style=color:#8be9fd>int</span>&gt; GetDataAsync()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>async</span> Task&lt;<span style=color:#8be9fd>int</span>&gt; Fetch() <span style=color:#6272a4>// 局部异步函数</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>await</span> Task.Delay(<span style=color:#bd93f9>500</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>42</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>await</span> Fetch();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>可以用<code>static</code>修饰（C# 8+）
表示不捕获外部变量，避免闭包</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int</span> AddNumbers(<span style=color:#8be9fd>int</span> a, <span style=color:#8be9fd>int</span> b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>int</span> Add(<span style=color:#8be9fd>int</span> x, <span style=color:#8be9fd>int</span> y) =&gt; x + y;
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> Add(a, b);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>使用场景</strong></p><ul><li>复杂方法内的子逻辑：避免写到类级别</li><li>递归辅助函数：比如<code>DFS</code>、<code>Factorial</code></li><li>提高性能：在需要小函数但不想用Lambda时</li><li>异步内部步骤：<code>async Task</code>拆分</li></ul><h2 id=异步><a href=/LearnCSharp/Thread.cs>异步</a></h2><h2 id=顶级语句top-level-statementsc-90>顶级语句(Top-level statements)(C# 9.0+)</h2><p>在C# 9.0之后，微软引入了“顶级语句”的概念，它的作用是：让简单程序（特别是控制台应用）写起来更简洁，不必再写<code>class Program</code>和<code>static void Main</code><br>比如以前要写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main(<span style=color:#8be9fd>string</span>[] args)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#f1fa8c>&#34;Hello, World!&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>有了顶级语句之后，只需要</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#f1fa8c>&#34;Hello, World!&#34;</span>);
</span></span></code></pre></div><p>这里没有类，也没有<code>Main</code>，但编译器会自动生成一个<code>Program</code>类和<code>Main</code>方法，将顶级语句放入其中<br>所以顶级语句只是语法糖，不影响本质</p><h3 id=限制与规则>限制与规则</h3><ol><li>只能有一个文件使用顶级语句</li></ol><ul><li>如果多个文件使用了顶级语句，会报错</li></ul><ol start=2><li>命名空间、类、方法必须卸载顶级语句之后</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#f1fa8c>&#34;Hello&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>MyClass</span> { }
</span></span></code></pre></div><ol start=3><li>顶级语句不能出现在方法或类内部</li><li>适合小型程序、示例代码、脚本化开发</li></ol></div><nav class=post-nav><a href=/dotnetandwindows/file/c%23/exception/ class=hover:underline>pre: Exception</a>
<a href=/dotnetandwindows/file/c%23/generic/ class=hover:underline>next: Generic</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#参数传递>参数传递</a></li><li><a href=#main-function>Main Function</a><ul><li><a href=#命令行参数>命令行参数</a><ul><li><a href=#在程序中获取命令行参数>在程序中获取命令行参数</a></li><li><a href=#复杂命令行参数>复杂命令行参数</a></li></ul></li></ul></li><li><a href=#lambda>Lambda</a><ul><li><a href=#基础用法>基础用法</a></li></ul></li><li><a href=#局部函数c-70>局部函数（C# 7.0+）</a><ul><li><a href=#局部函数的优势>局部函数的优势</a></li><li><a href=#局部函数的特性>局部函数的特性</a></li></ul></li><li><a href=#异步>异步</a></li><li><a href=#顶级语句top-level-statementsc-90>顶级语句(Top-level statements)(C# 9.0+)</a><ul><li><a href=#限制与规则>限制与规则</a></li></ul></li></ul></li></ul></nav></aside><script defer src=/js/scrollspy.js></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>