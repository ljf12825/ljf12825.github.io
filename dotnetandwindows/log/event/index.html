<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Event</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-lua.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-rust.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/log/>Log</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a> |
<a href=https://isocpp.org/ target=_blank>isocpp</a> |
<a href=https://open-std.org target=_blank>open-std</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/ target=_blank>lua.org</a> |
<a href=https://www.luarocks.org/ target=_blank>luarocks.org</a> |
<a href=https://www.luajit.org/ target=_blank>luajit.org</a></p><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a></p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a></p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Event<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><p>事件是C#和.NET框架中实现<strong>发布-订阅</strong>模式的核心机制。它允许一个对象（发布者）在特定事情发生时，通知其他多个对象（订阅者）。这种设计实现了对象之间的松耦合，发布者不需要知道谁订阅了它，也不需要知道订阅者将如何处理通知</p><h2 id=核心概念>核心概念</h2><ul><li>发布者：拥有事件的对象。当某个条件满足或某个动作发生时，它负责触发事件。也称为"Sender"或"Event Source"</li><li>订阅者：对事件感兴趣的对象。它包含一个方法，当事件被触发时，这个方法会被调用。它负责订阅和取消订阅事件。也称为"Receiver"或"Event Handler"</li></ul><h2 id=事件的五个组成部分>事件的五个组成部分</h2><ol><li>委托：事件的<strong>契约</strong>或<strong>蓝图</strong>。它定义了订阅者的事件处理方法必须具有的签名（返回值类型和参数列表）</li><li>事件：使用<code>event</code>关键字声明的对象，它是委托的一个封装后的、安全的“包装器”</li><li>事件数据：一个从<code>EventArgs</code>派生的类，用于在触发事件时向订阅者传递相关信息</li><li>事件触发者：发布者类中负责调用事件（即调用封装在事件内的委托）的代码</li><li>事件处理器：订阅者类中符合委托签名的方法，用于响应事件</li></ol><h2 id=声明和使用事件的完整步骤>声明和使用事件的完整步骤</h2><p>以“按钮点击”为例</p><ol><li>定义事件数据类
通常继承自<code>EventArgs</code>。如果不需要传递额外数据，可以直接使用<code>EventArgs.Empty</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 自定义事件数据类，用于传递点击发生的时间</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>ButtonClickedEventArgs</span> : EvnetArgs
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> DateTime ClickedTime { <span style=color:#ff79c6>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> ButtonClickedEventArgs(DateTime time) =&gt; ClickedTime = time;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>定义委托
.NET提供了一个通用的委托类型<code>EventHandler&lt;TEventArgs></code>，在大多数情况下不需要自定义委托</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 过去可能需要这样定义委托</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// public delegate void ButtonClickEventHandler(object sender, ButtonClickedEventArgs e);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 现在，直接使用 EvnetHandler&lt;T&gt;即可</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 它的签名是：void (object sender, TEventArgs e)</span>
</span></span></code></pre></div><ol start=3><li>在发布者类中声明事件
使用<code>event</code>关键字，后跟委托类型和事件名称</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 发布者</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Button</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 1. 声明事件</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler&lt;ButtonClickedEventArgs&gt; Clicked;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 一个模拟按钮被按下去的方法</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> SimulateClick()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>&#34;按钮被按下了...&#34;</span>);
</span></span><span style=display:flex><span>        OnClicked(<span style=color:#ff79c6>new</span> ButtonClickedEventArgs(DateTime.Now));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 2. 定义触发事件的方法（约定以 On 开头）</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 使用 virtual 关键字允许子类重写触发逻辑</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>protected</span> <span style=color:#ff79c6>virtual</span> <span style=color:#ff79c6>void</span> OnClicked(ButtonClickedEventArgs e)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 临时将事件赋值给一个局部变量，防止竞态条件（在检查null后，另一个线程取消订阅）</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// EventHandler&lt;ButtonClickedEventArgs&gt; handler = Clicked;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 检查是否有订阅者</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// if (handler != null)</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// {</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//     // 触发事件！‘this’是发送者（发布者自己），e是事件数据</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//     handler(this, e);</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// }</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 在C# 6.0 及以后，可以使用更简洁的Null条件操作符</span>
</span></span><span style=display:flex><span>        Clicked?.Invoke(<span style=color:#ff79c6>this</span>, e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>OnClicked</code>方法是触发事件的推荐方式。它封装了触发逻辑，使代码更清晰、更安全</li><li>使用<code>?.Invoke()</code>或局部变量是为了线程安全，确保在检查null和调用之间，事件不会被设置为null</li></ul><ol start=4><li>在订阅者类中创建事件处理器并订阅
事件处理器就是一个与委托签名匹配的方法</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 订阅者</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>UserInterface</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> UserInterface(Button button)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 订阅事件：使用+=操作符</span>
</span></span><span style=display:flex><span>        button.Clicked += OnButtonClicked;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 也可以使用 Lambda 表达式</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// button.Clicked += (sender, e) =&gt; Console.WriteLine($&#34;Lambda: 按钮在 {e.ClickedTime}被点击了&#34;);</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 事件处理器方法</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>void</span> OnButtonClicked(<span style=color:#8be9fd>object</span> sender, ButtonClickedEventArgs e)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 可以获取是哪个按钮触发的</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// Button button = sender as Button; </span>
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>$&#34;用户界面收到通知：按钮在{e.ClickedTime}被点击了。&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 这里可以更新UI，比如改变按钮颜色、弹出对话框等</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 一个用于取消订阅的方法</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> UnsubscribeFromButton(Button button)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        button.Clicked -= OnButtonClicked;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=5><li>运行程序</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main(<span style=color:#8be9fd>string</span>[] args)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 1. 创建发布者</span>
</span></span><span style=display:flex><span>        Button myButton = <span style=color:#ff79c6>new</span> Button();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 2. 创建订阅者，并订阅事件</span>
</span></span><span style=display:flex><span>        UserInterface ui = <span style=color:#ff79c6>new</span> UserInterface(myButton);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 3. 模拟事件发生</span>
</span></span><span style=display:flex><span>        myButton.SimulateClick();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 4. 取消订阅（如果需要）</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// ui.UnsubscribeFromButton(myButton);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Console.ReadKey();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>按钮被按下了...
</span></span><span style=display:flex><span>用户界面收到通知：按钮在 YYYY-mm-dd HH:MM:SS 被点击了
</span></span></code></pre></div><h2 id=eventhandler><code>EventHandler</code></h2><p><code>EventHandler</code>是.NET框架中预定义的一个委托类型，专门用于表示不携带自定义数据的事件处理方法<br>它定义在<code>System</code>命名空间中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>delegate</span> <span style=color:#ff79c6>void</span> EventHandler(<span style=color:#8be9fd>object</span> sender, EventArgs e);
</span></span></code></pre></div><ul><li>返回类型：<code>void</code>-事件处理器不返回值</li><li>第一个参数：<code>object sender</code>-触发事件的对象的引用</li><li>第二个参数：<code>EventArgs e</code>-事件数据，通常使用<code>EventArgs.Empty</code></li></ul><h3 id=存在意义统一的事件模式>存在意义：统一的事件模式</h3><p>在早期.NET中，如果没有标准化委托，每个事件都需要自定义委托</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 不统一的做法-每个事件都有自己的委托</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>delegate</span> <span style=color:#ff79c6>void</span> ClickHandler(<span style=color:#8be9fd>object</span> sender);
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>delegate</span> <span style=color:#ff79c6>void</span> LoadHandler(<span style=color:#8be9fd>object</span> sender, <span style=color:#8be9fd>string</span> message);
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>delegate</span> <span style=color:#ff79c6>void</span> CloseHandler();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> ClickHandler Clicked;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> LoadHandler Loaded;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> CloseHandler Closed;
</span></span></code></pre></div><p>这导致了：</p><ul><li>不一致的签名</li><li>难以记忆的参数</li><li>代码重复</li></ul><p><code>EventHandler</code>引入了统一的标准</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 统一的做法 - 所有事件都使用 EventHandler</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler Clicked;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler Loaded;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler Closed;
</span></span></code></pre></div><h3 id=基本用法>基本用法</h3><p>声明事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Button</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 声明使用 EventHandler 委托的事件</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler Clicked;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> SimulateClick()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>&#34;按钮被点击...&#34;</span>);
</span></span><span style=display:flex><span>        OnClicked();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>protected</span> <span style=color:#ff79c6>virtual</span> <span style=color:#ff79c6>void</span> OnClicked()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 触发事件，使用 EventArgs.Empty 表示没有额外数据</span>
</span></span><span style=display:flex><span>        Clicked?.Invoke(<span style=color:#ff79c6>this</span>, EventArgs.Empty);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>订阅和处理事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>UserInterface</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> UserInterface(Button button)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 订阅事件</span>
</span></span><span style=display:flex><span>        button.Clicked += OnButtonClicked;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 或者使用 Lambda表达式</span>
</span></span><span style=display:flex><span>        button.Clicked += (sender, e) =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#f1fa8c>&#34;Lambda：按钮被点击了！&#34;</span>);
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 事件处理方法 - 必须匹配 EventHandler 签名</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>void</span> OnButtonClicked(<span style=color:#8be9fd>object</span> sender, EventArgs e)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>&#34;收到按钮点击事件&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 可以通过 sender 参数知道哪个对象触发的事件</span>
</span></span><span style=display:flex><span>        Button clickedButton = sender <span style=color:#ff79c6>as</span> Button;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (clickedButton != <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#f1fa8c>$&#34;触发者：{clickedButton.GetType().Name}&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>var</span> button = <span style=color:#ff79c6>new</span> Button();
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>var</span> ui = <span style=color:#ff79c6>new</span> UserInterface(button);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        button.SimulateClicked();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=eventhandler-vs-eventhandlert><code>EventHandler</code> vs <code>EventHandler&lt;T></code></h3><table><thead><tr><th>特性</th><th><code>EventHandler</code></th><th><code>EventHandler&lt;TEventArgs></code></th></tr></thead><tbody><tr><td>定义</td><td><code>delegate void EventHandler(object sender, EventArgs e)</code></td><td><code>delegate void EventHandler&lt;T>(object sender, T e)</code></td></tr><tr><td>数据传递</td><td>只能使用<code>EventArgs.Empty</code></td><td>可以传递自定义事件数据</td></tr><tr><td>使用场景</td><td>不需要额外数据的事件</td><td>需要传递数据的事件</td></tr><tr><td>示例</td><td><code>event EventHandler Clicked</code></td><td><code>event EventHandler&lt;MouseEventArgs> MouseClick</code></td></tr></tbody></table><ul><li>使用<code>EventHandler</code>：事件本身的发生就是唯一信息</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler Initialized; <span style=color:#6272a4>// 初始化完成</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler Shutdown; <span style=color:#6272a4>// 关闭</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler StatusChanged; <span style=color:#6272a4>// 状态改变</span>
</span></span></code></pre></div><ul><li>使用<code>EventHandler&lt;T></code>：需要传递具体数据</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged; <span style=color:#6272a4>// 价格变化</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler&lt;ErrorEventArgs&gt; ErrorOccurred; <span style=color:#6272a4>// 错误发生</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler&lt;ProgressEventArgs&gt; ProgressUpdated; <span style=color:#6272a4>// 进度更新</span>
</span></span></code></pre></div><h2 id=eventargs><code>EventArgs</code></h2><p><code>EventArgs</code>是.NET类库中的一个类，位于<code>System</code>命名空间。它的核心作用是作为所有事件数据类的基类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 在.NET中的定义（简化）</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>EventArgs</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>readonly</span> EventArgs Empty;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> EventArgs();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>它本身不包含任何数据。它主要提供两种用途</p><ol><li>作为一个标记：表示这是一个用于事件参数的类型</li><li>作为基类：可以派生出自定义的事件数据类</li></ol><h3 id=存在意义>存在意义</h3><p>在没有<code>EventArgs</code>的情况下，如果想通过事件传递数据，可能会这样定义委托和事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 不推荐的做法：为每种数据都定义不同的委托</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>delegate</span> <span style=color:#ff79c6>void</span> ClickEventHandler(<span style=color:#8be9fd>int</span> x, <span style=color:#8be9fd>int</span> y, <span style=color:#8be9fd>string</span> buttonName);
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> ClickEventHandler Clicked;
</span></span></code></pre></div><p>这种做法的问题：</p><ul><li>缺乏统一性：每个事件的数据签名都不同，订阅者需要记住各种不同的参数顺序和类型</li><li>扩展性差：如果未来需要传递新的数据（比如时间戳），就必须改变委托签名，这会破坏所有现有的订阅者代码</li></ul><p><code>EventArgs</code>通过引入一个标准化的、可扩展的容器来解决这些问题</p><h3 id=使用场景>使用场景</h3><h4 id=1-不需要传递任何数据>1. 不需要传递任何数据</h4><p>当事件本身的发生就是唯一的信息时（例如，“任务完成”、“状态重置”），可以使用<code>EventArgs.Empty</code>。这是一个静态只读字段，表示一个空的、不包含任何数据的事件参数实例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Timer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 使用 EventHandler 而不是 EventHandler&lt;T&gt;，因为不需要自定义数据</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler Tick;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>protected</span> <span style=color:#ff79c6>virtual</span> <span style=color:#ff79c6>void</span> OnTick()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 使用 EventArgs.Empty</span>
</span></span><span style=display:flex><span>        Tick?.Invoke(<span style=color:#ff79c6>this</span>, EventArgs.Empty)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 订阅</span>
</span></span><span style=display:flex><span>timer.Tick += (sender, e) =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 这里的e就是EventArgs.Empty</span>
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#f1fa8c>&#34;Tick! 无需任何额外数据&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=2-需要传递自定义数据>2. 需要传递自定义数据</h4><p>这是<code>EventArgs</code>最主要的使用场景。需要创建一个继承自<code>EventArgs</code>的类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 自定义事件数据类</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>PriceChangedEventArgs</span> : EventArgs
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 通常属性是只读的，以保证在事件处理过程中的数据一致性</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>decimal</span> OldPrice { <span style=color:#ff79c6>get</span>; }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>decimal</span> NewPrice { <span style=color:#ff79c6>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> PriceChangedEventArgs(<span style=color:#8be9fd>decimal</span> oldPrice, <span style=color:#8be9fd>decimal</span> newPrice)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        OldPrice = oldPrice;
</span></span><span style=display:flex><span>        NewPrice = newPrice;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 在发布者类中使用</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Stock</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>decimal</span> _price;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 声明使用自定义 EventArgs 的事件</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>decimal</span> Price
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>get</span> =&gt; _price;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>set</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (_price == <span style=color:#ff79c6>value</span>) <span style=color:#ff79c6>return</span>; <span style=color:#6272a4>// 价格未变，直接返回</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>decimal</span> oldPrice = _price;
</span></span><span style=display:flex><span>            _price = <span style=color:#ff79c6>value</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 价格变化时，触发事件并传递旧价格和新价格</span>
</span></span><span style=display:flex><span>            OnPriceChanged(<span style=color:#ff79c6>new</span> PriceChangedEventArgs(oldPrice, _price));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>protected</span> <span style=color:#ff79c6>virtual</span> <span style=color:#ff79c6>void</span> OnPriceChanged(PriceChangedEventArgs e)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        PriceChanged?.Invoke(<span style=color:#ff79c6>this</span>, e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 订阅者</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>var</span> stock = <span style=color:#ff79c6>new</span> Stock();
</span></span><span style=display:flex><span>stock.PriceChanged += (sender, e) =&gt; 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#f1fa8c>$&#34;价格从 {e.OldPrice:C} 变为 {e.NewPrice:C}&#34;</span>); <span style=color:#6272a4>// e 是 PriceChangedEventArgs 类型</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 可以根据新旧价格做出不同反应，例如：</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (e.NewPrice &gt; e.OldPrice)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>&#34;股票上涨了！&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=设计eventargs类的最佳实践>设计EventArgs类的最佳实践</h3><ol><li>命名：类名应以<code>EventArgs</code>结尾，例如<code>MouseEventArgs</code>, <code>KeyPressEventArgs</code></li><li>不可变性：事件数据对象在创建后不应该被修改。因此，通常：<ul><li>通过构造函数来初始化所有数据</li><li>只提供只读属性（只有<code>get</code>访问器）来暴露数据</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>MailReceivedEventArgs</span> : EventArgs
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>string</span> From { <span style=color:#ff79c6>get</span>; }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>string</span> Subject { <span style=color:#ff79c6>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> MailReceivedEventArgs(<span style=color:#8be9fd>string</span> <span style=color:#ff79c6>from</span>, <span style=color:#8be9fd>string</span> subject)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        From = <span style=color:#ff79c6>from</span>;
</span></span><span style=display:flex><span>        Subject = subject;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>这确保了所有订阅者接收到的是同一时刻、同一状态的数据，避免了在事件处理过程中数据意外被修改的风险</li></ul><ol start=3><li>继承自 EventArgs：始终从<code>EventArgs</code>派生，这是.NET的通用约定</li><li>包含相关信息：只包含订阅者处理该事件时真正需要的数据。不要传递整个发布者对象，而是通过<code>sender</code>参数来访问发布者</li></ol><h2 id=sender参数><code>sender</code>参数</h2><p>在事件处理器中，除了<code>EventArgs e</code>，还有一个<code>object sender</code>参数。它是对触发事件的发布者对象的引用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>stock.PriceChanged += (sender, e) =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 可以将 sender 转换回具体的类型，以访问其成员</span>
</span></span><span style=display:flex><span>    Stock stockWhichChanged = sender <span style=color:#ff79c6>as</span> Stock;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (stockWhichChanged != <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#f1fa8c>$&#34;当前股票价格是：{stockWhichChanged.Price}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 同时使用 sender 和 e</span>
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#f1fa8c>$&#34;变化详情：{e.OldPrice} -&gt; {e.NewPrice}&#34;</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>使用建议：</p><ul><li>优先使用<code>e</code>来获取数据，因为它就是为此目的设计的</li><li>只有当事件数据<code>e</code>中没有包含需要的、属于发布者的其他信息时，才使用<code>sender</code>并对其进行类型转换</li></ul><h2 id=invoke><code>?.Invoke()</code></h2><p><code>?.Invoke()</code>主要用于安全地调用委托和事件，它实际上是两个操作的组合：</p><ul><li><code>?.</code>：Null条件操作符（Null-conditional operator），也叫Elvis操作符</li><li><code>.Invoke()</code>：委托的调用方法</li></ul><p>组合在一起，它的作用是：如果左边的对象不为null，就调用其Invoke方法；如果为null，就什么都不做，返回null</p><h3 id=存在意义-1>存在意义</h3><p><strong>传统方式的问题</strong><br>在C# 6.0 引入<code>?.</code>操作符之前，这样触发事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Button</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler Clicked;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>protected</span> <span style=color:#ff79c6>virtual</span> <span style=color:#ff79c6>void</span> OnClicked()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 传统方式 - 存在竞态条件风险</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (Clicked != <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Clicked(<span style=color:#ff79c6>this</span>, EventArgs.Empty);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>问题：在多线程环境下，可能存在竞态条件</p><ol><li>线程A检查<code>Clicked != null</code> -> 结果为 true</li><li>线程B取消了事件订阅，设置<code>Clicked = null</code></li><li>线程A执行<code>Clicked(this, EventArgs.Empty)</code> -> 抛出<code>NullReferenceException</code></li></ol><p><strong>解决方案1：使用局部变量（C# 6.0之前）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>protected</span> <span style=color:#ff79c6>virtual</span> <span style=color:#ff79c6>void</span> OnClicked()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 将委托复制到局部变量</span>
</span></span><span style=display:flex><span>    EventHandler handler = Clicked;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (handler != <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        handler(<span style=color:#ff79c6>this</span>, EventArgs.Empty);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>原理：委托是不可变的，<code>+=</code>和<code>-=</code>操作实际上回创建新的委托实例。将事件复制到局部变量后，即使其他线程修改了原始事件，局部变量仍然指向原来的委托链</p><p><strong>解决方案2：使用<code>?.Invoke()</code>（C# 6.0+）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>protected</span> <span style=color:#ff79c6>virtual</span> <span style=color:#ff79c6>void</span> OnClicked()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 现代方式 - 线程安全且简洁</span>
</span></span><span style=display:flex><span>    Clicked?.Invoke(<span style=color:#ff79c6>this</span>, EventArgs.Empty);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这行代码等价于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>var</span> handler = Clicked;
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (handler != <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    handler.Invoke(<span style=color:#ff79c6>this</span>, EventArgs.Empty);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=工作原理>工作原理</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#6272a4>// 这行代码：</span>
</span></span><span style=display:flex><span>Clicked?.Invoke(<span style=color:#ff79c6>this</span>, EvnetArgs.Empty);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 实际上被编译器转换为</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>var</span> temp = Clicked;
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (temp != <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    temp.Invoke(<span style=color:#ff79c6>this</span>, EventArgs.Empty);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>关键点：</p><ol><li>线程安全：先将事件引用复制到临时变量</li><li>空值检查：检查临时变量是否为null</li><li>安全调用：只有不为null时才调用Invoke</li></ol><h2 id=为什么使用事件而不是简单的委托>为什么使用事件而不是简单的委托</h2><p>事件本质上是委托的安全封装</p><ul><li>封装性<ul><li>委托（public）：订阅者可以使用<code>=</code>操作符，这会覆盖掉之前所有的订阅</li><li>事件（public）：订阅者只能使用<code>+=</code>和<code>-=</code>来添加或移除自己的处理器，无法覆盖其他人的订阅，也无法直接触发事件。事件在类外部只能出现在<code>+=</code>和<code>-=</code>左边</li></ul></li></ul><p>示例对比</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>PublisherWithDelegate</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> Action PublicDelegate; <span style=color:#6272a4>// 公共委托</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> Action PublicEvent; <span style=color:#6272a4>// 公共事件</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> Test()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 在类内部，两者都可以调用</span>
</span></span><span style=display:flex><span>        PublicDelegate?.Invoke();
</span></span><span style=display:flex><span>        PublicEvent?.Invoke();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 在另一个类中</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>var</span> pub = <span style=color:#ff79c6>new</span> PublisherWithDelegate()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 委托的危险操作</span>
</span></span><span style=display:flex><span>pub.PublicDelegate = () =&gt; Console.WriteLine(<span style=color:#f1fa8c>&#34;Handler 1&#34;</span>); <span style=color:#6272a4>// 直接赋值，清空其他订阅</span>
</span></span><span style=display:flex><span>pub.PublicDelegate += () =&gt; Console.WriteLine(<span style=color:#f1fa8c>&#34;Handler 2&#34;</span>);
</span></span><span style=display:flex><span>pub.PublicDelegate(); <span style=color:#6272a4>// 外部可以直接触发！这可能不是我们想要的</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 事件的安全操作</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// pub.PublicEvent = ... // 错误！编译不通过，不能直接赋值</span>
</span></span><span style=display:flex><span>pub.PublicEvent += () =&gt; Console.WriteLine(<span style=color:#f1fa8c>&#34;EventHandler 1&#34;</span>);
</span></span><span style=display:flex><span>pub.PublicEvent += () =&gt; Console.WriteLine(<span style=color:#f1fa8c>&#34;EventHandler 2&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// pub.PublicEvent(); // 错误！编译不通过，外部不能触发事件</span>
</span></span></code></pre></div><p><code>event</code>实际上是编译器在委托基础上生成了一组<code>add</code>/<code>remove</code>访问器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> EventHandler Clicked;
</span></span><span style=display:flex><span><span style=color:#6272a4>// 编译后大致等于</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> EventHandler _Clicked;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> add_Clicked(EventHandler <span style=color:#ff79c6>value</span>) =&gt; _Clicked += <span style=color:#ff79c6>value</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> remove_Clicked(EventHandler <span style=color:#ff79c6>value</span>) =&gt; _Clicked -= <span style=color:#ff79c6>value</span>;
</span></span></code></pre></div><h2 id=现代语法与高级技巧>现代语法与高级技巧</h2><h3 id=lambda表达式订阅>Lambda表达式订阅</h3><p>传统订阅事件时，必须写完整方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>button.Clicked += OnButtonClicked;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>void</span> OnButtonClicked(<span style=color:#8be9fd>object</span> sender, EventArgs e)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#f1fa8c>&#34;按钮被点击&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现代C#提供Lambda表达式，直接内联事件处理逻辑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>button.Clicked += (_, e) =&gt; Console.WriteLine(<span style=color:#f1fa8c>&#34;Lambda: 按钮被点击！&#34;</span>);
</span></span></code></pre></div><p>特点：</p><ul><li><code>_</code>表示忽略<code>sender</code>参数（C#9.0引入的弃元变量discard）</li><li>适用于小型、一次性逻辑</li><li>缺点是无法取消订阅，因为Lambda是匿名的</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>button.Clicked -= (_, e) =&gt; Console.WriteLine(<span style=color:#f1fa8c>&#34;...&#34;</span>); <span style=color:#6272a4>// ❌ 无法解除，会生成不同的匿名类</span>
</span></span></code></pre></div><p>如果可能需要取消订阅，应保留委托引用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>EventHandler handler = (_, e) =&gt; Console.WriteLine(<span style=color:#f1fa8c>&#34;Lambda：按钮被点击！&#34;</span>);
</span></span><span style=display:flex><span>button.Clicked += handler;
</span></span><span style=display:flex><span>button.Clicked -= handler; <span style=color:#6272a4>// 可以正确取消</span>
</span></span></code></pre></div><h3 id=轻量事件使用action或func替代标准模式>轻量事件：使用<code>Action</code>或<code>Func</code>替代标准模式</h3><p>当在引擎、工具或内部系统中实现简化事件机制时，不一定非要用<code>EventHandler</code><br>C#允许使用任意委托类型作为事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> Action&lt;<span style=color:#8be9fd>int</span>&gt; HealthChanged; <span style=color:#6272a4>// 比 EventHandler&lt;T&gt; 更轻</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>protected</span> <span style=color:#ff79c6>void</span> OnHealthChanged(<span style=color:#8be9fd>int</span> hp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    HealthChanged?.Invoke(hp);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>优点：</p><ul><li>简洁、高性能（少一层封装）</li><li>对于频繁触发的小事件（如游戏中帧级回调）更高效</li></ul><p>缺点：</p><ul><li>失去了统一签名（<code>object sender, EventArgs e</code>）的兼容性</li><li>不适合公开API或框架接口，建议仅用于内部模块通信</li></ul><h3 id=线程安全触发invoke的底层原理>线程安全触发：<code>?.Invoke()</code>的底层原理</h3><p>C# 6 引入的Null条件操作符简化了事件触发</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Clicked?.Invoke(<span style=color:#ff79c6>this</span>, EventArgs.Empty);
</span></span></code></pre></div><p>编译器会自动生成线程安全代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>var</span> temp = Clicked;
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (temp != <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>    temp.Invoke(<span style=color:#ff79c6>this</span>, EventArgs.Empty);
</span></span></code></pre></div><p>核心点：</p><ul><li>委托是不可变对象，<code>+=</code>或<code>-=</code>实际会创建新的委托实例；</li><li>将事件复制到局部变量后，即使别的线程取消订阅，也不会影响当前触发</li><li>因此这是事件触发的推荐写法</li></ul><h3 id=弱事件weakeventmanager>弱事件（WeakEventManager）</h3><p>强引用事件的风险：<br>订阅者（Subscriber）被发布者（Publisher）强引用，若发布者生命周期更长，则订阅者无法被GC释放，造成内存泄露</p><p><strong>解决方案：弱事件</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Windows;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>WeakEventManager&lt;Button, EventArgs&gt;.AddHandler(button, <span style=color:#f1fa8c>&#34;Clicked&#34;</span>, OnButtonClicked);
</span></span><span style=display:flex><span>WeakEventManager&lt;Button, EventArgs&gt;.RemoveHandler(button, <span style=color:#f1fa8c>&#34;Clicked&#34;</span>, OnButtonClicked);
</span></span></code></pre></div><p>适用场景：</p><ul><li>WPF、MVVM、长期存在的全局事件系统</li><li>游戏/编辑器中持久对象监听短期对象事件</li><li>日志、状态广播系统</li></ul><p>原理：</p><ul><li><code>WeakEventManager</code>使用弱引用（<code>WeakReference</code>）保存订阅者</li><li>当订阅者被GC回收时，事件会自动移除，不阻止释放</li><li>代价是触发时略有性能开销</li></ul><h3 id=反射访问事件高级元编程>反射访问事件（高级元编程）</h3><p>可以通过反射读取类型中声明的所有事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>var</span> events = <span style=color:#ff79c6>typeof</span>(Button).GetEvents();
</span></span><span style=display:flex><span><span style=color:#ff79c6>foreach</span> (<span style=color:#8be9fd>var</span> e <span style=color:#ff79c6>in</span> events)
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#f1fa8c>$&#34;事件名：{e.Name}，委托类型：{e.EventHandlerType}&#34;</span>);
</span></span></code></pre></div><p>可以用于</p><ul><li>自动绑定事件（例如UI自动注册）</li><li>事件系统调试与日志</li><li>框架级信号分发（如Unity的Editor工具）</li></ul><p>不过</p><ul><li>无法直接通过反射触发事件（因为<code>event</code>只公开<code>add/remove</code>访问器）</li><li>若缺失需要触发，可通过<code>FieldInfo</code>获取backing field（不推荐，仅限内部框架使用）</li></ul><h3 id=异步事件事件--asyncawait>异步事件：事件 + async/await</h3><p>事件处理器可以是异步方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>event</span> Func&lt;<span style=color:#8be9fd>object</span>, EventArgs, Task&gt; DataLoaded;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>protected</span> <span style=color:#ff79c6>virtual</span> <span style=color:#8be9fd;font-style:italic>async</span> Task OnDataLoadedAsync()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (DataLoaded != <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>await</span> DataLoaded.Invoke(<span style=color:#ff79c6>this</span>, EventArgs.Empty);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这允许订阅者异步执行逻辑（例如网络请求、IO操作）而不阻塞主线程<br>但要注意：</p><ul><li>所有订阅方法都会被await；若其中任何一个耗时，发布者会等待全部完成</li><li>若想并发执行所有订阅，可用<code>Task.WhenAll</code></li></ul><h2 id=最佳实践和注意事项>最佳实践和注意事项</h2><ol><li>命名约定：<ul><li>事件名使用PasalCase，如<code>Clicked</code>,<code>ValueChanged</code></li><li>事件处理器方法名通常为<code>On</code>+事件名，如<code>OnButtonClicked</code></li><li>触发事件的方法名为<code>On</code>+事件名，如<code>OnClicked</code></li></ul></li><li>线程安全：始终使用<code>?.Invoke()</code>或局部变量来触发事件，以防止竞态条件</li><li>及时取消订阅：如果订阅者的生命周期短于发布者，务必在订阅者销毁前取消订阅（例如在<code>Dispose</code>方法中）。否则，发布者会持有对订阅者的引用，导致内存泄露，因为垃圾回收器无法回收仍在被引用的对象</li><li>事件数据不可变性：<code>EventArgs</code>派生类中的属性应该是只读的，以防止订阅者在事件处理过程中修改数据，影响其他订阅者</li></ol></div><nav class=post-nav><a href=/dotnetandwindows/log/delegate/ class=hover:underline>pre: Delegate</a>
<a href=/dotnetandwindows/log/exception/ class=hover:underline>next: Exception</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#核心概念>核心概念</a></li><li><a href=#事件的五个组成部分>事件的五个组成部分</a></li><li><a href=#声明和使用事件的完整步骤>声明和使用事件的完整步骤</a></li><li><a href=#eventhandler><code>EventHandler</code></a><ul><li><a href=#存在意义统一的事件模式>存在意义：统一的事件模式</a></li><li><a href=#基本用法>基本用法</a></li><li><a href=#eventhandler-vs-eventhandlert><code>EventHandler</code> vs <code>EventHandler&lt;T></code></a></li></ul></li><li><a href=#eventargs><code>EventArgs</code></a><ul><li><a href=#存在意义>存在意义</a></li><li><a href=#使用场景>使用场景</a><ul><li><a href=#1-不需要传递任何数据>1. 不需要传递任何数据</a></li><li><a href=#2-需要传递自定义数据>2. 需要传递自定义数据</a></li></ul></li><li><a href=#设计eventargs类的最佳实践>设计EventArgs类的最佳实践</a></li></ul></li><li><a href=#sender参数><code>sender</code>参数</a></li><li><a href=#invoke><code>?.Invoke()</code></a><ul><li><a href=#存在意义-1>存在意义</a></li><li><a href=#工作原理>工作原理</a></li></ul></li><li><a href=#为什么使用事件而不是简单的委托>为什么使用事件而不是简单的委托</a></li><li><a href=#现代语法与高级技巧>现代语法与高级技巧</a><ul><li><a href=#lambda表达式订阅>Lambda表达式订阅</a></li><li><a href=#轻量事件使用action或func替代标准模式>轻量事件：使用<code>Action</code>或<code>Func</code>替代标准模式</a></li><li><a href=#线程安全触发invoke的底层原理>线程安全触发：<code>?.Invoke()</code>的底层原理</a></li><li><a href=#弱事件weakeventmanager>弱事件（WeakEventManager）</a></li><li><a href=#反射访问事件高级元编程>反射访问事件（高级元编程）</a></li><li><a href=#异步事件事件--asyncawait>异步事件：事件 + async/await</a></li></ul></li><li><a href=#最佳实践和注意事项>最佳实践和注意事项</a></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>