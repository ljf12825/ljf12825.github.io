<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Delegate</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/log/>Log</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Delegate<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><p>委托是类型安全的函数指针——它把方法当作值来传递、存储、组合和调用<br>可以把“要做的动作”抽象成一个委托类型，然后把不同的方法绑定到它上面</p><h2 id=声明与使用>声明与使用</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> DelegateTest(<span style=color:#66d9ef>int</span> x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FuncLib</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Foo(<span style=color:#66d9ef>int</span> x) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;foo&#34;</span> + x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Bar(<span style=color:#66d9ef>int</span> x) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;bar&#34;</span> + x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Func1(<span style=color:#66d9ef>int</span> x) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;func1&#34;</span> + x);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Func_inner(<span style=color:#66d9ef>int</span> x) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;funcinner&#34;</span> + x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        FuncLib funclib = <span style=color:#66d9ef>new</span>();
</span></span><span style=display:flex><span>        DelegateTest d = FuncLib.Foo;
</span></span><span style=display:flex><span>        d += FuncLib.Bar;
</span></span><span style=display:flex><span>        d += funclib.Func1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        d(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        DelegateTest dd = x =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;inner&#34;</span> + x);
</span></span><span style=display:flex><span>        dd(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>委托绑定的函数具有以下约束</p><ul><li>访问修饰符：绑定额方法必须对当前上下文可见</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> PrivateMethod(<span style=color:#66d9ef>int</span> x) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;private&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> ProtectedMethod(<span style=color:#66d9ef>int</span> x) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;protected&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>void</span> InternalMethod(<span style=color:#66d9ef>int</span> x) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;internal&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> PublicMethod(<span style=color:#66d9ef>int</span> x) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;public&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MyClass obj = <span style=color:#66d9ef>new</span> MyClass();
</span></span><span style=display:flex><span>        DelegateTest d;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        d = obj.PublicMethod; <span style=color:#75715e>// 可以访问</span>
</span></span><span style=display:flex><span>        d = obj.InternalMethod; <span style=color:#75715e>// 同程序集可以访问</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// d = obj.PrivateMethod; // 不可访问</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// d = obj.ProtectedMethod; // 不可访问</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>静态上下文：静态方法中不能直接绑定实例方法</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InstanceMethod(<span style=color:#66d9ef>int</span> x) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;instance&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> StaticMethod(<span style=color:#66d9ef>int</span> x) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;static&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    DelegateTest instanceDelegate = InstanceMethod; <span style=color:#75715e>// 实例字段绑定实例方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>作用域：委托可以绑定局部方法，但会延长其生命周期</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 局部方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> LocalMethod(<span style=color:#66d9ef>int</span> x) =&gt; Console.WriteLine(<span style=color:#e6db74>$&#34;local: {x}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    DelegateTest d = LocalMethod; <span style=color:#75715e>// 可以绑定局部方法</span>
</span></span><span style=display:flex><span>    d(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 注意：委托会延长局部方法的生命周期</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 即使退出Main方法，LocalMethod也不会被立即回收</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>对象生命周期：绑定实例方法时，要确保对象实例不会被意外回收</li><li>封装性：即使通过委托，也不能绕过类的访问控制规则</li></ul><h2 id=常见内置委托>常见内置委托</h2><p>不用显式声明类型时常用</p><ul><li><code>Action&lt;T1,...></code>：返回<code>void</code>，可以有0~16个参数，适合用在回调函数，事件响应，不关心返回值</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Action</span>
</span></span><span style=display:flex><span>Action action1 = () =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Hello, World!&#34;</span>);
</span></span><span style=display:flex><span>action1();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Action&lt;T&gt;</span>
</span></span><span style=display:flex><span>Action&lt;<span style=color:#66d9ef>string</span>&gt; action2 = (name) =&gt; Console.WriteLine(<span style=color:#e6db74>$&#34;Hello, {name}!&#34;</span>);
</span></span><span style=display:flex><span>action2(<span style=color:#e6db74>&#34;Alice&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Action&lt;T1, T2&gt;</span>
</span></span><span style=display:flex><span>Action&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>int</span>&gt; action3 = (name, age) =&gt; Console.WriteLine(<span style=color:#e6db74>$&#34;{name} is {age} years old&#34;</span>);
</span></span><span style=display:flex><span>action3(<span style=color:#e6db74>&#34;Bob&#34;</span>, <span style=color:#ae81ff>25</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 多播</span>
</span></span><span style=display:flex><span>Action multiAction = () =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;First action&#34;</span>);
</span></span><span style=display:flex><span>multiAction += () =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Second action&#34;</span>);
</span></span><span style=display:flex><span>multiAction += () =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Third action&#34;</span>);
</span></span><span style=display:flex><span>multiAction();
</span></span></code></pre></div><ul><li><code>Func&lt;T1,...,TReturn></code>：返回值类型放最后，可以有0~16个参数，适合用在数据转换、计算、延迟计算，组合函数逻辑</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Func&lt;TReturn&gt;</span>
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>&gt; func1 = () =&gt; <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;Result: {func1()}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Func&lt;T, TReturn&gt;</span>
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>string</span>&gt; func2 = (x) =&gt; <span style=color:#e6db74>$&#34;Number: {x}&#34;</span>;
</span></span><span style=display:flex><span>Console.WriteLine(func2(<span style=color:#ae81ff>100</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Func&lt;T1, T2, TReturn&gt;</span>
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; func3 = (a, b) =&gt; a + b;
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;Sum: {func3(5, 3)}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 复杂示例：字符串处理</span>
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>string</span>&gt; formatName = (firstName, lastName) =&gt; <span style=color:#e6db74>$&#34;{lastName}, {firstName}&#34;</span>;
</span></span><span style=display:flex><span>Console.WriteLine(formatName(<span style=color:#e6db74>&#34;John&#34;</span>, <span style=color:#e6db74>&#34;Doe&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 多播（只返回最后一个方法的返回值）</span>
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>&gt; multiFunc = () =&gt; { Console.WriteLine(<span style=color:#e6db74>&#34;First&#34;</span>); <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; };
</span></span><span style=display:flex><span>multiFunc += () =&gt; { Console.WriteLine(<span style=color:#e6db74>&#34;Second&#34;</span>); <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> result = multiFunc(); <span style=color:#75715e>// 输出：First, Second, 返回2</span>
</span></span></code></pre></div><ul><li><code>Predicate&lt;T></code>：<code>Func&lt;T,bool></code>的特例，表示“判定”函数</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Predicate&lt;T&gt;</span>
</span></span><span style=display:flex><span>Predicate&lt;<span style=color:#66d9ef>int</span>&gt; isEven = (x) =&gt; x % <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;Is 10 even? {isEven(10)}&#34;</span>);
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;Is 7 even? {isEven(7)}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 字符串判断</span>
</span></span><span style=display:flex><span>Predicate&lt;<span style=color:#66d9ef>string</span>&gt; isLongEnough = (s) =&gt; s.Length &gt;= <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;Is &#39;hello&#39; long enough? {isLongEnough(&#34;</span>hello<span style=color:#e6db74>&#34;)}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在List中使用Predicate</span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; numbers = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt; { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用Predicate查找所有偶数</span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; evenNumber = numbers.FindAll(isEven);
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>&#34;Even numbers: &#34;</span> + <span style=color:#66d9ef>string</span>.Join(<span style=color:#e6db74>&#34;, &#34;</span>, evenNumber));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用匿名方法</span>
</span></span><span style=display:flex><span>Predicate&lt;<span style=color:#66d9ef>int</span>&gt; isGreaterThan5 = (x) =&gt; x &gt; <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; largeNumbers = numbers.FindAll(isGreaterThan5);
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>&#34;Numbers &gt; 5: &#34;</span> + <span style=color:#66d9ef>string</span>.Join (<span style=color:#e6db74>&#34;, &#34;</span>, largeNumbers));
</span></span></code></pre></div><ul><li><code>Comparison&lt;T></code>：比较委托器，常用于排序</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Comparison</span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>string</span>&gt; names = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>string</span>&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;John&#34;</span>, <span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#e6db74>&#34;Bob&#34;</span>, <span style=color:#e6db74>&#34;Zoe&#34;</span>, <span style=color:#e6db74>&#34;Mike&#34;</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Comparison&lt;T&gt;</span>
</span></span><span style=display:flex><span>Comparison&lt;<span style=color:#66d9ef>string</span>&gt; byLength = (x, y) =&gt; x.Length.CompareTo(y.Length);
</span></span><span style=display:flex><span>Comparison&lt;<span style=color:#66d9ef>string</span>&gt; alphabetically = (x, y) =&gt; <span style=color:#66d9ef>string</span>.Compare(x, y);
</span></span><span style=display:flex><span>Comparison&lt;<span style=color:#66d9ef>string</span>&gt; byLengthDesc = (x, y) =&gt; y.Length.CompareTo(x.Length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 按长度排序</span>
</span></span><span style=display:flex><span>names.Sort(byLength);
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>&#34;By length: &#34;</span> + <span style=color:#66d9ef>string</span>.Join(<span style=color:#e6db74>&#34;, &#34;</span>, names));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 按字母顺序排序</span>
</span></span><span style=display:flex><span>names.Sort(alphabetically);
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>&#34;Alphabetically: &#34;</span> + <span style=color:#66d9ef>string</span>.Join(<span style=color:#e6db74>&#34;, &#34;</span>, names));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 按长度降序排序</span>
</span></span><span style=display:flex><span>names.Sort(byLengthDesc);
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>&#34;By length desc: &#34;</span> + <span style=color:#66d9ef>string</span>.Join(<span style=color:#e6db74>&#34;, &#34;</span>, names));
</span></span></code></pre></div><ul><li><code>Converter&lt;TInput, TOutput></code>：转换器委托，把一个对象转换成另一个对象</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Converter</span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; numbers_ = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt; { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Converter&lt;TInput, TOutput&gt;</span>
</span></span><span style=display:flex><span>Converter&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>string</span>&gt; intToString = (x) =&gt; <span style=color:#e6db74>$&#34;Number: {x}&#34;</span>;
</span></span><span style=display:flex><span>Converter&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>double</span>&gt; intToDouble = (x) =&gt; x * <span style=color:#ae81ff>1.5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 转换整个列表</span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>string</span>&gt; stringNumbers = numbers_.ConvertAll(intToString);
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>double</span>&gt; doubleNumbers = numbers_.ConvertAll(intToDouble);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 复杂转换示例</span>
</span></span><span style=display:flex><span>Converter&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>int</span>&gt; parseToInt = (s) =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>int</span>.TryParse(s, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int</span> result))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>string</span>&gt; stringValues = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>string</span>&gt; { <span style=color:#e6db74>&#34;10&#34;</span>, <span style=color:#e6db74>&#34;20&#34;</span>, <span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;30&#34;</span> };
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; parsedNumbers = stringValues.ConvertAll(parseToInt);
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>&#34;Parsed numbers: &#34;</span> + <span style=color:#66d9ef>string</span>.Join(<span style=color:#e6db74>&#34;, &#34;</span>, parsedNumbers));
</span></span></code></pre></div><h2 id=绑定与多播>绑定与多播</h2><h3 id=绑定binding>绑定(Binding)</h3><p>绑定就是将具体的方法与委托实例关联起来的过程</p><ol><li>直接绑定单个方法</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> Show(<span style=color:#66d9ef>string</span> msg) =&gt; Console.WriteLine(msg);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MyDelegate del = Show; <span style=color:#75715e>// 绑定</span>
</span></span><span style=display:flex><span>del(<span style=color:#e6db74>&#34;Hello&#34;</span>); <span style=color:#75715e>// 调用</span>
</span></span></code></pre></div><ul><li>绑定时编译器会检查签名是否匹配</li><li>实际上这会生成一个委托对象，内部保存着方法的引用（MethodInfo）和目标对象（如果是实例方法）</li></ul><ol start=2><li>绑定静态方法</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Print(<span style=color:#66d9ef>string</span> msg) =&gt; Console.WriteLine(msg);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MyDelegate del = Print;
</span></span><span style=display:flex><span>del(<span style=color:#e6db74>&#34;Static method&#34;</span>);
</span></span></code></pre></div><p>静态方法没有目标对象，委托内部的<code>Target</code>字段为<code>null</code></p><ol start=3><li>绑定实例方法</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> obj = <span style=color:#66d9ef>new</span> Program();
</span></span><span style=display:flex><span>MyDelegate del = obj.Show;
</span></span></code></pre></div><p>实例方法绑定时，委托内部保存着</p><ul><li>方法指针</li><li><code>Target</code>指向这个<code>obj</code></li></ul><p>调用时就像<code>obj.Show(msg)</code>一样执行</p><h3 id=多播multicast>多播（Multicast）</h3><p>一个委托实例可以绑定多个方法，调用时会按顺序执行所有方法</p><ol><li>使用<code>+</code>或<code>+=</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> A(<span style=color:#66d9ef>string</span> msg) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;A: &#34;</span> + msg);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> B(<span style=color:#66d9ef>string</span> msg) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;B: &#34;</span> + msg);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MyDelegate del = A;
</span></span><span style=display:flex><span>del += B; <span style=color:#75715e>// 多播绑定</span>
</span></span><span style=display:flex><span>del(<span style=color:#e6db74>&#34;Hi&#34;</span>);
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>A: Hi
</span></span><span style=display:flex><span>B: Hi
</span></span></code></pre></div><ol start=2><li>使用<code>-=</code>取消绑定</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>del -= A;
</span></span><span style=display:flex><span>del(<span style=color:#e6db74>&#34;Hi again&#34;</span>);
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>B: Hi again
</span></span></code></pre></div><p>多播委托内部维护一个调用列表（Invocation List）<br>可以通过</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Delegate[] list = del.GetInvocationList();
</span></span></code></pre></div><p>来查看有哪些函数被绑定<br>当执行<code>del()</code>时，运行时会按列表顺序依次调用每个目标函数</p><p>对于多播委托</p><ul><li>只有最后一个方法的返回值会被保留</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>int</span> Calc();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Calc c = () =&gt; <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>c += () =&gt; <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> result = c(); <span style=color:#75715e>// result == 2</span>
</span></span></code></pre></div><ul><li>如果中间某个方法抛异常，后续方法不会执行，异常会直接抛出</li><li>如果委托使用<code>=</code>绑定过一个方法，然后用<code>+=</code>进行多播绑定，随后再次<code>=</code>绑定，则之前的绑定会被覆盖掉</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>int</span> Func();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Func f = () =&gt; Console.WriteLine(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>f += () =&gt; Console.WriteLine(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>f = () Console.WriteLine(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>f(); <span style=color:#75715e>// 3</span>
</span></span></code></pre></div><h2 id=委托的底层>委托的底层</h2><p>委托在C#中本质上就是一个类<br>它并不是“语法糖”或“函数指针”，而是一个真正的类实例————一个封装了“函数入口 + 调用目标”的对象<br>但这东西的地位很特殊：</p><ul><li>它是CLR层面专门支持的类</li><li>编译器和运行时对它有特殊处理</li><li>它是C#函数式能力的底层基石（包括事件、Lambda、LINQ都靠它）</li></ul><h3 id=委托的编译后结构>委托的编译后结构</h3><p>源代码 vs 编译后代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 源代码</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> MyDelegate(<span style=color:#66d9ef>string</span> message);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 编译后实际上会生成一个完整的类</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyDelegate</span> : System.MulticastDelegate
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 构造函数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> MyDelegate(<span style=color:#66d9ef>object</span> target, IntPtr methodPtr); <span style=color:#75715e>// 构造函数的参数决定其可以接受任意类型，任意类型函数</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 调用方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Invoke(<span style=color:#66d9ef>string</span> message);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 异步调用方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> IAsyncResult BeginInvoke(<span style=color:#66d9ef>string</span> message, AsyncCallback callback, <span style=color:#66d9ef>object</span> state);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> EndInvoke(IAsyncResult result);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这说明</p><ul><li><code>delegate</code>语法其实是一个类型定义器</li><li>每定义一个委托类型，编译器就生成一个继承自<code>MulticastDelegate</code>的密封类</li><li>委托变量就是这个类的实例</li><li><code>Invoke</code>是真正的调用方法（编译器自动插入调用）</li></ul><p>虽然语法上看是<code>class</code>，但它不是普通的用户类，而是CLR特殊支持类型<br><code>Delegate</code>和<code>MulticastDelegate</code>是由运行时（Runtime）内部硬编码逻辑管理的<br>也就是说：编译器和CLR一起为委托类型生成了“隐藏的行为”</p><p>看起来很普通，但关键在于</p><ul><li><code>MyDelegate</code>的构造函数、<code>Invoke</code>、<code>BeginInvoke</code>、<code>EndInvoke</code>都是由CLR自动充填行为</li><li>它的构造器能接受任意目标对象和方法指针</li><li>CLR在创建时会验证方法签名与委托签名兼容</li><li>一旦兼容，就能把这个方法“封装”为一个委托实例</li></ul><h3 id=构造过程的底层逻辑>构造过程的底层逻辑</h3><p>当写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>MyDelegate d = <span style=color:#66d9ef>new</span> MyDelegate(SomeMethod);
</span></span></code></pre></div><p>编译器其实转成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>d = (MyDelegate)Delegate.CreateDelegate(<span style=color:#66d9ef>typeof</span>(MyDelegate), <span style=color:#66d9ef>null</span>, methodInfo);
</span></span></code></pre></div><p>而<code>Delegate.CreateDelegate</code>的底层逻辑是</p><ol><li>检查方法签名是否和<code>MyDelegate</code>匹配</li><li>拿到该方法的入口地址（<code>IntPtr methodPtr</code>）</li><li>如果是实例方法，记录目标对象（<code>target</code>）</li><li>创建一个委托对象</li><li>把<code>_methodPtr</code>和<code>_target</code>写进去</li><li>返回一个完整可调用的委托实例</li></ol><p>所以每一个委托实例，本质上就是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>{
</span></span><span style=display:flex><span>    _target = 对象指针（或null）
</span></span><span style=display:flex><span>    _methodPtr = 方法JIT后入口地址
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>只要这个方法签名匹配，CLR就能让它调用起来</p><p>这其实跟C++的函数指针没本质区别<br>可以这样类比</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>void</span> (<span style=color:#f92672>*</span>MyDelegate)(<span style=color:#66d9ef>int</span>);
</span></span></code></pre></div><p>这个函数指针可以指向任意<code>void f(int)</code>的函数，因为签名匹配</p><p>C#委托就是它的“安全封装版”</p><ul><li>增加了类型信息</li><li>增加了目标对象引用</li><li>增加了GC跟踪</li><li>增加了多播支持</li><li>增加了JIT校验</li><li>增加了调用时异常安全</li></ul><blockquote><p>C#委托就是类型安全的函数指针对象</p></blockquote><h3 id=委托的内存布局>委托的内存布局</h3><p>委托对象的内部结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Delegate</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 三个核心字段</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>object</span> _target; <span style=color:#75715e>// 方法所属的对象实例（静态方法时为null）</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> IntPtr _methodPtr; <span style=color:#75715e>// 方法指针</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> IntPtr _invocationList; <span style=color:#75715e>// 多播委托的调用列表</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>C#的<code>MulticastDelegate</code>正是基于<code>_invocationList</code>实现多播</p><p>实际内存示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> StaticMethod(<span style=color:#66d9ef>string</span> msg) { }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> InstanceMethod(<span style=color:#66d9ef>string</span> msg) { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 单播委托</span>
</span></span><span style=display:flex><span>        MyDelegate del1 = StaticMethod;
</span></span><span style=display:flex><span>        MyDelegate del2 = <span style=color:#66d9ef>new</span> Program().InstanceMethod;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 内存结构</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// del1: _target = null, _methodPtr = StaticMethod地址</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// del2: _target = Program实例，_methodPtr = InstanceMethod地址</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=多播委托的底层实现>多播委托的底层实现</h3><p>调用链的存储方式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    MyDelegate multicast = Method1;
</span></span><span style=display:flex><span>    multicast += Method2;
</span></span><span style=display:flex><span>    multicast += Method3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 底层实现</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// multicast._invocationList 指向一个数组</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// [Delegate(Method1), Delegate(Method2), Delegate(Method3)]</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>多播委托的调用过程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 伪代码展示多播委托的Invoke实现</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Invoke(<span style=color:#66d9ef>string</span> message)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (_invocationList == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 单播委托：直接调用</span>
</span></span><span style=display:flex><span>        _methodPtr.Invoke(_target, message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 多播委托：遍历调用列表</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> delegates = (Delegate[])_invocationList;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> del <span style=color:#66d9ef>in</span> delegates)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            del.Invoke(message);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=通过ildasm查看实际il代码>通过ILDASM查看实际IL代码</h3><p>源代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> MyDelegate(<span style=color:#66d9ef>string</span> msg);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Method1(<span style=color:#66d9ef>string</span> msg) { }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Method2(<span style=color:#66d9ef>string</span> msg) { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MyDelegate del = Method1;
</span></span><span style=display:flex><span>        del += Method2;
</span></span><span style=display:flex><span>        del(<span style=color:#e6db74>&#34;test&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对应的IL代码（简化）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 委托实例化
</span></span><span style=display:flex><span>IL_0000: ldnull
</span></span><span style=display:flex><span>IL_0001: ldftn void Program::Method1(string)
</span></span><span style=display:flex><span>IL_0007: newobj instance void MyDelegate::.ctor(object, native int)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 多播委托组合
</span></span><span style=display:flex><span>IL_000c: ldnull  
</span></span><span style=display:flex><span>IL_000d: ldftn void Program::Method2(string)
</span></span><span style=display:flex><span>IL_0013: newobj instance void MyDelegate::.ctor(object, native int)
</span></span><span style=display:flex><span>IL_0018: call class [mscorlib]System.Delegate 
</span></span><span style=display:flex><span>        [mscorlib]System.Delegate::Combine(class [mscorlib]System.Delegate, 
</span></span><span style=display:flex><span>                                          class [mscorlib]System.Delegate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 委托调用
</span></span><span style=display:flex><span>IL_001d: ldstr &#34;test&#34;
</span></span><span style=display:flex><span>IL_0022: callvirt instance void MyDelegate::Invoke(string)
</span></span></code></pre></div><h2 id=性能与开销>性能与开销</h2><h3 id=委托的本质性能角度>委托的本质（性能角度）</h3><p>委托本质是一个类对象，继承自<code>System.MulticastDelegate</code><br>它不是轻量的“函数指针”，而是一个包含以下信息的结构体/对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MulticastDelegate</span> 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>object</span> Target; <span style=color:#75715e>// 实例引用（如果静态方法则为null）</span>
</span></span><span style=display:flex><span>    IntPtr MethodPtr; <span style=color:#75715e>// 方法指针</span>
</span></span><span style=display:flex><span>    MulticastDelegate Prev; <span style=color:#75715e>// 用于形成调用链（多播）</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>每次写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Action a = Foo;
</span></span></code></pre></div><p>编译器背后做的是</p><ol><li>创建一个新的委托对象</li><li>在其中记录目标实例和方法指针</li></ol><p>这意味着：</p><ul><li>创建委托时会分配堆内存</li><li>调用委托时会简洁调用目标方法</li></ul><h3 id=创建成本绑定阶段>创建成本（绑定阶段）</h3><table><thead><tr><th>场景</th><th>开销</th></tr></thead><tbody><tr><td>绑定静态方法</td><td>较低（一次分配）</td></tr><tr><td>绑定实例方法</td><td>稍高（需要保存目标引用）</td></tr><tr><td>多播（<code>+=</code>）</td><td>较高（新建委托链对象）</td></tr><tr><td>Lambda捕获</td><td>最高（生成闭包类 + 实例化）</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Action a = Foo; <span style=color:#75715e>// 创建一个委托对象</span>
</span></span><span style=display:flex><span>a += Bar; <span style=color:#75715e>// 实际上创建了一个新的MulticastDelegate</span>
</span></span></code></pre></div><p>每次<code>+=</code>都会产生一个新对象，因为<code>MulticastDelegate</code>是不可变的</p><blockquote><p>因此频繁地<code>+=</code>/<code>-=</code>会产生GC压力；尤其在事件系统中，建议提前缓存委托对象，不要每帧都新建</p></blockquote><h3 id=调用成本执行阶段>调用成本（执行阶段）</h3><p>调用委托的成本主要来自</p><ol><li>一次间接跳转（类似虚函数调用）</li><li>安全检查与封装开销</li><li>多播时的循环遍历</li></ol><p>大致性能对比（以Release模式为基准）</p><table><thead><tr><th>调用方式</th><th>相对耗时</th><th>说明</th></tr></thead><tbody><tr><td>直接方法调用</td><td>1x</td><td>基准</td></tr><tr><td>虚函数调用</td><td>~1.2x</td><td>有一次虚表跳转</td></tr><tr><td>单播委托调用</td><td>~1.5x</td><td>额外的委托封装层</td></tr><tr><td>多播委托调用（3个目标）</td><td>~3.5x</td><td>逐个调用InvocationList</td></tr></tbody></table><blockquote><p>在现代JIT(RyuJIT)下，单播委托的调用几乎能被内联优化到接近直接调用。但多播或捕获闭包的情况仍然较慢</p></blockquote><h3 id=闭包带来的额外成本>闭包带来的额外成本</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> x = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>Action a = () =&gt; x++;
</span></span></code></pre></div><p>编译器生成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DisplayClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Lambda() { x++; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这会带来</p><ul><li>一次堆分配（DisplayClass）</li><li>一次委托分配（Action对象）</li><li>闭包对象会被捕获在堆上，直到lambda不再被引用才释放</li></ul><blockquote><p>所以如果在Update、Timer或循环中频繁创建lambda，GC压力会显著上升</p></blockquote><p>优化策略</p><ul><li>尽量避免在高频逻辑中捕获变量的lambda</li><li>可将委托缓存为静态字段</li><li>或使用结构化回调（<code>struct</code> + <code>interface</code>）代替</li></ul><h3 id=多播调用链的开销>多播调用链的开销</h3><p>当有多播委托时</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Action a = Foo;
</span></span><span style=display:flex><span>a += Bar;
</span></span><span style=display:flex><span>a += Baz;
</span></span><span style=display:flex><span>a();
</span></span></code></pre></div><p>执行过程：</p><ol><li>获取<code>InvocationList</code></li><li>遍历每个目标</li><li>逐个调用</li></ol><p>这意味着时间复杂度是O(n)<br>当n较大时（例如事件订阅几十个监听器），性能会线性下降</p><h3 id=jit优化与委托内联>JIT优化与委托内联</h3><p>现代.NET JIT（RyuJIT、CoreCLR）在以下场景可内联委托</p><ul><li>单播委托</li><li>无捕获lambda</li><li>委托在局部作用域内</li><li>无需boxing/unboxing</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Action a = Foo;
</span></span><span style=display:flex><span>a(); <span style=color:#75715e>// JIT可直接内联为 Foo();</span>
</span></span></code></pre></div><h2 id=常见陷阱>常见陷阱</h2><h3 id=引用捕获陷阱lambda闭包>引用捕获陷阱（Lambda闭包）</h3><ol><li>捕获外部变量的生命周期延长</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;Action&gt; actions = <span style=color:#66d9ef>new</span> List&lt;Action&gt;();
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>3</span>; i++)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    actions.Add(() =&gt; Console.WriteLine(i));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> a <span style=color:#66d9ef>in</span> actions) a();
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>3
</span></span><span style=display:flex><span>3
</span></span><span style=display:flex><span>3
</span></span></code></pre></div><p>因为Lambda捕获了变量<code>i</code>的引用，而不是当时的值。<code>i</code>在循环结束后等于<code>3</code>，所以所有委托都输出3<br>正确做法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>3</span>; i++)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> copy = i;
</span></span><span style=display:flex><span>    actions.Add(() =&gt; Console.WriteLine(copy));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>捕获导致GC无法回收
如果一个委托捕获了外部对象引用（比如<code>this</code>或局部变量），即使那个对象已经“理论上”不需要了，委托持有的闭包对象依然会让它存活<br>结果：内存泄露</li></ol><h3 id=事件解绑陷阱>事件解绑陷阱</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>button.Click += (s, e) =&gt; DoSomething();
</span></span><span style=display:flex><span>button.Click -= (s, e) =&gt; DoSomething(); <span style=color:#75715e>// 无效解绑</span>
</span></span></code></pre></div><p>这两个Lambda是不同的实例，所以第二行不会解除绑定<br>正确做法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>EventHandler handler = (s, e) =&gt; DoSomething();
</span></span><span style=display:flex><span>button.Click += handler;
</span></span><span style=display:flex><span>button.Click -= handler; <span style=color:#75715e>// 有效解绑</span>
</span></span></code></pre></div><p>陷阱实质</p><ul><li>Lambda每次定义都会生成一个新的委托对象</li><li>想要解绑，必须持有同一个委托实例</li></ul><h3 id=性能陷阱>性能陷阱</h3><ol><li>多播委托开销
多播委托（<code>+=</code>多个方法）内部是也给调用链表，每次<code>Invoke()</code>都会遍历调用</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> d <span style=color:#66d9ef>in</span> invocationList)
</span></span><span style=display:flex><span>    d.DynamicInvoke(args);
</span></span></code></pre></div><p>问题</p><ul><li>不能短路（每个都调用）</li><li>每个<code>Invoke</code>都有堆栈开销</li><li>若中间某个委托抛异常，后面的不会执行</li></ul><blockquote><p>在高频调用场景（如游戏Update循环）中，多播委托不适合直接使用。可以用事件分发器（如UnityEvent、自定义ActionList）优化</p></blockquote><h3 id=异步与委托陷阱>异步与委托陷阱</h3><ol><li>异步捕获上下文</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>button.Click += <span style=color:#66d9ef>async</span>(s, e) =&gt; <span style=color:#66d9ef>await</span>.LongTask();
</span></span></code></pre></div><p>如果<code>LongTask()</code>抛异常，事件调用者无法感知异常（因为返回的是<code>void</code>异步委托）<br>推荐</p><ul><li>避免在事件中直接用<code>async void</code></li><li>或者在内部手动捕获异常</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>button.Click += <span style=color:#66d9ef>async</span> (s, e) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> { <span style=color:#66d9ef>await</span> LongTask(); }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> (Exception ex) { Log(ex); }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=静态与实例绑定陷阱>静态与实例绑定陷阱</h3><p>委托可绑定</p><ul><li>静态方法（无目标）</li><li>实例方法（有目标<code>Target</code>）</li></ul><p>在某些情况下，忘记解除绑定的实例方法会持有整个对象的引用，导致</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>eventHandler += obj.SomeMethod; <span style=color:#75715e>// obj无法被回收</span>
</span></span></code></pre></div><p>这会引起对象长期驻留内存，尤其是订阅了全局事件（例如静态事件）<br>解决方案：</p><ul><li>使用弱引用包装（<code>WeakEventManager</code>或自定义WeakDelegate）</li><li>或在对象销毁时手动解绑</li></ul><h3 id=delegatecombineremove的逻辑陷阱>Delegate.Combine/Remove的逻辑陷阱</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Action a = A;
</span></span><span style=display:flex><span>a += B;
</span></span><span style=display:flex><span>a += A;
</span></span><span style=display:flex><span>a -= A;
</span></span><span style=display:flex><span>a();
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>B
</span></span><span style=display:flex><span>A
</span></span></code></pre></div><p>因为<code>-=</code>只移除最后一次出现的匹配项，要清除所有<code>A</code>，必须循环调用<code>-=</code>或重新构造链</p><h3 id=泛型委托的类型匹配陷阱协变逆变>泛型委托的类型匹配陷阱（协变/逆变）</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>object</span>&gt; f1 = () =&gt; <span style=color:#e6db74>&#34;hello&#34;</span>;
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>string</span>&gt; f2 = f1; <span style=color:#75715e>// 编译错误（逆变不允许）</span>
</span></span></code></pre></div><p>协变和逆变在<code>delegate</code>类型参数上有限制</p><ul><li><code>Func&lt;out T></code>协变，只能从子类 -> 父类</li><li><code>Action&lt;in T></code>逆变，只能从父类 -> 子类</li></ul><p>理解错会导致委托赋值异常</p><h3 id=delegatedynamicinvoke性能坑>Delegate.DynamicInvoke性能坑</h3><p>使用<code>DynamicInvoke()</code>调用委托非常慢（涉及反射调用和装箱拆箱），除非必要，不要再热路径使用<br>替代方案：直接调用委托</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>delegateInstance(param); <span style=color:#75715e>// 比DynamicInvoke快几十倍</span>
</span></span></code></pre></div></div><nav class=post-nav><a href=/dotnetandwindows/log/datatypeconvert/ class=hover:underline>pre: Data Type and Convert</a>
<a href=/dotnetandwindows/log/event/ class=hover:underline>next: Event</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#声明与使用>声明与使用</a></li><li><a href=#常见内置委托>常见内置委托</a></li><li><a href=#绑定与多播>绑定与多播</a><ul><li><a href=#绑定binding>绑定(Binding)</a></li><li><a href=#多播multicast>多播（Multicast）</a></li></ul></li><li><a href=#委托的底层>委托的底层</a><ul><li><a href=#委托的编译后结构>委托的编译后结构</a></li><li><a href=#构造过程的底层逻辑>构造过程的底层逻辑</a></li><li><a href=#委托的内存布局>委托的内存布局</a></li><li><a href=#多播委托的底层实现>多播委托的底层实现</a></li><li><a href=#通过ildasm查看实际il代码>通过ILDASM查看实际IL代码</a></li></ul></li><li><a href=#性能与开销>性能与开销</a><ul><li><a href=#委托的本质性能角度>委托的本质（性能角度）</a></li><li><a href=#创建成本绑定阶段>创建成本（绑定阶段）</a></li><li><a href=#调用成本执行阶段>调用成本（执行阶段）</a></li><li><a href=#闭包带来的额外成本>闭包带来的额外成本</a></li><li><a href=#多播调用链的开销>多播调用链的开销</a></li><li><a href=#jit优化与委托内联>JIT优化与委托内联</a></li></ul></li><li><a href=#常见陷阱>常见陷阱</a><ul><li><a href=#引用捕获陷阱lambda闭包>引用捕获陷阱（Lambda闭包）</a></li><li><a href=#事件解绑陷阱>事件解绑陷阱</a></li><li><a href=#性能陷阱>性能陷阱</a></li><li><a href=#异步与委托陷阱>异步与委托陷阱</a></li><li><a href=#静态与实例绑定陷阱>静态与实例绑定陷阱</a></li><li><a href=#delegatecombineremove的逻辑陷阱>Delegate.Combine/Remove的逻辑陷阱</a></li><li><a href=#泛型委托的类型匹配陷阱协变逆变>泛型委托的类型匹配陷阱（协变/逆变）</a></li><li><a href=#delegatedynamicinvoke性能坑>Delegate.DynamicInvoke性能坑</a></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>