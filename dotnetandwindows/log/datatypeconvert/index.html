<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Data Type and Convert</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-lua.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-rust.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/log/>Log</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a> |
<a href=https://isocpp.org/ target=_blank>isocpp</a> |
<a href=https://open-std.org target=_blank>open-std</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/ target=_blank>lua.org</a> |
<a href=https://www.luarocks.org/ target=_blank>luarocks.org</a> |
<a href=https://www.luajit.org/ target=_blank>luajit.org</a></p><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a></p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a></p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Data Type and Convert<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><p>C#中的数据类型可以分为值类型、引用类型、指针类型</p><h2 id=值类型value-types>值类型（Value Types）</h2><p>变量直接包含其值，而不是引用</p><p>它们通常分配在栈上（也可能在堆上，取决于上下文）</p><h3 id=特点>特点</h3><ul><li>存储位置：通常在stack上分配</li><li>值的复制方式：赋值时复制整个值本身，两个变量互不影响</li><li>默认值：没有显示初始化时，具有默认值</li><li>继承限制：不能从另一个值类型继承，只能继承自<code>System.ValueType</code></li></ul><h3 id=常见的值类型>常见的值类型</h3><ol><li>内置基本类型（C#关键字）</li></ol><ul><li><p>整数类型 默认值：0</p><ul><li>int 4Byte</li><li>uint 4Byte</li><li>short 2Byte</li><li>ushort 2Byte</li><li>long 8Byte</li><li>ulong 8Byte</li><li>byte 1Byte (uint)</li><li>sbyte 1Byte (signed)</li></ul></li><li><p>浮点类型 默认值：0.0</p><ul><li>float 4Byte</li><li>double 8Byte</li><li>decimal 16Byte</li></ul></li><li><p>布尔类型 默认值：flase</p><ul><li>bool 1Byte</li></ul></li></ul><ol start=2><li>枚举类型(<code>enum</code>)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>enum</span> Day { Sunday, Monday, Tuesday }
</span></span></code></pre></div><ul><li>本质上时整数类型（默认为<code>int</code>）</li><li>是值类型，存储为对应的数值</li></ul><ol start=3><li>结构体类型(<code>struct</code>)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Point</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> X;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> Y;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>用户自定义的复合值类型</li><li>不支持继承其他结构体，但可实现接口</li><li>是<code>System.ValueType</code>的子类</li></ul><ol start=4><li><code>Nullable&lt;T></code>（可空值类型）
可空值类型是C#中用于给值类型添加<code>null</code>表示能力的一种语法和语义扩展，主要解决“值类型不能为null”的限制
很多情况下，值类型需要一个“未赋值”或“无值”的状态，例如\</li></ol><ul><li>数据库中的<code>int?</code>字段</li><li>UI输入框中的可选数值</li><li>网络传输中的可能缺失的字段</li></ul><p>定义方式（两种等价）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int?</span> x = <span style=color:#ff79c6>null</span>; <span style=color:#6272a4>// 常用写法（语法糖）</span>
</span></span><span style=display:flex><span>Nullale&lt;<span style=color:#8be9fd>int</span>&gt; x = <span style=color:#ff79c6>null</span>; <span style=color:#6272a4>// 等价写法（本质）</span>
</span></span></code></pre></div><p>可以用在任何值类型上</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>bool?</span> b;
</span></span><span style=display:flex><span><span style=color:#8be9fd>float?</span> f;
</span></span><span style=display:flex><span><span style=color:#8be9fd>decimal?</span> money;
</span></span><span style=display:flex><span>DateTime? birthday;
</span></span></code></pre></div><p>Nullable<t>的本质<br>编译器背后的原理是这个结构体</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Nullable</span>&lt;T&gt; <span style=color:#ff79c6>where</span> T : <span style=color:#ff79c6>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> T Value { <span style=color:#ff79c6>get</span>; }
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>bool</span> HasValue { <span style=color:#ff79c6>get</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>所以<code>int?</code>本质上是<code>Nullable&lt;int></code>，包含两部分</p><ul><li><code>Value</code>：存储实际数值</li><li><code>HasValue</code>：是否有值（不是null）</li></ul><p><code>HasValue</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int?</span> a = <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>Console.WriteLine(a.HasValue); <span style=color:#6272a4>// false</span>
</span></span></code></pre></div><p><code>Value</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int?</span> b = <span style=color:#bd93f9>10</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (b.HasValue)
</span></span><span style=display:flex><span>	Console.WriteLine(b.<span style=color:#ff79c6>value</span>); <span style=color:#6272a4>// 10</span>
</span></span></code></pre></div><p>如果访问<code>null</code>值的<code>.Value</code>，会抛出异常<code>InvalidOperationException</code></p><p>空合并运算符<code>??</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int?</span> age = <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> realAge = age ?? <span style=color:#bd93f9>18</span>; <span style=color:#6272a4>// 如果age是null，则使用18</span>
</span></span></code></pre></div><p>可空值运算</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int?</span> a = <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>int?</span> b = <span style=color:#bd93f9>5</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>int?</span> c = a + b; <span style=color:#6272a4>// c == null, 如果任意一项是null，结果是null</span>
</span></span></code></pre></div><p><strong>判断一个类型是否是值类型</strong><br>可以使用<code>typeof(T).IsValueType</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Console.WriteLine(<span style=color:#ff79c6>typeof</span>(<span style=color:#8be9fd>int</span>).IsValueType); <span style=color:#6272a4>// True</span>
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#ff79c6>typeof</span>(stirng).IsValueType); <span style=color:#6272a4>// False</span>
</span></span></code></pre></div><p><strong>判断一个类型的大小</strong><br>可以使用<code>sizeof(T)</code></p><p><strong>获取类型名</strong><br><code>this.GetType().Name</code>, <code>typeof(T).Name</code></p><h3 id=systemvaluetype>System.ValueType</h3><p><code>System.ValueType</code>是.NET类型系统中的一个基础类，位于<code>System</code>命名空间中，它是所有值类型(value types)的基类，其存在意义主要是为了让值类型可以作为对象(object)使用</p><p><code>System.ValueType</code>是值类型的抽象父类，本身是一个引用类型，它继承自<code>System.Object</code>，但专门为值类型提供了一些特性</p><blockquote><p>所有用<code>struct</code>关键字定义的类型，都会自动继承<code>System.ValueType</code>，这与<code>class</code>自动继承<code>System.Object</code>类似</p></blockquote><h3 id=valuetype的作用>ValueType的作用</h3><ol><li>实现值类型和引用类型的桥梁</li></ol><ul><li>虽然值类型本质不是对象，但因为继承了<code>ValueType</code>，它们可以被装箱(Boxing)，从而以<code>object</code>的形式使用</li></ul><ol start=2><li>重写了<code>Object</code>的方法
<code>ValueType</code>重写了<code>Equals</code>、<code>GetHashCode</code>和<code>ToStirng</code>方法，使得结构体能够正确地比较和显示内容</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Point</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> X;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> Y;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>Point p1 = <span style=color:#ff79c6>new</span> Point { X = <span style=color:#bd93f9>1</span>, Y = <span style=color:#bd93f9>2</span> };
</span></span><span style=display:flex><span>Point p2 = <span style=color:#ff79c6>new</span> Point { X = <span style=color:#bd93f9>1</span>, Y = <span style=color:#bd93f9>2</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(p1.Equals(p2)); <span style=color:#6272a4>// 比较字段而不是引用</span>
</span></span></code></pre></div><p>为所有值类型统一提供对<code>System.Object</code>的方法的“默认特化实现”</p><ul><li><code>System.Object.Equals()</code>默认是引用比较(==)</li><li><code>System.Object.GetHashCOde()</code>默认基于引用地址生成hash</li><li><code>System.Object.ToString()</code>默认返回类型名</li></ul><p>而这些对于值类型来说是不合理的</p><p>在内部，<code>System.ValueType</code>重写了这些方法</p><ol><li><code>Equals(object obj)</code></li></ol><ul><li>反射方式：比较两个值类型实例的每个字段是否相等</li><li>如果没有手动重写结构体的<code>Equals</code>，它会自动比较字段值</li></ul><ol start=2><li><code>GetHashCode()</code></li></ol><ul><li>基于字段计算哈希值，而不是像<code>Object</code>那样基于地址</li></ul><ol start=3><li><code>ToString()</code></li></ol><ul><li>默认行为是打印字段列表（不如类那样详细，建议手动重写）</li></ul><p>虽然<code>ValueType</code>做了字段比较，但性能不算高，因为使用的是反射（尤其在<code>Equals()</code>中)</p><p>所以在性能敏感场景（如大量结构体比较）推荐手动重写</p><h2 id=引用类型reference-types>引用类型(Reference Types)</h2><p>在C#中，引用类型表示变量中存储的是对象的引用地址，而不是对象本身。对象的实际数据存储在托管堆中</p><table><thead><tr><th>特性</th><th>值类型（Value Type）</th><th>引用类型（Reference Type）</th></tr></thead><tbody><tr><td>存储位置</td><td>栈或嵌入到对象中</td><td>堆（实际对象），栈中存储引用</td></tr><tr><td>是否复制对象</td><td>是，按值复制</td><td>否，复制的是引用</td></tr><tr><td>可为 null</td><td>否（除非是 <code>Nullable&lt;T></code>）</td><td>是</td></tr><tr><td>继承</td><td>不能继承（只能继承自 <code>System.ValueType</code>）</td><td>可继承</td></tr><tr><td>默认比较行为</td><td>比较内容</td><td>比较引用地址（除非重写 <code>Equals</code>）</td></tr></tbody></table><table><thead><tr><th>类型种类</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>class</code></td><td>类，是最常用的引用类型</td><td><code>class Person {}</code></td></tr><tr><td><code>interface</code></td><td>接口，也是引用类型</td><td><code>interface IMovable {}</code></td></tr><tr><td><code>delegate</code></td><td>委托，用于函数对象</td><td><code>delegate void Action();</code></td></tr><tr><td><code>object</code></td><td>所有引用类型的基类</td><td><code>object obj = new Person();</code></td></tr><tr><td><code>string</code></td><td>字符串是特殊的引用类型（<strong>不可变</strong>）</td><td><code>string s = "hello";</code></td></tr></tbody></table><p>内存结构：引用类型的生命周期</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>变量声明:
</span></span><span style=display:flex><span>Person p = new Person();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>内存布局:
</span></span><span style=display:flex><span>+--------------------+
</span></span><span style=display:flex><span>| 栈内存             |
</span></span><span style=display:flex><span>|--------------------|
</span></span><span style=display:flex><span>| p (引用地址) ------|------+
</span></span><span style=display:flex><span>+--------------------+      |
</span></span><span style=display:flex><span>                            |
</span></span><span style=display:flex><span>+--------------------+      |
</span></span><span style=display:flex><span>| 堆内存             | &lt;----+
</span></span><span style=display:flex><span>|--------------------|
</span></span><span style=display:flex><span>| Person 实例        |
</span></span><span style=display:flex><span>| name = &#34;Jeff&#34;      |
</span></span><span style=display:flex><span>+--------------------+
</span></span></code></pre></div><p>栈中保存变量<code>p</code>的引用地址，堆中存储实际的<code>Person</code>对象。当引用失效，GC会自动清理对象</p><h3 id=深拷贝与浅拷贝>深拷贝与浅拷贝</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Person</span> { <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>string</span> Name; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Person p1 = <span style=color:#ff79c6>new</span> Person { Name = <span style=color:#f1fa8c>&#34;Alice&#34;</span> };
</span></span><span style=display:flex><span>Person p2 = p1; <span style=color:#6272a4>// p2引用同一个对象</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p2.Name = <span style=color:#f1fa8c>&#34;Bob&#34;</span>;
</span></span><span style=display:flex><span>Console.WriteLine(p1.Name); <span style=color:#6272a4>// Bob</span>
</span></span></code></pre></div><blockquote><p>两个变量指向同一块堆内存，修改其中一个变量的字段，另一个变量也会反映这个修改</p></blockquote><ul><li>浅拷贝：复制引用（默认行为，使用<code>MemberwiseClone()</code>）</li><li>深拷贝：复制整个对象内容（需手动实现）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> Person DeepCopy() =&gt; <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> Person { Name = <span style=color:#8be9fd>string</span>.Copy(<span style=color:#ff79c6>this</span>.Name) };
</span></span></code></pre></div><p>或者使用序列化技术实现深拷贝（如<code>JsonSerializer</code>/<code>BinaryFormatter</code>）</p><h3 id=引用类型的默认行为>引用类型的默认行为</h3><table><thead><tr><th>方法</th><th>默认行为</th></tr></thead><tbody><tr><td><code>Equals()</code></td><td>比较引用地址（可重写）</td></tr><tr><td><code>GetHashCode()</code></td><td>与引用相关（可重写）</td></tr><tr><td><code>==</code> 运算符</td><td>比较地址（除非被重载，例如 <code>string</code>）</td></tr></tbody></table><h3 id=引用类型与gc>引用类型与GC</h3><p>引用类型对象位于托管堆中，由CLR的GC管理内存</p><p><strong>GC回收条件</strong></p><ul><li>没有任何活动引用指向该对象</li><li>不是被根对象（如局部变量、静态字段）引用的对象</li></ul><p>C#的析构函数不确定何时调用，由GC控制</p><h3 id=为什么需要引用对象>为什么需要引用对象</h3><p>有很多实际需求无法通过值类型（拷贝）来完成，必须依赖对象共享、动态行为、抽象能力、复杂结构等特性，而这些特性只能由引用对象提供</p><p>值类型效率高但灵活性低，引用类型牺牲了一些效率，换来了更强大的表达力与建模能力</p><table><thead><tr><th>目的</th><th>引用对象的作用</th></tr></thead><tbody><tr><td>共享数据</td><td>多个变量/系统使用同一个对象</td></tr><tr><td>建模复杂实体</td><td>对象可以拥有状态、行为、继承层次</td></tr><tr><td>动态性与多态性</td><td>支持虚方法、接口、动态派发等</td></tr><tr><td>避免内存复制</td><td>对象很大时，拷贝成本高，引用更轻便</td></tr><tr><td>支持链式结构</td><td>如图结构、树、图、链表等</td></tr><tr><td>GC自动管理</td><td>堆分配+GC管理，程序更安全稳定</td></tr></tbody></table><h3 id=为什么引用类型内容在堆上>为什么引用类型内容在堆上</h3><ol><li>引用类型大小不可预知
栈是一块连续的内存区域，要求每个变量在编译期就确定大小<br>而引用类型是：</li></ol><ul><li>可以继承（派生类可能添加字段）</li><li>字段可以是引用类型（嵌套）</li><li>包含对象图（Object Graph）</li><li>可变结构（如数组、链表）</li></ul><p>所以，引用类型的大小通常在运行时才知道，无法放在栈上</p><ol start=2><li><p>栈的生命周期与方法调用同步，太短
栈上的变量在方法返回后立即销毁，如果对象存在于栈上，那一旦函数返回了，对象也就不存在了<br>而引用类型经常在方法之外继续使用（比如：作为成员变量、事件回调、全局数据等），必须在方法栈帧之外生存</p></li><li><p>需要支持多个引用指向同一个对象
如果把对象放在栈中，那么指向该对象的引用就可能失效，为了保证引用安全和共享性，引用类型的数据必须放在一个不会随函数退出而消失的地方：也就是托管堆</p></li><li><p>支持GC
值类型（在栈上）是自动释放的，编译器控制生命周期<br>引用类型（在堆上）需要动态管理<br>所以CLR引入了GC，自动清理没有引用的堆对象</p></li></ol><h3 id=object>Object</h3><p>在C#中，<code>Object</code>类（也叫<code>System.Object</code>）是一切类型的根基，是CLR类型系统的根基（Root Class），无论是值类型、引用类型，最终都从<code>Object</code>直接或间接继承而来</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>namespace</span> System
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Object</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> Object();
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>virtual</span> <span style=color:#8be9fd>bool</span> Equals(<span style=color:#8be9fd>object</span> obj);
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>bool</span> Equals(<span style=color:#8be9fd>object</span> objA, <span style=color:#8be9fd>object</span> objB);
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>bool</span> ReferenceEquals(<span style=color:#8be9fd>object</span> objA, <span style=color:#8be9fd>object</span> objB);
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>virtual</span> <span style=color:#8be9fd>int</span> GetHashCode();
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>virtual</span> <span style=color:#8be9fd>string</span> ToString();
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>virtual</span> <span style=color:#ff79c6>void</span> Finalize();
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> Type GetType();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>所有类型都隐式或显式继承自<code>System.Object</code></li><li>是CLR类型系统统一的抽象基础</li><li>是实现装箱、反射、多态的核心</li></ul><ol><li><p><code>Equals()</code>
用于判断两个对象是否“值相等”（默认比较地址），如果需要比较“值”，需要重写<code>Equals()</code></p></li><li><p><code>ReferenceEquals()</code>
比较两个引用是否指向完全相同的对象</p></li></ol><ul><li>与<code>==</code>不同，<code>ReferenceEquals</code>不可重载，绝对安全</li></ul><ol start=3><li><code>GetHashCode()</code>
返回一个整数，用于表示对象的哈希值<br>默认行为是：</li></ol><ul><li>引用类型：使用对象地址或内部ID</li><li>值类型：使用字段值组合而成</li></ul><p>如果自定义类并重写<code>Equals()</code>，必须也重写<code>GetHashCode()</code>，以保证在哈希表中工作正确</p><ol start=4><li><p><code>ToString()</code>
返回对象的字符串表示，默认是类名</p></li><li><p><code>GetType()</code>
获取当前实例的运行时类型（返回<code>System.Type</code>对象），是实现反射的基础</p></li><li><p><code>Finalize()</code>
析构函数的底层形式</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>~MyClass() { ... } <span style=color:#6272a4>// 实际上编译成 override Finalize()</span>
</span></span></code></pre></div><ul><li><code>Finalize</code>是GC回收前调用的最后机会</li><li>默认<code>Object</code>实现是空的</li><li>不推荐滥用（推荐使用<code>IDisposable</code>）</li></ul><h4 id=objectobjectsystemobject><code>Object</code>、<code>object</code>、<code>System.Object</code></h4><p>在C#中，<code>object</code>是一个语言关键字，它等价于<code>System.Object</code>，而<code>Object</code>通常是指引入了<code>System</code>命名空间后对<code>System.Object</code>的简写引用名</p><p>它们其实都代表同一个.NET类型：<code>System.Object</code>，区别仅仅是上下文不同</p><table><thead><tr><th>名称</th><th>类型</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>System.Object</code></td><td>完整类型名</td><td>BCL中的真正类型，定义在 <code>mscorlib.dll</code> 中</td><td><code>System.Object o = new System.Object();</code></td></tr><tr><td><code>Object</code></td><td>类型别名（类名）</td><td>当引入了 <code>using System;</code> 后的简写写法</td><td><code>Object o = new Object();</code></td></tr><tr><td><code>object</code></td><td>C# 关键字</td><td>编译器关键字，等价于 <code>System.Object</code>，就像<code>int</code>等价于<code>System.Int32</code>一样</td><td><code>object o = new object();</code></td></tr></tbody></table><p><strong>编译器角度</strong>
这三种形式在IL中都是一样的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>object</span> o = <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>object</span>();
</span></span><span style=display:flex><span>Object o2 = <span style=color:#ff79c6>new</span> Object();
</span></span><span style=display:flex><span>System.Object o3 = <span style=color:#ff79c6>new</span> System.Object();
</span></span></code></pre></div><p>编译之后的IL代码中，它们都会创建一个<code>System.Object</code>实例</p><table><thead><tr><th>用法</th><th>推荐写法</th><th>原因</th></tr></thead><tbody><tr><td>普通开发</td><td><code>object</code></td><td>符合 C# 语言习惯，简洁</td></tr><tr><td>底层开发（如反射、Interop）</td><td><code>System.Object</code></td><td>更明确，避免命名冲突</td></tr><tr><td>语法糖场景</td><td><code>object</code></td><td>与 <code>int</code>, <code>string</code> 等一致</td></tr></tbody></table><p>一般写object即可，它们三个是一个东西</p><h3 id=string>String</h3><p>String是C#中最常用也是最重要的类型之一，它不仅仅是字符串的容器，更体现了C#语言设计的不可变性、托管安全、优化机制等诸多理念</p><blockquote><p><code>string</code>是C#关键字，对应.NET中的<code>System.String</code>类型，它是一个不可变（immutable）的引用类型，用于表示Unicode字符</p></blockquote><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>类型名</td><td><code>System.String</code></td></tr><tr><td>C# 关键字</td><td><code>string</code></td></tr><tr><td>所属程序集</td><td><code>mscorlib.dll</code></td></tr><tr><td>类型分类</td><td>引用类型，但行为类似值类型（不可变 + 值语义）</td></tr><tr><td>存储内容</td><td>UTF-16 编码的 Unicode 字符数组</td></tr></tbody></table><h4 id=string的不可变性>String的不可变性</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>string</span> s = <span style=color:#f1fa8c>&#34;Hello&#34;</span>;
</span></span><span style=display:flex><span>s += <span style=color:#f1fa8c>&#34; World&#34;</span>;
</span></span></code></pre></div><p>虽然看起来在修改字符串，但其实</p><ul><li><code>Hello</code>是原始字符串</li><li><code>Hello World</code>是新创建的字符串</li><li><code>s</code>指向了一个新的字符串对象</li></ul><p>旧字符串仍然存在于内存中，等待GC回收</p><p><strong>为什么要设计成不可变</strong></p><ol><li>线程安全（无锁共享）</li><li>哈希值缓存稳定</li><li>可用于字典、集合等键类型</li><li>提升性能（如字符串驻留）</li><li>减少错误（避免被外部修改）</li></ol><h4 id=字符串驻留interning>字符串驻留（Interning）</h4><p>C#编译器会把相同字面值的字符串常量指向同一内存</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>string</span> a = <span style=color:#f1fa8c>&#34;abc&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>string</span> b = <span style=color:#f1fa8c>&#34;abc&#34;</span>;
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#8be9fd>object</span>.ReferenceEquals(a, b)); <span style=color:#6272a4>// True</span>
</span></span></code></pre></div><p>所以字符串字面量是驻留的，避免重复创建</p><h5 id=实现机制>实现机制</h5><ol><li><p>编译器阶段优化
当有多个相同的字符串字面量时，编译器会自动合并为一个驻留字符串</p></li><li><p>运行时通过Intern Pool判断
CLR通过内部的字符串池（intern pool）判断字符串是否已存在，并决定是否复用</p></li></ol><p>当在运行时动态创建字符串时（如拼接、读取）时，它不会自动驻留</p><p><strong>手动判断/驻留</strong>\</p><ol><li>使用<code>string.IsInterned()</code>判断是否驻留</li><li>使用<code>string.Intern()</code>手动驻留
<code>Intern()</code>会</li></ol><ul><li>检查池中是否已经有相同内容字符串</li><li>若有，返回现有实例</li><li>若没有，加入池并返回这个实例</li></ul><p><strong>驻留池生命周期</strong></p><ul><li>驻留池存在于应用程序域（AppDomain）中</li><li>字符串一旦被驻留，就不会被GC回收</li><li>所以不要频繁动态调用<code>Intern()</code>来驻留临时字符串，会造成内存泄露</li></ul><h4 id=string的特殊性>string的特殊性</h4><p>string的分类为引用类型（在堆中分配），但是语义缺执行值语义行为（赋值复制引用，但不可变），比较时按值比较（而不是引用）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>string</span> s1 = <span style=color:#f1fa8c>&#34;abc&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>string</span> s2 = s1; <span style=color:#6272a4>// s2指向同一个字符串</span>
</span></span><span style=display:flex><span>s2 = <span style=color:#f1fa8c>&#34;xyz&#34;</span>; <span style=color:#6272a4>// s2改指向一个新的字符串，s1不受影响</span>
</span></span><span style=display:flex><span>Console.WriteLine(s1) <span style=color:#6272a4>// abc</span>
</span></span></code></pre></div><h4 id=string的实现>string的实现</h4><p>C#中的<code>string</code>是一个类（引用类型），它内部使用<code>char[]</code>表示字符内容</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>sealed</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>String</span> : IComparable, ICloneable, IEnumerable&lt;<span style=color:#8be9fd>char</span>&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>readonly</span> <span style=color:#8be9fd>int</span> _stringLength;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>readonly</span> <span style=color:#8be9fd>char</span> _firstChar;
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 实际上还有内部字段存储字符数组</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由于是<code>sealed</code>，<code>String</code>不能被继承</p><p><strong>操作符重载</strong></p><ul><li><code>==</code>/<code>!=</code>：按值不叫字符串内容（已经被重载）</li><li><code>+</code>：连接字符串（编译器自动转换为<code>Concat</code>或<code>StringBuilder</code>）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>string</span> s = <span style=color:#f1fa8c>&#34;Hello&#34;</span> + <span style=color:#f1fa8c>&#34;World&#34;</span>; <span style=color:#6272a4>// 编译器优化为常量”Hello World“</span>
</span></span></code></pre></div><h4 id=字符串操作效率问题>字符串操作效率问题</h4><p>由于不可变，频繁拼接会创建大量新对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>string</span> result = <span style=color:#f1fa8c>&#34;&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>0</span>; i &lt; <span style=color:#bd93f9>1000</span>; ++i) result += i;
</span></span></code></pre></div><p>性能极差</p><p>推荐使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>var</span> sb = <span style=color:#ff79c6>new</span> StringBuilder();
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>0</span>; i &lt; <span style=color:#bd93f9>1000</span>; i++) sb.Append(i);
</span></span><span style=display:flex><span><span style=color:#8be9fd>string</span> result = sb.ToString();
</span></span></code></pre></div><h4 id=api>API</h4><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td><code>Length</code></td><td>获取字符串长度（字符数）</td></tr><tr><td><code>Substring(start, length)</code></td><td>截取子串</td></tr><tr><td><code>IndexOf(char/str)</code></td><td>查找字符/子串索引</td></tr><tr><td><code>ToUpper()</code> / <code>ToLower()</code></td><td>字母大小写转换</td></tr><tr><td><code>Trim()</code> / <code>TrimStart()</code> / <code>TrimEnd()</code></td><td>去除空白字符</td></tr><tr><td><code>Replace(old, new)</code></td><td>替换子串</td></tr><tr><td><code>Split(char[])</code></td><td>拆分成字符串数组</td></tr><tr><td><code>Contains(string)</code></td><td>是否包含子串</td></tr><tr><td><code>StartsWith()</code> / <code>EndsWith()</code></td><td>前缀/后缀判断</td></tr></tbody></table><h3 id=dynamic慎用>Dynamic（慎用）</h3><p>它代表了动态类型系统的入口，让C#拥有了类似Python、JavaScript的运行时绑定的能力</p><h2 id=指针类型pointer-types>指针类型（Pointer Types）</h2><p>这是C#中一部分不常用但非常底层的特性，它让C#在特定场景下具备类似C++的裸指针能力</p><p>指针类型是C#的unsafe功能，它允许直接访问内存地址、操作指针，就像在C/C++中一样，但需要使用<code>unsafe</code>关键字显式开启</p><h3 id=语法>语法</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>type* pointerName;
</span></span></code></pre></div><ul><li><code>type</code>可以是任意可寻址类型</li><li>必须写在<code>unsafe</code>上下文中</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>unsafe</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> x = <span style=color:#bd93f9>10</span>;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span>* ptr = &amp;x;
</span></span><span style=display:flex><span>	Console.WriteLine(*ptr);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>开启条件</strong><br>由于C#是类型安全的语言，默认不允许使用指针，因此必须：</p><ol><li>显式使用<code>unsafe</code>修饰代码块或方法</li><li>在项目属性中开启允许不安全代码</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>unsafe</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>UnsafeClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> x = <span style=color:#bd93f9>123</span>;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span>* p = &amp;x;
</span></span><span style=display:flex><span>	Console.WriteLine(*p); <span style=color:#6272a4>// 123</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>指针可用于所有值类型，不可用于所有引用类型，也就是说，指针蹦年指向托管堆上的对象，这是不安全行为，堆上的对象会被GC移动</p><p>C#提供了更安全的替代方式</p><ul><li>Span<t>/ReadOnlySpan<t> 高性能、零拷贝内存访问</li><li>Memory<t> 可用于异步场景</li><li>Marshal类 于非托管内存交互</li><li>fixed关键字 将托管变量固定以防止GC移动</li></ul><h2 id=类型转换>类型转换</h2><table><thead><tr><th>类型转换类别</th><th>描述</th></tr></thead><tbody><tr><td>隐式转换（implicit）</td><td>安全、自动完成，无需强制转换符</td></tr><tr><td>显式转换（cast）</td><td>可能丢失精度，需使用强制转换符 <code>()</code></td></tr><tr><td>装箱（Boxing）</td><td>值类型 → 引用类型（object）</td></tr><tr><td>拆箱（Unboxing）</td><td>引用类型 → 值类型（需类型匹配）</td></tr><tr><td>使用 <code>Convert</code> 类</td><td>安全地处理类型转换，含 null 检查等</td></tr><tr><td><code>Parse</code> / <code>TryParse</code></td><td>将字符串转换为数值等基本类型</td></tr><tr><td>用户自定义转换</td><td>自定义 <code>implicit</code> 或 <code>explicit</code> 运算符</td></tr></tbody></table><h3 id=隐式转换implicit>隐式转换（implicit）</h3><p>隐式转换是指：编译器自动完成类型转换而不显式使用<code>cast</code>操作符的情况</p><p>它是语言的类型和操作符重载机制中非常重要的一部分</p><p>特点：</p><ul><li>编译器自动完成（无需(T)xxx）</li><li>不会造成数据丢失或运行时异常</li><li>常用于“容量小”到“容量大”的数值类型转换</li></ul><h4 id=内置类型的隐式转换>内置类型的隐式转换</h4><p><strong>常见数值类型之间的隐式转换</strong></p><table><thead><tr><th>来源类型</th><th>目标类型</th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>decimal</code></td></tr><tr><td><code>short</code></td><td><code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>decimal</code></td></tr><tr><td><code>int</code></td><td><code>long</code>, <code>float</code>, <code>double</code>, <code>decimal</code></td></tr><tr><td><code>float</code></td><td><code>double</code></td></tr><tr><td><code>char</code></td><td><code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code>, <code>decimal</code></td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>100</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>double</span> d = i; <span style=color:#6272a4>// 隐式转换：int -&gt; double</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>float</span> f = <span style=color:#bd93f9>3.14f</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>double</span> d2 = f; <span style=color:#6272a4>// 隐式转换：float -&gt; double</span>
</span></span></code></pre></div><h4 id=自定义类型中的隐式转换>自定义类型中的隐式转换</h4><p>使用<code>implicit</code>关键字来自定义转换操作符</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Meter</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>double</span> <span style=color:#ff79c6>value</span> { <span style=color:#ff79c6>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> Meter(<span style=color:#8be9fd>double</span> <span style=color:#ff79c6>value</span>) =&gt; Value = <span style=color:#ff79c6>value</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 自定义从double到Meter的隐式转换</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>implicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> Meter(<span style=color:#8be9fd>double</span> <span style=color:#ff79c6>value</span>) =&gt; <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> Meter(<span style=color:#ff79c6>value</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 自定义从Meter到double的隐式转换</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>implicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> <span style=color:#8be9fd>double</span>(Meter meter) =&gt; <span style=color:#ff79c6>return</span> meter.Value;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>用法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Meter m = <span style=color:#bd93f9>5.0</span>; <span style=color:#6272a4>// 隐式double -&gt; Meter</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>double</span> d = m; <span style=color:#6272a4>// 隐式Meter -&gt; double</span>
</span></span></code></pre></div><h4 id=注意事项>注意事项</h4><ol><li>不要滥用隐式转换操作符：过度使用可能会降低代码的可读性，使得类型之间的边界变得模糊</li><li>避免转换歧义：如果两个类型之间同时定义了<code>implicit</code>和<code>explicit</code>，要明确选择</li><li>接口与继承结构中，隐式转换通常用于“上转型”</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Stream s = <span style=color:#ff79c6>new</span> FileStream(...); <span style=color:#6272a4>// FileStream -&gt; Stream 是隐式转换</span>
</span></span></code></pre></div><h4 id=示例封装单位系统>示例：封装单位系统</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Celsius</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>double</span> Degrees { <span style=color:#ff79c6>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> Celsius(<span style=color:#8be9fd>double</span> degrees)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Degrees = degrees;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>implicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> Fahrenheit(Celsius c)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> Fahrenheit(c.Degrees * <span style=color:#bd93f9>9</span> / <span style=color:#bd93f9>5</span> + <span style=color:#bd93f9>32</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Fahrenheit</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>double</span> Degrees { <span style=color:#ff79c6>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> Fahrenheit(<span style=color:#8be9fd>double</span> degrees)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Degrees = degrees;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>implicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> Celsius(Fahrenheit f)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> Celsius((f.Degrees - <span style=color:#bd93f9>32</span>) * <span style=color:#bd93f9>5</span> / <span style=color:#bd93f9>9</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 用法</span>
</span></span><span style=display:flex><span>Celsius c = <span style=color:#ff79c6>new</span> Fahrenheit(<span style=color:#bd93f9>98.6</span>); <span style=color:#6272a4>// 自动转为 Celsius</span>
</span></span><span style=display:flex><span>Fahrenheit f = <span style=color:#ff79c6>new</span> Celsius(<span style=color:#bd93f9>37</span>);  <span style=color:#6272a4>// 自动转为 Fahrenheit</span>
</span></span></code></pre></div><h3 id=显式转换cast>显式转换（cast）</h3><p>开发者使用强制类型转换(cast)语法手动进行的类型转换</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int</span> i = (<span style=color:#8be9fd>int</span>)<span style=color:#bd93f9>3.14</span>;
</span></span></code></pre></div><p>C#中的显式转换用于那些可能丢失信息或失败的转换，因此编译器不会自动完成，必须使用<code>(T)</code>的形式进行转换</p><h4 id=内置类型的显式转换>内置类型的显式转换</h4><p>内置数值类型之间存在一些需要显式转换的形式：</p><table><thead><tr><th>来源类型</th><th>目标类型</th><th>是否需要显式转换</th><th>原因</th></tr></thead><tbody><tr><td><code>double</code></td><td><code>int</code></td><td>是</td><td>可能丢失小数部分</td></tr><tr><td><code>long</code></td><td><code>int</code></td><td>是</td><td>可能溢出</td></tr><tr><td><code>float</code></td><td><code>byte</code></td><td>是</td><td>可能精度损失和溢出</td></tr></tbody></table><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>double</span> d = <span style=color:#bd93f9>3.14</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> i = (<span style=color:#8be9fd>int</span>)d; <span style=color:#6272a4>// i = 3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>long</span> l = <span style=color:#bd93f9>9999999999</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> j = (<span style=color:#8be9fd>int</span>)l; <span style=color:#6272a4>// 溢出，j的值将错误</span>
</span></span></code></pre></div><h4 id=显式转换的本质>显式转换的本质</h4><p>C#通过<code>explicit</code>关键字来定义类中的自定义显式类型转换操作符，用来让开发者明确地从一种类型转换为另一种类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>explicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> TargetType(SourceType <span style=color:#ff79c6>value</span>)
</span></span></code></pre></div><p>示例：显式转换一个自定义类为<code>int</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>MyClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> Value { <span style=color:#ff79c6>get</span>; <span style=color:#ff79c6>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> MyClass(<span style=color:#8be9fd>int</span> <span style=color:#ff79c6>value</span>) =&gt; Value = <span style=color:#ff79c6>value</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>explicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> <span style=color:#8be9fd>int</span>(MyClass obj)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> obj.Value;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>explicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> MyClass(<span style=color:#8be9fd>int</span> <span style=color:#ff79c6>value</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> MyClass(<span style=color:#ff79c6>value</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>用法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>MyClass a = (MyClass)<span style=color:#bd93f9>42</span>; <span style=color:#6272a4>// 显式从int转为MyClass</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> x = (<span style=color:#8be9fd>int</span>)a; <span style=color:#6272a4>// 显式从MyClass转为int</span>
</span></span></code></pre></div><p>如果不使用<code>(int)</code>强制转换，上面代码将无法编译</p><h4 id=隐式转换-vs-显式转换>隐式转换 vs 显式转换</h4><table><thead><tr><th>对比项</th><th>隐式转换（implicit）</th><th>显式转换（explicit）</th></tr></thead><tbody><tr><td>编译器行为</td><td>自动进行</td><td>必须手动 <code>(T)value</code></td></tr><tr><td>安全性</td><td>必须是无损转换</td><td>可以是有损或可能失败的转换</td></tr><tr><td>用户体验</td><td>更加自然、易于使用</td><td>更安全，提醒开发者确认转换逻辑</td></tr><tr><td>典型用法场景</td><td>小类型 → 大类型、单位包装类、语义增强</td><td>大类型 → 小类型、自定义类结构、需防误用的场景</td></tr></tbody></table><h4 id=示例>示例</h4><p>数值和包装类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Health</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> Value;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> Health(<span style=color:#8be9fd>int</span> <span style=color:#ff79c6>value</span>) =&gt; Value = <span style=color:#ff79c6>value</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>explicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> <span style=color:#8be9fd>int</span>(Health h) =&gt; h.Value;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>explicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> Health(<span style=color:#8be9fd>int</span> v) =&gt; <span style=color:#ff79c6>new</span> Health(v);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 用法</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> hp = (<span style=color:#8be9fd>int</span>)<span style=color:#ff79c6>new</span> Health(<span style=color:#bd93f9>100</span>);
</span></span><span style=display:flex><span>Health h2 = (Health)hp;
</span></span></code></pre></div><p>从字符串解析对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>IPAddress</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>string</span> Address { <span style=color:#ff79c6>get</span>; <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> IPAddress(<span style=color:#8be9fd>string</span> addr) =&gt; Address = addr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>explicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> IPAddress(<span style=color:#8be9fd>string</span> input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 假设格式检查</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (input.Contains(<span style=color:#f1fa8c>&#34;.&#34;</span>))
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> IPAddress(input);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> FormatException(<span style=color:#f1fa8c>&#34;Invalid IP address&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=值类型与引用类型之间的转换>值类型与引用类型之间的转换</h3><h4 id=装箱boxing-值类型---引用类型>装箱（Boxing）=> 值类型 -> 引用类型</h4><p>将值类型转换为引用类型（通常是<code>object</code>或接口类型），该值会被拷贝一份并放到堆上，返回的是引用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>42</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>object</span> obj = i; <span style=color:#6272a4>// 装箱：int -&gt; object</span>
</span></span></code></pre></div><p>本质：</p><ol><li>在堆上分配一块内存</li><li>把<code>i</code>的值拷贝到堆上</li><li>包装成一个<code>System.ValueType</code>的实例</li><li>返回该引用（地址）</li></ol><p>注意：</p><ul><li>装箱是隐式的，自动进行</li><li>但是开销很大：堆分配 + 复制 + 类型信息封装</li></ul><h4 id=拆箱unboxing-引用类型---值类型>拆箱（Unboxing）=> 引用类型 -> 值类型</h4><p>将一个已经装箱的对象（如<code>object</code>）重新转换为其原始的值类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>object</span> obj = <span style=color:#bd93f9>42</span>; <span style=color:#6272a4>// 装箱</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> i = (<span style=color:#8be9fd>int</span>)obj; <span style=color:#6272a4>// 拆箱</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>float</span> f = (<span style=color:#8be9fd>float</span>)obj; <span style=color:#6272a4>// 抛出异常，不能拆箱为不同类型</span>
</span></span></code></pre></div><p>注意：</p><ul><li>拆箱是显式的，必须用强制类型转换<code>(T)</code></li><li>拆箱过程中必须提供原始的值类型，否则运行时会抛出<code>InvalidCastException</code></li></ul><h4 id=结构体和接口之间的装箱>结构体和接口之间的装箱</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>MyStruct</span> : IMyInterface
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> Value;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> DoSomething() =&gt; Console.WriteLine(Value);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>IMyInterface iface = <span style=color:#ff79c6>new</span> MyStruct { Value = <span style=color:#bd93f9>10</span> }; <span style=color:#6272a4>// 装箱</span>
</span></span><span style=display:flex><span>iface.DoSometing(); <span style=color:#6272a4>// iface是一个引用</span>
</span></span></code></pre></div><p>结构体实现接口时，赋值给接口类型变量会触发装箱，导致拷贝和性能损耗</p><h4 id=值类型转引用类型的其他形式>值类型转引用类型的其他形式</h4><ol><li>值类型 -><code>object</code>/<code>dynamic</code>/接口类型</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int</span> a = <span style=color:#bd93f9>5</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>object</span> obj = a; <span style=color:#6272a4>// boxing</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>dynamic</span> d = a; <span style=color:#6272a4>// boxing</span>
</span></span><span style=display:flex><span>IComparable cmp = a; <span style=color:#6272a4>// boxing</span>
</span></span></code></pre></div><ol start=2><li>使用泛型装箱陷阱</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>void</span> Print&lt;T&gt;(T <span style=color:#ff79c6>value</span>) =&gt; <span style=color:#8be9fd>object</span> obj = <span style=color:#ff79c6>value</span>; <span style=color:#6272a4>// 如果T是值类型，这里会装箱</span>
</span></span></code></pre></div><h4 id=值类型转换为引用类型的扩展方式>值类型转换为引用类型的扩展方式</h4><p>除了<code>object</code>、接口等默认机制，也可以在自定义类中自定义显式或隐式转换</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Health</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#ff79c6>value</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>implicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> Health(<span style=color:#8be9fd>int</span> <span style=color:#ff79c6>value</span>) =&gt; <span style=color:#ff79c6>new</span> Health { Value = <span style=color:#ff79c6>value</span>; };
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>explicit</span> <span style=color:#8be9fd;font-style:italic>operator</span> <span style=color:#8be9fd>int</span>(Health h) =&gt; h.Value;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样就可以</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Health h = <span style=color:#bd93f9>100</span>; <span style=color:#6272a4>// 隐式装箱为结构体（无引用）</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#ff79c6>value</span> = (<span style=color:#8be9fd>int</span>)h;
</span></span></code></pre></div><h4 id=避免装箱的优化建议>避免装箱的优化建议</h4><ul><li>接口调用结构体：使用泛型接口（如<code>IEquatable&lt;T></code>，或避免接口封装</li><li>Unity ECS：使用<code>struct</code> + <code>ref struct</code> + 泛型，尽量避免装箱</li><li>遍历集合：使用<code>for</code>遍历代替<code>foreach</code>（尤其对<code>struct</code>）</li><li>自定义数据结构：用泛型减少类型擦除、减少runtime装箱开销</li></ul><h3 id=string转基本类型>String转基本类型</h3><p>三种常见的转换方式</p><table><thead><tr><th>方法</th><th>是否安全</th><th>失败行为</th><th>备注</th></tr></thead><tbody><tr><td><code>Convert.ToXxx(string)</code></td><td>否</td><td>抛出异常</td><td>快捷但不安全</td></tr><tr><td><code>Xxx.Parse(string)</code></td><td>否</td><td>抛出异常</td><td>比较常见，但需自己 try-catch</td></tr><tr><td><code>Xxx.TryParse(string, out value)</code></td><td>是</td><td>返回 <code>false</code></td><td>推荐，性能更稳健</td></tr></tbody></table><h4 id=parse><code>Parse</code></h4><p><code>Parse</code>是一组用于将字符串转换为对应基本类型的方法，它们存在于相应类型的静态方法中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int</span>.Parse(<span style=color:#8be9fd>string</span>);
</span></span><span style=display:flex><span><span style=color:#8be9fd>float</span>.Parse(<span style=color:#8be9fd>string</span>);
</span></span><span style=display:flex><span>DateTime.Parse(<span style=color:#8be9fd>string</span>);
</span></span><span style=display:flex><span>Enum.Parse(Type, <span style=color:#8be9fd>string</span>)
</span></span></code></pre></div><p><code>Parse</code>是强类型转换的一种形式，要求输入格式必须合法，否则会抛出异常</p><h5 id=parse的基本行为><code>Parse</code>的基本行为</h5><ul><li>属于静态方法</li><li>输入必须是合法格式的字符串</li><li>失败时抛出异常</li><li>不安全，不建议用于不确定来源的字符串</li></ul><h5 id=常见类型的转换>常见类型的转换</h5><ul><li><code>int.Parse</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>int</span> num = <span style=color:#8be9fd>int</span>.Parse(<span style=color:#f1fa8c>&#34;123&#34;</span>); <span style=color:#6272a4>// OK</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> bad = <span style=color:#8be9fd>int</span>.Parse(<span style=color:#f1fa8c>&#34;abc&#34;</span>); <span style=color:#6272a4>// FormatException</span>
</span></span></code></pre></div><ul><li><code>float.Parse</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>float</span> pi = <span style=color:#8be9fd>float</span>.Parse(<span style=color:#f1fa8c>&#34;3.14&#34;</span>);
</span></span></code></pre></div><ul><li><code>bool.Parse</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>bool</span> b1 = <span style=color:#8be9fd>bool</span>.Parse(<span style=color:#f1fa8c>&#34;true&#34;</span>); <span style=color:#6272a4>// OK</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>bool</span> b2 = <span style=color:#8be9fd>bool</span>.Parse(<span style=color:#f1fa8c>&#34;FALSE&#34;</span>); <span style=color:#6272a4>// OK</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>bool</span> b3 = <span style=color:#8be9fd>bool</span>.Parse(<span style=color:#f1fa8c>&#34;yes&#34;</span>); <span style=color:#6272a4>// FormatException</span>
</span></span></code></pre></div><ul><li><code>DataTime.Parse</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>DataTime dt = DataTime.Parse(<span style=color:#f1fa8c>&#34;2025-07-29&#34;</span>);
</span></span></code></pre></div><p>支持多种格式，但有区域性依赖（受<code>CultureInfo</code>控制）</p><ul><li><code>Enum.Parse</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>enum</span> Direction { Up, Down, Left, Right }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Dirction d = (Direction)Enum.Parse(<span style=color:#ff79c6>typeof</span>(Direction), <span style=color:#f1fa8c>&#34;Up&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 也可以忽略大小写</span>
</span></span><span style=display:flex><span>Enum.Parse(<span style=color:#ff79c6>typeof</span>(Direction), <span style=color:#f1fa8c>&#34;down&#34;</span>, <span style=color:#ff79c6>true</span>);  <span style=color:#6272a4>// 返回 Direction.Down</span>
</span></span></code></pre></div><p><strong>常见异常</strong></p><table><thead><tr><th>异常类型</th><th>说明</th></tr></thead><tbody><tr><td><code>FormatException</code></td><td>字符串格式不合法</td></tr><tr><td><code>ArgumentNullException</code></td><td>传入的是 <code>null</code></td></tr><tr><td><code>OverflowException</code></td><td>数值超出类型范围（如 <code>int.Parse("999999999999")</code>）</td></tr></tbody></table><h5 id=自定义类中实现parse>自定义类中实现Parse</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>string</span> Name;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> Age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> Person Parse(<span style=color:#8be9fd>string</span> s)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>var</span> parts = s.Split(<span style=color:#f1fa8c>&#39;,&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> Person
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      Name = parts[<span style=color:#bd93f9>0</span>], 
</span></span><span style=display:flex><span>      Age = <span style=color:#8be9fd>int</span>.Parse(parts[<span style=color:#bd93f9>1</span>])
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Person p = Person.Parse(<span style=color:#f1fa8c>&#34;Jeff,24&#34;&#34;)
</span></span></span></code></pre></div><h4 id=tryparse><code>TryParse</code></h4><p><code>TryParse</code>是C#中用于安全地将字符串转换为基本类型的一种方法，它是<code>Parse</code>的安全替代方案。<code>TryParse</code>不会抛出异常，而是返回一个布尔值表示转换是否成功，转换结果通过<code>out</code>参数返回</p><h5 id=基本语法>基本语法</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>bool</span> TryParse(<span style=color:#8be9fd>string</span> s, <span style=color:#ff79c6>out</span> T result)
</span></span></code></pre></div><ul><li><code>s</code>：要转换的字符串</li><li><code>result</code>：输出参数，转换成功后的值，转换失败为0</li><li>返回值为<code>true</code>表示转换成功，<code>false</code>表示失败</li></ul><h5 id=基本类型的tryparse>基本类型的TryParse</h5><p><code>int.TryParse</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>string</span> input = <span style=color:#f1fa8c>&#34;123&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (<span style=color:#8be9fd>int</span>.TryParse(input, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>int</span> number))
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#f1fa8c>&#34;转换成功：&#34;</span> + number);
</span></span><span style=display:flex><span><span style=color:#ff79c6>else</span>
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#f1fa8c>&#34;转换失败&#34;</span>);
</span></span></code></pre></div><p><code>float.TryParse</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>float</span>.TryParse(<span style=color:#f1fa8c>&#34;3.14&#34;</span>, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>float</span> pi); <span style=color:#6272a4>// pi = 3.14</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>float</span>.TryParse(<span style=color:#f1fa8c>&#34;abc&#34;</span>, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>float</span> pi); <span style=color:#6272a4>// fail = 0</span>
</span></span></code></pre></div><p><code>bool.TryParse</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>bool</span>.TryParse(<span style=color:#f1fa8c>&#34;true&#34;</span>, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>bool</span> b1); <span style=color:#6272a4>// true</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>bool</span>.TryParse(<span style=color:#f1fa8c>&#34;yes&#34;</span>, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>bool</span> b2); <span style=color:#6272a4>// false</span>
</span></span></code></pre></div><h5 id=parse-vs-tryparse><code>Parse</code> vs <code>TryParse</code></h5><table><thead><tr><th>特性</th><th><code>Parse</code></th><th><code>TryParse</code></th></tr></thead><tbody><tr><td>失败处理方式</td><td>抛出异常</td><td>返回 false，不抛异常</td></tr><tr><td>推荐程度</td><td>不推荐（除非能确保输入）</td><td>推荐用于所有用户输入或不确定值</td></tr><tr><td>返回类型</td><td>转换后的类型</td><td><code>bool</code>（成功与否）</td></tr><tr><td>性能表现</td><td>较差（失败时抛异常开销大）</td><td>优秀，特别是在循环中</td></tr></tbody></table><h5 id=enumtryparses示例>Enum.TryParses示例</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>enum</span> Direction { Up, Down, Left, Right }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Enum.TryParse(<span style=color:#f1fa8c>&#34;Left&#34;</span>, <span style=color:#ff79c6>out</span> Direction d); <span style=color:#6272a4>// 成功</span>
</span></span><span style=display:flex><span>Enum.TryParse(<span style=color:#f1fa8c>&#34;INVALID&#34;</span>, <span style=color:#ff79c6>out</span> Dirction d2); <span style=color:#6272a4>// 失败，d2 = default(Direction)</span>
</span></span><span style=display:flex><span>Enum.TryParse(<span style=color:#f1fa8c>&#34;up&#34;</span>, ignoreCase: <span style=color:#ff79c6>true</span>, <span style=color:#ff79c6>out</span> Direction d3); <span style=color:#6272a4>// 忽略大小写</span>
</span></span></code></pre></div><p><code>Enum.TryParse&lt;TEnum>(string, bool ignoreCase, out TEnum)</code>是泛型形式，推荐使用</p><h5 id=封装通用tryparse方法>封装通用TryParse方法</h5><p>如果频繁使用TryParse，或者string要转复杂的大量的自定义类型，可以做以下封装，提高代码扩展性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>ParseHelper</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>bool</span> TryParse&lt;T&gt;(<span style=color:#8be9fd>string</span> input, <span style=color:#ff79c6>out</span> T result)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        result = <span style=color:#ff79c6>default</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>var</span> type = <span style=color:#ff79c6>typeof</span>(T);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (type == <span style=color:#ff79c6>typeof</span>(<span style=color:#8be9fd>int</span>) &amp;&amp; <span style=color:#8be9fd>int</span>.TryParse(input, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>int</span> i)) { result = (T)(<span style=color:#8be9fd>object</span>)i; <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>; }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (type == <span style=color:#ff79c6>typeof</span>(<span style=color:#8be9fd>float</span>) &amp;&amp; <span style=color:#8be9fd>float</span>.TryParse(input, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>float</span> f)) { result = (T)(<span style=color:#8be9fd>object</span>)f; <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>; }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (type == <span style=color:#ff79c6>typeof</span>(<span style=color:#8be9fd>bool</span>) &amp;&amp; <span style=color:#8be9fd>bool</span>.TryParse(input, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>bool</span> b)) { result = (T)(<span style=color:#8be9fd>object</span>)b; <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>; }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (type.IsEnum &amp;&amp; Enum.TryParse(type, input, <span style=color:#ff79c6>true</span>, <span style=color:#ff79c6>out</span> <span style=color:#8be9fd>object</span> e)) { result = (T)e; <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=convert><code>Convert</code></h3><p><code>Convert</code>类是C#中一个非常强大的工具，它提供了一些列静态方法，用于将各种类型之间进行转换</p><p>相比于<code>Parse</code>和<code>TryParse</code>，<code>Convert</code>在类型转换上更为宽松，支持更广泛的类型转换，不仅支持值类型和引用类型之间的转换，还可以处理不同类型之间的转换，如从<code>int</code>到<code>double</code>，从<code>DateTime</code>到<code>string</code>等</p><h4 id=convert类的作用><code>Convert</code>类的作用</h4><p><code>Convert</code>类位于<code>System</code>命名空间下，提供了一些非常常见的转换方法，它的作用主要包括：</p><ol><li><p>类型转换： 支持 值类型到值类型、引用类型到值类型、值类型到引用类型 的转换。</p></li><li><p>兼容性强： 能够在很多情况下进行类型的宽松转换，例如将数字类型（int、double、float）互相转换，或者将日期类型转换为字符串等。</p></li><li><p>null 处理： 与 Parse 不同，Convert 不会抛出异常，而是将 null 转换为适当的默认值。</p></li></ol><h4 id=convert常用方法><code>Convert</code>常用方法</h4><p><code>Convert</code>类提供了多个静态方法，以下是其中一些常用的方法</p><ul><li><code>Convert.ToInt32</code> / <code>Convert.ToInt64</code> / <code>Convert.ToDouble</code> / <code>Convert.ToBoolean</code>
这些方法会尝试将一个对象转换为目标类型，如果无法转换，会抛出异常</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>object</span> obj = <span style=color:#f1fa8c>&#34;123&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> num = Convert.ToInt32(obj); <span style=color:#6272a4>// 结果：123</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>object</span> nullObj = <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> result = Convert.ToInt32(nullObj); <span style=color:#6272a4>// 结果：0（null 转为默认值）</span>
</span></span></code></pre></div><ul><li><code>Convert.ToString</code>
将对象转换为字符串，如果对象是<code>null</code>，则返回空字符串</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>object</span> obj1 = <span style=color:#bd93f9>123</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>string</span> str1 = Convert.ToString(obj1); <span style=color:#6272a4>// 结果：&#34;123&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>object</span> obj2 = <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>string</span> str2 = Convert.ToString(obj2); <span style=color:#6272a4>// 结果&#34;&#34;（空字符串）</span>
</span></span></code></pre></div><ul><li><code>Convert.ToDateTime</code>
将对象转换为<code>DateTime</code>类型</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>object</span> obj = <span style=color:#f1fa8c>&#34;2025-07-29&#34;</span>;
</span></span><span style=display:flex><span>DateTime date = Convert.ToDateTime(obj); <span style=color:#6272a4>// 结果：2025/07/-29</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>object</span> obj2 = <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>DateTime date2 = Convert.ToDateTime(obj2); <span style=color:#6272a4>// 结果：01/01/0001 00：00：00（默认值）</span>
</span></span></code></pre></div><ul><li><code>Convert.ToDecimal</code>
将对象转换为<code>decimal</code>类型，禅功与金融和高精度计算</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>object</span> obj = <span style=color:#bd93f9>3.14f</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>decimal</span> dec = Convert.ToDecimal(obj);  <span style=color:#6272a4>// 结果：3.14</span>
</span></span></code></pre></div><ul><li><code>Convert.ChangeType</code>
<code>Convert.ChangeType</code>是一种非常强大的方法，允许将对象转换为任何类型，但必须指定目标类型。适合于更动态的场景<br>它的强大之处在于可以第二个参数，可以在运行时动态获得<br>它返回一个object类型</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#8be9fd>object</span> obj = <span style=color:#bd93f9>123</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> num = (<span style=color:#8be9fd>int</span>)Convert.ChangeType(obj, <span style=color:#ff79c6>typeof</span>(<span style=color:#8be9fd>int</span>));  <span style=color:#6272a4>// 结果：123</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>object</span> strObj = <span style=color:#f1fa8c>&#34;2025-07-29&#34;</span>;
</span></span><span style=display:flex><span>DateTime date = (DateTime)Convert.ChangeType(strObj, <span style=color:#ff79c6>typeof</span>(DateTime));  <span style=color:#6272a4>// 结果：2025/07/29</span>
</span></span></code></pre></div><p><code>Convert.ChangeType</code>是通过反射来实现的，适用于需要动态类型转换的情况
<code>Convert.ChangeType</code>没有对null的特殊处理，所以当将null转换为非空类型时会抛出异常，需要进行显式处理</p><h4 id=convert内部原理>Convert内部原理</h4><ol><li>基于 IConvertible 接口：C# 中的大部分类型（如 int、float、double、DateTime、string 等）都实现了 IConvertible 接口，Convert 类使用该接口提供的转换方法来执行类型转换。</li><li>处理 null 值：Convert 类会自动将 null 转换为该类型的默认值。例如，Convert.ToInt32(null) 会返回 0，Convert.ToDateTime(null) 会返回 DateTime.MinValue，而Convert.ChangeType需要显式处理</li><li>类型溢出处理：Convert 会根据目标类型的大小范围执行适当的类型溢出检查。如果值超出目标类型的范围，Convert 会抛出 OverflowException。</li><li>宽松转换：Convert 会尽可能地进行宽松的类型转换，比如将 int 转换为 double，将 float 转换为 decimal 等。但有些类型无法自动转换，如将 string 转换为 int（必须是格式正确的字符串）。</li></ol></div><nav class=post-nav><a href=/dotnetandwindows/log/datastructure/ class=hover:underline>pre: Data Structure</a>
<a href=/dotnetandwindows/log/delegate/ class=hover:underline>next: Delegate</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#值类型value-types>值类型（Value Types）</a><ul><li><a href=#特点>特点</a></li><li><a href=#常见的值类型>常见的值类型</a></li><li><a href=#systemvaluetype>System.ValueType</a></li><li><a href=#valuetype的作用>ValueType的作用</a></li></ul></li><li><a href=#引用类型reference-types>引用类型(Reference Types)</a><ul><li><a href=#深拷贝与浅拷贝>深拷贝与浅拷贝</a></li><li><a href=#引用类型的默认行为>引用类型的默认行为</a></li><li><a href=#引用类型与gc>引用类型与GC</a></li><li><a href=#为什么需要引用对象>为什么需要引用对象</a></li><li><a href=#为什么引用类型内容在堆上>为什么引用类型内容在堆上</a></li><li><a href=#object>Object</a><ul><li><a href=#objectobjectsystemobject><code>Object</code>、<code>object</code>、<code>System.Object</code></a></li></ul></li><li><a href=#string>String</a><ul><li><a href=#string的不可变性>String的不可变性</a></li><li><a href=#字符串驻留interning>字符串驻留（Interning）</a><ul><li><a href=#实现机制>实现机制</a></li></ul></li><li><a href=#string的特殊性>string的特殊性</a></li><li><a href=#string的实现>string的实现</a></li><li><a href=#字符串操作效率问题>字符串操作效率问题</a></li><li><a href=#api>API</a></li></ul></li><li><a href=#dynamic慎用>Dynamic（慎用）</a></li></ul></li><li><a href=#指针类型pointer-types>指针类型（Pointer Types）</a><ul><li><a href=#语法>语法</a></li></ul></li><li><a href=#类型转换>类型转换</a><ul><li><a href=#隐式转换implicit>隐式转换（implicit）</a><ul><li><a href=#内置类型的隐式转换>内置类型的隐式转换</a></li><li><a href=#自定义类型中的隐式转换>自定义类型中的隐式转换</a></li><li><a href=#注意事项>注意事项</a></li><li><a href=#示例封装单位系统>示例：封装单位系统</a></li></ul></li><li><a href=#显式转换cast>显式转换（cast）</a><ul><li><a href=#内置类型的显式转换>内置类型的显式转换</a></li><li><a href=#显式转换的本质>显式转换的本质</a></li><li><a href=#隐式转换-vs-显式转换>隐式转换 vs 显式转换</a></li><li><a href=#示例>示例</a></li></ul></li><li><a href=#值类型与引用类型之间的转换>值类型与引用类型之间的转换</a><ul><li><a href=#装箱boxing-值类型---引用类型>装箱（Boxing）=> 值类型 -> 引用类型</a></li><li><a href=#拆箱unboxing-引用类型---值类型>拆箱（Unboxing）=> 引用类型 -> 值类型</a></li><li><a href=#结构体和接口之间的装箱>结构体和接口之间的装箱</a></li><li><a href=#值类型转引用类型的其他形式>值类型转引用类型的其他形式</a></li><li><a href=#值类型转换为引用类型的扩展方式>值类型转换为引用类型的扩展方式</a></li><li><a href=#避免装箱的优化建议>避免装箱的优化建议</a></li></ul></li><li><a href=#string转基本类型>String转基本类型</a><ul><li><a href=#parse><code>Parse</code></a><ul><li><a href=#parse的基本行为><code>Parse</code>的基本行为</a></li><li><a href=#常见类型的转换>常见类型的转换</a></li><li><a href=#自定义类中实现parse>自定义类中实现Parse</a></li></ul></li><li><a href=#tryparse><code>TryParse</code></a><ul><li><a href=#基本语法>基本语法</a></li><li><a href=#基本类型的tryparse>基本类型的TryParse</a></li><li><a href=#parse-vs-tryparse><code>Parse</code> vs <code>TryParse</code></a></li><li><a href=#enumtryparses示例>Enum.TryParses示例</a></li><li><a href=#封装通用tryparse方法>封装通用TryParse方法</a></li></ul></li></ul></li><li><a href=#convert><code>Convert</code></a><ul><li><a href=#convert类的作用><code>Convert</code>类的作用</a></li><li><a href=#convert常用方法><code>Convert</code>常用方法</a></li><li><a href=#convert内部原理>Convert内部原理</a></li></ul></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>