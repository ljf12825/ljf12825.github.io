<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Control Blocks</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/log/>Log</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/ target=_blank>lua.org</a>
<a href=https://www.luarocks.org/ target=_blank>luarocks.org</a>
<a href=https://www.luajit.org/ target=_blank>luajit.org</a></p><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Control Blocks<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><h3 id=while--do-while>while / do while</h3><h4 id=while><code>while</code></h4><p>用于事前检查型循环，常见于：</p><ul><li><p>等待条件成立</p></li><li><p>迭代器遍历</p></li><li><p>流式读取</p></li><li><p>基本结构</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>while</span> (condition)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// loop body</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>先判断条件</li><li>条件为<code>true</code> -> 执行循环体</li><li>条件为<code>false</code> -> 直接跳出循环</li></ol><h4 id=do-while><code>do while</code></h4><p>用于必须先执行依次的场景，例如</p><ul><li>菜单输入循环</li><li>用户输入验证</li><li>游戏主循环（update-loop原型）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// loop body</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (condition)
</span></span></code></pre></div><p>执行逻辑：</p><ol><li>先执行循环体一次</li><li>再判断条件</li><li>条件为<code>true</code> -> 继续循环</li><li>否则跳出</li></ol><h3 id=for-foreach-getenumerator><code>for</code>, <code>foreach</code>, <code>GetEnumerator()</code></h3><h4 id=for><code>for</code></h4><p>最原始，最接近机器模型的循环<br>语法本质</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>init</span>; condition; iterator)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	body
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是纯语法结构，不是方法，也不是接口驱动的<br>编译器做的事情非常直接</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>init</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (condition)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	body;
</span></span><span style=display:flex><span>	iterator;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=核心特性>核心特性</h5><ul><li>完全程序员控制<ul><li>循环变量生命周期</li><li>步进方式</li><li>终止条件</li></ul></li><li>不依赖任何接口</li><li>可被JIT极度优化<ul><li>边界检查消除（bounds check elimination）</li><li>向量化（SIMD）</li><li>循环展开（unrolling）</li></ul></li></ul><h5 id=性能与内存视角>性能与内存视角</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; arr.Length; i++)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	sum += arr[i];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>JIT在这里可以做到</p><ul><li><code>arr.Length</code>hoist到循坏外</li><li>消除重复bounds check</li><li>使用寄存器保存<code>i</code></li><li>几乎等价于C/C++循环</li></ul><p>这也是为什么数值计算、引擎代码、热路径几乎只用<code>for</code></p><h4 id=foreach与getenumerator><code>foreach</code>与<code>GetEnumerator</code></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> x <span style=color:#66d9ef>in</span> collection)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	body;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>foreach</code>是编译器级别的语法糖，核心依赖<code>GetEnumerator()</code>协议，但它不是简单地调用接口</p><h5 id=foreach查找规则><code>foreach</code>查找规则</h5><p>注意：<code>foreach</code>不要求类型实现<code>IEnumerable</code>接口**<br>编译器在看到 <code>foreach (var x in expr)</code> 时，会按顺序尝试</p><h6 id=1-是否存在可访问的实例方法>1. 是否存在可访问的实例方法</h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>GetEnumerator()
</span></span></code></pre></div><p>返回的类型（Enumerator）必须满足</p><ul><li>有<code>bool MoveNext</code></li><li>有<code>Current</code>属性（或字段）</li></ul><p>不要求接口，不要求继承，只要“形状匹配”，即duck typing，但发生在编译期</p><h6 id=2-如果没有实例方法>2. 如果没有实例方法</h6><p>尝试扩展方法<code>GetEnumerator()</code></p><h6 id=3-如果都没有>3. 如果都没有</h6><p>才退化为</p><ul><li><code>IEnumerable</code></li><li><code>IEnumerable&lt;T></code></li></ul><h5 id=一个非接口的枚举器例子>一个“非接口”的枚举器例子</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyCollection</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Enumerator GetEnumerator() =&gt; <span style=color:#66d9ef>new</span> Enumerator();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Enumerator</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Current =&gt; i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> MoveNext()
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			i++;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> i &lt; <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>完全合法的<code>foreach</code>对象，没有接口，没有继承，没有装箱，编译器在编译期通过形状匹配识别枚举器</p><h5 id=编译器对foreach的处理>编译器对<code>foreach</code>的处理</h5><ol><li>源代码</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> x <span style=color:#66d9ef>in</span> collection)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Do(x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>编译器展开（概念等价）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> enumerator = collection.GetEnumerator();
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (enumerator.MoveNext())
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> x = enumerator.Current;
</span></span><span style=display:flex><span>		Do(x);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>finally</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (enumerator <span style=color:#66d9ef>is</span> IDisposable d)
</span></span><span style=display:flex><span>		d.Dispose();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=getenumerator><code>GetEnumerator()</code></h5><h6 id=基本概念>基本概念</h6><p><code>GetEnumerator()</code>是一个方法，用来获取集合的枚举器（Enumerator）。枚举器是对象或结构体，负责在循环中提供“当前元素”和迭代状态</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; list = <span style=color:#66d9ef>new</span>() { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> enumerator = list.GetEnumerator();
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (enumerator.MoveNext())
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> x = enumerator.Current;
</span></span><span style=display:flex><span>	Console.WriteLine(x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>foreach</code>就是编译器把循环展开成调用<code>GetEnumerator()</code> + <code>MoveNext()</code> + <code>Current</code></li></ul><h6 id=语言层定义>语言层定义</h6><p>在C#中，<code>GetEnumerator()</code>有两种常见签名</p><ol><li>非泛型版本（<code>IEnumerable</code>）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerator IEnumerable.GetEnumerator();
</span></span></code></pre></div><p>返回IEnumerator，只提供<code>object Current</code></p><ol start=2><li>泛型版本（<code>IEnumerable&lt;T></code>）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator();
</span></span></code></pre></div><p>返回IEnumerator<t>，提供类型安全的<code>T Current</code></p><h6 id=getenumerator与枚举器协议><code>GetEnumerator()</code>与枚举器协议</h6><p>枚举器协议：C#编译器规定，只要返回对象满足以下条件就可以用于<code>foreach</code></p><ul><li>有<code>MoveNext()</code>方法，返回<code>bool</code></li><li>有<code>Current</code>属性（类型可以是<code>T</code>或<code>object</code>）</li><li>可选：实现IDisposable，编译器会在<code>finally</code>自动调用</li></ul><blockquote><p>不要求实现<code>IEnumerator</code>接口，只要“形状匹配”即可</p></blockquote><h6 id=getenumerator的两种实现方式><code>GetEnumerator()</code>的两种实现方式</h6><ol><li>类似数组<code>List&lt;T></code>的结构体枚举器<ul><li>返回struct，避免装箱</li><li>JIT可内联<code>MoveNext()</code>和<code>Current</code>，性能接近<code>for</code></li><li>保存索引和版本号</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Enumerator</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> List&lt;T&gt; _list;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _index;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _version;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T Current =&gt; _list[_index];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> MoveNext() { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>yield / iterator 生成器<ul><li>编译器自动生成 state machine类</li><li><code>GetEnumerator()</code>返回class类型的枚举器</li><li><code>MoveNext</code>内部控制状态机</li><li>支持延迟计算</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerable&lt;<span style=color:#66d9ef>int</span>&gt; Numbers()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>实际生成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NumbersIterator</span> : IEnumerable&lt;<span style=color:#66d9ef>int</span>&gt;, IEnumerator&lt;<span style=color:#66d9ef>int</span>&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> state;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> current;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> MoveNext() { ... }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Current =&gt; current;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> IEnumerator&lt;<span style=color:#66d9ef>int</span>&gt; GetEnumerator() =&gt; <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=getenumerator存在的意义><code>GetEnumerator</code>存在的意义</h5><p>回到最开始的问题，<code>foreach</code>不要求类型实现<code>IEnumerable</code>接口，可以通过<code>GetEnumerator</code>，而不是只靠接口<br>原因只有一个：性能 + 表达力</p><ul><li>接口 -> 必然虚调用</li><li>值类型 + 接口 -> 必然装箱</li></ul><p>这是高性能场景无法接受的<br>所有C#选择：编译期协议，而非运行时</p><h5 id=值类型枚举器-vs-接口枚举器>值类型枚举器 vs 接口枚举器</h5><p>为什么<code>List&lt;T>.foreach</code>很快</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> x <span style=color:#66d9ef>in</span> list)
</span></span></code></pre></div><p>因为</p><ul><li><code>List&lt;T>.Enumerator</code>是struct</li><li><code>GetEnumerator()</code>返回具体类型</li><li>没有接口调用</li><li>没有装箱</li><li>JIT可以内联<code>MoveNext()</code></li></ul><p>慢的情况</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerable&lt;<span style=color:#66d9ef>int</span>&gt; e = list;
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> x <span style=color:#66d9ef>in</span> e)
</span></span></code></pre></div><p>此时</p><ul><li>使用<code>IEnumerator&lt;int></code>接口</li><li><code>struct Enumerator</code>被装箱</li><li><code>MoveNext</code>是虚调用</li><li>性能显著下降</li></ul><h5 id=只读遍历>只读遍历</h5><p>这是一个语言设计层面的“硬约束”问题，C#无法、也不愿意，为<code>foreach</code>保证“可写语义”在所有枚举器模型下成立</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> x <span style=color:#66d9ef>in</span> list)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	x = <span style=color:#ae81ff>10</span> ; <span style=color:#75715e>// 编译错误</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>或</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>int</span> x <span style=color:#66d9ef>in</span> array)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	x++; <span style=color:#75715e>// 不影响原数组</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>x = ...</code>直接报错（语法层）</li><li><code>x++</code>不生效（语义层）</li></ul><p>原因不完全相同但本质一致</p><h6 id=foreach的核心语义><code>foreach</code>的核心语义</h6><p>编译器对<code>foreach</code>的展开中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> x = enumerator.Current;
</span></span></code></pre></div><p><code>Current</code>是一个属性，属性返回值，不是可写引用。<code>foreach</code>根本不知道你枚举的是什么东西</p><p><code>GetEnumerator</code>协议只要求</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>bool</span> MoveNext();
</span></span><span style=display:flex><span>T Current { <span style=color:#66d9ef>get</span>; }
</span></span></code></pre></div><ul><li>没有<code>set</code></li><li>没有“回写”语义</li></ul><p>因此，语言层面只能承诺：可以读到一个元素，而不是可以修改集合中的这个位置</p><h6 id=为什么不能设计成可写foreach>为什么不能设计成“可写foreach”</h6><ol><li>因为很多集合根本不存在“可写位置”</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerable&lt;<span style=color:#66d9ef>int</span>&gt; Numbers()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里的<code>Current</code>不是数组元素，不是内存位置，是状态机计算出来的临时值</p><ol start=2><li>即使是数组，也存在歧义</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> x <span style=color:#66d9ef>in</span> GetArray())
</span></span><span style=display:flex><span>{ 
</span></span><span style=display:flex><span>	x = <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>GetArray()</code>是什么？未知</p><h6 id=值类型枚举器>值类型枚举器</h6><p>常见枚举器是<code>struct</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;T&gt;.Enumerator : <span style=color:#66d9ef>struct</span>
</span></span></code></pre></div><p>如果允许</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> x <span style=color:#66d9ef>in</span> list)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	x = ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>那等价于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>enumerator.Current = ...
</span></span></code></pre></div><p>但问题是</p><ul><li><code>enumerator</code>是值类型</li><li><code>Current</code>是属性</li><li>属性返回的是副本</li></ul><p>如果强行支持，会导致灾难性不一致：值类型可改，引用类型不可改，这在语言设计上是不可接受的<br>C#的设计原则是：宁可统一禁止，也不制造“看起来能用、但实际上不可靠”的语义</p><h6 id=foreach中允许修改对象的字段><code>foreach</code>中允许修改对象的字段</h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> obj <span style=color:#66d9ef>in</span> list)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	obj.Value = <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// 合法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>obj</code>是引用的拷贝，拷贝的是地址，修改的是对象本体；没有修改“枚举变量”，而是修改它指向的对象，这和<code>foreach</code>的只读规则不冲突</p><h6 id=ref-foreach><code>ref foreach</code></h6><p>C# 7.3 引入特例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>ref</span> <span style=color:#66d9ef>var</span> x <span style=color:#66d9ef>in</span> array)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	x = <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里成立是因为</p><ul><li>数组元素有稳定内存地址</li><li>编译器能拿到<code>ref T</code></li><li>完全没有枚举器抽象</li></ul><p>这是专门为数组和Span设计的“受限逃生口”</p><p>为什么不能对所有IEnumerable生效？<br>因为</p><ul><li>大多数枚举器无法提供ref返回</li><li><code>ref T Current</code>会破坏现有协议</li><li>会强迫所有集合暴露内部存储</li></ul><p>这是不可接收的API破坏</p><h5 id=版本检查>版本检查</h5><h6 id=定义>定义</h6><ul><li>几乎所有可变集合(<code>List&lt;T></code>, <code>Dictionary&lt;TKey, TValue></code>等)都有一个内部整型字段，通常叫<code>_version</code>或类似名字</li><li>初始值：通常从0开始</li><li>每次修改集合都会让<code>_version</code>增加</li></ul><h6 id=作用>作用</h6><p>检测枚举器在枚举期间是否被修改</p><ul><li>如果在<code>foreach</code>迭代过程中修改了集合，枚举器会通过对比版本号发现不一致，然后抛出<code>InvalidOperationException</code></li><li>这是fail-fast（枚举器一致性检查）机制，防止隐藏的bug（比如数组越界、引用失效）</li></ul><h6 id=运行机制>运行机制</h6><p>枚举开始前保存枚举器开始时的集合版本，每次<code>MoveNext()</code>检查<code>_version</code>是否匹配，不匹配则抛出异常</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>List</span>&lt;T&gt; : IEnumerable&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _version;  <span style=color:#75715e>// 每次修改集合时递增</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> T[] _items;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Add(T item)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ... 添加逻辑</span>
</span></span><span style=display:flex><span>        _version++;  <span style=color:#75715e>// 修改后版本号递增</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Enumerator</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> List&lt;T&gt; _list;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _index;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _version;  <span style=color:#75715e>// 保存迭代开始时的版本号</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Enumerator(List&lt;T&gt; list)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            _list = list;
</span></span><span style=display:flex><span>            _index = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            _version = list._version;  <span style=color:#75715e>// 捕获当前版本</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> MoveNext()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 关键检查！</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (_version != _list._version)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InvalidOperationException(
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;Collection was modified; enumeration operation may not execute.&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ... 正常的迭代逻辑</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>正常情况（没有修改）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; list = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt; { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> item <span style=color:#66d9ef>in</span> list) <span style=color:#75715e>// 创建枚举器：_version = 1</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Console.WriteLine(item); <span style=color:#75715e>// MoveNext() 检查：1 == 1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 顺利执行完成</span>
</span></span></code></pre></div><ul><li>异常情况</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; list = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt; { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> item <span style=color:#66d9ef>in</span> list) <span style=color:#75715e>// 创建枚举器 _version = 1</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Console.WriteLine(item);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (item == <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		lsit.Add(<span style=color:#ae81ff>4</span>); <span style=color:#75715e>// 修改集合：_version = 2</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 下次 MoveNext() 检查失败，抛出异常</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// InvalidOperationException</span>
</span></span></code></pre></div><h4 id=值类型struct下的行为不同点>值类型（struct）下的行为不同点</h4><p><code>foreach</code>中结构体是拷贝副本</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyStruct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> X;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Mystruct[] arr = { <span style=color:#66d9ef>new</span> MyStruct { X = <span style=color:#ae81ff>1</span> } };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> s <span style=color:#66d9ef>in</span> arr) s.X = <span style=color:#ae81ff>999</span>; <span style=color:#75715e>// 改变的是副本原数组不会改变</span>
</span></span></code></pre></div><p>而<code>for</code>中是通过索引器访问，直接修改原始结构体</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; arr.Length; ++i) arr[i].X = <span style=color:#ae81ff>999</span>; <span style=color:#75715e>// 真正修改了数组中的元素</span>
</span></span></code></pre></div><h4 id=适用场景>适用场景</h4><ul><li><p><code>for</code></p><ul><li>性能关键路径</li><li>需要修改集合元素，可在遍历时直接修改</li><li>复杂迭代逻辑</li></ul></li><li><p><code>foreach</code></p><ul><li>只读遍历</li><li>不确定集合类型时</li><li>自定义集合（实现了GetEnumerator）</li></ul></li><li><p><code>GetEnumerator()</code></p><ul><li>设计自定义集合时</li></ul></li></ul><h3 id=if>if</h3><h4 id=基本结构>基本结构</h4><p><code>if</code>是C#中最常见的条件分支语句</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (condition expr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 条件为 true 时执行的代码</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以加上</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (expr1)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// expr1 成立</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (expr2)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// expr2 成立</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 前面的都不成立</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=条件表达式的要求>条件表达式的要求</h4><p>C#中<code>if</code>后面必须是一个布尔类型表达式（<code>bool</code>）<br>不像C/C++那样可以把<code>int</code>当成真假</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> x = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// if (x) // Error: Cannot implicitly convert type &#39;int&#39; to &#39;bool&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (x != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>&#34;x is not zero&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这体现了C#更强的类型安全设计理念</p><h4 id=简写与嵌套>简写与嵌套</h4><ol><li>单行简写
如果只有一条语句，可以省略花括号（但不推荐）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (score &gt; <span style=color:#ae81ff>90</span>)
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>&#34;Excellent&#34;</span>);
</span></span></code></pre></div><ol start=2><li>嵌套if</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (age &gt; <span style=color:#ae81ff>18</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (hasID)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		Console.WriteLine(<span style=color:#e6db74>&#34;Access granted&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>嵌套太多会让逻辑混乱，建议使用<code>&&</code>、<code>||</code>合并逻辑或提取函数</p><h4 id=进阶写法>进阶写法</h4><ol><li>条件表达式（三元运算符）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>string</span> msg = (score &gt;= <span style=color:#ae81ff>60</span>) ? <span style=color:#e6db74>&#34;及格&#34;</span> : <span style=color:#e6db74>&#34;不及格&#34;</span>;
</span></span></code></pre></div><p>相当于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (score &gt;= <span style=color:#ae81ff>60</span>)
</span></span><span style=display:flex><span>	msg = <span style=color:#e6db74>&#34;及格&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> 
</span></span><span style=display:flex><span>	msg=<span style=color:#e6db74>&#34;不及格&#34;</span>;
</span></span></code></pre></div><ol start=2><li><code>if</code>与<code>var</code>结合</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>int</span>.TryParse(input, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>var</span> number))
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>$&#34;输入了数字 {number}&#34;</span>)<span style=color:#960050;background-color:#1e0010>；</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> Console.WriteLine(<span style=color:#e6db74>&#34;输入无效&#34;</span>)<span style=color:#960050;background-color:#1e0010>；</span>
</span></span></code></pre></div><p>这里的<code>number</code>只在<code>if</code>的作用域内有效</p><h4 id=常见陷阱>常见陷阱</h4><ol><li>多行省略花括号陷阱</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (flag)
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>&#34;Yes&#34;</span>);
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>&#34;No&#34;</span>); <span style=color:#75715e>// 这行总会执行</span>
</span></span></code></pre></div><ol start=2><li>混用<code>=</code>和<code>==</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (a = <span style=color:#66d9ef>true</span>) <span style=color:#75715e>// 编译错误</span>
</span></span></code></pre></div><p>C#特意设计为错误，防止C风格的低级错误</p><p><code>if</code>是控制流的最小单元，但成熟的代码尽量减少显式if</p><ul><li>通过策略模式、多态、字典映射、switch表达式替代复杂分支</li><li><code>if</code>应该表达“决策点”，而不是“流程泥潭”</li></ul><h3 id=switch>switch</h3><h4 id=基础语法c早期版本>基础语法（C#早期版本）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>switch</span> (day)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>		Console.WriteLine(<span style=color:#e6db74>&#34;Monday&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>		Console.WriteLine(<span style=color:#e6db74>&#34;Tuesday&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>		Console.WriteLine(<span style=color:#e6db74>&#34;Unknown&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>switch</code>表达式里的值必须是整型、枚举或字符串（早期限制，现在放宽）</li><li>每个<code>case</code>后必须<code>break</code>（或<code>return</code>、<code>throw</code>）</li><li><code>default</code>是可选的，用来兜底</li></ul><h4 id=字符串与枚举支持>字符串与枚举支持</h4><p>C#从早期版本就支持</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>switch</span> (command)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;start&#34;</span>:
</span></span><span style=display:flex><span>		Start();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;stop&#34;</span>:
</span></span><span style=display:flex><span>		Stop();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>枚举更常见</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>enum</span> Direction { Up, Down, Left, Right }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>switch</span> (dir)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> Direction.Up:
</span></span><span style=display:flex><span>		MoveUp();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=c7模式匹配>C#7+模式匹配</h4><p>C# 7开始，<code>switch</code>不再局限于“相等比较”，而是能做类型匹配与条件判断</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>object</span> obj = <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>switch</span> (obj)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span> i when i &gt; <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>		Console.WriteLine(<span style=color:#e6db74>$&#34;正整数: {i}&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>string</span> s:
</span></span><span style=display:flex><span>		Console.WriteLine(<span style=color:#e6db74>$&#34;字符串: {s}&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>		Console.WriteLine(<span style=color:#e6db74>$&#34;null 值&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>		Console.WriteLine(<span style=color:#e6db74>$&#34;未知类型&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里引入了两个关键点</p><ol><li>类型模式（<code>case int i</code>）
自动检测类型并声明局部变量</li><li>条件保护(when)
让<code>case</code>可以附加逻辑判断</li></ol><h4 id=c-8-新写法switch-表达式>C# 8+ 新写法：<code>switch 表达式</code></h4><p><code>switch</code>不再是语句(statement)，而是表达式(expression)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>string</span> GetDayType(<span style=color:#66d9ef>int</span> day) =&gt;
</span></span><span style=display:flex><span>	day <span style=color:#66d9ef>switch</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>1</span> or <span style=color:#ae81ff>2</span> or <span style=color:#ae81ff>3</span> or <span style=color:#ae81ff>4</span> or <span style=color:#ae81ff>5</span> =&gt; <span style=color:#e6db74>&#34;工作日&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>6</span> or <span style=color:#ae81ff>7</span> =&gt; <span style=color:#e6db74>&#34;周末&#34;</span>
</span></span><span style=display:flex><span>		_ =&gt; <span style=color:#e6db74>&#34;未知&#34;</span>
</span></span><span style=display:flex><span>	};
</span></span></code></pre></div><ul><li>不需要<code>break</code></li><li>用箭头表达式(<code>=></code>)</li><li>支持逻辑模式（<code>or</code>/<code>and</code>/<code>_</code>通配符）</li><li>返回值直接表达逻辑结果，更函数时、更干净</li></ul><h5 id=语句statement与表达式expression>语句(statement)与表达式(expression)</h5><table><thead><tr><th>概念</th><th>定义</th><th>特点</th><th>结果</th></tr></thead><tbody><tr><td>表达式（Expression）</td><td>能计算出一个值的代码单元</td><td>有值、有类型、可嵌套</td><td>产生一个结果</td></tr><tr><td>语句（Statement）</td><td>执行某种操作或行为的代码单元</td><td>无值、控制流程、作用于状态</td><td>不产生值（或值被丢弃）</td></tr></tbody></table><blockquote><p>表达式是“有结果的东西”，语句是“做事的东西”</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> x = <span style=color:#ae81ff>3</span> + <span style=color:#ae81ff>4</span>;
</span></span></code></pre></div><ul><li><code>3 + 4</code> 表达式（它有值：7）</li><li><code>int x = 3 + 4</code> 语句（它做了一件事：定义并赋值变量）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>x = y * <span style=color:#ae81ff>2</span>;
</span></span></code></pre></div><ul><li><code>y * 2</code>是表达式（有值）</li><li>整句<code>x = y * 2</code>是语句（执行赋值动作）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (x &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	y = <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><ul><li><code>(x > 0)</code>是表达式（返回<code>true</code>或<code>false</code>）</li><li><code>if (...) y = 1;</code>是语句（控制执行流程）</li></ul><ol><li>表达式可以嵌套、组合</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> z = (x + y) * max(<span style=color:#ae81ff>3</span>, f(<span style=color:#ae81ff>2</span>));
</span></span></code></pre></div><p>整个都是表达式，嵌套了函数调用、算术运算、常量等</p><ol start=2><li>语句控制执行顺序</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (...) { ... }
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (...) { ... }
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> ...;
</span></span></code></pre></div><p>它们决定代码“什么时候做什么事”，但自身不返回值</p><ol start=3><li>部分语言模糊两者界限</li></ol><ul><li>在C、C++、C#里：语句和表达式是分开的</li><li>在Python、Rust、Scala、F#里：很多语句其实都是表达式</li></ul><p>现代语言设计趋向于“让语句表达式化”，这样可以写出更简洁的代码</p><h4 id=c-912的进一步强化>C# 9~12的进一步强化</h4><ol><li>关系模式</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>string</span> GetTempDesc(<span style=color:#66d9ef>double</span> t) =&gt; t <span style=color:#66d9ef>switch</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	&lt; <span style=color:#ae81ff>0</span> =&gt; <span style=color:#e6db74>&#34;冰点以下&#34;</span>,
</span></span><span style=display:flex><span>	&gt;= <span style=color:#ae81ff>0</span> and &lt; <span style=color:#ae81ff>30</span> =&gt; <span style=color:#e6db74>&#34;正常&#34;</span>,
</span></span><span style=display:flex><span>	&gt;= <span style=color:#ae81ff>30</span> =&gt; <span style=color:#e6db74>&#34;高温&#34;</span>,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ol start=2><li>属性模式</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Person p = <span style=color:#66d9ef>new</span> Person { Name = <span style=color:#e6db74>&#34;Tom&#34;</span>, Age = <span style=color:#ae81ff>20</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> type = p <span style=color:#66d9ef>switch</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	{ Age: &lt; <span style=color:#ae81ff>18</span> } =&gt; <span style=color:#e6db74>&#34;未成年&#34;</span>,
</span></span><span style=display:flex><span>	{ Age: &gt;= <span style=color:#ae81ff>18</span> and &lt; <span style=color:#ae81ff>65</span> } =&gt; <span style=color:#e6db74>&#34;成年人&#34;</span>,
</span></span><span style=display:flex><span>	{ Age: &gt;= <span style=color:#ae81ff>65</span> } =&gt; <span style=color:#e6db74>&#34;老年人&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>嵌套解构模式</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> result = point <span style=color:#66d9ef>switch</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	{ X: <span style=color:#ae81ff>0</span>, Y: <span style=color:#ae81ff>0</span> } =&gt; <span style=color:#e6db74>&#34;原点&#34;</span>,
</span></span><span style=display:flex><span>	{ X: &gt; <span style=color:#ae81ff>0</span>, Y: &gt; <span style=color:#ae81ff>0</span> } =&gt; <span style=color:#e6db74>&#34;第一象限&#34;</span>,
</span></span><span style=display:flex><span>	_ =&gt; <span style=color:#e6db74>&#34;其他&#34;</span>, 
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这些新特性让<code>switch</code>变成一种模式匹配引擎，而不仅仅是分支语句</p><h4 id=常见陷阱-1>常见陷阱</h4><ol><li>忘了<code>break</code>（老语法会导致穿透）</li><li>混用值类型和引用类型导致匹配失败</li><li>早期C#不支持多个<code>case</code>合并，现在可用<code>or</code></li></ol><h4 id=核心哲学>核心哲学</h4><p>C#的<code>switch</code>从命令式走向声明式，从“判断谁”变成“描述模式”<br>这种变化的本质，是把控制流逻辑结构化、数据化、函数化</p></div><nav class=post-nav><a href=/dotnetandwindows/log/clr/ class=hover:underline>pre: CLR</a>
<a href=/dotnetandwindows/log/datastructure/ class=hover:underline>next: Data Structure</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#while--do-while>while / do while</a><ul><li><a href=#while><code>while</code></a></li><li><a href=#do-while><code>do while</code></a></li></ul></li><li><a href=#for-foreach-getenumerator><code>for</code>, <code>foreach</code>, <code>GetEnumerator()</code></a><ul><li><a href=#for><code>for</code></a><ul><li><a href=#核心特性>核心特性</a></li><li><a href=#性能与内存视角>性能与内存视角</a></li></ul></li><li><a href=#foreach与getenumerator><code>foreach</code>与<code>GetEnumerator</code></a><ul><li><a href=#foreach查找规则><code>foreach</code>查找规则</a><ul><li><a href=#1-是否存在可访问的实例方法>1. 是否存在可访问的实例方法</a></li><li><a href=#2-如果没有实例方法>2. 如果没有实例方法</a></li><li><a href=#3-如果都没有>3. 如果都没有</a></li></ul></li><li><a href=#一个非接口的枚举器例子>一个“非接口”的枚举器例子</a></li><li><a href=#编译器对foreach的处理>编译器对<code>foreach</code>的处理</a></li><li><a href=#getenumerator><code>GetEnumerator()</code></a><ul><li><a href=#基本概念>基本概念</a></li><li><a href=#语言层定义>语言层定义</a></li><li><a href=#getenumerator与枚举器协议><code>GetEnumerator()</code>与枚举器协议</a></li><li><a href=#getenumerator的两种实现方式><code>GetEnumerator()</code>的两种实现方式</a></li></ul></li><li><a href=#getenumerator存在的意义><code>GetEnumerator</code>存在的意义</a></li><li><a href=#值类型枚举器-vs-接口枚举器>值类型枚举器 vs 接口枚举器</a></li><li><a href=#只读遍历>只读遍历</a><ul><li><a href=#foreach的核心语义><code>foreach</code>的核心语义</a></li><li><a href=#为什么不能设计成可写foreach>为什么不能设计成“可写foreach”</a></li><li><a href=#值类型枚举器>值类型枚举器</a></li><li><a href=#foreach中允许修改对象的字段><code>foreach</code>中允许修改对象的字段</a></li><li><a href=#ref-foreach><code>ref foreach</code></a></li></ul></li><li><a href=#版本检查>版本检查</a><ul><li><a href=#定义>定义</a></li><li><a href=#作用>作用</a></li><li><a href=#运行机制>运行机制</a></li></ul></li></ul></li><li><a href=#值类型struct下的行为不同点>值类型（struct）下的行为不同点</a></li><li><a href=#适用场景>适用场景</a></li></ul></li><li><a href=#if>if</a><ul><li><a href=#基本结构>基本结构</a></li><li><a href=#条件表达式的要求>条件表达式的要求</a></li><li><a href=#简写与嵌套>简写与嵌套</a></li><li><a href=#进阶写法>进阶写法</a></li><li><a href=#常见陷阱>常见陷阱</a></li></ul></li><li><a href=#switch>switch</a><ul><li><a href=#基础语法c早期版本>基础语法（C#早期版本）</a></li><li><a href=#字符串与枚举支持>字符串与枚举支持</a></li><li><a href=#c7模式匹配>C#7+模式匹配</a></li><li><a href=#c-8-新写法switch-表达式>C# 8+ 新写法：<code>switch 表达式</code></a><ul><li><a href=#语句statement与表达式expression>语句(statement)与表达式(expression)</a></li></ul></li><li><a href=#c-912的进一步强化>C# 9~12的进一步强化</a></li><li><a href=#常见陷阱-1>常见陷阱</a></li><li><a href=#核心哲学>核心哲学</a></li></ul></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>