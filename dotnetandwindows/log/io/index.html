<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>IO Stream</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/logsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/log/>Log</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/ target=_blank>lua.org</a>
<a href=https://www.luarocks.org/ target=_blank>luarocks.org</a>
<a href=https://www.luajit.org/ target=_blank>luajit.org</a></p><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>IO Stream<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><p>I/O(Input/Output)流是C#中处理数据输入输出的核心机制，它提供了一种统一的方式来处理不同类型的数据源和目标（如文件、内存、网络等）</p><h2 id=io流的概念>I/O流的概念</h2><p>在C#中，流（Stream）是一个抽象概念，表示一系列连续的字节数据。所有流都继承自<code>System.IO.Stream</code>抽象类，它定义了流的基本操作：</p><ul><li>读取（Read）</li><li>写入（Write）</li><li>定位（Seek）</li><li>关闭（Close）</li></ul><p>在C#中，I/O流分为两种：</p><ul><li>字节流（Byte Streams）：用于处理原始二进制数据，通常用于图片、音频、视频等文件。字节流的基类是<code>Stream</code>，常用的字节流包括:<ul><li><code>FileStream</code>：用于文件的读取和写入，既可以以字节为单位，也可以通过缓冲区进行处理</li><li><code>MemoryStream</code>：用于内存中的数据流，可以临时存储数据，类似于一个内存中的文件</li><li><code>BufferedStream</code>：通过缓冲区对其他流（如文件流）进行优化，提高读取/写入性能</li><li><code>NetworkStream</code>：用于通过网络进行数据传输的流</li></ul></li><li>字符流（Character Streams）：用于处理文本数据，它是基于字符的编码和解码方式的。字符流的基类是基类为<code>TextReader</code>和<code>TextWriter</code>字符流通过读取和写入字符而非字节来工作，适合处理文本文件。常用的字符流包括：<ul><li><code>StreamReader</code>：用于读取字符数据，通常用于读取文本文件</li><li><code>StreamWriter</code>：用于写入字符数据，通常用于向文件写入文本</li><li><code>StringReader</code> 和 <code>StringWriter</code>：用于在内存中操作字符串</li></ul></li></ul><h2 id=字节流byte-streams操作>字节流（Byte Streams）操作</h2><h3 id=filestream><code>FileStream</code></h3><p><code>FileStream</code>是.NET中用于读取和写入文件的类。它提供了对文件的字节级别的访问，可以处理较大的文件并允许逐字节地操作文件内容，适用于需要直接操作文件内容的场景</p><h4 id=基本概念>基本概念</h4><p><code>FileStream</code>类位于<code>System.IO</code>命名空间中，支持异步和同步操作，通常用于文件的读取、写入以及定位。它可以处理任意类型的文件，不仅仅是文本文件，还可以处理二进制文件</p><h4 id=常见用法>常见用法</h4><p><strong>构造函数</strong><br><code>FileStream</code>有多个构造函数，每个构造函数都可以根据不同的需求来打开或创建文件</p><ol><li>基本构造函数</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> FileStream(<span style=color:#66d9ef>string</span> path, FileMode mode);
</span></span></code></pre></div><ul><li><code>path</code>：文件的路径（包括文件名）</li><li><code>mode</code>：指定文件操作的模式，决定了如何打开文件</li></ul><ol start=2><li>指定文件访问权限</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> FileStream(<span style=color:#66d9ef>string</span> path, FileMode mode, FileAccess access)
</span></span></code></pre></div><ul><li><code>access</code>：文件访问权限，指定对文件的读取、写入或读写权限</li></ul><ol start=3><li>指定文件访问权限和共享模式</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> FileStream(<span style=color:#66d9ef>string</span> path, FileMode mode, FileAccess access, FileShare share);
</span></span></code></pre></div><ul><li><code>share</code>：指定文件共享选项，控制其他进程如何访问该文件</li></ul><ol start=4><li>指定缓冲区大小</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> FileStream(<span style=color:#66d9ef>string</span> path, FileMode mode, FileAccess access, FileShare share, <span style=color:#66d9ef>int</span> bufferSize);
</span></span></code></pre></div><ul><li><code>bufferSize</code>：指定缓冲区的大小。缓冲区越大，读取和写入速度通常会更快</li></ul><ol start=5><li>指定文件路径和流的创建方式</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> FileStream(<span style=color:#66d9ef>string</span> path, FileMode mode, FileAccess access, FileShare share, <span style=color:#66d9ef>int</span> bufferSize, FileOptions options);
</span></span></code></pre></div><ul><li><code>options</code>：文件的其他选项</li></ul><p><strong>文件模式（FileMode）</strong></p><ul><li>FileMode.Create：创建一个新文件。如果文件已经存在，会覆盖</li><li>FileMode.Open：打开现有文件。如果文件不存在，抛出异常</li><li>FileMode.OpenOrCreate：打开文件，如果文件不存在，则创建</li><li>FileMode.Append：打开文件并将数据追加到文件末尾。如果文件不存在，则创建文件</li><li>FileMode.Truncate：打开文件并清空内容（文件长度设为零）</li></ul><p><strong>文件访问权限（FileAccess）</strong></p><ul><li>FileAccess.Read：只读访问</li><li>FileAccess.Write：只写访问</li><li>FileAccess.ReadWrite：可读写访问</li></ul><p><strong>文件共享（FileShare）</strong><br>控制其他进程对文件的访问权限。常用的选项有</p><ul><li>FileShare.None：不允许其他程序访问</li><li>FileShare.Read：允许其他程序读取文件</li><li>FileShare.Write：允许其他程序写入文件</li></ul><p><strong>文件的其他选项（FileOptions）</strong></p><ul><li><code>Asynchronous</code>：文件流支持异步操作</li><li><code>DeleteOnClose</code>：文件在流关闭时自动删除</li></ul><p><strong>文件位置操作</strong><br><code>FileStream</code>支持文件中的位置操作，允许控制当前读取或写入的位置。可以通过<code>Position</code>属性来获取或设置当前的文件指针位置</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>fs.Position = <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 设置文件指针到文件开头</span>
</span></span></code></pre></div><p><strong>读取和写入数据</strong>
<code>FileStream</code>提供了字节级别的操作方法，例如：</p><ul><li><code>Read</code>：读取字节流到缓冲区<ul><li>方法签名</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>int</span> Read(<span style=color:#66d9ef>byte</span>[] array, <span style=color:#66d9ef>int</span> offset, <span style=color:#66d9ef>int</span> count);
</span></span></code></pre></div><ul><li><code>array</code>：要存储读取数据的字节数组</li><li><code>offset</code>：字节数组中从哪个位置开始存储数据</li><li><code>count</code>：要读取的字节数</li><li>返回值
<code>Raed</code>方法韩慧实际读取的字节数。它可能少于请求的字节数，尤其是在文件末尾时。如果读取的字节数为0，且没有更多数据可读，则表示文件结束</li><li>注意事项<ul><li><code>Read</code>方法会从文件流中读取数据，直到达到指定的字节数<code>count</code>或者文件末尾</li><li>在读取时，如果文件数据不够<code>count</code>字节，<code>Read</code>会尽可能读取到剩余的数据</li><li>如果多次调用<code>Read</code>，它会从文件流中继续读取剩余内容</li></ul></li></ul></li><li><code>Write</code>：将字节流写入文件<ul><li>方法签名</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Write(<span style=color:#66d9ef>byte</span>[] array, <span style=color:#66d9ef>int</span> offset, <span style=color:#66d9ef>int</span> count);
</span></span></code></pre></div><ul><li>无返回值，它将指定字节数组中的数据写入到文件中，直到达到指定的字节数</li><li>注意事项<ul><li><code>Write</code>方法会覆盖当前文件的位置指针所在的内容。如果打开的是一个已存在的文件并且使用了<code>FileMode.Create</code>或者<code>FileMode.Truncate</code>，它会覆盖文件内容</li><li>如果使用<code>FileMode.Append</code>，写入的数据会追加到文件末尾</li><li><code>Write</code>会阻塞执行，直到写入操作完成，因此如果需要高效的文件写入，可以考虑异步写入</li></ul></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 写入文件</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>byte</span>[] data = Encoding.UTF8.GetBytes(<span style=color:#e6db74>&#34;Hello, World!&#34;</span>);
</span></span><span style=display:flex><span>fs.Write(data, <span style=color:#ae81ff>0</span>, data.Length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 读取文件</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>byte</span>[] buffer = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span>[fs.Length];
</span></span><span style=display:flex><span>fs.Read(buffer, <span style=color:#ae81ff>0</span>, buffer.Length);
</span></span><span style=display:flex><span>Console.WriteLine(Encoding.UTF8.GetString(buffer));
</span></span></code></pre></div><p><strong>异步操作</strong>
<code>FileStream</code>还支持异步操作，尤其适用于需要处理大量数据或在UI应用中避免阻塞主线程的场景</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>await</span> fs.WriteAsync(data, <span style=color:#ae81ff>0</span>, data.Length);
</span></span><span style=display:flex><span><span style=color:#66d9ef>byte</span>[] buffer = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span>[fs.Length];
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> fs.ReadAsync(buffer, <span style=color:#ae81ff>0</span>, buffer.Length);
</span></span></code></pre></div><p><strong>适用场景</strong></p><ul><li>大文件的分块读取：可以利用<code>FileStream</code>来按块读取大文件，逐渐加载文件内容，而不必一次性将所有文件加载到内存中</li><li>日志文件操作：用于实时写入日志文件，不会占用过多内存</li><li>图像和音频文件处理：在处理二进制文件（如图片、音频、视频）时，<code>FileStream</code>是一个常见的选择</li></ul><p><strong>使用完<code>FileStream</code>后的清理</strong><br>通常，当操作文件流时，需要及时释放资源。最安全的方式是使用<code>using</code>语句，它确保即使发生异常，文件流也会正常关闭</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (FileStream fs = <span style=color:#66d9ef>new</span> FileStream(<span style=color:#e6db74>&#34;example.txt&#34;</span>, FileMode.OpenOrCreate))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// file ops</span>
</span></span><span style=display:flex><span>}<span style=color:#75715e>// stream close</span>
</span></span></code></pre></div><h3 id=memorystream><code>MemoryStream</code></h3><p><code>MemoryStream</code>允许在内存中读写数据，而不是像<code>FileStream</code>那样操作磁盘文件。它的底层是一个字节数组<code>byte[]</code>，所以读写速度非常快，但数据是非持久化的，程序结束或对象被回收后数据就消失了</p><h4 id=核心特点>核心特点</h4><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>数据存储</td><td>内存中（<code>byte[]</code>）</td></tr><tr><td>可读写</td><td>可以读、写，支持随机访问（Seek）</td></tr><tr><td>性能</td><td>高速，因为不涉及磁盘 I/O</td></tr><tr><td>数据长度可变</td><td>内部缓冲区会自动扩容</td></tr><tr><td>可转字节数组</td><td>可通过 <code>ToArray()</code> 获取整个内容</td></tr></tbody></table><blockquote><p>注意：如果使用<code>MemoryStream</code>构造函数时传入一个固定的<code>byte[]</code>，默认不可扩展，写入过多数据会抛异常</p></blockquote><h4 id=常用构造函数>常用构造函数</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>MemoryStream() <span style=color:#75715e>// 空的内存流</span>
</span></span><span style=display:flex><span>MemoryStream(<span style=color:#66d9ef>byte</span>[] buffer) <span style=color:#75715e>// 用已有字节数组初始化</span>
</span></span><span style=display:flex><span>MemoryStream(<span style=color:#66d9ef>byte</span>[] buffer, <span style=color:#66d9ef>bool</span> writable) <span style=color:#75715e>// 指定是否可写</span>
</span></span><span style=display:flex><span>MemoryStream(<span style=color:#66d9ef>int</span> capacity) <span style=color:#75715e>// 指定初始容量</span>
</span></span></code></pre></div><h4 id=核心方法和属性>核心方法和属性</h4><table><thead><tr><th>方法 / 属性</th><th>用法</th><th>说明</th></tr></thead><tbody><tr><td><code>Write(byte[] buffer, int offset, int count)</code></td><td>写入字节</td><td>向流写入数据</td></tr><tr><td><code>Read(byte[] buffer, int offset, int count)</code></td><td>读取字节</td><td>从流读取数据</td></tr><tr><td><code>Seek(long offset, SeekOrigin origin)</code></td><td>定位</td><td>设置读写指针位置</td></tr><tr><td><code>ToArray()</code></td><td>获取字节数组</td><td>返回内存流中所有数据的副本</td></tr><tr><td><code>GetBuffer()</code></td><td>获取内部缓冲区</td><td>注意：可能比实际数据长</td></tr><tr><td><code>Length</code></td><td>流长度</td><td>已写入的数据长度</td></tr><tr><td><code>Position</code></td><td>读写位置</td><td>当前指针位置</td></tr><tr><td><code>SetLength(long value)</code></td><td>设置长度</td><td>可以截断或扩展流</td></tr><tr><td><code>Flush()</code></td><td>刷新流</td><td>对 <code>MemoryStream</code> 通常无操作</td></tr></tbody></table><h4 id=示例>示例</h4><p>写入数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  staitc <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (MemoryStream ms = <span style=color:#66d9ef>new</span> MemoryStream())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>string</span> text = <span style=color:#e6db74>&#34;Hello MemoryStream!&#34;</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>byte</span>[] bytes = Encoding.UTF8.GetBytes(text);
</span></span><span style=display:flex><span>      ms.Write(bytes, <span style=color:#ae81ff>0</span>, bytes.Length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      Console.WriteLine(<span style=color:#e6db74>&#34;Length: &#34;</span> + ms.Length); <span style=color:#75715e>// 输出长度</span>
</span></span><span style=display:flex><span>      Condole.WriteLine(<span style=color:#e6db74>&#34;Position: &#34;</span> + ms.Position); <span style=color:#75715e>// 输出当前位置</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 重置位置以便读取</span>
</span></span><span style=display:flex><span>      ms.Position = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>byte</span>[] buffer = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span>[ms.Length];
</span></span><span style=display:flex><span>      ms.Read(buffer, <span style=color:#ae81ff>0</span>, buffer.Length);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>string</span> result = Encoding.UTF8.GetString(buffer);
</span></span><span style=display:flex><span>      Console.WriteLine(result); <span style=color:#75715e>// 输出 Hello MemoryStream</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从字节数组创建并读取</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>byte</span>[] data = {<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>40</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> (MemoryStream ms = <span style=color:#66d9ef>new</span> MemoryStream(data))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; ms.Length; ++i)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>value</span> = ms.ReadByte(); <span style=color:#75715e>// 单字节读取</span>
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=使用场景>使用场景</h4><ol><li><p>临时数据缓存
比如读取文件后先在内存处理，然后再写回磁盘或发送网络</p></li><li><p>网络数据处理
和<code>BinaryReader/BinaryWriter</code>配合，序列化/反序列化数据</p></li><li><p>图片/音频处理
在内存中编辑或转换图像，再通过<code>Image.FromStream(ms)</code>使用</p></li><li><p>避免频繁磁盘操作
流程中大量临时数据操作时，用<code>MemoryStream</code>会快很多</p></li></ol><h4 id=注意事项>注意事项</h4><ul><li>内存流不是持久化流，如果数据需要保存，要写回文件或数据库</li><li><code>GetBuffer()</code>返回内部数组，长度可能大于实际数据，使用时要注意<code>Length</code></li><li>当数据量很大时（几十MB甚至上百MB），内存占用可能成为瓶颈</li><li><code>MemoryStream</code>实现了<code>IDisposable</code>，要用<code>using</code>或手动<code>Dispose()</code></li></ul><h3 id=bufferedstream><code>BufferedStream</code></h3><p><code>BufferedStream</code>是.NET提供的一个带缓冲的流包装器。它本身不直接读写文件或内存，而是包装另一个流（如<code>FileStream</code>或<code>NetworkStream</code>），在读写时增加一个内存缓冲区来提升性能</p><h4 id=工作原理>工作原理</h4><ul><li><p>读操作
当调用<code>Read</code>时，<code>BufferedStream</code>会一次性从底层流读一大块数据到内存缓冲区。之后的读操作如果能在缓冲区中找到数据，就直接返回，而不是每次都触发磁盘/网络/IO</p></li><li><p>写操作
当调用<code>Write</code>时，数据会先写入缓冲区。只有当缓冲区满了、显式调用<code>Flush()</code>、或关闭流时，才会一次性写入底层流</p></li></ul><p>这种机制大大减少了I/O的调用次数，提高了性能</p><h4 id=构造函数>构造函数</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>BufferedStream(Stream stream)
</span></span><span style=display:flex><span>BufferedStream(Stream stream, <span style=color:#66d9ef>int</span> bufferSize)
</span></span></code></pre></div><ul><li><code>stream</code>：底层流（必须是可读/可写的，如<code>FileStream</code>）</li><li><code>bufferSize</code>：缓冲区大小（默认4096Byte）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (FileStream fs = <span style=color:#66d9ef>new</span> FileStream(<span style=color:#e6db74>&#34;test.txt&#34;</span>, FileMode.OpenOrCreate))
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> (BufferedStream bs = <span style=color:#66d9ef>new</span> BufferedStream(fs, <span style=color:#ae81ff>8192</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// bs.Read / bs.Write</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=常用方法和属性>常用方法和属性</h4><table><thead><tr><th>方法 / 属性</th><th>说明</th></tr></thead><tbody><tr><td><code>Read(byte[] buffer, int offset, int count)</code></td><td>从缓冲区或底层流读取数据</td></tr><tr><td><code>Write(byte[] buffer, int offset, int count)</code></td><td>写入数据到缓冲区</td></tr><tr><td><code>Flush()</code></td><td>把缓冲区数据写入底层流</td></tr><tr><td><code>Seek(long offset, SeekOrigin origin)</code></td><td>改变读写位置（影响底层流和缓冲区）</td></tr><tr><td><code>Length</code></td><td>底层流的长度</td></tr><tr><td><code>Position</code></td><td>当前读写位置</td></tr></tbody></table><h4 id=示例-1>示例</h4><p>写文件（带缓冲）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (FileStream fs = <span style=color:#66d9ef>new</span> FileStream(<span style=color:#e6db74>&#34;data.txt&#34;</span>, FileMode.Create, FileAccess.Write))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (BufferedStream bs = <span style=color:#66d9ef>new</span> BufferedStream(fs, <span style=color:#ae81ff>8192</span>)) <span style=color:#75715e>// 8KB缓冲区</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (StreamWriter sw = <span style=color:#66d9ef>new</span> StreamWriter(bs, Encoding.UTF8))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>1000</span>; ++i)
</span></span><span style=display:flex><span>        sw.WriteLine(<span style=color:#e6db74>&#34;Line &#34;</span> + i);
</span></span><span style=display:flex><span>    } <span style=color:#75715e>// 这里会自动 Flush + Dispose</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>读文件（带缓冲）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (FileStream fs = <span style=color:#66d9ef>new</span> FileStream(<span style=color:#e6db74>&#34;data.txt&#34;</span>, FileMode.Open, FileAccess.Read))
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> (BufferedStream bs = <span style=color:#66d9ef>new</span> BufferedStream(fs, <span style=color:#ae81ff>8192</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> (StreamReader sr = <span style=color:#66d9ef>new</span> StreamReader(bs, Encoding.UTF8))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>string</span> line;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> ((line = sr.ReadLine()) != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    Console.WriteLine(line);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=使用场景-1>使用场景</h4><ul><li>大文件读写
避免频繁触发磁盘I/O，比如日志写入、批量导出</li><li>网络流
对<code>NetworkStream</code>包一层，减少网络API调用次数，提升吞吐量</li><li>组合模式
常见模式是：<code>FileStream -> BufferedStream -> StreamReader/StreamWriter</code></li></ul><h4 id=注意事项-1>注意事项</h4><ul><li><p>小数据写入时更高效
如果一次性写大块数据（比如一次写10MB），用不用<code>BufferedStream</code>差别不大，因为底层API已经优化过了<br>但如果是频繁小块写入（比如循环中写几百字节），<code>BufferedStream</code>会显著提升性能</p></li><li><p>记得Flush()
如果写入的数据没有及时Flush，可能还在缓冲区里没写到文件。关闭/释放流时会自动Flush，但在关键时机要手动调用</p></li><li><p>缓冲区大小
默认4KB，很多时候可以根据场景调整。过大浪费内存，过小性能不明显</p></li></ul><h4 id=bufferedstream-vs-memorystream><code>BufferedStream</code> vs <code>MemoryStream</code></h4><table><thead><tr><th>特点</th><th><code>MemoryStream</code></th><th><code>BufferedStream</code></th></tr></thead><tbody><tr><td>存储位置</td><td>内存（字节数组）</td><td>内存缓冲区 + 底层流</td></tr><tr><td>是否依赖底层流</td><td>否</td><td>是（必须包装其他流）</td></tr><tr><td>数据是否持久化</td><td>否</td><td>取决于底层流（比如 FileStream）</td></tr><tr><td>适用场景</td><td>临时数据处理</td><td>减少 I/O 调用次数</td></tr></tbody></table><ul><li><code>MemoryStream</code>数据完全在内存中</li><li><code>BufferedStream</code>在内存中加一层缓存，优化对磁盘/网络的访问</li></ul><h3 id=networkstream><code>NetworkStream</code></h3><p><code>NetworkStream</code>是.NET中用于网络数据传输的流类型，它直接封装了底层<code>Socket</code>对象，可以用流的方式来读写网络数据。因为它继承自<code>Stream</code>，所以可以和<code>StreamReader</code>、<code>StreamWriter</code>、<code>BinaryReader</code>、<code>BinaryWriter</code>等搭配使用，方便进行文本/二进制通信</p><h4 id=工作方式>工作方式</h4><p><code>NetworkStream</code>基于TCP套接字（<code>Socket</code>/<code>TcpClinet</code>/<code>TcpListener</code>）<br>它不自己管理连接，而是依赖外部的<code>Socket</code></p><ul><li>服务端：用<code>TcpListener.AcceptTcpClient()</code>得到<code>TcpClient</code>，再取<code>NetworkStream</code></li><li>客户端：用<code>TcpClient.Connect()</code>连接服务器，再取<code>NetworkStream</code></li></ul><p>数据走向</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>程序</span> <span style=color:#f92672>&lt;</span>-&gt; <span style=color:#a6e22e>NetworkStream</span> <span style=color:#f92672>&lt;</span>-&gt; <span style=color:#a6e22e>Socket</span> <span style=color:#f92672>&lt;</span>-&gt; <span style=color:#a6e22e>TCP</span><span style=color:#f92672>/</span>IP协议栈 <span style=color:#f92672>&lt;</span>-&gt; <span style=color:#960050;background-color:#1e0010>网络</span>
</span></span></code></pre></div><h4 id=构造函数-1>构造函数</h4><p>通常不会手动<code>new NetworkStream(Socket)</code>，而是通过<code>TcpClient.GetStream()</code>获取</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>TcpClient client = <span style=color:#66d9ef>new</span> TcpClient(<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>, <span style=color:#ae81ff>8080</span>);
</span></span><span style=display:flex><span>NetworkStream ns = client.GetStream();
</span></span></code></pre></div><p>如果真的要自己构造，可以传入一个已连接的<code>Socket</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Socket socket = <span style=color:#66d9ef>new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
</span></span><span style=display:flex><span>socket.Connect(<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>, <span style=color:#ae81ff>8080</span>);
</span></span><span style=display:flex><span>NetworkStream ns = <span style=color:#66d9ef>new</span> NetworkStream(socket ownsSocket: <span style=color:#66d9ef>true</span>);
</span></span></code></pre></div><ul><li><code>ownsSocket: true</code>表示关闭流时自动关闭底层Socket</li></ul><h4 id=常用方法>常用方法</h4><table><thead><tr><th>方法/属性</th><th>说明</th></tr></thead><tbody><tr><td><code>Read(byte[] buffer, int offset, int size)</code></td><td>从网络中读取数据（阻塞）</td></tr><tr><td><code>Write(byte[] buffer, int offset, int size)</code></td><td>向网络写数据</td></tr><tr><td><code>Flush()</code></td><td>TCP 流不需要手动 Flush，调用没效果</td></tr><tr><td><code>CanRead</code>/<code>CanWrite</code></td><td>是否可读写</td></tr><tr><td><code>DataAvailable</code></td><td>是否有可读数据（非阻塞检查）</td></tr><tr><td><code>ReadAsync</code>/<code>WriteAsync</code></td><td>异步读写（推荐）</td></tr></tbody></table><h4 id=示例-2>示例</h4><p>简单客户端</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Net.Scokets;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Client</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (TcpClient client = <span style=color:#66d9ef>new</span> TcpClient(<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>, <span style=color:#ae81ff>8080</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (NetworkStream ns = client.GetStream())
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (StreamWriter writer = <span style=color:#66d9ef>new</span> StreamWriter(ns, Encoding.UTF8) { AutoFlush = <span style=color:#66d9ef>true</span> })
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (StreamReader reader = <span style=color:#66d9ef>new</span> StreamReader(ns, Encoding.UTF8))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      writer.WriteLine(<span style=color:#e6db74>&#34;Hello Server!&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>string</span> response = reader.ReadLine();
</span></span><span style=display:flex><span>      Console.WriteLine(<span style=color:#e6db74>&#34;Server says: &#34;</span> + response);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>简单服务器端</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Net;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Net.Sockets;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Server</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  staitc <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    TcpListener listener = <span style=color:#66d9ef>new</span> TcpListener(IPAddress.Any, <span style=color:#ae81ff>8080</span>);
</span></span><span style=display:flex><span>    listener.Start();
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;Server started...&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      TcpClient client = listener.AcceptTcpClient();
</span></span><span style=display:flex><span>      Console.WriteLine(<span style=color:#e6db74>&#34;Client connected.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>using</span> (NerworkStream ns = client.GetStream())
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>using</span> (StreamReader reader = <span style=color:#66d9ef>new</span> StreamReader(ns, Encoding.UTF8))
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>using</span> (StreamWriter writer = <span style=color:#66d9ef>new</span> StreamWriter(ns, Encoding.UTF8) { AutoFlush = ture })
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> msg = reader.ReadLine();
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;Client says: &#34;</span> + msg);
</span></span><span style=display:flex><span>        writer.WriteLine(<span style=color:#e6db74>&#34;Hello Client!&#34;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=使用场景-2>使用场景</h4><ul><li>即时通讯（聊天软件、游戏大厅、匹配系统）</li><li>游戏网络同步（Unity/UE中TCP/UDP风暴处理，TCP通常用于可靠消息）</li><li>远程调用（RPC、Socket服务）</li><li>协议实现（自己写应用层协议，比如简单的JSON协议）</li></ul><h4 id=注意事项-2>注意事项</h4><ol><li>阻塞问题</li></ol><ul><li><code>Read()</code>默认是阻塞的，没有数据时会卡住</li><li>建议使用<code>ReadAsync</code>或<code>DataAvailiable</code>做非阻塞检查</li></ul><ol start=2><li>TCP是流式协议</li></ol><ul><li>没有“消息边界”，一次<code>Write</code>的数据，可能需要多次<code>Read</code>才能收完</li><li>实际开发中要自己设计报文头（长度字段）来分包</li></ul><ol start=3><li>生命周期</li></ol><ul><li><code>NetworkStream.Dispose()</code>会影响底层Socket</li><li>一般和<code>TcpClient</code>一起管理</li></ul><ol start=4><li>性能优化</li></ol><ul><li>小数据包建议配合<code>BufferedStream</code></li><li>大数据包要考虑分包/粘包问题</li></ul><h2 id=字符流character-streams操作>字符流（Character Streams）操作</h2><h3 id=streamreader--streamwriter><code>StreamReader</code> & <code>StreamWriter</code></h3><ul><li><code>StreamReader</code>：从一个字节流中读取字符（解码），通常用于读取文本文件或网络文本数据</li><li><code>StreamWriter</code>：向一个字节流中写入字符（编码），会根据编码（如UTF-8）转换成字节</li></ul><p><code>Stream</code>本身只处理字节<code>byte[]</code>，但经常处理文本（比如日志、配置文件、JSON、XML、网络消息）<br>所以：</p><ul><li><code>StreamReader/Writer</code>提供了编码解码功能，自动把字节和字符串相互转换</li><li>内部还带有缓冲，提高效率</li><li>是处理文本的首选工具</li></ul><h4 id=构造函数-2>构造函数</h4><p><code>StreamReader</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>StreamReader(Stream stream)
</span></span><span style=display:flex><span>StreamReader(Stream stream, Encoding encoding)
</span></span><span style=display:flex><span>StreamReader(<span style=color:#66d9ef>string</span> path)
</span></span><span style=display:flex><span>StreamReader(<span style=color:#66d9ef>string</span> path, Encoding encoding)
</span></span></code></pre></div><p><code>StreamWriter</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>StreamWriter(Stream stream)
</span></span><span style=display:flex><span>StreamWriter(Stream stream, Encodign encoding)
</span></span><span style=display:flex><span>StreamWriter(<span style=color:#66d9ef>string</span> path)
</span></span><span style=display:flex><span>StringWriter(<span style=color:#66d9ef>string</span> path, <span style=color:#66d9ef>bool</span> append)
</span></span><span style=display:flex><span>StreamWriter(<span style=color:#66d9ef>string</span> path, <span style=color:#66d9ef>bool</span> append, Encoding encoding)
</span></span></code></pre></div><h4 id=常用方法-1>常用方法</h4><p>StreamReader</p><table><thead><tr><th>方法 / 属性</th><th>说明</th></tr></thead><tbody><tr><td><code>Read()</code></td><td>读取一个字符（返回 <code>int</code>，-1 表示结束）</td></tr><tr><td><code>ReadLine()</code></td><td>读取一行文本</td></tr><tr><td><code>ReadToEnd()</code></td><td>读取整个流的剩余内容</td></tr><tr><td><code>Peek()</code></td><td>查看下一个字符但不移动指针</td></tr><tr><td><code>EndOfStream</code></td><td>是否读到结尾</td></tr></tbody></table><p>StreamWriter</p><table><thead><tr><th>方法 / 属性</th><th>说明</th></tr></thead><tbody><tr><td><code>Write(string)</code></td><td>写文本（不换行）</td></tr><tr><td><code>WriteLine(string)</code></td><td>写文本并换行</td></tr><tr><td><code>Flush()</code></td><td>把缓冲区内容写入底层流</td></tr><tr><td><code>AutoFlush</code></td><td>设置是否每次写入后自动刷新</td></tr></tbody></table><h4 id=示例-3>示例</h4><p>写入文本文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (StreamWriter writer = <span style=color:#66d9ef>new</span> StreamWriter(<span style=color:#e6db74>&#34;log.txt&#34;</span>, <span style=color:#66d9ef>false</span>, Encoding.UTF8))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      writer.WriteLine(<span style=color:#e6db74>&#34;Hello World!&#34;</span>);
</span></span><span style=display:flex><span>      writer.WriteLine(<span style=color:#e6db74>&#34;时间：&#34;</span> + DateTime.Now);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;写入完成&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>读取文本文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (StreamReader reader = <span style=color:#66d9ef>new</span> StreamReader(<span style=color:#e6db74>&#34;log.txt&#34;</span>, Encoding.UTF8))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>string</span> line;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> ((line = reader.ReadLine()) != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    Console.WriteLine(line);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>结合<code>NetworkStream</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (StreamReader reader = <span style=color:#66d9ef>new</span> StreamReader(networkStream, Encoding.UTF8))
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> (StreamWriter writer = <span style=color:#66d9ef>new</span> StreamWriter(networkStream, Encoding.UTF8) { AutoFlush = ture })
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  writer.WriteLine(<span style=color:#e6db74>&#34;Hello Server&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>string</span> response = reader.ReadLine();
</span></span><span style=display:flex><span>  Console.WriteLine(<span style=color:#e6db74>&#34;Server: &#34;</span> + response);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=使用场景-3>使用场景</h4><ul><li>文件操作：读写日志、配置、脚本、JSON文件等</li><li>网络通信：和<code>NetworkStream</code>配合，处理基于文本的协议（HTTP、聊天消息）</li><li>内存操作：配合<code>MemoryStream</code>，在内存中读写字符串</li></ul><h4 id=注意事项-3>注意事项</h4><ol><li>编码问题</li></ol><ul><li>默认编码依赖平台，推荐显式指定<code>Encoding.UTF8</code>，避免乱码</li><li>特别是跨平台/跨语言通信时，一定要统一编码</li></ul><ol start=2><li>缓冲区</li></ol><ul><li><code>StreamWriter</code>默认有缓冲，数据可能没立即写道文件/网络</li><li>关键时刻要<code>Flush()</code>或设置<code>AutoFlush = true</code></li></ul><ol start=3><li>换行符</li></ol><ul><li><code>WriteLine</code>使用系统默认换行符：Windows是<code>\r\n</code>，Linux是<code>\n</code></li><li>如果写跨平台文本文件，最好统一约定</li></ul><ol start=4><li>文件占用</li></ol><ul><li><code>StreamReader/Writer</code>默认独占文件，不能同时被其他进程访问</li><li>如果需要共享，可以在<code>FileStream</code>里设置<code>FileShare</code></li></ul><h3 id=stringreader--stringwriter><code>StringReader</code> & <code>StringWriter</code></h3><p>这两个类专门用来在内存里处理字符串，不依赖文件或网络，完全运行在内存中，非常轻量</p><ul><li><code>StringReader</code>：继承自<code>TextReader</code>，在内存中，把一个字符串当作“数据源”，按字符或行来读取，就像从文件读文本一样</li><li><code>StringWriter</code>：继承自<code>TextWriter</code>，在内存中，向一个字符串“写入”，最后可以得到完整的字符串</li></ul><h4 id=构造函数-3>构造函数</h4><p><code>StringReader</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>StringReader(<span style=color:#66d9ef>string</span> s)
</span></span></code></pre></div><ul><li>参数是一个字符串，后续就可以像读文件一样从中逐字符/逐行读取</li></ul><p><code>StringWriter</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>StringWriter()
</span></span><span style=display:flex><span>StringWriter(StringBuilder sb)
</span></span><span style=display:flex><span>StringWriter(IFormatProvider formatProvider)
</span></span><span style=display:flex><span>StringWriter(StringBuilder sb, IFormatProvider formatProvider)
</span></span></code></pre></div><ul><li>内部其实是写入到一个<code>StringBuilder</code></li><li>可以自己传入<code>StringBuilder</code>，或者让它默认帮你创建</li></ul><h4 id=常用方法-2>常用方法</h4><p>StringReader</p><table><thead><tr><th>方法 / 属性</th><th>说明</th></tr></thead><tbody><tr><td><code>Read()</code></td><td>读一个字符（返回 <code>int</code>，-1 表示结束）</td></tr><tr><td><code>ReadLine()</code></td><td>读一行（遇到 <code>\r\n</code> / <code>\n</code> 就结束）</td></tr><tr><td><code>ReadToEnd()</code></td><td>读完剩余的所有文本</td></tr><tr><td><code>Peek()</code></td><td>看下一个字符但不移动位置</td></tr></tbody></table><p>StringWriter</p><table><thead><tr><th>方法 / 属性</th><th>说明</th></tr></thead><tbody><tr><td><code>Write(string)</code></td><td>写字符串</td></tr><tr><td><code>WriteLine(string)</code></td><td>写一行（带换行符）</td></tr><tr><td><code>ToString()</code></td><td>返回最终拼接好的字符串</td></tr><tr><td><code>GetStringBuilder()</code></td><td>返回内部的 <code>StringBuilder</code></td></tr></tbody></table><h4 id=示例-4>示例</h4><p>使用StringReader</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> text = <span style=color:#e6db74>&#34;Hello\nWrold\nC#&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (StringReader reader = <span style=color:#66d9ef>new</span> StringReader(text))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>string?</span> line;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span>((line = reader.ReadLine()) != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;Line: &#34;</span> + line);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用StringWriter</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (StringWriter writer = <span style=color:#66d9ef>new</span> StringWriter())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      writer.WriteLine(<span style=color:#e6db74>&#34;Hello&#34;</span>);
</span></span><span style=display:flex><span>      writer.WriteLine(<span style=color:#e6db74>&#34;World&#34;</span>);
</span></span><span style=display:flex><span>      writer.WriteLine(<span style=color:#e6db74>&#34;C#&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>string</span> result = writer.ToString();
</span></span><span style=display:flex><span>      Console.WriteLine(result);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>联合使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>string</span> original = <span style=color:#e6db74>&#34;Line1\nLine3\nLine3&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> transformed;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> (StringReader reader = <span style=color:#66d9ef>new</span> StringReader(original));
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> (StringWriter writer = <span style=color:#66d9ef>new</span> StringWriter());
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>string?</span> line;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> ((line = reader.ReadLine()) != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    writer.WriteLine(line.ToUpper()); <span style=color:#75715e>// 转大写再写入</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  transformed = writer.ToString();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(transformed);
</span></span></code></pre></div><h4 id=使用场景-4>使用场景</h4><ul><li>文本处理：在内存中解析、修改文本（配置、脚本、模板）</li><li>调试/测试：替代文件读写，快速模拟输入输出</li><li>中间结果缓存：先用<code>StringWriter</code>拼接复杂文本，再一次性获取</li><li>和API集成：很多需要<code>TextReader</code>/<code>TextWriter</code>参数的方法，可以直接传<code>StringReader/StringWriter</code></li></ul><h2 id=异步io和缓冲流>异步I/O和缓冲流</h2><h2 id=io流异常处理>I/O流异常处理</h2><h2 id=常见io操作>常见I/O操作</h2><h3 id=文件操作>文件操作</h3><h3 id=目录操作>目录操作</h3><h2 id=io流优化>I/O流优化</h2><h2 id=file><code>File</code></h2><p><code>File</code>类是.NET中<code>System.IO</code>命名空间下提供的一个静态类，封装了与我呢见操作相关的常见方法。它提供了许多用于创建、删除、赋值、读取和写入文件的方法，简化了文件操作的过程，尤其是在不需要处理流(<code>Stream</code>)或文件的高级特性时，使用<code>File</code>类会非常方便</p><h3 id=file类的常见用途><code>File</code>类的常见用途</h3><p><code>File</code>类本身是一个静态类，因此它不需要实例化。它提供了一些静态方法，适用于文件的常见操作。<code>File</code>类比<code>FileStream</code>类更为简化和高层，适合于文件的常规操作</p><h3 id=常用方法-3>常用方法</h3><ol><li>创建文件</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>File.Create(<span style=color:#66d9ef>string</span> path);
</span></span></code></pre></div><ul><li><code>path</code>：要创建的文件的路径</li><li>返回值：返回一个<code>FileStream</code>对象，用于操作创建的文件</li></ul><ol start=2><li>复制文件</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>File.Copy(<span style=color:#66d9ef>string</span> sourceFileName, <span style=color:#66d9ef>string</span> destFileName);
</span></span><span style=display:flex><span>File.Copy(<span style=color:#66d9ef>string</span> sourceFileName, <span style=color:#66d9ef>string</span> destFileName, <span style=color:#66d9ef>bool</span> overwrite);
</span></span></code></pre></div><ul><li><code>sourceFileName</code>：源文件的路径</li><li><code>destFileName</code>：目标文件的路径</li><li><code>overwrite</code>：是否覆盖目标文件，如果目标文件存在</li></ul><ol start=3><li>删除文件</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>File.Delete(<span style=color:#66d9ef>string</span> path)
</span></span></code></pre></div><ol start=4><li>检查文件是否存在</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>File.Exists(<span style=color:#66d9ef>string</span> path);
</span></span></code></pre></div><ul><li>返回值：如果文件存在，返回<code>true</code>；否则返回<code>false</code></li></ul><ol start=5><li>移动文件</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>File.Move(<span style=color:#66d9ef>string</span> sourceFileName, <span style=color:#66d9ef>string</span> destFileName);
</span></span></code></pre></div><ol start=6><li>读取文件内容</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>File.ReadAllText(<span style=color:#66d9ef>string</span> path);
</span></span><span style=display:flex><span>File.ReadAllLines(<span style=color:#66d9ef>string</span> path);
</span></span></code></pre></div><ul><li>返回值<ul><li><code>ReadAllText</code>：返回文件的全部内容作为一个字符串</li><li><code>ReadAllLines</code>：返回文件中每一行内容的字符串数组</li></ul></li></ul><ol start=7><li>写入内容到文件</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>File.WriteAllText(<span style=color:#66d9ef>string</span> path, <span style=color:#66d9ef>string</span> contents);
</span></span><span style=display:flex><span>File.WriteAllLines(<span style=color:#66d9ef>string</span> path, <span style=color:#66d9ef>string</span>[] contents);
</span></span></code></pre></div><ul><li><code>WriteAllText</code>：写全部</li><li><code>WriteAllLines</code>：按行写</li></ul><ol start=8><li>追加内容到文件</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>File.AppendAllText(<span style=color:#66d9ef>string</span> path, <span style=color:#66d9ef>string</span> contents);
</span></span><span style=display:flex><span>File.AppendAllLines(<span style=color:#66d9ef>string</span> path, <span style=color:#66d9ef>string</span>[] contents);
</span></span></code></pre></div><ol start=9><li>获取文件信息</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>File.GetCreationTime(<span style=color:#66d9ef>string</span> path);
</span></span><span style=display:flex><span>File.GetLastAccessTime(<span style=color:#66d9ef>string</span> path);
</span></span><span style=display:flex><span>File.GetLastWriteTime(<span style=color:#66d9ef>string</span> path);
</span></span></code></pre></div><ul><li>返回值：返回一个<code>DateTime</code>对象，表示文件的创建、访问或修改时间</li></ul><h3 id=总结>总结</h3><ul><li><code>File</code>类是<code>System.IO</code>命名空间中的一个静态类，用于执行常见的文件操作</li><li>它提供了简便的方法来创建、删除、复制、移动文件，并支持读取、写入和修改文件</li><li>相比于<code>FileStream</code>类，<code>File</code>类是更高层次的文件操作API，适合用于常规文件处理操作，不需要处理流和字节级别的文件读写</li></ul><h2 id=binary-stream>Binary Stream</h2><p>二进制流是以二进制数据序列（0和1的字节序列）的方式在存储设备或网络中传输/存储信息的一种形式<br>相比于文本流（Text Stream，通常是以字符编码形式的字节流），二进制流更原始，它不依赖编码，而是直接操作原始字节</p><h3 id=二进制流的作用>二进制流的作用</h3><p>如果只用文本流，没法高效处理非文本数据比如：</p><ul><li>图片、视频、音频文件</li><li>压缩包、可执行程序</li><li>数据库文件、内存镜像</li></ul><p>这些文件都不能简单地用字符集去解释，只能用二进制流来表示</p><h3 id=二进制流特点>二进制流特点</h3><ol><li>原始性：直接操作字节，不依赖字符编码</li><li>通用性：任何文件最终都可以用二进制流表示</li><li>高效性：避免字符转换，更接近底层存储</li><li>不可读性：无法直接阅读，必须通过解析器或协议还原
// TODO:</li></ol></div><nav class=post-nav><a href=/dotnetandwindows/log/indexer/ class=hover:underline>pre: Indexer</a>
<a href=/dotnetandwindows/log/iterator/ class=hover:underline>next: Iterator</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#io流的概念>I/O流的概念</a></li><li><a href=#字节流byte-streams操作>字节流（Byte Streams）操作</a><ul><li><a href=#filestream><code>FileStream</code></a><ul><li><a href=#基本概念>基本概念</a></li><li><a href=#常见用法>常见用法</a></li></ul></li><li><a href=#memorystream><code>MemoryStream</code></a><ul><li><a href=#核心特点>核心特点</a></li><li><a href=#常用构造函数>常用构造函数</a></li><li><a href=#核心方法和属性>核心方法和属性</a></li><li><a href=#示例>示例</a></li><li><a href=#使用场景>使用场景</a></li><li><a href=#注意事项>注意事项</a></li></ul></li><li><a href=#bufferedstream><code>BufferedStream</code></a><ul><li><a href=#工作原理>工作原理</a></li><li><a href=#构造函数>构造函数</a></li><li><a href=#常用方法和属性>常用方法和属性</a></li><li><a href=#示例-1>示例</a></li><li><a href=#使用场景-1>使用场景</a></li><li><a href=#注意事项-1>注意事项</a></li><li><a href=#bufferedstream-vs-memorystream><code>BufferedStream</code> vs <code>MemoryStream</code></a></li></ul></li><li><a href=#networkstream><code>NetworkStream</code></a><ul><li><a href=#工作方式>工作方式</a></li><li><a href=#构造函数-1>构造函数</a></li><li><a href=#常用方法>常用方法</a></li><li><a href=#示例-2>示例</a></li><li><a href=#使用场景-2>使用场景</a></li><li><a href=#注意事项-2>注意事项</a></li></ul></li></ul></li><li><a href=#字符流character-streams操作>字符流（Character Streams）操作</a><ul><li><a href=#streamreader--streamwriter><code>StreamReader</code> & <code>StreamWriter</code></a><ul><li><a href=#构造函数-2>构造函数</a></li><li><a href=#常用方法-1>常用方法</a></li><li><a href=#示例-3>示例</a></li><li><a href=#使用场景-3>使用场景</a></li><li><a href=#注意事项-3>注意事项</a></li></ul></li><li><a href=#stringreader--stringwriter><code>StringReader</code> & <code>StringWriter</code></a><ul><li><a href=#构造函数-3>构造函数</a></li><li><a href=#常用方法-2>常用方法</a></li><li><a href=#示例-4>示例</a></li><li><a href=#使用场景-4>使用场景</a></li></ul></li></ul></li><li><a href=#异步io和缓冲流>异步I/O和缓冲流</a></li><li><a href=#io流异常处理>I/O流异常处理</a></li><li><a href=#常见io操作>常见I/O操作</a><ul><li><a href=#文件操作>文件操作</a></li><li><a href=#目录操作>目录操作</a></li></ul></li><li><a href=#io流优化>I/O流优化</a></li><li><a href=#file><code>File</code></a><ul><li><a href=#file类的常见用途><code>File</code>类的常见用途</a></li><li><a href=#常用方法-3>常用方法</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#binary-stream>Binary Stream</a><ul><li><a href=#二进制流的作用>二进制流的作用</a></li><li><a href=#二进制流特点>二进制流特点</a></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>