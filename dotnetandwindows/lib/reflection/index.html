<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Reflection</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/lib/>Lib</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /             <a class=nav-item data-path=/engine/ href=/engine/>Engine</a>         |
|                             |  /                 |           |
|                             | /                  |           |
|                             |/                   |           |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/framework/ href=/framework/>Framework</a>       |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Reflection<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><h2 id=基本概念>基本概念</h2><p>反射是一种计算机编程语言的能力，它允许程序在运行时（Runtime）检查、分析甚至修改自身的结构（如类、方法、属性、接口等）的行为<br>反射像一面镜子<br>在编写代码的编译时(Compiletime)，你很清晰程序的结构<br>而反射则让程序在运行时(Runtime)能够”照镜子“，看到自己由什么组成，并能动态地调用或操作这些部分\</p><blockquote><p>代码中有许多类，每个类都包含了许多字段，现在提供一个类<code>Type</code>，可以获得任何一个类的任何字段（包括私有字段），提供查看，修改，创建功能</p></blockquote><h3 id=反射的作用>反射的作用</h3><ol><li>在运行时检查类型信息</li></ol><ul><li>获取任何一个对象的类型（Class）</li><li>获取类的所有成员（字段/属性、方法、构造函数）</li><li>判断一个对象是否属于某个特定类，或者实现了某个接口</li></ul><ol start=2><li>在运行时操作类、对象和成员</li></ol><ul><li>动态创建对象：即使编译时不知道类的名字，也可以在运行时通过字符串形式的类名来创建实例</li><li>动态调用方法：通过方法的名字（字符串形式）来调用也给对象的方法</li><li>动态获取和设置字段值：访问甚至修改一个对象的字段（包括私有字段，取决于语言的安全策略）</li></ul><ol start=3><li>晚期绑定（Late Binding）</li></ol><ul><li>调用COM组件或那些在编译时无法直接引用的程序集中的方法。不需要在项目中提前”Add Reference“，可以在运行时动态加载程序集并与之交互</li></ul><h3 id=反射的优缺点>反射的优缺点</h3><p>优点</p><ul><li>极高的灵活性和动态性：这是其最大价值。它使得编写通用框架、插件系统、序列化/反序列化工具、对象关系映射器（ORM）成为可能</li><li>赋能框架：像ASP.NET Core（依赖注入、MVC路由）、Entity Framework Core（将数据库表映射到实体类）、xUnit（发现并运行测试方法）等而核心.NET技术都重度依赖反射来实现</li></ul><p>缺点：</p><ul><li>性能开销：反射操作比直接编译代码调用要慢几个数量级。因为所有的检查、方法查找和成员访问都是在运行时进行的，JIT编译器无法对其进行优化。应避免在性能关键的循环或路径中使用</li><li>安全性：反射可以绕过访问修饰符，这可能破坏封装性，带来安全风险</li><li>代码可维护性：大量使用反射的代码难以阅读、理解和调试，因为很多行为要到运行时才能确定</li><li>脆弱性：如果通过字符串名称查找类型或成员，一旦名称拼写错误或成员不存在，错误将在运行时才抛出，而不是在编译时</li></ul><h3 id=反射使用场景>反射使用场景</h3><p><strong>优先考虑编译时安全性和性能，仅在别无他法或收益远大于成本时，才在严格限制下使用反射</strong>\</p><ol><li><p>构建基础设施、框架和工具
编写通用工具或辅助方法<br>一个深度克隆（Deep Clone）工具方法。需要遍历一个对象的所有字段（包括私有字段），来创建一个完美的副本。这种方法通常会在项目的基础工具库中写一次，然后被广泛复用<br>时刻问自己：“我是在编写像框架一样的通用基础设施吗？”如果答案是否定的，那么你很可能不应该使用反射。日常业务中，99.9%的情况都有更好的、不依赖反射的解决方案</p></li><li><p>与外部系统或动态配置集成
当你的程序需要根据外部配置（如配置文件、数据库中的设置）来动态决定行为时<br>一个简单的插件系统。在配置文件中写上插件类的名称<code>"MyApp.Plugins.EmailNotifier"</code>，主程序通过<code>Type.GetType()</code>创建并加载它。虽然用了反射，但它被隔离在程序启动的初始化阶段，不会影响核心性能<br>反射操作比直接代码调用慢几个数量级。在性能关键的路径上使用反射是自杀行为</p></li><li><p>使用重度依赖反射的成熟库
很多时候，已经在“间接地”使用反射了，只是库帮你处理了所有复杂的细节，并做了性能优化</p></li><li><p>绝对尊重封装
仅仅因为能访问私有字段，不意味着应该这么做。修改私有成员是最后的手段，通常只用于测试、序列化等框架场景。滥用它会创建极其脆弱和难以维护的代码，因为代码与类的内部实现细节紧密耦合，一旦类的私有成员改变，代码就会立刻崩溃</p></li><li><p>安全风险
如果正在处理敏感数据（如密码、令牌），反射的存在意味着任何能运行代码的组件都可能提取这些数据。在设计安全敏感的系统时，必须考虑到这一点</p></li></ol><h2 id=c反射核心>C#反射核心</h2><h3 id=核心命名空间及其下的类>核心命名空间及其下的类</h3><ul><li><code>System</code><ul><li><code>System.Type</code>：一个类型的<code>Type</code>对象包含所有该类型的元数据信息</li></ul></li><li><code>System.Reflection</code><ul><li><code>Assembly</code>, <code>Module</code>, <code>MemberInfo</code>, <code>MethodInfo</code>, <code>PropertyInfo</code>, <code>FieldInfo</code>, <code>ConstructorInfo</code>, <code>ParameterInfo</code>, <code>BindingFlags</code></li></ul></li><li><code>System.Reflection.Emit</code>：动态生成/IL代码<ul><li><code>AssemblyBuilder</code>, <code>ModuleBuilder</code>, <code>TypeBuilder</code>, <code>MethodBuilder</code>, <code>ILGenerator</code>, <code>DynamicMethod</code></li></ul></li><li><code>System.Reflection.Metadata</code>：高级、只读元数据分析，用于直接读PE/元数据（通常用于工具/静态分析）</li><li><code>System.Runtime.Serialization</code>/<code>System.Reflection.TypeExtension</code>（若干辅助API）</li></ul><h3 id=systemtypetypeinfo><code>System.Type</code>/<code>TypeInfo</code></h3><h4 id=背景>背景</h4><p><code>TypeInfo</code>是<code>Type</code>功能的扩展，是<code>Type</code>的增强视图，它提供了更丰富、更符合现代.NET开发模式的反射API，尤其是在.NET Core和现代应用模型中<br>在传统的、完整的.NET Framework中，反射的核心一直是<code>System.Type</code>类。所有关于类型的信息都通过它来获取<br>当微软开始开发.NET Core（一个跨平台、模块化、高性能的.NET版本）时，他们需要一个策略来让平台更轻量级。一个核心思想是按需付费：你的应用程序不应该被迫加载一个庞大的完整程序集，而是只加载它实际需要的部分<br>传统的<code>System.Type</code>位于<code>mscorlib.dll</code>（后来是<code>System.Runtime.dll</code>）中，它是一个非常庞大和全面的类型。为了支持这种模块化，反射API被拆分和重新设计<br><code>System.Type</code>是一个装工具的大工具箱。<code>TypeInfo</code>就像是把这个工具箱打开，把里面的工具（方法、属性、基类等信息）都拿出来，整齐地摆在你面前，让你看得更清楚，用起来也更符合“按需取用”的原则<br>**<code>System.Type</code> vs <code>TypeInfo</code></p><table><thead><tr><th>特性</th><th><code>System.Type</code>（传统方式）</th><th><code>TypeInfo</code>（现代方式）</th></tr></thead><tbody><tr><td>所在程序集</td><td><code>System.Runtime</code></td><td><code>System.Reflection</code></td></tr><tr><td>设计哲学</td><td>“拉”（Pull）。你向<code>Type</code>请求信息（例如，调用<code>.GetMethods()</code>，它才会去加载并返回</td><td>“展”（Expose）API。类型的信息已经作为属性展示在<code>TypeInfo</code>对象上了</td></tr><tr><td>成员访问</td><td>通过方法获取数组成员（如<code>GetMethods()</code>, <code>GetProperties()</code>）</td><td>通过属性获取集合成员（如<code>DeclaredMethods</code>, <code>DeclaredProperties</code>），这些集合是预计算好的</td></tr><tr><td>延迟加载</td><td>√ 当你调用<code>GetMethod()</code>时，它才去计算并返回结果</td><td>概念上更倾向于提前计算。<code>TypeInfo</code>对象本身就承载着这些信息集合</td></tr><tr><td>主要使用场景</td><td>传统的.NET Framework应用</td><td>.NET Core+、.NET 5+、UWP、Xamarin等现代应用模型。特别是依赖于<code>Microsoft.Extensions.DependencInjection</code>的应用（如ASP.NET Core）</td></tr></tbody></table><h4 id=systemtype><code>System.Type</code></h4><h5 id=获取>获取</h5><ol><li><code>typeof</code>运算符：当你在编译时就知道类型时</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Type stringType = <span style=color:#66d9ef>typeof</span>(<span style=color:#66d9ef>string</span>);
</span></span><span style=display:flex><span>Type myClassType = <span style=color:#66d9ef>typeof</span>(MyClass);
</span></span></code></pre></div><ol start=2><li><code>Object.GetType()</code>实例方法：当你有一个对象实例时</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Person person = <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>Type personType = person.GetType(); <span style=color:#75715e>// 获取 person 实例的运行时类型</span>
</span></span></code></pre></div><ol start=3><li><code>Type.GetType()</code>静态方法：当你只有类型的完全限定名称字符串时（最动态的方式）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 格式：“命名空间.类名，程序集名”</span>
</span></span><span style=display:flex><span>Type type = Type.GetType(<span style=color:#e6db74>&#34;System.String, mscorlib&#34;</span>); <span style=color:#75715e>// 获取string的类型</span>
</span></span><span style=display:flex><span>Type type2 = Type.GetType(<span style=color:#e6db74>&#34;MyNamespace.MyClass, MyAssembly&#34;</span>);
</span></span></code></pre></div><h5 id=内容>内容</h5><p><code>Type</code>类包含了海量的信息，以下分类列出最重要和最常用的部分</p><ol><li>类型标识信息（Identity Information）
这些属性告诉你这个类型“是谁”</li></ol><ul><li><code>Name</code>：类型的名称（例如：<code>"String"</code>, <code>"List</code>1"）</li><li><code>FullName</code>：类型的完全限定名，包括命名空间（例如：<code>"System.String"</code>, <code>System.Collections.Generic.List</code>1"）</li><li><code>Namespace</code>：类型所属的命名空间（例如<code>"System"</code>）</li><li><code>Assembly</code>：获取声明该类型的<code>Assembly</code>。非常重要，告诉你类型来自哪个.dll或.exe</li><li><code>IsClass</code>, <code>InInterface</code>, <code>IsEnum</code>, <code>IsValueType</code>, <code>IsPrimitive</code>（如<code>int</code>, <code>bool</code>）：一系列布尔属性，用于判断类型的种类</li><li><code>BaseType</code>：获取该类型直接继承的父类的<code>Type</code>。这是实现继承树遍历的基础</li></ul><ol start=2><li>成员discovery（发现成员）
这是反射最核心的功能之一：获取类型的所有成员。这些方法通常返回<code>XXXInfo</code>类型的数组</li></ol><ul><li><code>GetMethods()</code>：返回所有公共方法的<code>MethodInfo[]</code></li><li><code>GetProperties()</code>：返回所有公共属性的<code>PropertyInfo[]</code></li><li><code>GetFields()</code>：返回所有公共字段的<code>FieldInfo[]</code></li><li><code>GetEvents()</code>：返回所有公共事件的<code>EventInfo[]</code></li><li><code>GetConstructors()</code>：返回所有公共构造函数的<code>ConstructorInfo[]</code></li><li><code>GetMembers()</code>：返回所有公共成员的<code>MemberInfo[]</code>（是上述所有成员的基类）</li></ul><p>以上方法通常有重载版本，接收<code>BindingFlags</code>枚举参数，让你能精确控制搜索范围（例如，查找私有成员、静态成员等）</p><ol start=3><li>泛型信息（Generic Information）
对于泛型类型，<code>Type</code>提供了专门的处理</li></ol><ul><li><code>IsGenericType</code>：判断是否是泛型类型（如<code>List&lt;T></code>）</li><li><code>GetGenericTypeDefinition()</code>：获取泛型类型的未绑定版本的类型。例如，对于<code>List&lt;string></code>，调用子方法会返回<code>List&lt;T></code>的<code>Type</code></li><li><code>GetGenericArguments()</code>：获取泛型类型参数或泛型方法类型参数的<code>Type</code>数组。例如，对于<code>Dictionary&lt;string, int></code>，这会返回<code>[typeof(string), typeof(int)]</code></li></ul><ol start=4><li>接口实现（Interface Implementation）</li></ol><ul><li><code>GetInterfaces()</code>：获取该类型实现的所有接口的<code>Type[]</code></li></ul><ol start=5><li>创建实例与获取特定成员</li></ol><ul><li><code>Activator.CreateInstance(Type)</code>：虽然这不是<code>Type</code>的实例方法，但它是使用<code>Type</code>对象最常见的方式之一：动态创建该类型的实例</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>object</span> myInstance = Activator.CreateInstance(myType);
</span></span></code></pre></div><ul><li><code>GetMethod(string name)</code>, <code>GetProperty(string name)</code>, <code>GetField(string name)</code>等：通过名称获取特定的成员，返回对应的<code>MethodInfo</code>, <code>PropertyInfo</code>等。这比遍历数组高效</li></ul><ol start=6><li>特性（Attributes）信息</li></ol><ul><li><code>GetCustomAttributes()</code>：获取应用于此类型的所有自定义特性（Attribute）。这是实现“约定由于配置”模式的基础</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> attributes = myType.GetCustomAttributes(<span style=color:#66d9ef>typeof</span>(ObsoleteAttribute), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (attribute.Length &gt; <span style=color:#ae81ff>0</span>) Console.WriteLine(<span style=color:#e6db74>&#34;This class is obsolete!&#34;</span>)
</span></span></code></pre></div><ol start=7><li>判断类型特征属性（<code>Isxxx</code>）
<strong>类型本质</strong></li></ol><table><thead><tr><th>属性</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>IsClass</code></td><td>是否为类（不含接口、值类型）</td><td><code>typeof(string).IsClass → true</code></td></tr><tr><td><code>IsInterface</code></td><td>是否为接口</td><td><code>typeof(IDisposable).IsInterface → true</code></td></tr><tr><td><code>IsValueType</code></td><td>是否为值类型（struct/enum）</td><td><code>typeof(int).IsValueType → true</code></td></tr><tr><td><code>IsEnum</code></td><td>是否为枚举</td><td><code>typeof(DayOfWeek).IsEnum → true</code></td></tr><tr><td><code>IsPrimitive</code></td><td>是否为基元类型（int, bool, char 等）</td><td><code>typeof(int).IsPrimitive → true</code></td></tr><tr><td><code>IsArray</code></td><td>是否为数组</td><td><code>typeof(int[]).IsArray → true</code></td></tr><tr><td><code>IsPointer</code></td><td>是否为指针类型</td><td><code>typeof(int*).IsPointer → true</code></td></tr><tr><td><code>IsByRef</code></td><td>是否为 <code>ref</code> 传递类型</td><td><code>typeof(int).MakeByRefType().IsByRef → true</code></td></tr><tr><td><code>IsSubclassOf(Type)</code></td><td>是否为某类型的子类</td><td><code>typeof(List&lt;int>).IsSubclassOf(typeof(object)) → true</code></td></tr></tbody></table><p><strong>类修饰符相关</strong></p><table><thead><tr><th>属性</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>IsAbstract</code></td><td>是否为抽象类/抽象方法</td><td><code>typeof(Stream).IsAbstract → true</code></td></tr><tr><td><code>IsSealed</code></td><td>是否为密封类（sealed）</td><td><code>typeof(string).IsSealed → true</code></td></tr><tr><td><code>IsPublic</code></td><td>是否为公共类型</td><td><code>typeof(string).IsPublic → true</code></td></tr><tr><td><code>IsNotPublic</code></td><td>是否为非公共类型</td><td>内部类等</td></tr><tr><td><code>IsVisible</code></td><td>是否对外可见（公共并且程序集可见性允许）</td><td></td></tr></tbody></table><p><strong>嵌套类可见性</strong><br>当类型时嵌套类才有意义</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>IsNestedPublic</code></td><td>公共嵌套类</td></tr><tr><td><code>IsNestedPrivate</code></td><td>私有嵌套类</td></tr><tr><td><code>IsNestedFamily</code></td><td><code>protected</code> 嵌套类</td></tr><tr><td><code>IsNestedAssembly</code></td><td><code>internal</code> 嵌套类</td></tr><tr><td><code>IsNestedFamANDAssem</code></td><td><code>protected internal</code> 且要在同一程序集中</td></tr><tr><td><code>IsNestedFamORAssem</code></td><td><code>protected internal</code> 或程序集可见</td></tr></tbody></table><p><strong>泛型相关</strong></p><table><thead><tr><th>属性</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>IsGenericType</code></td><td>是否为泛型类型</td><td><code>typeof(List&lt;int>).IsGenericType → true</code></td></tr><tr><td><code>IsGenericTypeDefinition</code></td><td>是否为开放泛型定义</td><td><code>typeof(List&lt;>).IsGenericTypeDefinition → true</code></td></tr><tr><td><code>IsConstructedGenericType</code></td><td>是否为已构造泛型（有具体类型参数）</td><td><code>typeof(List&lt;int>).IsConstructedGenericType → true</code></td></tr><tr><td><code>ContainsGenericParameters</code></td><td>是否还包含未绑定的泛型参数</td><td><code>typeof(Dictionary&lt;,>).ContainsGenericParameters → true</code></td></tr><tr><td><code>IsGenericParameter</code></td><td>是否为泛型参数本身</td><td>在 <code>T</code> 这样的泛型占位符时才为 true</td></tr></tbody></table><p><strong>高级/特殊情况</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>IsCOMObject</code></td><td>是否为 COM 对象类型</td></tr><tr><td><code>IsMarshalByRef</code></td><td>是否为按引用封送（Remoting 相关）</td></tr><tr><td><code>IsSecurityCritical</code> / <code>IsSecuritySafeCritical</code> / <code>IsSecurityTransparent</code></td><td>与安全模型相关</td></tr><tr><td><code>IsSerializable</code></td><td>是否可序列化</td></tr><tr><td><code>IsImport</code></td><td>是否使用 <code>ComImportAttribute</code> 标记</td></tr></tbody></table><h4 id=typeinfo><code>TypeInfo</code></h4><h5 id=获取-1>获取</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Reflection;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Type type = <span style=color:#66d9ef>typeof</span>(<span style=color:#66d9ef>string</span>); <span style=color:#75715e>// 先获取普通Type对象</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TypeInfo typeInfo = type.GetTypeInfo(); <span style=color:#75715e>// 通过Type对象获取增强视图TypeInfo</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(typeInfo.FullName);
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> method <span style=color:#66d9ef>in</span> typeInfo.DeclaredMethods)
</span></span><span style=display:flex><span>    Console.WriteLine(method.Name);
</span></span></code></pre></div><p>这是一种优雅的向后兼容策略。现有的代码仍然使用<code>Type</code>，完全不受影响。而新的、面向现代平台的代码可以轻松地切花电脑更强大的<code>TypeInfo</code>API</p><h5 id=内容-1>内容</h5><p><code>TypeInfo</code>不仅包含了<code>Type</code>的所有功能（通过其基类），还添加了更符合逻辑的分组和查询方式</p><ol><li>声明成员（Declared Members）
返回直接在该类型上声明的成员，而不是从基类继承来的</li></ol><ul><li><code>DeclaredMethods</code></li><li><code>DeclaredProperties</code></li><li><code>DeclaredFields</code></li><li><code>DeclaredConstructors</code></li><li><code>DeclaredEvents</code></li><li><code>DeclaredNestedTypes</code></li></ul><ol start=2><li>更清晰的继承链分析</li></ol><ul><li><code>BaseType</code>属性仍然存在（来自<code>Type</code>），直接获取基类</li><li><code>ImplementedInterfaces</code>：获取该类型实现的所有接口的集合(<code>IEnumerable&lt;Types></code>)，这比<code>Type.GetInterfaces()</code>返回数组更现代，更适合LINQ操作</li></ul><ol start=3><li>泛型信息的扩展</li></ol><ul><li><code>GenericTypeParameters</code>：对于泛型类型定义（如<code>List&lt;T></code>），获取其泛型参数列表（<code>T</code>的<code>Type</code>数组）。这与<code>Type.GetGenericArguments()</code>行为类似，但集成在<code>TypeInfo</code>的API中</li><li><code>GenericTypeArguments</code>：对于构造的泛型类型（如<code>List&lt;string></code>），获取其类型实参（<code>string</code>的<code>Type</code>数组）</li><li><code>IsGenericTypeDefinition</code>：判断是否是泛型类型定义</li></ul><ol start=4><li>Attributes信息</li></ol><ul><li><code>GetCustomAttributes()</code>：虽然<code>Type</code>也有此方法，但<code>TypeInfo</code>上的版本更好地集成在了新的反射模型中，用于检查应用于该类型的特性</li></ul><ol start=5><li>程序集和模块信息</li></ol><ul><li><code>Assembly</code>：获取声明该类型的程序集（<code>Assembly</code>）</li><li><code>Module</code>：获取声明该类型的模块（<code>Module</code>）。模块是程序集内部的子结构</li></ul><h5 id=核心价值>核心价值</h5><ol><li>声明视图：提供了<code>DeclaredXxx</code>属性，让你能专注于类型自身声明的成员，过滤掉继承的“噪音”，这是它相对于直接使用<code>Type</code>的<code>GetMethods()</code>等方法的巨大优势</li><li>LINQ友好：其属性大多返回<code>IEnumerable&lt;T></code>集合，可以无缝于LINQ查询集成，使得对类型元数据的查询、过滤和投影操作变得非常简洁和强大</li><li>现代API设计：它代表了.NET反射和API的现代化方向，更侧重于暴露数据而不是通过方法调用获取数据，这更符合.NET Core的轻量级和可组合性理念</li><li>功能完备：因为它继承自<code>Type</code>，所以可以在任何需要<code>Type</code>对象的地方使用<code>TypeInfo</code>，同时还能享受这些新增功能的强大</li></ol><p>在现代.NET开发中（.NET5+），当需要进行复杂的类型内省时，<code>TypeInfo</code>应该是首先工具，而传统的<code>Type</code>方法则更适合简单的、一次性的反射操作</p><h3 id=systemreflection><code>System.Reflection</code></h3><p><code>System.Reflection</code>是.NET Runtime的一个内省（introspection）和交互工具包，提供了程序在运行时检查、发现和操作程序集、模块、类型及其成员的所有能力</p><p>这个命名空间包含的类的能力：</p><ol><li>加载和分析程序集（<code>Assembly</code>）</li><li>检查和遍历类型结构（<code>Type</code>, <code>TypeInfo</code>）</li><li>操作类型成员：方法、属性、字段、构造函数、事件等</li><li>处理泛型和自定义特性</li></ol><h4 id=关键类和结构>关键类和结构</h4><h5 id=assembly><code>Assembly</code></h5><p>程序集的代表。反射的起点之一。可以用它来加载程序集、获取其中定义的所有类型、获取程序集信息（名称、版本、文化等）
<code>Assembly.LoadFrom("MyLibrary.dll")</code>：从文件路径加载程序集
<code>Assembly.GetExecutingAssembly()</code>：获取当前正在执行的代码所在的程序集
<code>assembly.GetTypes()</code>：获取程序集中定义的所有类型</p><h5 id=module><code>Module</code></h5><p>代表程序集内的一个模块(.netmodule)。程序集由一个或多个模块组成，但在日常开发中很少使用，通常一个程序集就是一个模块</p><h5 id=type--typeinfo><code>Type</code> & <code>TypeInfo</code></h5><p>类型的代表。这是反射最核心的类，包含了关于类型的所有元数据。<code>TypeInfo</code>是<code>Type</code>的扩展视图，在现代.NET中提供更丰富的API</p><h5 id=memberinfo派生类><code>MemberInfo</code>派生类</h5><p>这些类提供了对类型成员的具体操作能力，它们都继承自<code>MemberInfo</code></p><ul><li><code>ConstructorInfo</code>：提供了关于构造函数的信息。用于动态创建对象实例<ul><li><code>constructor.Invoke(new object[] { arg1, arg2 })</code>：调用构造函数创建对象</li></ul></li><li><code>MethodInfo</code>：提供关于方法的信息。用于动态调用方法<ul><li><code>method.Invoke(obj, new object[] { param1 })</code>：在对象<code>obj</code>上调用此方法</li></ul></li><li><code>PropertyInfo</code>：提供关于属性的信息。用于动态获取或设置属性值<ul><li><code>prop.GetValue(obj)</code>/<code>prop.SetValue(obj, value)</code></li></ul></li><li><code>FieldInfo</code>：提供关于字段（成员变量）的信息。用于动态读取或写入字段值，甚至可以访问<code>private</code>字段<ul><li><code>field.GetValue(obj)</code>/<code>field.SetValue(obj, value)</code></li></ul></li><li><code>EventInfo</code>：提供关于事件的信息。用于动态添加或移除事件处理程序<ul><li><code>eventInfo.AddEventHandler(obj, handler)</code></li></ul></li><li><code>ParameterInfo</code>：提供关于方法参数的信息</li></ul><h5 id=其他>其他</h5><ul><li><code>BindingFlags</code>：用于精确控制如何搜索和返回成员。例如，可以指定要搜索<code>public</code>/<code>non-public</code>、<code>static</code>/<code>instance</code>成员<ul><li><code>BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly</code></li></ul></li><li><code>CustomAttributeExtensions</code>：提供扩展方法（如<code>GetCustomAttribute()</code>）来检索应用于类型或成员的自定义特性</li><li><code>TargetException</code>, <code>TargetParamterCountException</code>等：反射操作失败时抛出的特定异常</li><li><code>IsDefined</code>：判断某个特性是否应用在类型或成员上<ul><li>所在类型<ul><li><code>MemberInfo.IsDefined(Type attributeType, bool inherit)</code></li><li><code>ParameterInfo.IsDefined(Type attributeType, bool inherit)</code></li><li><code>Module.IsDefined(Type attributeType, bool inherit)</code></li><li><code>Assembly.IsDefined(Type attributeType, bool inherit)</code></li></ul></li><li>返回值：<code>bool</code></li></ul></li></ul><h3 id=systemreflectionemit><code>System.Reflection.Emit</code></h3><p><code>System.Reflection</code>的作用是检查和分析已有代码元数据，<code>System.Reflection.Emit</code>就是让在运行时动态地创建和生成全新的代码<br>它提供了在内存中或磁盘上动态构建新Assembly、Module、Type and Method的能力，甚至可以直接生成IL指令</p><h4 id=核心思想运行时代码生成>核心思想：运行时代码生成</h4><p>不是在VS里写C#代码然后编译成<code>.dll</code>，而是用C#代码编写一个程序，这个程序本身会像一个编译器一样，在运行时输出另一个<code>.dll</code>或在内存中创建一个新的类型。这就是<code>Reflection.Emit</code>所做的事</p><h4 id=关键类>关键类</h4><p>这个命名空间包含一整套用于按层次结构构建程序集的类</p><h5 id=assemblybuilder-modulebuilder><code>AssemblyBuilder</code>, <code>ModuleBuilder</code></h5><ul><li><code>AssemblyBuilder</code>：代表一个正在构建中的动态程序集。这是所有动态代码生成的起点。可以选择将其保存到磁盘上的一个<code>.dll</code>或<code>.exe</code>文件，或者仅仅在内存中创建它<ul><li>通过<code>AppDomain.DefineDynamicAssembly</code>（旧版）或<code>AssemblyBuilder.DefineDynamicAssembly</code>（.NET Core+）创建</li></ul></li><li><code>ModuleBuilder</code>：代表动态程序集内的一个模块。程序集由一个或多个模块组成。必须在模块内定义类型<ul><li>通过<code>AssemblyBuilder.DefineDynamicModule</code>创建</li></ul></li></ul><h5 id=typebuilder-enumbuilder><code>TypeBuilder</code>, <code>EnumBuilder</code></h5><ul><li><code>TypeBuilder</code>：用于在模块内定义新的类、接口、结构体。可以指定其名称、可见性、父类、实现的接口等<ul><li>通过<code>ModuleBuilder.DefineType</code>创建</li></ul></li><li><code>EnumBuilder</code>：用于定义枚举类型。是<code>TypeBuilder</code>的一种特化形式</li></ul><h5 id=methodbuilder-constructorbuilder-fieldbuilder-propertybuilder-eventbuilder><code>MethodBuilder</code>, <code>ConstructorBuilder</code>, <code>FieldBuilder</code>, <code>PropertyBuilder</code>, <code>EventBuilder</code></h5><p>这些类用于为动态类型添加成员你</p><ul><li><code>MethodBuilder</code>：用于在动态类型上定义方法。可以指定方法名、参数、返回类型、可见性等</li><li><code>ConstructorBuilder</code>：用于定义构造函数（<code>.ctor</code>）和静态构造函数（<code>.cctor</code>）</li><li><code>FieldBuilder</code>：用于定义字段（成员变量）</li><li><code>PropertyBuilder</code>：用于定义属性（包括<code>get</code>和<code>set</code>访问器）</li><li><code>EventBuilder</code>：用于定义事件</li></ul><h5 id=ilgenerator><code>ILGenerator</code></h5><p>编写实际代码，这是最底层的，当使用<code>MethodBuilder</code>或<code>ConstructorBuilder</code>定义了方法的签名后，需要一个<code>ILGenerator</code>来填充方法的实际逻辑</p><ul><li><code>ILGenerator</code>这个类提供了发出（Emit）IL操作码的方法。IL是.NET的底层指令集<ul><li>通过<code>MethodBuilder.GetILGenerator()</code>获取</li><li>使用其方法如<code>Emit(OpCode)</code>、<code>EmitWriteLine</code>来生成指令</li><li>试用期方法来定义标签（<code>DefineLabel</code>）、声明局部变量（<code>DeclareLocal</code>），实现流程控制（如<code>if</code>判断、循环）</li></ul></li></ul><p>常见的IL指令示例</p><ul><li><code>OpCodes.Ldarg_0</code>：加载第0个参数（对于实例方法，通常是<code>this</code>）</li><li><code>OpCodes.Ldstr</code>：加载一个字符串</li><li><code>OpCodes.Call</code>：调用一个方法</li><li><code>OpCodes.Ret</code>：从方法返回</li><li><code>OpCodes.Newobj</code>：调用构造函数创建新对象</li><li><code>OpCodes.Stfld</code>：将值存储到对象的字段中</li></ul><h4 id=主要用途和应用场景>主要用途和应用场景</h4><ol><li>动态代理（AOP - Aspect-Oriented Programming）</li></ol><ul><li>框架如Castle DynamicProxy就是基于<code>Reflection.Emit</code>构建的。它们能在运行时生成一个继承自目标类或实现目标接口的代理类，并在调用实际方法前后插入代码（如日志、事务、缓存等）</li></ul><ol start=2><li>ORM和序列化器的动态实现</li></ol><ul><li>为了极致性能，ORM（如Dapper的高阶用法）可以动态生成一个专门用于映射特定实体类和数据行的代码，避免使用反射带来的开销</li></ul><ol start=3><li>编译器或脚本引擎</li></ol><ul><li>动态语言（如IronPython, IronRuby）的.NET实现使用它来将脚本代码编译成.NET程序集</li><li>你自己的领域特定语言（DSL）解释器</li></ul><ol start=4><li>动态生成高性能代码：</li></ol><ul><li>对于某些复杂的、基于配置的算法，可以动态生成最优化的IL代码，这比通过反射调用或解释配置要快得多</li></ul><h4 id=总结>总结</h4><p><code>System.Reflection.Emit</code>是一个极其强大但也非常复杂的底层API。它让你从”代码的消费者”变成了“代码的生产者”</p><ul><li>优点：无与伦比的灵活性和性能潜力</li><li>缺点：<ul><li>难：需要理解.NET类型系统、CLR内存模型和IL指令</li><li>难以调试：生成的IL代码很难调试和诊断</li><li>脆弱：生成的代码如果出错，通常会在运行时导致可怕的<code>InvalidProgramException</code></li></ul></li></ul><p>因此，绝大多数普通开发者不会直接使用它，而是使用基于它构建的高级库。它的主要用户是框架、库和编译器开发者</p><h3 id=systemreflectionmetadata><code>System.Reflection.Metadata</code></h3><p><code>System.Refelction.Metadata</code>是一个更现代、更轻量级、更高性能的用于读取.NET程序集元数据的API。它提供了对ECMA-335(.NET程序集标准格式)的低级访问</p><h4 id=核心思想低级只读高性能>核心思想：低级、只读、高性能</h4><p>与<code>System.Reflection</code>不同，<code>System.Reflection.Metadata</code>：</p><ol><li>只读（Read-Only）：它只用于读取元数据，不能用于动态创建或修改类型（那是<code>System.Reflection.Emit</code>的工作）</li><li>低级（Low-Level）：它不提供高层的抽象（如<code>Type</code>，<code>MethodInfo</code>对象），而是提供对元数据表、对、Blob的直接访问。需要自己组装出需要的信息</li><li>高性能（High-Performance）：因为它避免了创建大对象（如为每个方法创建一个<code>MethodInfo</code>实例）和复杂的逻辑，所以它的速度极快，内存占用极低</li><li>无负载（No Load）：它不会将程序集假爱到当前的<code>AppDomain</code>或<code>AssemblyLoadContext</code>中。它只是直接解析程序集的字节流。这意味着它更安全，不会导致程序集冲突或锁定文件</li></ol><h4 id=关键概念和核心类>关键概念和核心类</h4><p>要理解这个命名空间，需要先了解ECMA-335元数据格式的几个核心概念</p><ul><li>元数据表（Metadata Tables）：程序集元数据被组织成一系列的表，例如<code>TypeDef</code>表（类型定义）、<code>MethodDef</code>表（方法定义）、<code>FieldDef</code>表（字段定义）等。每张表都由许多行组成</li><li>句柄（Handles）：这是<code>System.Refelction.Metadata</code>的核心标识符。它是对元数据表中某一行的一个轻量级、高效的引用（类似于数据库中的行ID）。例如<code>TypeDefinitionHandle</code>, <code>MethodDefinitionHandle</code>。使用句柄来从阅读器中获取具体数据</li><li>Blob & Heap：字符串、签名、常量值等数据不是直接存储在表里，而是存储在特殊的堆（Heap）区域中，表里只能存储一个指向堆的偏移量（Blob Pointer）</li></ul><h5 id=metadatareader><code>MetadataReader</code></h5><p>这是整个API的核心和入口点。通过它来访问程序集的所有元数据</p><ul><li>如何创建：通过一个<code>byte[]</code>（程序集的字节）或<code>Stream</code>（指向程序集文件的流）来创建<code>PEReader</code>，然后再从<code>PEReader</code>获取<code>MetadataReader</code></li><li>功能：它提供了属性和方法来访问所有的元数据表、解析句柄、读取字符串等</li></ul><h5 id=xxxdefinition和xxxdefinitionhandle><code>XXXDefinition</code>和<code>XXXDefinitionHandle</code></h5><p>对于每种元数据元素，通常有一对类：</p><ul><li><code>XXXDefinition</code>：包含该元素的实际数据（如<code>TypeDefinition</code>包含类型的特性、名称、基类等）</li><li><code>XXXDefinitionHandle</code>：用于获取对应<code>XXXDefinition</code>的句柄</li></ul><p>例如：</p><ul><li><code>TypeDefinition</code> & <code>TypeDefinitionHandle</code></li><li><code>MethodDefinition</code> & <code>MethodDefinitionHandle</code></li><li><code>FieldDefinition</code> & <code>FieldDefinitionHandle</code></li><li><code>AssemblyDefinition</code> & <code>AssemblyDefinitionHandle</code></li></ul><h5 id=其他重要类型>其他重要类型</h5><ul><li><code>EntityHandle</code>：所有具体句柄（如<code>TypeDefinitionHandle</code>）的基类</li><li><code>BlobReader</code>：用于读取Blob堆中的二进制数据（例如方法签名）</li><li><code>StringReader</code>：用于从字符串堆中读取字符串</li></ul><p>如果用传统的<code>System.Reflection</code>，代码会简单得多：<code>Assembly.LoadFrom("MyLibrary.dll").GetTypes()</code>。但代价是加载了整个程序集，消耗了更多资源和时间</p><h4 id=主要用途和应用场景-1>主要用途和应用场景</h4><ol><li>编译器和分析器（Roslyn）</li></ol><ul><li>.NET编译器平台（Roslyn）本身大量使用此API来快速分析代码和元数据，而无需加载所有程序集</li></ul><ol start=2><li>高级代码分析工具</li></ol><ul><li>需要快速扫描大量程序集以生成依赖关系图、查找特定模式、检查代码规范的工具。因为它的低内存开销，可以同时处理成百上千个程序集</li></ul><ol start=3><li>IDE功能</li></ol><ul><li>Visual Studio 或 VS Code中的"Go to Definition"、&ldquo;Find All References&rdquo;、智能感知（IntelliSense）等功能需要在后台快速读取元数据，这个API是理想选择</li></ul><ol start=4><li>序列化器/映射器的高级优化</li></ol><ul><li>类似于<code>Reflection.Emit</code>的用途，但这里是用于分析而非生成。一个库可以在启动时使用<code>System.Reflection.Metadata</code>快速分析所有需要序列化的类型结构，然后为它们动态生成（通过<code>Emit</code>）最优化的序列化代码</li></ul><ol start=5><li>安全的元数据检查</li></ol><ul><li>当需要检查一个程序集的信息（版本、公开类型等），但又绝对不想把它加载到应用程序域中执行时（处于安全或隔离考虑），这是完美工具</li></ul><h3 id=原类型如何避免被反射>原类型如何避免被反射</h3><ol><li><p><code>SecurityCritical</code>和<code>SecuritySafeCritical</code>特性（在部分信任环境中）
在旧的.NET Framework代码访问安全（CAS）模型中，可以将代码标记为安全关键的，这会在部分信任的沙箱环境中阻止非特权代码通过反射进行访问。不过，这套模型在现代.NET中已经被认为过时且很少使用</p></li><li><p>运行时检查并拒绝
理论上，可以在属性的<code>setter</code>或方法里检查是谁在调用它。<code>.NET</code>提供了<code>StackTrace</code>和<code>CallingAssembly</code>等类来检查调用堆栈</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> SecretPassword
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>set</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> stackTrace = <span style=color:#66d9ef>new</span> StackTrace();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> callingMethod = stacckTrace.GetFrame(<span style=color:#ae81ff>1</span>)?.GetMethod();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果调用者是通过反色和来的，可以拒绝</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (callingMethod?.Name == <span style=color:#e6db74>&#34;Invoke&#34;</span> &amp;&amp; callingMethod.DeclaringType?.Name == <span style=color:#e6db74>&#34;RuntimeMethodInfo&#34;</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InvalidOperationException(<span style=color:#e6db74>&#34;Direct assignment only! No reflection allowed!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    _secretPassword = <span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是这种方法非常脆弱、有性能开销，而且很容易被绕过（例如，反射调用底层私有字段<code>_secretPassword</code>就直接绕过了这个属性setter），因此极不推荐</p><h2 id=反射在unity中的使用>反射在Unity中的使用</h2><h2 id=性能优化>性能优化</h2><h3 id=反射与委托结合>反射与委托结合</h3><h3 id=反射与泛型结合>反射与泛型结合</h3><h3 id=反射与linq结合>反射与LINQ结合</h3><h2 id=最佳实践>最佳实践</h2><h2 id=底层原理>底层原理</h2><h3 id=底层理解>底层理解</h3><h3 id=methodinfoinvoke-propertysetvalue-propertygetvalue><code>MethodInfo.Invoke</code>, <code>Property.SetValue</code>, <code>Property.GetValue</code></h3><h3 id=反射链路>反射链路</h3></div><nav class=post-nav><a href=/dotnetandwindows/lib/property/ class=hover:underline>pre: Property</a>
<a href=/dotnetandwindows/lib/unsafe/ class=hover:underline>next: Unsafe</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#基本概念>基本概念</a><ul><li><a href=#反射的作用>反射的作用</a></li><li><a href=#反射的优缺点>反射的优缺点</a></li><li><a href=#反射使用场景>反射使用场景</a></li></ul></li><li><a href=#c反射核心>C#反射核心</a><ul><li><a href=#核心命名空间及其下的类>核心命名空间及其下的类</a></li><li><a href=#systemtypetypeinfo><code>System.Type</code>/<code>TypeInfo</code></a><ul><li><a href=#背景>背景</a></li><li><a href=#systemtype><code>System.Type</code></a><ul><li><a href=#获取>获取</a></li><li><a href=#内容>内容</a></li></ul></li><li><a href=#typeinfo><code>TypeInfo</code></a><ul><li><a href=#获取-1>获取</a></li><li><a href=#内容-1>内容</a></li><li><a href=#核心价值>核心价值</a></li></ul></li></ul></li><li><a href=#systemreflection><code>System.Reflection</code></a><ul><li><a href=#关键类和结构>关键类和结构</a><ul><li><a href=#assembly><code>Assembly</code></a></li><li><a href=#module><code>Module</code></a></li><li><a href=#type--typeinfo><code>Type</code> & <code>TypeInfo</code></a></li><li><a href=#memberinfo派生类><code>MemberInfo</code>派生类</a></li><li><a href=#其他>其他</a></li></ul></li></ul></li><li><a href=#systemreflectionemit><code>System.Reflection.Emit</code></a><ul><li><a href=#核心思想运行时代码生成>核心思想：运行时代码生成</a></li><li><a href=#关键类>关键类</a><ul><li><a href=#assemblybuilder-modulebuilder><code>AssemblyBuilder</code>, <code>ModuleBuilder</code></a></li><li><a href=#typebuilder-enumbuilder><code>TypeBuilder</code>, <code>EnumBuilder</code></a></li><li><a href=#methodbuilder-constructorbuilder-fieldbuilder-propertybuilder-eventbuilder><code>MethodBuilder</code>, <code>ConstructorBuilder</code>, <code>FieldBuilder</code>, <code>PropertyBuilder</code>, <code>EventBuilder</code></a></li><li><a href=#ilgenerator><code>ILGenerator</code></a></li></ul></li><li><a href=#主要用途和应用场景>主要用途和应用场景</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#systemreflectionmetadata><code>System.Reflection.Metadata</code></a><ul><li><a href=#核心思想低级只读高性能>核心思想：低级、只读、高性能</a></li><li><a href=#关键概念和核心类>关键概念和核心类</a><ul><li><a href=#metadatareader><code>MetadataReader</code></a></li><li><a href=#xxxdefinition和xxxdefinitionhandle><code>XXXDefinition</code>和<code>XXXDefinitionHandle</code></a></li><li><a href=#其他重要类型>其他重要类型</a></li></ul></li><li><a href=#主要用途和应用场景-1>主要用途和应用场景</a></li></ul></li><li><a href=#原类型如何避免被反射>原类型如何避免被反射</a></li></ul></li><li><a href=#反射在unity中的使用>反射在Unity中的使用</a></li><li><a href=#性能优化>性能优化</a><ul><li><a href=#反射与委托结合>反射与委托结合</a></li><li><a href=#反射与泛型结合>反射与泛型结合</a></li><li><a href=#反射与linq结合>反射与LINQ结合</a></li></ul></li><li><a href=#最佳实践>最佳实践</a></li><li><a href=#底层原理>底层原理</a><ul><li><a href=#底层理解>底层理解</a></li><li><a href=#methodinfoinvoke-propertysetvalue-propertygetvalue><code>MethodInfo.Invoke</code>, <code>Property.SetValue</code>, <code>Property.GetValue</code></a></li><li><a href=#反射链路>反射链路</a></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>