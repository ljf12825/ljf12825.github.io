<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Miscellaneous</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/lib/>Lib</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /             <a class=nav-item data-path=/engine/ href=/engine/>Engine</a>         |
|                             |  /                 |           |
|                             | /                  |           |
|                             |/                   |           |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/framework/ href=/framework/>Framework</a>       |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Miscellaneous<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><h2 id=using><code>using</code></h2><p><code>using</code>在C#中有两种主要用法：作为指令（namespace导入）和作为语句（资源管理）</p><h3 id=using指令namespace导入>using指令（Namespace导入）</h3><p>用于导入命名空间，简化类型访问</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System; <span style=color:#75715e>// 导入 System命名空间</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO; <span style=color:#75715e>// 导入 System.IO命名空间</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Project.Models; <span style=color:#75715e>// 导入自定义命名空间</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用示例</span>
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>&#34;Hello&#34;</span>); <span style=color:#75715e>// 不需要写 System.Console.WriteLine</span>
</span></span></code></pre></div><p><strong>特殊用法</strong></p><ol><li>静态using（C# 6+）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> static System.Math; <span style=color:#75715e>// 导入静态类</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> x = Sqr(<span style=color:#ae81ff>16</span>); <span style=color:#75715e>// 可直接使用Sqrt而不是Math.Sqrt</span>
</span></span></code></pre></div><ol start=2><li>别名using</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> WinForms = System.Windows.Forms;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> form = <span style=color:#66d9ef>new</span> WinForms.Form(); <span style=color:#75715e>// 使用别名</span>
</span></span></code></pre></div><h3 id=using语句资源管理>using语句（资源管理）</h3><p>用于自动管理实现了<code>IDisposable</code>接口的对象资源，确保对象在使用后被正确释放</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> resource = <span style=color:#66d9ef>new</span> DisposableObject())
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 resource</span>
</span></span><span style=display:flex><span>} <span style=color:#75715e>// 自动调用 resource.Dispose()</span>
</span></span></code></pre></div><p><strong>示例</strong></p><ol><li>文件操作</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> file = <span style=color:#66d9ef>new</span> StreamWriter(<span style=color:#e6db74>&#34;test.txt&#34;</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    file.WriteLine(<span style=color:#e6db74>&#34;Hello&#34;</span>);
</span></span><span style=display:flex><span>} <span style=color:#75715e>// 自动关闭文件</span>
</span></span></code></pre></div><ol start=2><li>数据库连接</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> conn = <span style=color:#66d9ef>new</span> SqlConnection(connectingString))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    conn.Open();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 执行数据库操作</span>
</span></span><span style=display:flex><span>} <span style=color:#75715e>// 自动关闭连接</span>
</span></span></code></pre></div><ol start=3><li>多个资源</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> res1 = <span style=color:#66d9ef>new</span> Resource1())
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> res2 = <span style=color:#66d9ef>new</span> Resource2())
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 res1和res2</span>
</span></span><span style=display:flex><span>} <span style=color:#75715e>// 先释放 res2 再释放 res1</span>
</span></span></code></pre></div><p><strong>C# 8.0简化写法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> var file = <span style=color:#66d9ef>new</span> StreamWriter(<span style=color:#e6db74>&#34;test.txt&#34;</span>);
</span></span><span style=display:flex><span>file.WriteLine(<span style=color:#e6db74>&#34;Hello&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 当离开当前作用域时自动释放</span>
</span></span></code></pre></div><p><strong>底层原理</strong>
<code>using</code>语句会被编译器转换为类似以下结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> resource = <span style=color:#66d9ef>new</span> DisposableObject();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 代码块</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (resource != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            resource.Dispose();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=使用注意事项>使用注意事项</h4><ol><li>必须实现IDisposable</li><li>异常处理</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> resource = <span style=color:#66d9ef>new</span> DisposableObject())
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 即使这里抛出异常，Dispose()也会被调用</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>不要重复释放</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> resource = <span style=color:#66d9ef>new</span> DisposableObject();
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> (resouce)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 这里不要再调用 resource.Dispose()</span>
</span></span></code></pre></div><ol start=4><li>异步场景
C# 8.0+ 支持异步using</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>await</span> <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> resource = <span style=color:#66d9ef>new</span> AsyncDisposableObject())
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 异步操作</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=适用场景>适用场景</h4><ul><li>文件 I/O 类（<code>StreamReader</code>,<code>StreamWriter</code>,<code>FileStream</code>）</li><li>数据库相关（<code>SqlConnection</code>, <code>SqlCommand</code>）</li><li>网络相关（<code>HttpClient</code> 某些用法）</li><li>图形相关（<code>Bitmap</code>, <code>Graphics</code>）</li><li>其他实现了 <code>IDisposable</code> 的资源</li></ul><h2 id=defaultt><code>default(T)</code></h2><p><code>default(T)</code>是一个运算符，它返回类型<code>T</code>的默认值<br>它的作用就是：无论<code>T</code>是什么类型，都给我一个该类型最“默认”、最“基础”的值</p><h3 id=默认值规则>默认值规则</h3><p><code>default(T)</code>的行为取决于<code>T</code>是值类型还是引用类型，遵循C#语言的默认值规则：</p><ol><li>对于所有引用类型（<code>class</code>、<code>interface</code>、<code>delegate</code>、<code>array</code>、<code>string</code>等）</li></ol><ul><li><code>default(T)</code>返回<code>null</code></li><li>这表示一个“空”引用，不指向任何对象</li></ul><ol start=2><li>对于值类型（<code>struct</code>和所有数字类型、<code>bool</code>、<code>char</code>、<code>enum</code>等）</li></ol><ul><li><code>default(T)</code>返回一个所有字段都被设置为各自默认值得实例（即“归零”的实例）</li><li>这通常意味着<ul><li>数值类型（<code>int</code>, <code>double</code>, <code>decimal</code>等）返回<code>0</code></li><li><code>bool</code>返回<code>false</code></li><li><code>char</code>返回<code>'\0'</code>（空字符）</li><li><code>enmu</code>返回<code>(E)0</code>，即使这个枚举值可能没有定义</li><li>自定义的<code>struct</code>返回一个实例，其中每个字段都被设置为它的默认值</li></ul></li></ul><h3 id=defaultt的存在意义><code>default(T)</code>的存在意义</h3><p>主要原因是泛型。在编写泛型类后方法时，编译器在编译时无法知道类型参数<code>T</code>具体是值类型还是引用类型<br>假设没有<code>default(T)</code>，可能会这样写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> T GetDefaultValue&lt;T&gt;()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果T是引用类型，返回null是OK的</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果T是值类型，null不是有效值，编译错误</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// CS0403：无法将null转换为类型参数T</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>或者</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> T GetDefaultValue&lt;T&gt;()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果T是引用类型，返回0没有意义</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//编译错误</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// CS0029：无法将类型 int 隐式转换为T</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>default(T)</code>优雅地解决了这个问题。它让编译器根据具体的<code>T</code>在运行时决定返回<code>null</code>还是“归零”的值类型实例</p><h3 id=实际应用场景和示例>实际应用场景和示例</h3><ol><li>泛型类和方法的初始化
这是<code>default(T)</code>最经典的使用场景</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DataStroe</span>&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> T _data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DataStore()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在构造函数中，将_data初始化为T的默认值</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果T是 int， _data = 0</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果T是 string _data = null</span>
</span></span><span style=display:flex><span>        _data = <span style=color:#66d9ef>default</span>(T);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsDataPresent()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 比较时也需要 default(T)</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对于引用类型，这是与null比较</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对于值类型，这是与0/false等比较</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> !EqualityComparer&lt;T&gt;.Default.Equals(_data, <span style=color:#66d9ef>default</span>(T));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> intStore = <span style=color:#66d9ef>new</span> DataStore&lt;<span style=color:#66d9ef>int</span>&gt;(); <span style=color:#75715e>// _data初始化为0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> stringStore = <span style=color:#66d9ef>new</span> DataStore&lt;<span style=color:#66d9ef>string</span>&gt;(); <span style=color:#75715e>// _data 初始化为 null</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>方法的默认返回值
当一个泛型方法需要返回一个“无结果”或“初始”值时</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> T FindItem&lt;T&gt;(List&lt;T&gt; list, Predicate&lt;T&gt; predicate)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> item <span style=color:#66d9ef>in</span> list) <span style=color:#66d9ef>if</span> (predicate(item)) <span style=color:#66d9ef>return</span> item;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果没找到，返回T的默认值</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 对于引用类型返回null，对于值类型返回0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>default</span>(T);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用</span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>string</span>&gt; names = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>string</span>&gt; { <span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#e6db74>&#34;Bob&#34;</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> result = FindItem(names, n =&gt; n == <span style=color:#e6db74>&#34;Charlie&#34;</span>); <span style=color:#75715e>// result 为 null</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>string</span>&gt; numbers = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt; { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> result2 = FindItem(numbers, n =&gt; n &gt; <span style=color:#ae81ff>5</span>); <span style=color:#75715e>// result2 为 0</span>
</span></span></code></pre></div><ol start=3><li>重置或清除值</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ClearValue&lt;T&gt;(<span style=color:#66d9ef>ref</span> T <span style=color:#66d9ef>value</span>) =&gt; <span style=color:#66d9ef>value</span> = <span style=color:#66d9ef>default</span>(T); <span style=color:#75715e>// 将value重置为其类型的默认状态</span>
</span></span></code></pre></div><h3 id=defalut字面量c71引入><code>defalut</code>字面量（C#7.1引入）</h3><p>从C# 7.1开始，编译器变得足够智能，可以根据上下文推断出<code>T</code>的类型。因此，可以省略<code>&lt;T></code>，只写<code>default</code>，使代码更简洁</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 之前的写法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> num = <span style=color:#66d9ef>default</span>(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> str = <span style=color:#66d9ef>default</span>(<span style=color:#66d9ef>string</span>);
</span></span><span style=display:flex><span>MyGenericMethod&lt;<span style=color:#66d9ef>string</span>&gt;(<span style=color:#66d9ef>default</span>(<span style=color:#66d9ef>string</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// C# 7.1+ 的推荐写法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> num = <span style=color:#66d9ef>default</span>; <span style=color:#75715e>// 编译器知道你要的是 int，所以是 0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> str = <span style=color:#66d9ef>default</span>; <span style=color:#75715e>// 编译器知道你要的是 string，所以是 null</span>
</span></span><span style=display:flex><span>MyGenericMethod&lt;<span style=color:#66d9ef>string</span>&gt;(<span style=color:#66d9ef>default</span>); <span style=color:#75715e>// 编译器根据方法参数类型推断出是 default(string)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在泛型方法中同样适用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> T GetDefault() =&gt; <span style=color:#66d9ef>default</span>; <span style=color:#75715e>// 等价于 default(T)</span>
</span></span></code></pre></div><h2 id=expression-bodied>Expression-bodied</h2><p>表达式主体是一个从C# 6开始引入并逐步增强的语法糖，旨在让代码更简洁、更易读</p><h3 id=核心概念>核心概念</h3><p>表达式主题允许使用箭头符号<code>=></code>来替代传统的大括号<code>{}</code>代码块，将一个成员的定义简化为单个表达式<br>它的核心思想是：如果一个成员（如方法、属性）的逻辑可以在一行表达式内完成，那么就可以使用这种简洁的语法</p><p><strong>历史演变</strong></p><table><thead><tr><th>Edition</th><th>Support</th></tr></thead><tbody><tr><td>6.0</td><td>方法、只读属性、运算符</td></tr><tr><td>7.0</td><td>构造函数、终结器、Getter、Setter、索引器的访问器（get/set）</td></tr><tr><td>9.0</td><td>顶级语句（本质上是Main方法的表达式主体）</td></tr></tbody></table><h3 id=示例>示例</h3><ol><li>方法（Methods）- C# 6+</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 传统写法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> GetFullName(<span style=color:#66d9ef>string</span> firstName, <span style=color:#66d9ef>string</span> lastName)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>$&#34;{firstName} {lastName}&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 表达式主题写法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> GetFullName(<span style=color:#66d9ef>string</span> firstName, <span style=color:#66d9ef>string</span> lastName) =&gt; <span style=color:#e6db74>$&#34;{firstName} {lastName}&#34;</span>;
</span></span></code></pre></div><ul><li><code>=></code>替换了<code>{ return ...; }</code></li><li>表达式的结果自动作为方法的返回值</li></ul><ol start=2><li>只读属性（Read-only Properties）- C# 6+</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>//传统写法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> DateTime CreatedTime
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> DateTime.Now; }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 表达式主体写法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> DateTime CreatedTime =&gt; DateTime.Now;
</span></span></code></pre></div><ol start=3><li>属性访问器（Property Accessors）- C# 7+
C# 7.0允许对属性的<code>get</code>和<code>set</code>访问器单独使用表达式主体</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> _firstName;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 传统写法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> FirstName
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> _firstName; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>set</span> { _firstName = <span style=color:#66d9ef>value</span>; }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 表达式主体写法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> FirstName
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>get</span> =&gt; _firstName;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>set</span> =&gt; _firstName = <span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>构造函数和终结器（Constructors and Finalizers）- C#7+</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> _name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 传统构造函数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Person(<span style=color:#66d9ef>string</span> name)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _name = name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 表达式主体写法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Person(<span style=color:#66d9ef>string</span> name) =&gt; _name = name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 传统终结器（析构函数）</span>
</span></span><span style=display:flex><span>    ~Person()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;Finalized&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 表达式主体终结器</span>
</span></span><span style=display:flex><span>    ~Person() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Finalized&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意：构造函数通常有多个语句（参数验证、初始化等），所以旨在其逻辑非常简单（如直接赋值）时才适合表达式主体</p><ol start=5><li>索引器（Indexers） - C# 7+</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span>[] _items = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>string</span> [<span style=color:#ae81ff>10</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 传统写法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> <span style=color:#66d9ef>this</span>[<span style=color:#66d9ef>int</span> index]
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> _items[index]; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>set</span> { _items[index] = <span style=color:#66d9ef>value</span>; }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 表达式主体写法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> <span style=color:#66d9ef>this</span>[<span style=color:#66d9ef>int</span> index]
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>get</span> =&gt; _items[index];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>set</span> =&gt; _items[index] = <span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=使用表达式主体的优点>使用表达式主体的优点</h3><ol><li>简洁性（Brevity）：这是最主要的目的。它显著减少了样板代码（如大括号、<code>return</code>关键字、<code>get</code>/<code>set</code>块），让代码行数更少，更紧凑</li><li>可读性（Readability）：对于简单的成员，表达式主体就像数学公式一样一目了然，意图非常清晰。一眼就能看出“这个属性返回什么”或“这个方法做什么”</li><li>函数式风格（Functional Style）：它鼓励将逻辑编写为简单的表达式链，而不是复杂的语句块，使代码更接近函数式编程风格</li><li>与Lambda表达式一致：语法上与Lambda表达式<code>(x) => x * x</code>保持一致，降低了学习成本，让语言更统一</li></ol><h3 id=注意事项与缺陷>注意事项与缺陷</h3><ol><li>仅限单个表达式：这是最大的限制。表达式主体只能包含一个表达式，不能包含语句（如<code>if</code>、<code>switch</code>、<code>for</code>、<code>try-catch</code>等）</li></ol><ul><li>可行：<code>=> x + y</code>（表达式）</li><li>不可行：<code>=> { if (x > y) return x; else return y; }</code>（语句块）</li></ul><ol start=2><li><p>调试略有不同：在调试时，整个表达式主体被视为一行代码。无法像在代码块中那样在<code>return</code>前设置断点。但这通常不是大问题</p></li><li><p>不要过度使用：简洁不应以牺牲可读性为代价</p></li></ol><ul><li>适合：简单的计算、直接返回字段或属性、简单的委托</li><li>不适合：逻辑稍微复杂的方法。强行将多行逻辑塞进一个表达式（例如使用嵌套的三元运算符<code>?:</code>）会使代码难以阅读和维护。这时应果断换回传统的代码块写法</li></ul><h2 id=var><code>var</code></h2><p><code>var</code>是C# 3.0引入的一个非常重要的关键字，它允许开发者在声明变量时让编译器自动推断变量的类型</p><h3 id=基本语法和使用>基本语法和使用</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 显式类型声明</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> explicitName = <span style=color:#e6db74>&#34;John&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> explicitAge = <span style=color:#ae81ff>25</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用var隐式类型声明</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> implicitName = <span style=color:#e6db74>&#34;John&#34;</span>; <span style=color:#75715e>// 编译器推断为string</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> implicitAge = <span style=color:#ae81ff>25</span>; <span style=color:#75715e>// 编译器推断为 int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> implicitList = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>string</span>&gt;; <span style=color:#75715e>// 编译器推断为 List&lt;string&gt;</span>
</span></span></code></pre></div><h3 id=工作原理>工作原理</h3><p><code>var</code>的工作原理实际上是基于C#的类型推断机制<br>编译器通过分析<code>var</code>右侧的表达式来推导处变量的类型<br>这种推断发生在编译阶段，因此<code>var</code>变量的类型在运行时与显式声明的类型是完全一致的<br>尽管C#是一种强类型的语言，<code>var</code>只是简化了变量声明的过程，但最终类型依然是静态的，且在编译时已知<br>目的是提高开发效率、减少代码冗余，而不是改变C#的类型系统<br><code>var</code>在性能上是零成本的，因为在编译期推断，生成的IL代码与显式声明完全相同</p><h3 id=适用场景-1>适用场景</h3><ol><li>复杂类型声明</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 没有 var 的情况</span>
</span></span><span style=display:flex><span>Dictionary&lt;<span style=color:#66d9ef>string</span>, List&lt;Dictionary&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>string</span>&gt;&gt;&gt; complexDict = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, List&lt;Dictionary&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>string</span>&gt;&gt;&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用 var 的情况</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> complexDict = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, List&lt;Dictionary&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>string</span>&gt;&gt;&gt;();
</span></span></code></pre></div><ol start=2><li>LINQ查询结果</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> results = <span style=color:#66d9ef>from</span> person <span style=color:#66d9ef>in</span> people
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>where</span> person.Age &gt; <span style=color:#ae81ff>18</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>select</span> <span style=color:#66d9ef>new</span> { person.Name, person.Age };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 等价于</span>
</span></span><span style=display:flex><span>IEnumerable&lt;&lt;anonymous type&gt;&gt; results = ...;
</span></span></code></pre></div><ol start=3><li>匿名类型</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> person = <span style=color:#66d9ef>new</span> { Name = <span style=color:#e6db74>&#34;John&#34;</span>, Age = <span style=color:#ae81ff>30</span> };
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;{person.Name} is {person.Age} years old&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 没有 var, 匿名类型无法显式声明</span>
</span></span></code></pre></div><h3 id=不适用场景>不适用场景</h3><ol><li>不能用于字段声明</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// private var myField; // 编译错误！</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> myField; <span style=color:#75715e>// 正确</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>必须初始化</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#66d9ef>value</span>; <span style=color:#75715e>// 编译错误！必须初始化</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>value</span> = <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#66d9ef>value</span> = <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// 正确</span>
</span></span></code></pre></div><ol start=3><li>不能为null的初始化</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#66d9ef>value</span> = <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// 编译错误！无法推断类型</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 解决方案</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> <span style=color:#66d9ef>value</span> = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#66d9ef>value</span> = (<span style=color:#66d9ef>string</span>)<span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#66d9ef>value</span> = <span style=color:#66d9ef>default</span>(<span style=color:#66d9ef>string</span>);
</span></span></code></pre></div><h3 id=类型推断规则>类型推断规则</h3><ol><li>字面量推断</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> i = <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> d = <span style=color:#ae81ff>10.5</span>; <span style=color:#75715e>// double</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> f = <span style=color:#ae81ff>10.5f</span>; <span style=color:#75715e>// float</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> m = <span style=color:#ae81ff>10.5</span>m; <span style=color:#75715e>// decimal</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> s = <span style=color:#e6db74>&#34;hello&#34;</span>; <span style=color:#75715e>// string</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> b = <span style=color:#66d9ef>true</span>; <span style=color:#75715e>// bool</span>
</span></span></code></pre></div><ol start=2><li>表达式推断</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> result = GetResult(); <span style=color:#75715e>// 类型取决于方法的返回类型</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> sum = <span style=color:#ae81ff>5</span> + <span style=color:#ae81ff>3.2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> concat = <span style=color:#e6db74>&#34;Age: &#34;</span> + <span style=color:#ae81ff>25</span>; <span style=color:#75715e>// string</span>
</span></span></code></pre></div><h3 id=示例-1>示例</h3><ol><li>集合操作</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> numbers = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt; { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用 var 让代码更简洁</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> evenNumbers = numbers.Where(n =&gt; n % <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>0</span>).ToList();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> squareNumbers = numbers.Select(n =&gt; n * n).ToList();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 对比显式声明</span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; evenNumbersExplicit = numbers.Where(n =&gt; n % <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>0</span>).ToList();
</span></span></code></pre></div><ol start=2><li>异步编程</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task ProcessDataAsync()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 var 简化异步调用</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> result = <span style=color:#66d9ef>await</span> GetDataAsync();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> processed = <span style=color:#66d9ef>await</span> ProcessResultAsync(result);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 对比显式声明</span>
</span></span><span style=display:flex><span>    DataResult resultExplicit = <span style=color:#66d9ef>await</span> GetDataAsync();
</span></span><span style=display:flex><span>    ProcessedData processedExplicit = <span style=color:#66d9ef>await</span> ProcessResultAsync(resultExplicit);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>模式匹配(C# 7.0+)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ProcessObject(<span style=color:#66d9ef>object</span> obj)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 var 模式</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (obj <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>var</span> str &amp;&amp; str <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;String length: {str.Length}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 var 在 switch 表达式中国</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> result = obj <span style=color:#66d9ef>switch</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> s =&gt; <span style=color:#e6db74>$&#34;String: {s}&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i =&gt; <span style=color:#e6db74>$&#34;Int: {i}&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> unknown =&gt; <span style=color:#e6db74>$&#34;Unknown: {unknown?.GetType().Name}&#34;</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=最佳实践>最佳实践</h3><ol><li>在类型明显时使用<code>var</code></li><li>在复杂类型声明时使用<code>var</code>提高可读性</li><li>在LINQ查询和匿名类型中必须使用<code>var</code></li><li>在类型不明显时考虑使用显式以提高代码可读性</li><li>团队应该制定一致的<code>var</code>使用规范</li></ol><h2 id=dynamic><code>dynamic</code></h2><p><code>dynamic</code>是C#4.0中引入的关键字，它的核心目的是绕过编译时的类型检查，将类型解析的工作推迟到运行时</p><h3 id=静态类型-vs-动态类型>静态类型 vs 动态类型</h3><p>要理解<code>dynamic</code>，首先要明白C#本质上是一种静态类型语言</p><ul><li>静态类型（如<code>int</code>, <code>string</code>, <code>MyClass</code>）：在编译时，编译器就知道变量的类型。任何不符合类型的操作（比如对一个<code>string</code>变量进行数学运算）都会导致编译错误。这提供了安全性、智能感知（IntelliSense）和性能优化</li><li>动态类型（<code>dynamic</code>）：编译器对<code>dynamic</code>变量“放手不管”。它假设你在运行时对该变量做的任何操作都是有效的。编译时不会进行类型检查，也没有智能感知。所有的类型解析、方法调用、属性访问等都在程序运行时动态进行</li></ul><h3 id=基本用法和语法>基本用法和语法</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>dynamic</span> myVariable = <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// 开始时是整数</span>
</span></span><span style=display:flex><span>Console.WriteLine(myVariable); <span style=color:#75715e>// 输出：10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>myVariable = <span style=color:#e6db74>&#34;Hello, World!&#34;</span>; <span style=color:#75715e>// 现在变成了字符串</span>
</span></span><span style=display:flex><span>Console.WriteLine(myVariable); <span style=color:#75715e>// 输出：Hello, World!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>myVariable = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt;(); <span style=color:#75715e>// 现在又是一个列表</span>
</span></span></code></pre></div><p>一个<code>dynamic</code>变量在其生命周期内可以指向不同类型的对象</p><h3 id=使用场景>使用场景</h3><ol><li>与COM互操作（如Office自动化）
这是<code>dynamic</code>被引入的首要原因。早期操作Excel或Word时，代码非常冗长，需要大量强制转换<br>没有<code>dynamic</code>时</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> excelApp = <span style=color:#66d9ef>new</span> Microsoft.Office.Interop.Excel.Application();
</span></span><span style=display:flex><span>excelApp.Visible = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// 需要强制转换，而且参数是 ref object，很麻烦</span>
</span></span><span style=display:flex><span>Microsoft.Office.Interop.Excel.Workbook workbook = (Microsoft.Office.Interop.Excel.Workbook)excelApp.Workbooks.Add();
</span></span><span style=display:flex><span>Microsoft.Office.Interop.Excel.Worksheet worksheet = (Microsoft.Office.Interop.Excel.Worksheet)workbook.ActiveSheet;
</span></span><span style=display:flex><span>Microsoft.Office.Interop.Excel.Range range = (Microsoft.Office.Interop.Excel.Range)worksheet.Cells[<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;A&#34;</span>];
</span></span><span style=display:flex><span>range.Value2 = <span style=color:#e6db74>&#34;Hello&#34;</span>;
</span></span></code></pre></div><p>使用<code>dynamic</code>后</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>dynamic</span> excelApp = <span style=color:#66d9ef>new</span> Microsoft.Office.Interop.Excel.Application();
</span></span><span style=display:flex><span>excelApp.Visible = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>dynamic</span> workbook = excelApp.Workbooks.Add();
</span></span><span style=display:flex><span><span style=color:#66d9ef>dynamic</span> worksheet = workbook.ActiveSheet;
</span></span><span style=display:flex><span>worksheet.Cells[<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;A&#34;</span>].Value = <span style=color:#e6db74>&#34;Hello&#34;</span>; <span style=color:#75715e>// 代码简洁明了，像脚本语言一样</span>
</span></span></code></pre></div><ol start=2><li>与动态语言（IronPython, IronRuby）交互
当需要在C#中调用IronPython或IronRuby等动态语言编写的代码时，<code>dynamic</code>是完美的桥梁</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 示例：在 C# 中执行 Python 代码</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> engine = Python.CreateEngine();
</span></span><span style=display:flex><span><span style=color:#66d9ef>dynamic</span> scope = engine.CreateScope();
</span></span><span style=display:flex><span>engine.ExecuteFile(<span style=color:#e6db74>&#34;my_script.py&#34;</span>, scope);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 调用 Python 脚本中定义的函数</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>dynamic</span> result = scope.MyPythonFunction(<span style=color:#ae81ff>42</span>);
</span></span><span style=display:flex><span>Console.WriteLine(result);
</span></span></code></pre></div><ol start=3><li>处理动态JSON或XML（反序列化位置结构的数据）
当不确定反序列化后的JSON结构时，可以使用<code>dynamic</code>来轻松访问数据<br>使用Newtonsoft.Json(Json.NET)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>string</span> json = <span style=color:#e6db74>@&#34;{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#39;Name&#39;: &#39;Alice&#39;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#39;Age&#39;: 30,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#39;Pets&#39;: [&#39;Dog&#39;, &#39;Cat&#39;]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 反序列化为 dynamic</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>dynamic</span> data = JsonConvert.DeserializeObject(json);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(data.Name); <span style=color:#75715e>// 输出: Alice</span>
</span></span><span style=display:flex><span>Console.WriteLine(data.Age);  <span style=color:#75715e>// 输出: 30</span>
</span></span><span style=display:flex><span>Console.WriteLine(data.Pets[<span style=color:#ae81ff>0</span>]); <span style=color:#75715e>// 输出: Dog</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 甚至可以处理运行时才存在的属性</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (data.Hobbies != <span style=color:#66d9ef>null</span>) { <span style=color:#75715e>// 如果JSON中没有Hobbies属性，这里不会编译错误</span>
</span></span><span style=display:flex><span>    Console.WriteLine(data.Hobbies);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>模拟鸭子模型
“鸭子模型”是动态语言中的一个概念：“如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子。”即只关心对象有没有某个方法或属性，而不关心它的具体类型</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> MakeSound(<span style=color:#66d9ef>dynamic</span> animal)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 只要在运行时，animal有Quack方法，这行代码就能成功</span>
</span></span><span style=display:flex><span>    animal.Quack();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 这两个类没有继承自同一个接口或基类</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Duck</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Quack() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Quack!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Quack() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;人叫&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用</span>
</span></span><span style=display:flex><span>MakeSound(<span style=color:#66d9ef>new</span> Duck()); <span style=color:#75715e>// 成功</span>
</span></span><span style=display:flex><span>MakeSound(<span style=color:#66d9ef>new</span> Person()); <span style=color:#75715e>// 成功</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// MakeSound(new Dog()); // 如果Dog没有Quack方法，运行时这里会抛出异常</span>
</span></span></code></pre></div><h3 id=优缺点>优缺点</h3><p>优点</p><ul><li>灵活性：可以编写非常灵活、适应多种类型的代码</li><li>简化代码：在与COM或动态语言交互时，代码变得极其简洁</li><li>开发效率：在快速原型开发或处理不确定数据结构时，可以提高效率</li></ul><p>缺点</p><ul><li>性能开销：运行时解析类型和方法调用比直接的静态调用慢，因为涉及反射等机制</li><li>失去编译时安全：这是最大的风险。如果代码中有拼写错误或类型不匹配，编译器不会报错，直到运行时才会抛出<code>RuntimeBinderException</code></li><li>失去智能感知：在Visual Studio中，对<code>dynamic</code>变量不会有自动完成、方法列表等提示，这会影响开发体验和代码可读性</li></ul><h3 id=dynamic与var的区别><code>dynamic</code>与<code>var</code>的区别</h3><table><thead><tr><th>特性</th><th><code>var</code></th><th><code>dynamic</code></th></tr></thead><tbody><tr><td>类型决定时间</td><td>编译时</td><td>运行时</td></tr><tr><td>类型安全</td><td>是，编译器推断出类型后，就等同于该类型</td><td>否，编译器不做检查</td></tr><tr><td>智能感知</td><td>有</td><td>无</td></tr><tr><td>是否可以重新赋值为不同类型</td><td>否</td><td>是</td></tr></tbody></table><h2 id=null-forgiving-空值忽略符><code>!</code>(null-forgiving. 空值忽略符)</h2><p>告诉编译器“确信这里不为空，不要再报可能为null的警告”</p><h3 id=示例-2>示例</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Type? t = <span style=color:#66d9ef>typeof</span>(<span style=color:#66d9ef>string</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>object?</span> obj = Activator.CreateInstance(t); <span style=color:#75715e>// 可能返回 null </span>
</span></span></code></pre></div><p>C#的可空类型检查系统（nullable reference types）会在这里发出警告：“<code>Activator.CreateInstance</code>可能返回null”<br>如果这样写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>object</span> instance = Activator.CreateInstance(t)!;
</span></span></code></pre></div><p>编译器会认为：“开发者负责保证这不是null，不再发出警告”</p><h3 id=实际行为>实际行为</h3><p><code>!</code>只影响编译器的可空检查，对运行时完全没有任何效果<br>如果结果真的为<code>null</code>，程序依然会<code>NullReferenceException</code>崩溃<br>这可能会掩盖潜在的bug，建议只在非常确信值不可能为null时使用</p><h2 id=_discard弃元运算符><code>_</code>(Discard，弃元运算符)</h2><h3 id=在switch语句中作为弃元>在<code>switch</code>语句中作为弃元</h3><p>在C#7.0引入的模式匹配中，<code>_</code>在<code>switch</code>语句里充当“默认”或“匹配所有“的案例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>object</span> obj = <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>switch</span> (obj)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>string</span> s:
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;这是一个字符串：{s}&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span> i when i &gt; <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;这是一个正整数：{i}&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span> i:
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;这是一个整数：{i}&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;这是 null&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>var</span> _: <span style=color:#75715e>// 使用_来匹配任何其他情况，但不关心匹配到的值</span>
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;未知的类型&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 传统的 default: 也可以，但 case var _: 更侧重于“不关心值”</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这里，<code>case var _:</code>捕获了所有未被前面案例处理的情况，并且明确表示不关心这个匹配到的对象是什么。它比<code>default</code>在语义上更强调“忽略”</p><h3 id=在元组和结构中作为弃元>在元组和结构中作为弃元</h3><p>当使用元组或进行结构操作时，经常只对其中一部分值感兴趣。<code>_</code>可以用来忽略那些不关心的部分</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 返回一个元组的方法</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>string</span> Name, <span style=color:#66d9ef>int</span> Age, <span style=color:#66d9ef>string</span> City) GetPersonInfo()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#ae81ff>30</span>, <span style=color:#e6db74>&#34;New York&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 只关心姓名和你那零，不关心城市</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (name, age, _) = GetPersonInfo();
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;{name} is {age} years old.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 甚至可以忽略多个值</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (firstName, _, _) = GetPersonInfo();
</span></span></code></pre></div><p>这使代码非常简洁，避免了为不需要的变量起名字</p><h3 id=在out参数中作为弃元>在Out参数中作为弃元</h3><p>在调用带有<code>out</code>参数的方法时，如果不管关心那个输出值，可以使用<code>_</code>来忽略它。这从C#7.0开始被支持</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 例如 int.TryParse 方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> input = <span style=color:#e6db74>&#34;123&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 旧方式：即使不关心结果，也必须声明一个变量</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> unused;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>int</span>.TryParse(input, <span style=color:#66d9ef>out</span> unused))
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;解析成功！&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 新方式：使用_弃元，代码更清晰</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>int</span>.TryParse(input, out_))
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;解析成功！&#34;</span>);
</span></span></code></pre></div><h3 id=在lambda表达式中作为参数>在Lambda表达式中作为参数</h3><p>在Lambda表达式中，如果某个参数不被使用，可以将其命名为<code>_</code>，以明确表示该参数被故意忽略</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 例如，一个按钮的点击事件，不需要使用 EventArgs 参数</span>
</span></span><span style=display:flex><span>button.Click += (_, _) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Button clicked!&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 或者对于 Func/Action，如果有多个参数但只能使用一个</span>
</span></span><span style=display:flex><span>Action&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; action = (_, <span style=color:#66d9ef>value</span>) =&gt; Console.WriteLine(<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>action(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>); <span style=color:#75715e>// 只输出 2</span>
</span></span></code></pre></div><p>注意：在同时忽略多个参数时（如<code>(_, _)</code>），这是允许的。但如果只忽略一个参数，而使用另一个，编译器是能区分开的</p><h3 id=作为私有字段的命名前缀约定俗成>作为私有字段的命名前缀（约定俗成）</h3><p>这虽然不是语言特性，但是在C#社区中也给非常广泛和重要的编码约定<br>在定义类的私有字段时，很多人喜欢在其名字前加上<code>_</code>作为前缀，以便于将其与同名的局部变量（尤其是构造函数或属性设置器中的参数）区分开来</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> _name; <span style=color:#75715e>// 私有字段</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Person(<span style=color:#66d9ef>string</span> name, <span style=color:#66d9ef>int</span> age)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _name = name; <span style=color:#75715e>// 清晰地区分了参数 name 和字段 _name</span>
</span></span><span style=display:flex><span>        _age = age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> _name; }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>set</span> { _name = <span style=color:#66d9ef>value</span>; }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个约定极大地提高了代码的可读性，让人一眼就能看出一个标识符时类的私有字段还是一个局部变量</p><h3 id=在数字字面量中作为数字分隔符>在数字字面量中作为数字分隔符</h3><p>从C#7.0开始，<code>_</code>可以在数字字面量中作为分隔符使用，以提高大数字的可读性。它不会影响数字的值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>long</span> bigNumber = <span style=color:#ae81ff>1_000_000_000</span>; <span style=color:#75715e>//1B</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> pi = <span style=color:#ae81ff>3.141</span>_592_653_589_793;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint</span> hex = <span style=color:#ae81ff>0xDE</span>_AD_BE_EF;
</span></span><span style=display:flex><span><span style=color:#66d9ef>byte</span> binary = <span style=color:#ae81ff>0</span>b1101_0101;
</span></span></code></pre></div><p>这使得数字更容易被人阅读和理解</p><h2 id=where--when><code>where</code> & <code>when</code></h2><ul><li><code>when</code>是一个修饰条件的“过滤器”。它的核心作用是“进一步限定匹配的条件”</li><li><code>where</code>用于泛型约束，意思是“这个泛型类型或方法，只接受满足某种条件的类型”</li></ul><h3 id=switch表达式或语句中的when><code>switch</code>表达式或语句中的<code>when</code></h3><p>C#7.0引入模式匹配（pattern matching）后，<code>when</code>可以用来对匹配成功的模式再加一道过滤逻辑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>switch</span> (obj)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span> n when n &gt; <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;正整数&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span> n when n &lt; <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;负整数&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span> n:
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;0&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>string</span> s when s.Length &gt; <span style=color:#ae81ff>5</span>:
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;长字符串&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;其他类型&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里<code>when</code>起的作用就是：只有模式匹配成功，并且<code>when</code>后面的表达式为<code>true</code>时，这个case才会命中<br>它让<code>switch</code>语句从原来的“静态匹配”变成了“模式 + 条件”的组合，就像给<code>case</code>增加了一个“守卫”（guard）</p><h3 id=catch子句中的when><code>catch</code>子句中的<code>when</code></h3><p>它允许在捕获异常时有条件地决定是否处理该异常</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    DangerousOperation();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (IOException ex) when (ex.Message.Contains(<span style=color:#e6db74>&#34;disk&#34;</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;磁盘相关的IO错误&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (IOException ex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;其他IO错误&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样做的好处是：不需要在catch块内部再去<code>if (...) throw;</code><br>直接在<code>when</code>过滤阶段就能决定是否进入该块</p><p>在异常处理中使用<code>when</code>是非常优雅的方式，因为它不会吞掉异常链的信息（不像try-catch-if-throw那样会重新抛出而改变栈信息）</p><h3 id=where泛型约束><code>where</code>泛型约束</h3><h4 id=1-限制类型必须实现某接口>1. 限制类型必须实现某接口</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> Print&lt;T&gt;(T obj) <span style=color:#66d9ef>where</span> T : IDisposable =&gt; obj.Dispose();
</span></span></code></pre></div><p><code>T</code>必须实现<code>IDisposable</code>，否则编译不通过</p><h4 id=2-限制类型必须继承某类>2. 限制类型必须继承某类</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span> : Base {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Show&lt;T&gt;(T <span style=color:#66d9ef>value</span>) <span style=color:#66d9ef>where</span> T : Base =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;T继承自Base&#34;</span>)<span style=color:#960050;background-color:#1e0010>；</span>
</span></span></code></pre></div><h4 id=3-限制类型必须有无参构造函数>3. 限制类型必须有无参构造函数</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> Create&lt;T&gt;() <span style=color:#66d9ef>where</span> T : <span style=color:#66d9ef>new</span>() =&gt; <span style=color:#66d9ef>var</span> obj = <span style=color:#66d9ef>new</span> T();
</span></span></code></pre></div><h4 id=4-多重约束可以叠加>4. 多重约束（可以叠加）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> DoSomething&lt;T&gt;() <span style=color:#66d9ef>where</span> T : BaseClass, IInterface, <span style=color:#66d9ef>new</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=5-约束多个泛型参数>5. 约束多个泛型参数</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Manager</span>&lt;T, U&gt;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span> T : <span style=color:#66d9ef>class</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>where</span> U : <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>    { }
</span></span></code></pre></div><h2 id=record><code>record</code></h2><p>在C#9之前，只能用class或struct</p><table><thead><tr><th>类型</th><th>语义</th><th>特点</th></tr></thead><tbody><tr><td>class</td><td>引用语义</td><td>比较地址（引用），可变</td></tr><tr><td>struct</td><td>值语义</td><td>拷贝传递，性能好但语法笨重</td></tr></tbody></table><p>如果只想表达“一组数据”，比如<code>Person(Name, Age)</code>，但不想写一堆样板代码（<code>Equals</code>、<code>ToString</code>、<code>GetHashCode</code>），而且希望它是不可变的（immutable），同时希望比较的是内容相等，不是内存引用。所以微软在C#9.0引入了<code>record</code></p><h3 id=基本语法>基本语法</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>Person</span>(<span style=color:#66d9ef>string</span> Name, <span style=color:#66d9ef>int</span> Age);
</span></span></code></pre></div><p>这行代码等价于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>init</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Age { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>init</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Person(<span style=color:#66d9ef>string</span> Name, <span style=color:#66d9ef>int</span> Age)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.Name = Name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.Age = Age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>string</span> ToString() =&gt; <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#e6db74>&#34;Person {{ Name = {Name}, Age = {Age} }
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>bool</span> Euqals(<span style=color:#66d9ef>object?</span> obj) =&gt; obj <span style=color:#66d9ef>is</span> Person other &amp;&amp; Name == other.Name &amp;&amp; Age == other.Age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>int</span> GetHashCode() =&gt; HashCode.Combine(Name, Age);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>record</code>会自动</p><ol><li>定义构造函数</li><li>定义只读属性（<code>init</code>）</li><li>实现<code>Equals</code>和<code>GetHashCode</code>（按值相等）</li><li>生成友好的<code>ToString()</code></li></ol><h3 id=值相等value-equality>值相等（Value Equality）</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> p1 = <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#ae81ff>18</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> p2 = <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#ae81ff>18</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(p1 == p2); <span style=color:#75715e>// True</span>
</span></span></code></pre></div><p>区别于<code>class</code></p><ul><li>普通<code>class</code>比较的是“引用是否相同”</li><li><code>record</code>比较的是“字段内容是否相同”</li></ul><p>这也是它被称为“record type（记录类型）”的原因</p><h3 id=不可变对象immutable>不可变对象（Immutable）</h3><p><code>record</code>默认使用<code>init</code>访问器，而不是<code>set</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> p = <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#ae81ff>18</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// p.Age = 10; // 不允许修改</span>
</span></span></code></pre></div><p>但可以通过<code>with</code>表达式复制并修改</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> p2 = p with { Age = <span style=color:#ae81ff>19</span> };
</span></span></code></pre></div><p>这会创建一个新对象，原对象不变</p><h3 id=with表达式复制表达式><code>with</code>表达式（复制表达式）</h3><p>这是<code>record</code>的灵魂搭档</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> p1 = <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#ae81ff>18</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> p2 = p1 with { Name = <span style=color:#e6db74>&#34;Bob&#34;</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(p2); <span style=color:#75715e>// Person { Name = Bob, Age = 18 }</span>
</span></span></code></pre></div><p>它相当于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> p2 = <span style=color:#66d9ef>new</span> Person(p1.Name, p1.Age);
</span></span><span style=display:flex><span>p2.Name = <span style=color:#e6db74>&#34;Bob&#34;</span>;
</span></span></code></pre></div><h3 id=继承与record-class--record-struct>继承与Record Class / Record Struct</h3><p>默认</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>Person</span>(<span style=color:#66d9ef>string</span> Name);
</span></span></code></pre></div><p>等价于<code>public record class Person(string Name)</code><br>如果想要值类型（避免堆分配）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>struct</span> Point(<span style=color:#66d9ef>int</span> X, <span style=color:#66d9ef>int</span> Y)
</span></span></code></pre></div><ul><li><code>record class</code>：引用类型，按值比较</li><li><code>record struct</code>：值类型，按字段比较</li></ul><h3 id=解构deconstruction>解构（Deconstruction）</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> person = <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#ae81ff>18</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (name, age) = person;
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;{name}, {age}&#34;</span>);
</span></span></code></pre></div><p>C#会自动生成<code>Deconstruct</code>方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Deconstruct(<span style=color:#66d9ef>out</span> <span style=color:#66d9ef>string</span> Name, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int</span> Age)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Name = <span style=color:#66d9ef>this</span>.Name;
</span></span><span style=display:flex><span>    Age = <span style=color:#66d9ef>this</span>.Age;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=继承与record层次结构>继承与Record层次结构</h3><p>Record支持继承，并保持值相等的正确行为</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>Person</span>(<span style=color:#66d9ef>string</span> Name);
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>Student</span>(<span style=color:#66d9ef>string</span> Name, <span style=color:#66d9ef>int</span> Grade) : Person(Name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> s1 = <span style=color:#66d9ef>new</span> Student(<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> s2 = <span style=color:#66d9ef>new</span> Student(<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Console.WriteLine(s1 == s2); <span style=color:#75715e>// True</span>
</span></span></code></pre></div><p>但注意：</p><blockquote><p>record的相等比较是基于类型 + 内容的
即使内容相同，不同类型也不相等</p></blockquote><h3 id=可变record不推荐>可变record（不推荐）</h3><p>可以改成这样，但失去了不可变的优势</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Age { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=底层原理编译后>底层原理（编译后）</h3><p>编译器实际上生成的是一个普通类，只是自动生成了</p><ul><li>构造函数</li><li><code>Equals</code>、<code>GetHashCode</code></li><li><code>ToString</code></li><li><code>Deconstruct</code></li><li><code>with</code>克隆支持</li></ul><p>这意味着也可以重写这些方法来自定义行为</p><h2 id=and-or-not><code>and</code>, <code>or</code>, <code>not</code></h2><p>C#9.0引入<strong>逻辑模式匹配关键字：</strong><code>and</code>, <code>or</code>, <code>not</code><br>它们不是用来替代<code>&&</code>, <code>||</code>, <code>|</code>，而是<strong>只在模式匹配（pattern matching）上下文中生效</strong></p><h3 id=背景模式逻辑表达式的自然语言化>背景：模式逻辑表达式的自然语言化</h3><p>在传统C#中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (x &gt; <span style=color:#ae81ff>0</span> &amp;&amp; x &lt; <span style=color:#ae81ff>10</span>)
</span></span></code></pre></div><p>这是典型的逻辑运算符（operators）<br>当当模式匹配出现后，可以写出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (x <span style=color:#66d9ef>is</span> &gt; <span style=color:#ae81ff>0</span> and &lt; <span style=color:#ae81ff>10</span>)
</span></span></code></pre></div><p>这时候<code>and</code>, <code>or</code>, <code>not</code>并不是操作符，而是模式组合符<br>它们属于<code>pattern syntax</code>，而不是<code>boolean logic</code></p><h3 id=语法规则>语法规则</h3><table><thead><tr><th>关键字</th><th>对应符号</th><th>含义</th><th>适用场景</th><th></th><th></th></tr></thead><tbody><tr><td><code>and</code></td><td><code>&&</code></td><td>两个模式都要匹配</td><td>模式组合</td><td></td><td></td></tr><tr><td><code>or</code></td><td>`</td><td></td><td>`</td><td>任意一个模式匹配即可</td><td>模式选择</td></tr><tr><td><code>not</code></td><td><code>!</code></td><td>匹配模式取反</td><td>模式否定</td><td></td><td></td></tr></tbody></table><p>这些关键字只能出现在pattern matching表达式中（<code>is</code>或<code>switch</code>），不能在普通布尔逻辑中替代符号形式</p><ol><li><code>and</code>——逻辑与（组合两个模式）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> x = <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (x <span style=color:#66d9ef>is</span> &gt; <span style=color:#ae81ff>0</span> and &lt; <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;在0~10之间&#34;</span>);
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (x &gt; <span style=color:#ae81ff>0</span> &amp;&amp; x &lt; <span style=color:#ae81ff>10</span>)
</span></span></code></pre></div><p>但<code>and</code>的强大之处在于：它可以组合任意两种“模式”，不仅限于数值比较</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>object</span> obj = <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (obj <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>int</span> n and &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>$&#34;正整数 {n}&#34;</span>);
</span></span></code></pre></div><ul><li><code>int n</code>是一个类型模式</li><li><code>> 0</code>是一个关系模式</li><li><code>and</code>把它们组合成“是int且大于0”的模式</li></ul><ol start=2><li><code>or</code>——逻辑或（匹配任意一个模式）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> x = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (x <span style=color:#66d9ef>is</span> &lt; <span style=color:#ae81ff>0</span> or &gt; <span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;超出范围&#34;</span>);
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (x &lt; <span style=color:#ae81ff>0</span> || x &gt; <span style=color:#ae81ff>100</span>)
</span></span></code></pre></div><p>同样可以组合不同类型的模式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>object</span> obj = <span style=color:#e6db74>&#34;Hello&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (obj <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>int</span> or <span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;是数字或字符串&#34;</span>);
</span></span></code></pre></div><ol start=3><li><code>not</code>——模式取反</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>object</span> obj = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (obj <span style=color:#66d9ef>is</span> not <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;不是 null&#34;</span>);
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (obj != <span style=color:#66d9ef>null</span>)
</span></span></code></pre></div><p>也可以取反整个复杂模式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (x <span style=color:#66d9ef>is</span> not (&gt;<span style=color:#ae81ff>0</span> and &lt; <span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;不在 0~10 之间&#34;</span>);
</span></span></code></pre></div><blockquote><p>C#逐步在向“模式导向语言”转型。模式匹配的语法希望更自然、可读、接近英语表达</p></blockquote><h2 id=isas><code>is</code>/<code>as</code></h2><p><code>is</code>和<code>as</code>是两个用于类型转换和类型检查的关键字</p><h3 id=is><code>is</code></h3><p><code>is</code>用来检查对象是否是某个类型的实例，它返回一个布尔值，表示指定对象是否能够成功转换为目标类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>object</span> obj = <span style=color:#e6db74>&#34;Hello, world&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> result = obj <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>string</span>; <span style=color:#75715e>// true, typeof(obj) == string</span>
</span></span></code></pre></div><ul><li>类型检查：<code>is</code>可以检查对象是否是指定类型，或者是否可以隐式转换为目标类型</li><li>返回值：如果对象符合目标类型，则返回<code>true</code>，否则返回<code>false</code></li></ul><p>C#7.0之后，<code>is</code>可以同时进行类型检查和类型转换，这被称为模式匹配。如果类型匹配，<code>obj</code>会自动转换为目标类型，如果不匹配，不会进行转换</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>object</span> obj = <span style=color:#e6db74>&#34;Hello, world!&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (obj <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>string</span> str) Console.WriteLine(str);
</span></span></code></pre></div><h3 id=as><code>as</code></h3><p><code>as</code>是安全的转换，将对象转换为指定的目标类型，<code>as</code>在转换时不会抛出异常，如果转换成功，返回目标类型的对象；如果失败，返回<code>null</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>object</span> obj = <span style=color:#e6db74>&#34;Hello, world&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> str = obj <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>string</span>; <span style=color:#75715e>// str 是 ”Hello, world“</span>
</span></span></code></pre></div><ul><li><code>as</code>用于将对象转换为目标类型，并且如果转换失败返回<code>null</code>，这对引用类型非常有用</li><li>无法转换的情况下，<code>as</code>返回<code>null</code>（而不是抛出异常）</li></ul><p>对于值类型，如<code>int</code>、<code>struct</code>等，<code>as</code>不能用于值类型转换，如果尝试将一个值类型转换成另一个值类型，<code>as</code>将无法工作，编译时会报错</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span> <span style=color:#66d9ef>float</span> f1 = <span style=color:#ae81ff>2.3f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> d1 = <span style=color:#ae81ff>3.33</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> d2 = f1 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>double</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> f2 = d1 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>float</span>; <span style=color:#75715e>// 编译错误</span>
</span></span></code></pre></div><p>为什么<code>as</code>对值类型没有作用<br><code>as</code> 在底层实际上执行的是 引用类型的安全转换。它试图将一个对象引用转换为目标类型，如果目标类型不匹配，它会返回 <code>null</code>。但对于值类型，<code>as</code> 没有办法做这种转换，因为值类型本身没有像引用类型那样的 类型兼容性</p><h3 id=is-vs-as><code>is</code> vs <code>as</code></h3><table><thead><tr><th>特性</th><th><code>is</code> 关键字</th><th><code>as</code> 关键字</th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>类型检查，并且可以做类型转换（模式匹配）</td><td>安全的类型转换，如果失败返回 <code>null</code></td></tr><tr><td><strong>返回值</strong></td><td><code>true</code> 或 <code>false</code>（布尔值）</td><td>转换后的目标类型（或 <code>null</code>）</td></tr><tr><td><strong>转换失败时行为</strong></td><td>如果转换失败，返回 <code>false</code></td><td>转换失败时返回 <code>null</code></td></tr><tr><td><strong>使用场景</strong></td><td>用于检查对象是否符合某类型，适用于类型匹配检查</td><td>用于安全的类型转换，避免异常抛出</td></tr><tr><td><strong>适用类型</strong></td><td>适用于所有类型（包括值类型和引用类型）</td><td>只适用于引用类型（<code>class</code>、<code>interface</code>，不能用于值类型）</td></tr><tr><td><strong>性能</strong></td><td>性能稍差，进行类型检查</td><td>性能较好，不会抛出异常（适合频繁调用）</td></tr></tbody></table><ol><li>类型检查与转换</li></ol><ul><li><code>is</code>用来检查对象是否是某个类型的实例，并且可以在类型匹配时进行转换</li><li><code>as</code>用来尝试将对象转换为指定类型，如果转换失败，返回<code>null</code></li></ul><ol start=2><li>适用场景</li></ol><ul><li><code>is</code>更适用于你只关心类型是否匹配的场景</li><li><code>as</code>更适用于你不确定类型转换是否会成功的场景，避免异常抛出</li></ul><ol start=3><li>性能差异</li></ol><ul><li><code>is</code>在检查类型时，可能需要更复杂的检查（特别时类型匹配时）</li><li><code>as</code>通常比<code>is</code>性能好，因为它直接尝试转换，而不会检查类型后转换</li></ul><h3 id=使用场景示例>使用场景示例</h3><p>场景1：类型检查与转换<code>is</code><br>假设你有一个动物类<code>Animal</code>和它的派生类<code>Dog</code>，你想检查一个<code>Animal</code>对象是否是<code>Dog</code>类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span> { }
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span> : Animal { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Animal animal = <span style=color:#66d9ef>new</span> Dog();
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (animal <span style=color:#66d9ef>is</span> Dog dog)
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;dog&#34;</span>);
</span></span></code></pre></div><p>这里的 <code>is</code> 既是类型检查，又进行了类型转换，<code>animal</code> 被转换为 <code>Dog</code> 类型，赋值给变量 <code>dog</code></p><p>场景2：安全的类型转换<code>as</code><br>假设你有一个对象，它可能是某个类型，也可能不是，你希望安全地转换它</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>object</span> obj = <span style=color:#e6db74>&#34;Hello, world!&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> str = obj <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (str != <span style=color:#66d9ef>null</span>) Console.WriteLine(<span style=color:#e6db74>&#34;success&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> Console.WriteLine(<span style=color:#e6db74>&#34;default&#34;</span>);
</span></span></code></pre></div><h2 id=跳转指令>跳转指令</h2><ol><li><code>break</code><ul><li>作用：立即退出当前循环（<code>for</code>/<code>while</code>/<code>do while</code> / <code>switch</code>）</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>10</span>; i++)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (i == <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>; <span style=color:#75715e>// 当 i == 5 时退出循环</span>
</span></span><span style=display:flex><span>	Console.WriteLine(i); 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出 0, 1, 2, 3, 4</span>
</span></span></code></pre></div><pre><code>- 只会跳出当前层级的循环
- 常用于提前结束循环，比如找到目标后不再继续搜索
</code></pre><ol start=2><li><code>continue</code><ul><li>作用：跳过当前这次循环，直接进入下一次循环迭代</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>5</span>; ++i)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (i == <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>continue</span>; <span style=color:#75715e>// 跳过 i == 2 这次循环</span>
</span></span><span style=display:flex><span>	Console.WriteLine(i);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出 0, 1, 3, 4</span>
</span></span></code></pre></div><pre><code>- `continue`不会终止循环，只是“跳过这次”
- 通常用于“跳过不需要处理的情况”
</code></pre><ol start=3><li><code>goto</code><ul><li>作用：跳转到代码中带有特定标签的位置</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> x = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>start: <span style=color:#75715e>// 标签</span>
</span></span><span style=display:flex><span>Console.WriteLine(x);
</span></span><span style=display:flex><span>x++;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (x &lt; <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>goto</span> start; <span style=color:#75715e>// 跳回标签处</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出 0, 1, 2</span>
</span></span></code></pre></div><pre><code>- `goto`是“无条件跳转”，强大但危险
- 会破坏结构化编程的逻辑流，不建议随便用
- 唯一合理使用场景：
  - 从嵌套循环中跳出多层；
  - 或在`switch`中做复杂分支跳转
</code></pre><ol start=4><li><code>return</code><ul><li>作用：立即结束当前方法的执行，并可选择性地返回一个值
无返回值</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> PrintNumbeer(<span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (n &lt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>; <span style=color:#75715e>// 提前结束函数</span>
</span></span><span style=display:flex><span>	Console.WriteLine(n);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>有返回值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> Add(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> a + b;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>return</code>会立刻离开当前函数</li><li>常用于错误检测、提前退出或返回结果</li></ul><h2 id=yield-return><code>yield return</code></h2><p><code>yield return</code>是C#提供的一种语法糖，用于快速、方便地创建迭代器</p><ul><li>目的：能轻松编写一个方法，该方法可以按需返回一个序列（如集合）中的元素，而不是一次性返回整个集合</li><li>关键字：<code>yield return</code>, <code>yield break</code></li><li>返回值类型：使用<code>yield return</code>的方法的返回值必须是<code>IEnumerable</code>, <code>IEnumerable&lt;T></code>， <code>IEnumerator</code>或<code>IEnumerator&lt;T></code></li></ul><p>简单来说，它让你能像写普通方法一样，写一个能“记住”执行状态的方法，每次调用只返回下一个值</p><h3 id=执行模型>执行模型</h3><p>当写一个含有<code>yield return</code>的方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerable&lt;<span style=color:#66d9ef>int</span>&gt; Foo() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译器不会按字面理解那样生成一个返回值列表<br>编译器会偷偷把这个方法编译成一个隐藏类，这个类实现了<code>IEnumerable&lt;T></code>和<code>IEnumerator&lt;T></code><br>也就是说，编译器自动实现了</p><ul><li>一个状态机类</li><li>一个记录当前运行进度的字段（如state = 0, 1, 2&mldr;）</li><li><code>MoveNext()</code>方法中用<code>switch(state)</code>控制流程</li><li><code>Current()</code>属性返回当前值</li></ul><p>大致的结构（由编译器自动生成）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FooIterator</span> : IEnumerable&lt;<span style=color:#66d9ef>int</span>&gt;, IEnumerator&lt;<span style=color:#66d9ef>int</span>&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _state;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _current;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> MoveNext()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> (_state)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                _state = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                _current = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                _state = <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>                _current = <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>                _state = <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>                _current = <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Current =&gt; _current;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>就像Unity的Coroutine也是用C#的状态机做出来的一样</p><p>写一行<code>yield return</code>，实际底层是编译器在创建一个小型“协程”</p><h4 id=执行流程>执行流程</h4><p>当写下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> x <span style=color:#66d9ef>in</span> Foo())
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>流程是这样的</p><ol><li>调用<code>Foo()</code>，返回的是一个“迭代器对象”（状态机实例）</li><li>foreach调用它的<code>MoveNext()</code></li><li>方法运行到第一个<code>yield return</code> —— 暂停！返回元素</li><li>下一次<code>MoveNext()</code>，从暂停位置继续执行</li><li>再次遇到<code>yield return</code>—— 再暂停</li><li>直到代码跑到结尾</li></ol><p>这就是“能暂停的函数”；把普通函数变成可挂起/可恢复的流程流程</p><h3 id=yield-return--return><code>yield return</code> != <code>return</code></h3><p>这完全是两个东西</p><ul><li><code>return</code> 方法结束</li><li><code>yield return</code> 方法暂停，等下回继续</li></ul><p>这种能力是在C++里必须手写状态机、lambda或coroutine才能实现</p><h3 id=示例-3>示例</h3><ol><li>在循环中求值</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>static</span> IEnumerable&lt;<span style=color:#66d9ef>int</span>&gt; GenerateEvenNumbers(<span style=color:#66d9ef>int</span> count)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; count; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 每次返回一个值</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> i * <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>int</span> even <span style=color:#66d9ef>in</span> GenerateEvenNumbers(<span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(even); <span style=color:#75715e>// 输出 0, 2, 4, 6, 8</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>使用<code>yield break</code>提前终止</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>static</span> IEnumerable&lt;<span style=color:#66d9ef>string</span>&gt; GetMessageUntilStop(<span style=color:#66d9ef>string</span>[] message)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>string</span> msg <span style=color:#66d9ef>in</span> message)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (msg == <span style=color:#e6db74>&#34;stop&#34;</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>break</span>; <span style=color:#75715e>// 立即终止</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> msg;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=yield-return的存在意义与适用场景><code>yield return</code>的存在意义与适用场景</h3><p>有些数据没必要一次性构造全部<br>比如读大文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerable&lt;<span style=color:#66d9ef>string</span>&gt; ReadLines(<span style=color:#66d9ef>string</span> path)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> var r = <span style=color:#66d9ef>new</span> StreamReader(path);
</span></span><span style=display:flex><span>    stirng line;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> ((line = r.ReadLine()) != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> line;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>传统写法会</p><ul><li>把所有行读进数组</li><li>占用内存</li><li>等待文件全部读完才能用</li></ul><p><code>yield return</code>则是</p><ul><li>读到一行 -> 立刻往外产出</li><li>外部消费一行 -> 继续读下一行</li><li>内存占用极小</li></ul><h4 id=适用场景-2>适用场景</h4><ul><li>惰性求值
这是<code>yield return</code>最重要得特性。元素只在被请求时（即<code>foreach</code>循环到它时）才生成。这在处理大量数据或无限序列时极其高效，因为它不需要一次性将所有数据加载到内存中</li><li>大数据流处理</li><li>图遍历（DFS/BFS）</li><li>编写解析器（Yield-based tokenizer）</li><li>组合复杂迭代逻辑（比如Unity的协程）
比如根据角色状态生成下一帧行为</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>IEnumerable&lt;Action&gt; BehaviorTreeNode()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> Patrol();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> Chase();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> Attack();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=注意事项和常见误区>注意事项和常见误区</h3><ol><li>多次迭代
每次遍历迭代器方法，都会创建一个新的状态机实例，导致方法从头开始执行</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> numvers = GetNumbers(); <span style=color:#75715e>// 这只是一个IEnumerable&lt;int&gt; ，不是具体的数据</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> n <span style=color:#66d9ef>in</span> numbers) { ... } <span style=color:#75715e>// 执行一次 GetNumbers 方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> n <span style=color:#66d9ef>in</span> numbers) { ... } <span style=color:#75715e>// 再次执行 GetNumbers 方法，从头开始</span>
</span></span></code></pre></div><p>如果方法内部有昂贵的操作（如数据库查询），这会导致性能问题。解决方法：如果确定需要多次遍历，可以将其具体化，例如通过<code>.ToList()</code>或<code>.ToArray()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> numbersList = GetNumbers().ToList(); <span style=color:#75715e>// 立即执行方法，将所有结果存入List</span>
</span></span></code></pre></div><ol start=2><li><p>不支持所有接口
返回值类型必须是前面提到的四种接口之一</p></li><li><p><code>IDisposable</code>
编译器生成的状态机实现了<code>IDisposable</code>。如果使用手动枚举器，最好使用<code>using</code>语句</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> enumerator = GetNumbers().GetEnumerator())
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(enumerator.MoveNext())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（在<code>foreach</code>中，编译器会自动处理这些）</p><ol start=4><li>线程安全
编译器生成的状态机不是线程安全的。多个线程同时遍历同一个迭代器实例会导致不可预知的行为</li></ol><h2 id=heading><code>[]</code></h2><p>C#中的下标访问只是语法糖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>something[index]
</span></span></code></pre></div><p>会被编译成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>something.get_Item(index)
</span></span></code></pre></div><p>写入</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>something[index] = <span style=color:#66d9ef>value</span>;
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>something.set_Item(index, <span style=color:#66d9ef>value</span>);
</span></span></code></pre></div><p>这件事依赖于两个条件</p><ol><li>类型具有名为<code>Item</code>的成员（通常是索引器）</li><li>类型标记了<code>[DefaultMember("Item")]</code></li></ol><p>只要满足这两点，C#编译器才能识别这个类型有“默认索引器”</p><h3 id=defaultmemberitem><code>[DefaultMember("Item")]</code></h3><p><code>[DefaultMember("Item")]</code>是个很隐蔽但很关键的老属性，它的作用是告诉编译器：这个类型的“默认成员”叫Item<br>换句话说，它让C#支持</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>obj[x]
</span></span></code></pre></div><p>这种下标访问语法<br>没有这个属性，编译器不知道<code>[]</code>应该绑定哪个成员函数\</p><h3 id=item><code>Item</code></h3><p><code>Item</code>是索引器的真实名字，当你使用索引器时，其实在访问<code>Item</code><br>C#把<code>Item</code>包装成一个“类数组的语法糖”：<code>obj[x]</code>本质是<code>obj.Item[x]</code>的语法糖<br>.NET BCL选择了一个通用名字<code>Item</code>，确保所有实现索引器的类型都能用同一套编译规则<br>这是设计者的取舍：强制统一名字，才能在语言层保证索引器语法是固定的\</p><h4 id=存在意义>存在意义</h4><p>一切都来自CLR的世界比较古早的设计<br>在.NET初期，CLR并不知道C#所谓的“索引器”概念——在IL层面，它只是一个名字叫<code>Item</code>的属性<br>为了让C#编译器在看到<code>obj[]</code>语法后知道去找“<code>Item</code>属性”，就得告诉它：这个类的默认成员就是Item，于是有了这个属性</p><h4 id=在现代c中>在现代C#中</h4><p>因为现代C#语法糖越来越高级，实际写索引器时是这样</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyList</span>&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T <span style=color:#66d9ef>this</span>[<span style=color:#66d9ef>int</span> index] =&gt; ...;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译器自动生成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[DefaultMember(&#34;Item&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyList</span>&lt;T&gt; { ... }
</span></span></code></pre></div><p>没有写它，编译器也会自动补充上<br>只有在</p><ul><li>用反射</li><li>自己生成IL</li><li>做CodeDOM</li><li>写动态类型桥接层</li><li>分析第三方编译器产生的代码</li><li>搞C#和其他语言互操作（比如COM或IronPython）</li></ul><p>时才会看到它</p><h2 id=xml注释>XML注释</h2><p>XML注释（也称为文档注释）在C#中是用来生成程序文档的工具，格式类似于XML，用于为类、方法、属性、字段等成员提供详细的说明。它不仅有助于代码的可读性，还能够通过工具生成API文档，方便其他开发者理解你的代码</p><h3 id=基本结构>基本结构</h3><p>XML注释的基本格式如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 这是对成员的简短描述</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span></code></pre></div><p>这种注释格式通常出现在方法、属性、类等成员的上方。<code>&lt;summary></code>标签用于提供简短的描述，描述该成员的作用</p><h3 id=常见的xml注释标签>常见的XML注释标签</h3><ul><li><code>&lt;summary></code>：简要说明一个成员的作用或功能</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 用户管理类</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span></code></pre></div><ul><li><code>&lt;param></code>：描述方法参数，通常用于方法和构造函数。<code>name</code>属性指定参数的名称</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;param name=&#34;id&#34;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 用户ID</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/param&gt;</span>
</span></span></code></pre></div><ul><li><code>&lt;returns></code>：说明方法返回值的含义</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;returns&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 操作是否成功</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/returns&gt;</span>
</span></span></code></pre></div><ul><li><code>&lt;remarks></code>：提供额外的说明信息，通常用于描述实现细节</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;remarks&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 这个方法线程安全</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/remarks&gt;</span>
</span></span></code></pre></div><ul><li><code>&lt;exception></code>：描述方法可能抛出异常</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;exception cref=&#34;ArgumentNullException&#34;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 参数为null时抛出</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/exception&gt;</span>
</span></span></code></pre></div><ul><li><code>&lt;example></code>：给出如何使用该方法、类或属性的示例</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;example&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 见代码示例</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/example&gt;</span>
</span></span></code></pre></div><ul><li><code>&lt;value></code>：用于描述属性的值</li><li><code>&lt;typeparam></code>：泛型类型参数说明</li><li><code>&lt;seealso></code>：参考其他相关主题</li><li><code>&lt;code></code>：内嵌代码</li><li><code>&lt;para></code>：段落格式（在<code>&lt;remarks></code>中使用）</li></ul><h3 id=示例-4>示例</h3><ol><li><code>&lt;remarks></code>用于补充详细信息，通常在<code>&lt;summary></code>之后</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 计算两个数的商</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;param name=&#34;a&#34;&gt;被除数&lt;/param&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;param name=&#34;b&#34;&gt;除数&lt;/param&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;returns&gt;返回值&lt;/returns&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;remarks&gt;如果除数为0，将抛出除零异常&lt;/remarks&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> Divide(<span style=color:#66d9ef>double</span> a, <span style=color:#66d9ef>double</span> b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (b == <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> DivideByZeroException();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a / b;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li><code>&lt;exception></code>用于描述方法可能抛出的异常</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 从文件中读取数据</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;param name=&#34;filePath&#34;&gt;文件路径&lt;/param&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;returns&gt;返回文件内容&lt;/returns&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;exception cref=&#34;FileNotFoundException&#34;&gt;文件未找到时抛出&lt;/exception&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;exception cref=&#34;IOException&#34;&gt;读取过程中发生 IO 错误时抛出&lt;/exception&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> ReadFile(<span style=color:#66d9ef>string</span> filePath)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (!File.Exist(filePath))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FileNotFoundException(<span style=color:#e6db74>&#34;文件未找到&#34;</span>, filePath);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> File.ReadAllText(filePath);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>一个完整示例</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 表示一个用户实体</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;remarks&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;para&gt;这个类用于存储用户的基本信息&lt;/para&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;para&gt;包含用户ID、姓名和年龄&lt;/para&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/remarks&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// 用户ID</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;value&gt;正整数，唯一标识用户&lt;/value&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Id { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// 用户姓名</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// 根据ID查找用户</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;param name=&#34;id&#34;&gt;要查找的用户ID&lt;/param&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;returns&gt;找到的用户对象，未找到时返回null&lt;/returns&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;exception cref=&#34;ArgumentException&#34;&gt;当id小于等于0时抛出&lt;/exception&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;example&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;code&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// var user = User.FindById(1);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// if (user != null)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// {</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>///     Console.WriteLine(user.Name);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// }</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;/code&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;/example&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;seealso cref=&#34;GetAllUsers&#34;/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> User FindById(<span style=color:#66d9ef>int</span> id)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (id &lt;= <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentException(<span style=color:#e6db74>&#34;ID必须大于0&#34;</span>, nameof(id));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 实际查找逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// 获取所有用户</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;typeparam name=&#34;T&#34;&gt;返回的集合类型&lt;/typeparam&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/// &lt;returns&gt;用户列表&lt;/returns&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List&lt;User&gt; GetAllUsers&lt;T&gt;() <span style=color:#66d9ef>where</span> T : <span style=color:#66d9ef>class</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> List&lt;User&gt;();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>引用其他成员</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 使用&lt;see cref=&#34;CalculateTotal&#34;/&gt;方法计算结果</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 参考&lt;seealse cref=&#34;MathHelper&#34;/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span></code></pre></div><ol start=5><li>条件注释</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 异步获取数据</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;include file=&#39;ExtraComments.xml&#39; path=&#39;docs/members[@name=&#34;AsyncMethod&#34;]/*&#39;&gt;</span>
</span></span></code></pre></div><h3 id=ide支持和智能感知>IDE支持和智能感知</h3><h3 id=注意事项>注意事项</h3><ol><li>XML必须格式良好：标签必须正确闭合</li><li>cref属性值必须有效：引用的类型必须存在</li><li>注释与实际代码一致：避免误导</li><li>不要过度注释：自解释的代码不需要过多注释</li></ol><h3 id=使用xml的好处>使用XML的好处</h3><ol><li><p>自动化文档生成：通过XML注释，可以使用工具如<code>Doxygen</code>或Visual Studio的文档生成工具来自动生成API文档</p><ol><li>项目配置
在.csproj文件中添加<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;PropertyGroup&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;GenerateDocumentationFile&gt;</span>true<span style=color:#f92672>&lt;/GenerateDocumentationFile&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;DocumentationFile&gt;</span>bin\Debug\net8.0\MyProject.xml<span style=color:#f92672>&lt;/DocumentationFile&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/PropertyGroup&gt;</span>
</span></span></code></pre></div></li><li>编译输出
编译后生成XML文档文件，可以与以下工具配合<ul><li>Sandcastle：生成CHM/网站文档</li><li>DocFX：生成现代Web文档</li><li>Swagger：API文档（配合Swashbuckle）</li></ul></li></ol></li><li><p>IDE支持：许多IDE（如Visual Studio）能够解析这些注释，提供代码提示和文档预览，增强开发体验</p><ul><li>智能感知提示：鼠标悬停时显示XML注释</li><li>快速文档视图：Ctrl+Q查看完整文档</li><li>自动生成：输入<code>///</code>在方法/类上方自动生成模板<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// </span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;param name=&#34;param1&#34;&gt;&lt;/param&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;returns&gt;&lt;/returns&gt;</span>
</span></span></code></pre></div></li></ul></li><li><p>提升代码可读性：XML注释可以帮助开发者更清晰地理解代码的意图和用法，特别是在大型项目中，文档化的代码易于维护</p></li><li><p>标准化：XML注释使得代码文档化过程更规范，便于团队协作，确保文档内容完整</p></li></ol></div><nav class=post-nav><a href=/dotnetandwindows/lib/linq/ class=hover:underline>pre: LINQ</a>
<a href=/dotnetandwindows/lib/oop/ class=hover:underline>next: OOP</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#using><code>using</code></a><ul><li><a href=#using指令namespace导入>using指令（Namespace导入）</a></li><li><a href=#using语句资源管理>using语句（资源管理）</a><ul><li><a href=#使用注意事项>使用注意事项</a></li><li><a href=#适用场景>适用场景</a></li></ul></li></ul></li><li><a href=#defaultt><code>default(T)</code></a><ul><li><a href=#默认值规则>默认值规则</a></li><li><a href=#defaultt的存在意义><code>default(T)</code>的存在意义</a></li><li><a href=#实际应用场景和示例>实际应用场景和示例</a></li><li><a href=#defalut字面量c71引入><code>defalut</code>字面量（C#7.1引入）</a></li></ul></li><li><a href=#expression-bodied>Expression-bodied</a><ul><li><a href=#核心概念>核心概念</a></li><li><a href=#示例>示例</a></li><li><a href=#使用表达式主体的优点>使用表达式主体的优点</a></li><li><a href=#注意事项与缺陷>注意事项与缺陷</a></li></ul></li><li><a href=#var><code>var</code></a><ul><li><a href=#基本语法和使用>基本语法和使用</a></li><li><a href=#工作原理>工作原理</a></li><li><a href=#适用场景-1>适用场景</a></li><li><a href=#不适用场景>不适用场景</a></li><li><a href=#类型推断规则>类型推断规则</a></li><li><a href=#示例-1>示例</a></li><li><a href=#最佳实践>最佳实践</a></li></ul></li><li><a href=#dynamic><code>dynamic</code></a><ul><li><a href=#静态类型-vs-动态类型>静态类型 vs 动态类型</a></li><li><a href=#基本用法和语法>基本用法和语法</a></li><li><a href=#使用场景>使用场景</a></li><li><a href=#优缺点>优缺点</a></li><li><a href=#dynamic与var的区别><code>dynamic</code>与<code>var</code>的区别</a></li></ul></li><li><a href=#null-forgiving-空值忽略符><code>!</code>(null-forgiving. 空值忽略符)</a><ul><li><a href=#示例-2>示例</a></li><li><a href=#实际行为>实际行为</a></li></ul></li><li><a href=#_discard弃元运算符><code>_</code>(Discard，弃元运算符)</a><ul><li><a href=#在switch语句中作为弃元>在<code>switch</code>语句中作为弃元</a></li><li><a href=#在元组和结构中作为弃元>在元组和结构中作为弃元</a></li><li><a href=#在out参数中作为弃元>在Out参数中作为弃元</a></li><li><a href=#在lambda表达式中作为参数>在Lambda表达式中作为参数</a></li><li><a href=#作为私有字段的命名前缀约定俗成>作为私有字段的命名前缀（约定俗成）</a></li><li><a href=#在数字字面量中作为数字分隔符>在数字字面量中作为数字分隔符</a></li></ul></li><li><a href=#where--when><code>where</code> & <code>when</code></a><ul><li><a href=#switch表达式或语句中的when><code>switch</code>表达式或语句中的<code>when</code></a></li><li><a href=#catch子句中的when><code>catch</code>子句中的<code>when</code></a></li><li><a href=#where泛型约束><code>where</code>泛型约束</a><ul><li><a href=#1-限制类型必须实现某接口>1. 限制类型必须实现某接口</a></li><li><a href=#2-限制类型必须继承某类>2. 限制类型必须继承某类</a></li><li><a href=#3-限制类型必须有无参构造函数>3. 限制类型必须有无参构造函数</a></li><li><a href=#4-多重约束可以叠加>4. 多重约束（可以叠加）</a></li><li><a href=#5-约束多个泛型参数>5. 约束多个泛型参数</a></li></ul></li></ul></li><li><a href=#record><code>record</code></a><ul><li><a href=#基本语法>基本语法</a></li><li><a href=#值相等value-equality>值相等（Value Equality）</a></li><li><a href=#不可变对象immutable>不可变对象（Immutable）</a></li><li><a href=#with表达式复制表达式><code>with</code>表达式（复制表达式）</a></li><li><a href=#继承与record-class--record-struct>继承与Record Class / Record Struct</a></li><li><a href=#解构deconstruction>解构（Deconstruction）</a></li><li><a href=#继承与record层次结构>继承与Record层次结构</a></li><li><a href=#可变record不推荐>可变record（不推荐）</a></li><li><a href=#底层原理编译后>底层原理（编译后）</a></li></ul></li><li><a href=#and-or-not><code>and</code>, <code>or</code>, <code>not</code></a><ul><li><a href=#背景模式逻辑表达式的自然语言化>背景：模式逻辑表达式的自然语言化</a></li><li><a href=#语法规则>语法规则</a></li></ul></li><li><a href=#isas><code>is</code>/<code>as</code></a><ul><li><a href=#is><code>is</code></a></li><li><a href=#as><code>as</code></a></li><li><a href=#is-vs-as><code>is</code> vs <code>as</code></a></li><li><a href=#使用场景示例>使用场景示例</a></li></ul></li><li><a href=#跳转指令>跳转指令</a></li><li><a href=#yield-return><code>yield return</code></a><ul><li><a href=#执行模型>执行模型</a><ul><li><a href=#执行流程>执行流程</a></li></ul></li><li><a href=#yield-return--return><code>yield return</code> != <code>return</code></a></li><li><a href=#示例-3>示例</a></li><li><a href=#yield-return的存在意义与适用场景><code>yield return</code>的存在意义与适用场景</a><ul><li><a href=#适用场景-2>适用场景</a></li></ul></li><li><a href=#注意事项和常见误区>注意事项和常见误区</a></li></ul></li><li><a href=#heading><code>[]</code></a><ul><li><a href=#defaultmemberitem><code>[DefaultMember("Item")]</code></a></li><li><a href=#item><code>Item</code></a><ul><li><a href=#存在意义>存在意义</a></li><li><a href=#在现代c中>在现代C#中</a></li></ul></li></ul></li><li><a href=#xml注释>XML注释</a><ul><li><a href=#基本结构>基本结构</a></li><li><a href=#常见的xml注释标签>常见的XML注释标签</a></li><li><a href=#示例-4>示例</a></li><li><a href=#ide支持和智能感知>IDE支持和智能感知</a></li><li><a href=#注意事项>注意事项</a></li><li><a href=#使用xml的好处>使用XML的好处</a></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>