<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Attribute</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/lib/>Lib</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/runtime/ href=/runtime/>Runtime</a>         |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Attribute<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><h1 id=attribute>Attribute</h1><p>Attribute是C#里一个非常强大的元编程机制——它让代码可以携带额外的“说明性数据”，这些数据可以再运行时或编译时被读取，用来改变程序的行为、提供元信息或做自动化处理<br>可以把它理解为：给类型、方法、字段等打标签，然后通过反射读取这些标签</p><h2 id=attribute是什么>Attribute是什么</h2><p>在.NET世界里，Attribute是继承自<code>System-Attribute</code>的类，用来给程序元素（类、方法、属性、参数、程序集等）附加元数据（metadata）</p><p>这些元数据在编译后会被写入到程序集的metadata字段里，在运行时可以通过反射(<code>System.Reflection</code>)读取</p><h2 id=系统内置的常见attribute>系统内置的常见Attribute</h2><p>| 名称 | 用途 |
| <code>[Obsolete]</code> | 标记成员已废弃。编译器会警告或报错 |
| <code>[Serializable]</code> | 标记类可以被序列化 |
| <code>[NoSerialized]</code> | 标记字段在序列化时被跳过 |
| <code>[DllImport]</code> | 用于调用非托管代码（P/Invoke）|
| <code>[Conditional]</code> | 根据编译条件决定是否调用方法 |
| <code>[AttributeUsage]</code> | 限定自定义Attribute的使用范围 |</p><h3 id=obsolete><code>[Obsolete]</code></h3><p>告诉编译器“这个方法、类或属性已经过时”，鼓励使用新API</p><p>定义 （.NET Framework源码）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[AttributeUsage(AttributeTargets.All, Inherited = false)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObsoleteAttribute</span> : Attribute
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Message { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsError { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ObsoleteAttribute(<span style=color:#66d9ef>string</span> message, <span style=color:#66d9ef>bool</span> error = <span style=color:#66d9ef>false</span>) { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Game</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Obsolete(&#34;Use InitGame instead&#34;, true)]</span> <span style=color:#75715e>// 第二个参数为true会报错</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> StartGame() { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> InitGame() { }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> g = <span style=color:#66d9ef>new</span> Game();
</span></span><span style=display:flex><span><span style=color:#75715e>// g.StartGame(); // CS0619</span>
</span></span></code></pre></div><ul><li>第一个参数是提示消息</li><li>第二个参数<code>true</code>表示编译错误，<code>false</code>只警告</li><li>这是编译器特性，不会影响运行时</li></ul><p>用法场景：在API版本升级时非常常见，比如Unity的老API或.NET的旧接口</p><h3 id=serializable><code>[Serializable]</code></h3><p>告诉.NET序列化器（如BinaryFormatter、XmlSerializer）这个类的对象可以被序列化（即转成字节流保存或传输）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[Serializable]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Player</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Level;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [NonSerialized]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> TempScore;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>序列化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> palyer = <span style=color:#66d9ef>new</span> Player { Name = <span style=color:#e6db74>&#34;LJF&#34;</span>, Level = <span style=color:#ae81ff>10</span>, TempScore = <span style=color:#ae81ff>99</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> fs <span style=color:#66d9ef>new</span> FileStream(<span style=color:#e6db74>&#34;player.dat&#34;</span>, FileMode.Create))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> formatter = <span style=color:#66d9ef>new</span> BinaryFormatter();
</span></span><span style=display:flex><span>    formatter.Serialize(fs, player);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>反序列化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> fs = <span style=color:#66d9ef>new</span> FileStream(<span style=color:#e6db74>&#34;player.dat&#34;</span>, FileMode.Open))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> formatter = <span style=color:#66d9ef>new</span> BinaryFormatter();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> restore = (Player)formatter.Deserialize(fs);
</span></span><span style=display:flex><span>    Console.WriteLine(rstored.Name); <span style=color:#75715e>// 输出LJF</span>
</span></span><span style=display:flex><span>    Console.WriteLine(restored.TempScore); <span style=color:#75715e>// 输出0（被跳过了）</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>[Serializable]</code>告诉运行时在反射扫描时，将该类型字段纳入序列化流程</p><h3 id=nonserialized><code>[NonSerialized]</code></h3><p>配合<code>[Serializable]</code>使用，表示该字段在序列化时被忽略</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[Serializable]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Player</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name;
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [NonSerialized]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Password;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Password</code>在序列化时不会被写入数据流<br>常用于跳过缓存字段、临时数据或敏感信息<br>只对字段(field)生效，不作用于属性(property)</p><blockquote><p>二进制序列化已经被废弃，取而代之的是Json序列化</p></blockquote><h3 id=dllimport><code>[DllImport]</code></h3><p>用于声明外部函数（通常是C/C++ 动态库函数），告诉CLR这是个“外部实现”的方法<br>定义（位于<code>System.Runtime.InteropServices</code>）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[AttributeUsage(AttributeTargets.Method)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DllImportAttribute</span> : Attribute
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DllImportAttribute(<span style=color:#66d9ef>string</span> dllName) { ... }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> CallingConvention CallingConvention { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> EntryPoint { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用例子</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Runtime.InteropServices;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NativeMethods</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [DllImport(&#34;user32.dll&#34;, CharSet = CharSet.Unicode)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> MessageBox(IntPtr hWnd, <span style=color:#66d9ef>string</span> text, <span style=color:#66d9ef>string</span> caption, <span style=color:#66d9ef>int</span> type);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NativeMethods.MessageBox(IntPtr.Zero, <span style=color:#e6db74>&#34;你好&#34;</span>, <span style=color:#e6db74>&#34;提示&#34;</span>, <span style=color:#ae81ff>0</span>)
</span></span></code></pre></div><p>这就是P/Invoke<br>C#会在运行时加载<code>user32.dll</code>并调用其中的<code>MessageBox</code>函数</p><p>用法场景：
Unity、.NET Core、Mono都广泛使用它来桥接C/C++层，比如</p><ul><li>调用OpenGL/Vulkan/Win32 API</li><li>调用C写的音频或图像库</li><li>嵌入系统底层调用</li></ul><h3 id=conditional><code>[Conditional]</code></h3><p>让某个方法在特定条件下才会被编译调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Diagnostics;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Logger</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Conditional(&#34;DEBUG&#34;)]</span> <span style=color:#75715e>// VS在Debug模式下，会自动#define DEBUG，因此会生效</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Log(<span style=color:#66d9ef>string</span> msg) =&gt; Console.WriteLine(msg);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Logger.Log(<span style=color:#e6db74>&#34;Game started!&#34;</span>);
</span></span></code></pre></div><p>编译</p><ul><li>如果定义了宏<code>DEBUG</code>（在项目属性或<code>#define DEBUG</code>），这行代码会保留</li><li>否则整行会被编译器直接忽略（像从源代码中删掉一样）</li></ul><p>注意</p><ul><li>仅影响调用，不影响方法定义</li><li>只能修饰返回类型为<code>void</code>的方法</li><li>可用多个条件，如<code>[Conditional("DEBUG"), Conditional("TRACE")]</code></li></ul><p>这在日志系统、调试开关、断言机制中非常有用</p><h3 id=attributeusage><code>[AttributeUsage]</code></h3><p>控制自定义Attriute的适用位置、可重复性、继承性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[AttributeUsage(
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    AttributeTargets.Class | AttributeTargets.Method,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    AllowMultiple = true,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    Inherited = false)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthorAttribute</span> : Attribute
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AuthorAttribute(<span style=color:#66d9ef>string</span> name) { Name = name; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>AtrributeTargets: 限定能贴在哪些元素上（类、方法、属性、字段、参数等）</li><li>AllowMultiple：是否能多次使用同一个特性</li><li>Inherited：是否能被子类继承</li></ul><p>示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[Author(&#34;ljf12825&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[Author(&#34;system&#34;, AllowMultiple = true)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameEngine</span> { }
</span></span></code></pre></div><p>反射读取</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> attrs = <span style=color:#66d9ef>typeof</span>(GameEngine).GetCustomAttributes(<span style=color:#66d9ef>typeof</span>(AuthorAttribute), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (AuthorAttribute attr <span style=color:#66d9ef>in</span> attrs)
</span></span><span style=display:flex><span>    Console.WriteLine(attr.Name);
</span></span></code></pre></div><h3 id=小结>小结</h3><p>这六种基本Attribute代表了Attribute的“六种哲学”</p><table><thead><tr><th>特性</th><th>领域</th><th>核心思想</th></tr></thead><tbody><tr><td><code>[Obsolete]</code></td><td>编译期提示</td><td>可攻至版本演化</td></tr><tr><td><code>[Serializable]</code>/<code>[NonSerialized]</code></td><td>运行时序列化</td><td>数据状态的持久化控制</td></tr><tr><td><code>[DllImport]</code></td><td>系统互操作</td><td>扩展托管代码边界</td></tr><tr><td><code>[Conditional]</code></td><td>条件编译</td><td>动态编译控制</td></tr><tr><td><code>[AttributeUsage]</code></td><td>自定义约束</td><td>元编程的元规则</td></tr></tbody></table><p>这些特性合起来体现了C#的一个哲学：“元数据驱动的行为控制”<br>它不是仅仅写死逻辑，而是把“信息”挂在结构上，再由编译器、运行时或框架去解释执行<br>这正式Unity、ASP.NET、Entity Framework、XUnit等框架的底层机制所在</p><h2 id=自定义attribute>自定义Attribute</h2><p>自定义Attribute只需要继承自<code>System.Attribute</code>即可</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthorAttribute</span> : Attribute
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Version { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AuthorAttribute(<span style=color:#66d9ef>string</span> name) =&gt; Name = name;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#a6e22e>[Author(&#34;ljf12825&#34;, Version = 1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GameEngine</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Author(&#34;tester&#34;, Version = 2)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Innit() { }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=读取attribute反射>读取Attribute（反射）</h2><p>可以在运行时读取类或方法上的特性，并作出相应逻辑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Type type = <span style=color:#66d9ef>typeof</span>(GameEngine);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> attrs = type.GetCustomAttributes(<span style=color:#66d9ef>typeof</span>(AuthorAttriute), <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (AuthorAttribute attr <span style=color:#66d9ef>in</span> attrs)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>$&#34;Author: {attr.Name}, Version: {attr.Version}&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也可以这样查方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> method = type.GetMethod(<span style=color:#e6db74>&#34;Init&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> attr = (AuthorAttribute)method.GetCustomAttribute(<span style=color:#66d9ef>typeof</span>(AuthorAttribute));
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;Method Author: {attr.Name}&#34;</span>);
</span></span></code></pre></div></div><nav class=post-nav><a href=/dotnetandwindows/lib/csharp/ class=hover:underline>next: C# and .NET</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><a href=#attribute>Attribute</a><ul><li><a href=#attribute是什么>Attribute是什么</a></li><li><a href=#系统内置的常见attribute>系统内置的常见Attribute</a><ul><li><a href=#obsolete><code>[Obsolete]</code></a></li><li><a href=#serializable><code>[Serializable]</code></a></li><li><a href=#nonserialized><code>[NonSerialized]</code></a></li><li><a href=#dllimport><code>[DllImport]</code></a></li><li><a href=#conditional><code>[Conditional]</code></a></li><li><a href=#attributeusage><code>[AttributeUsage]</code></a></li><li><a href=#小结>小结</a></li></ul></li><li><a href=#自定义attribute>自定义Attribute</a></li><li><a href=#读取attribute反射>读取Attribute（反射）</a></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>