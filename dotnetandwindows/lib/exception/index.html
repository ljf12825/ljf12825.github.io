<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Exception</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/lib/>Lib</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /             <a class=nav-item data-path=/engine/ href=/engine/>Engine</a>         |
|                             |  /                 |           |
|                             | /                  |           |
|                             |/                   |           |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/framework/ href=/framework/>Framework</a>       |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Exception<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><p>异常处理是编写健壮、可靠应用程序的基石，它允许程序以可空的方式响应运行时错误，而不是直接崩溃<br>C#的异常体系，本质上是把“程序在正常道路上走不下去了”这件事转成一种结构化的、可推断的控制流</p><h2 id=什么是异常>什么是异常</h2><p>异常是指在程序执行过程中发生的、破坏正常指令流的不正常或意外情况。通俗地说，就是程序在运行时遇到了一个它无法处理的“错误”</p><ul><li>尝试打开一个不存在的文件（<code>FileNotFoundException</code>）</li><li>访问数组范围之外的元素（<code>IndexOutOfRangeException</code>）</li><li>将非数字字符串转换为整数（<code>FormatException</code>）</li><li>尝试访问空引用的成员（<code>NullReferenceException</code>）</li><li>网络连接中断（<code>IOException</code>）</li></ul><h3 id=三类异常>三类异常</h3><ol><li>开发期异常：比如NullReferenceException, IndexOutOfRangeException, InvalidCastException 它们说明你代码写坏了，本质是bug，出现就应该修。正常运行时不应该去catch这些</li><li>环境类异常：IOException, SocketException, UnauthorizedAccessException 它们来自系统或外部资源的不确定性。无法预知什么时候来，但必须处理</li><li>业务逻辑异常：通常继承自ApplicationException或自定义。比如角色升级但经验不足、配置数据格式错误、资源引用不存在。这类异常更多是为了简化流程，让错误自动冒泡到合适的地方</li></ol><h2 id=exception-in-c>Exception in C#</h2><p>异常在C#里是一个对象。所有异常都继承自Exception类。它包含错误信息、堆栈、内部异常、HResult等字段。throw做的事情，就是把当前执行栈一路拆开，直到找到能处理它的catch块</p><p>这套unwinding机制的重点是：失败不是返回值，而是一种控制流中断。也就是说，只要抛出异常，方法剩下的部分不执行，直接跳出栈帧</p><p>为什么这样设计？因为大量错误不属于“业务逻辑”，而是“根本无法继续执行”。比如文件打开失败、网络掉线、索引越界、资源缺失等。如果用返回值层层上传，会污染函数签名；而使用异常则把错误从逻辑通道剥离了</p><h3 id=异常处理的核心关键字try-catch-finally>异常处理的核心关键字：<code>try</code>, <code>catch</code>, <code>finally</code></h3><p>C#使用结构化的异常处理模型，主要围绕三个关键字，语义很直观</p><ul><li><p><code>try</code>块：开始一段有风险的操作</p><ul><li>包含可能会抛出异常的代码</li><li>它必须至少跟一个<code>catch</code>块或一个<code>finally</code>块</li></ul></li><li><p><code>catch</code>块：捕获特定类型的异常</p><ul><li>用于捕获和处理特定类型的异常</li><li>可以有多个<code>catch</code>块来捕获不同类型的异常，处理更具体的异常应该放在前面</li><li>C#支持按类型匹配，也支持when条件过滤；<code>catch(Exception)</code>是大网，但别乱用，大网会吞掉本来应该在调试阶段暴露的错误</li></ul></li><li><p><code>fianlly</code>块：无论是否发生异常都执行的地方</p><ul><li>包含的代码总是会执行，无论是否发生异常</li><li>通常用于释放资源，例如关闭文件流、数据库连接等</li><li>销毁资源、回收句柄、释放锁都应该写在这里</li></ul></li><li><p><code>using</code>：是语法糖</p><ul><li>它会在using 块结束时自动调用对象的Dispose，用法等价于try/finally</li></ul></li></ul><h3 id=基本语法和工作流程>基本语法和工作流程</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 可能会将抛出异常的代码</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> divisor = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result = <span style=color:#ae81ff>10</span> / divisor; <span style=color:#75715e>// 这将抛出 divideByZeroException</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (DivideByZeroException ex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 专门处理除以零的异常</span>
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>$&#34;发生除以零错误：{ex.Message}&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (Exception ex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 捕获所有其他类型的异常（更通用的异常应该放在后面）</span>
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>$&#34;发生未知错误：{ex.Message}&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>finally</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 无论是否发生异常，这里的代码都会执行</span>
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;finally 块执行了，用于清理资源&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行流程</p><ol><li>执行<code>try</code>块内的代码</li><li>如果无异常，跳过所有<code>catch</code>块，执行<code>finally</code>块（如果有）</li><li>如果有异常，CLR会查找匹配的<code>catch</code>块</li><li>找到匹配的<code>catch</code>块后，执行其中的代码</li><li>最后，执行<code>finally</code>块（如果有）</li></ol><h3 id=常见的异常类型继承自systemexception>常见的异常类型（继承自<code>System.Exception</code>）</h3><p>所有异常都派生自<code>System.Exception</code>类</p><p>| 异常类型 | 描述 |
| <code>SystemException</code> | 系统定义的运行时异常的基类 |
| <code>ArgumentException</code> | 当向方法传递了无效参数时抛出 |
| <code>ArgumentNullException</code> | 当传递了不应为<code>null</code>的参数时抛出 |
| <code>IndexOutOfRangeException</code> | 当数组索引超出范围时抛出 |
| <code>NullReferenceException</code> | 当尝试访问空引用的成员时抛出 |
| <code>DivideByZeroException</code> | 当尝试用整数除以零时抛出 |
| <code>FormatException</code> | 当参数的格式不符合调用方法的规范时抛出（如<code>int.Parse("abc")</code>）|
| <code>FileNotFoundException</code> | 当尝试访问不存在的文件时抛出 |
| <code>IOException</code> | 发生I/O错误时抛出的异常的基类 |</p><h3 id=创建和抛出自定义异常>创建和抛出自定义异常</h3><p>有时，需要创建特定于自己应用程序业务的异常</p><ol><li>创建一个类，继承自<code>Exception</code>或其子类（如<code>ApplicationException</code>），但微软现在更推荐直接继承<code>Exception</code></li><li>实现基本的构造函数</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 自定义异常类</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InsufficientFundsException</span> : Exception
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>decimal</span> CurrentBalance { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>decimal</span> WithdrawAmount { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 构造函数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> InsufficientFundsException(<span style=color:#66d9ef>string</span> message, <span style=color:#66d9ef>decimal</span> currentBalance, <span style=color:#66d9ef>decimal</span> withdrawAmount) : <span style=color:#66d9ef>base</span>(message)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        CurrentBalance = currentBalance;
</span></span><span style=display:flex><span>        WithdrawAmount = withdrawAmount;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 重写 ToString() 来提供更多信息</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>string</span> ToString()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>$&#34;{Message} (当前余额：{CurrentBalance}, 尝试取款：{WithdrawAmount})&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用自定义异常</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BankAccount</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>decimal</span> Balance { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Withdraw(<span style=color:#66d9ef>decimal</span> amount)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (amount &gt; Balance)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 抛出自定义异常</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InsufficientFundsException(<span style=color:#e6db74>&#34;余额不足&#34;</span>, Balance, amount);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Balance -= amount;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Deposit(<span style=color:#66d9ef>decimal</span> amount)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (amount &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Balance += amount;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 调用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> account = <span style=color:#66d9ef>new</span> BankAccount { };
</span></span><span style=display:flex><span>            account.Deposit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            account.Withdraw(<span style=color:#ae81ff>200</span>); <span style=color:#75715e>// 这会抛出 InsufficientFundsException</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>catch</span> (InsufficientFundsException ex)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(ex.ToString()); 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=finally><code>finally</code></h3><p><code>finally</code>块无论是否抛异常都会执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	OpenConnection();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>&#34;连接失败&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>finally</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	CloseConnection(); <span style=color:#75715e>// 一定执行</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>即使在<code>catch</code>里<code>return</code>，<code>finally</code>仍然会执行</p><h4 id=简化写法>简化写法</h4><p>可以使用<code>using</code>替代，<code>try-finally</code> <code>using</code>本质是try-finally的语法糖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> fs = <span style=color:#66d9ef>new</span> FileStream(<span style=color:#e6db74>&#34;data.txt&#34;</span>, FileMode.Open))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 自动调用 fs.Dispose()</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>FileStream fs = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	fs = <span style=color:#66d9ef>new</span> FileStream(<span style=color:#e6db74>&#34;data.txt&#34;</span>, FileMode.Open);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>finally</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	fs?.Dispose();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=异常机制的底层逻辑>异常机制的底层逻辑</h3><p>C#的异常是基于CLR的结构化异常处理（SEH）<br>一旦发生错误，程序会</p><ol><li>创建一个异常对象（派生自<code>System.Exception</code>）</li><li>沿调用栈逐层回溯，寻找匹配的<code>catch</code></li><li>如果没人接住，程序终止</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> A() =&gt; B();
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> B() =&gt; <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;出错了!&#34;</span>)<span style=color:#960050;background-color:#1e0010>；</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> { A(); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (Exception ex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Console.WriteLine(ex.message);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：<code>出错了!</code><br>异常从<code>B()</code>一路冒泡，被最外层的<code>catch</code>捕获</p><h4 id=catch的多种形态>catch的多种形态</h4><p>C#允许多种<code>catch</code>形式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (FileNotFoundException ex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>&#34;文件未找到&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (IOException ex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>&#34;IO错误&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (Exception ex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>&#34;其他错误&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>顺序重要，子类要放在前面</li><li><code>catch</code>可以没有变量</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>catch</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>&#34;发生错误&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>可以使用过滤器</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>catch</span> (Exception ex) when (ex.Message.Contains(<span style=color:#e6db74>&#34;网络&#34;</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>&#34;网络相关异常&#34;</span>)<span style=color:#960050;background-color:#1e0010>；</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=异常机制底层实现>异常机制底层实现</h3><h4 id=异常在底层的运行>异常在底层的运行</h4><p>C#的异常不是“if分支”，而是运行时机制<br>当<code>throw</code>一个异常时，CLR(.NET运行时)会做三件事</p><ol><li>构造异常对象</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InvalidOperationException(<span style=color:#e6db74>&#34;非法操作&#34;</span>);
</span></span></code></pre></div><p>在堆上分配一个<code>InvalidOperationException</code>对象
2. 展开调用栈（stack unwinding）
- CLR会从当前函数开始，逐层往上查找有无<code>try</code>区块
- 每经过一层函数，都会销毁局部变量（执行析构或<code>finally</code>）
- 直到找到能匹配的<code>catch</code>
3. 转移控制流
- 控制权交给<code>catch</code>块
- 没人接住 -> 程序终止（或触发全局异常事件）</p><p>这是一整套系统级过程，不是普通跳转<br>所以异常的“代价”主要来自栈展开和对象创建</p><h4 id=性能开销>性能开销</h4><p>异常的代价不是“存在try-catch”，而是“发生 throw”</p><p>不抛异常时<br><code>try-catch</code>几乎零性能损耗<br>JIT编译器只是在内部生成异常表，正常路径完全一样</p><p>抛出异常时<br>就贵了，主要开销</p><ol><li>创建异常对象（内存分配 + 收集堆栈信息）</li><li>栈展开 + 调用<code>finally</code></li><li>CLR捕获堆栈、调用异常过滤器等</li></ol><p>大致成本几倍：</p><ul><li>普通函数调用：微秒级</li><li>异常抛出 + 捕获：百微妙~毫秒级（取决于栈深度）
在循环或高频逻辑里抛异常时灾难性的</li></ul><h4 id=c为什么要这么设计>C#为什么要这么设计</h4><p>因为异常的目的不是性能，而是语义：把“异常流程”从“正常流程”中隔离开<br>异常让：</p><ul><li>调用层代码更干净</li><li>错误流与业务流分离</li><li>框架层可以集中捕获并处理</li></ul><p>也就是说：异常是一种控制流语义分层机制，不是“错误检测语法糖”</p><h4 id=throw与throw-ex的区别><code>throw</code>与<code>throw ex</code>的区别</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>catch</span> (Exception ex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>throw</span>; <span style=color:#75715e>// 保留原始调用堆栈</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (Exception ex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>throw</span> ex; <span style=color:#75715e>// 堆栈从这里重新开始，丢失源头</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>CLR在执行<code>throw;</code>时不会重建异常对象，只是继续向上抛<br>这就是为什么总是推荐使用裸<code>throw;</code></p><h4 id=内部结果异常表exception-handling-table>内部结果：异常表（Exception Handling Table）</h4><p>JIT编译时，CLR会为每个函数建立一张异常表</p><table><thead><tr><th>Try Start</th><th>Try End</th><th>Handler Type</th><th>Handler Start</th><th>Exception Type</th></tr></thead><tbody><tr><td>IL_0001</td><td>IL_0020</td><td>Catch</td><td>IL_0021</td><td>System.Exception</td></tr></tbody></table><p>也就是说：</p><ul><li><code>try-catch</code>是一种元数据结构</li><li>不是在每个if中插入判断</li><li>所以不抛异常时，执行性能几乎一致</li></ul><h3 id=c中异常控制结构的正确使用方式>C#中异常控制结构的正确使用方式</h3><p>抛异常要谨慎。异常不是炫技工具，不是“我不想写if就直接throw”。一个好的throw应该用于“此路径无法继续”的时刻，而不是替代if-check</p><p>C#的异常会导致GC压力增加，因为堆栈信息需要分配对象。同时，它会破坏CPU分支预测，对性能敏感的场景，比如Update循环、深度递归中、每帧执行的热路径，都尽量避免抛异常。Unity的游戏逻辑尤其如此，异常抛多了，不仅卡顿，还让profiler看起来像在尖叫</p><h4 id=最佳实践>最佳实践</h4><ol><li>只在真正异常的情况下使用异常<ul><li>不要用异常来控制正常的程序流程。例如，检查文件是否存在应该用<code>File.Exists</code>，而不是通过捕获<code>FileNotFoundException</code>来实现</li></ul></li></ol><p>不好的做法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    File.ReadAllText(<span style=color:#e6db74>&#34;myfile.txt&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (FileNotFoundException)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 文件不存在的处理</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>好的做法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>if</span> (File.Exists(<span style=color:#e6db74>&#34;myfile.txt&#34;</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    File.ReadAllText(<span style=color:#e6db74>&#34;myfile.txt&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 文件不存在的处理</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li><p>从最具体到最不具体捕获异常</p><ul><li>这样能确保最合适的处理程序被执行</li></ul></li><li><p>不要“吞噬”异常</p><ul><li>空的<code>catch</code>块会隐藏错误，使得调试极其困难</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 不好的做法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> { <span style=color:#75715e>/*dosomething*/</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (Exception) { } <span style=color:#75715e>// 吞掉异常，什么也不做</span>
</span></span></code></pre></div><ul><li>至少应该记录下异常信息，一遍后续分析和调试</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>catch</span> (Exception ex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Logger.LogError(ex, <span style=color:#e6db74>&#34;操作失败&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 可能还需要决定是重新抛出、吞下还是抛出新的异常</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>使用<code>throw;</code>而不是<code>throw ex;</code>来重新抛出<ul><li><code>throw;</code>会保留原始的异常堆栈跟踪，而<code>throw ex;</code>会重置堆栈跟踪，丢失关键的调试信息</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>catch</span> (Exception)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 一些清理工作</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span>; <span style=color:#75715e>// 正确，保留原始堆栈跟踪</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// throw ex; // 错误，堆栈跟踪从这里开始</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=5><li>利用<code>using</code>语句管理资源<ul><li>对于实现了<code>IDisposable</code>接口的对象（如文件流、数据库连接），使用<code>using</code>语句可以确保资源被正确释放，即使发生异常。它在功能上等同于<code>try-finally</code></li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// using 语句等价于 try-finally，并自动调用 Dispose()</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> fileStream = <span style=color:#66d9ef>new</span> FileStream(<span style=color:#e6db74>&#34;file.txt&#34;</span>, FileMode.Open))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 fileStream</span>
</span></span><span style=display:flex><span>} <span style=color:#75715e>// 这里会自动调用 fileStream.Dispose(), 关闭文件</span>
</span></span></code></pre></div><p>异常的捕获，要么处理它，要么别动它<br>catch之后什么都不做，然后继续运行，这类代码是灾难。要么把错误往上传，要么记录日志，要么转成更具体的错误，要么在catch后让程序回到一个安全状态<br>C#的异常体系不是为了“修补错误”，而是为了“让错误显式化、结构化、可追踪”<br>写代码不怕出错，怕的是出错后系统没反应；优秀的程序员不会让异常消失，而是让它有迹可循<br>在好的架构里，异常有“层级传递”</p><ul><li>底层：抛出具体异常（IO、网络、解析等）</li><li>中层：转译为业务语义异常</li><li>顶层：集中捕获、记录日志、优雅退出</li></ul><table><thead><tr><th>场景</th><th>建议</th></tr></thead><tbody><tr><td>可预期错误</td><td>用<code>if</code>检查、不抛异常</td></tr><tr><td>不可预期错误</td><td>抛异常（<code>throw</code>）</td></tr><tr><td>临界资源</td><td><code>try-finally</code>或<code>using</code></td></tr><tr><td>顶层逻辑</td><td>全局异常捕获（<code>AppDomain.CurrentDomain.UnhandledException</code>）</td></tr><tr><td>框架封装</td><td>定义自定义异常类，分层管理</td></tr></tbody></table><h4 id=异常适用场景>异常适用场景</h4><table><thead><tr><th>场景</th><th>说明</th><th>是否该抛异常</th></tr></thead><tbody><tr><td>文件不存在</td><td>用户输入错误可预期</td><td>用<code>File.Exists()</code>检查</td></tr><tr><td>网络断开</td><td>系统不可控因素</td><td>抛异常</td></tr><tr><td>参数非法</td><td>编程错误</td><td>抛<code>ArgumentException</code></td></tr><tr><td>玩家按错按钮</td><td>业务逻辑</td><td>if检查</td></tr><tr><td>程序逻辑错误</td><td>无法恢复</td><td>抛异常或<code>Debug.Assert</code></td></tr></tbody></table><p>通俗讲：可预期的用条件判断，不可预期的才抛异常</p><h2 id=用返回值表示失败-vs-抛出异常>用返回值表示失败 vs 抛出异常</h2><p>异常是API契约的一部分。当设计一个方法，是用返回值表示失败，还是用异常，背后是一个哲学问题：失败是“预期路径”还是“异常路径”\</p><ul><li>返回值表示错误：显式、可控、但容易被忽略<ul><li>优点：没有隐藏成本，没有额外控制流跳跃，性能更可预测，非常适合底层代码、性能敏感路径、游戏引擎内部循环</li><li>缺点：调用者完全忽略</li><li>适用场景<ul><li>预期的、经常发生的失败情况</li><li>性能敏感场景</li><li>与其他语言/系统交互</li><li>简单状态检查</li></ul></li></ul></li><li>抛出异常：强制中断流、自动传播<ul><li>优点：写业务逻辑时不需要每行都在if(err)里反复检查</li><li>缺点：异常跨栈展开会毁掉性能预知性，在游戏循环、渲染管线、实时逻辑里异常传播增加调试难度</li><li>适用场景<ul><li>意外的、异常的情况</li><li>严重的、不可恢复的错误</li><li>违反前置条件的情况</li><li>需要沿调用栈向上传播的错误</li></ul></li></ul></li></ul><p>判断是否该抛异常，只问一句话：这件事的失败，是“可预期事件”还是“违反世界规则”</p><p>无论作何选择，一致性比绝对正确更重要。在同一个项目或模块中保持统一的错误处理策略</p></div><nav class=post-nav><a href=/dotnetandwindows/lib/event/ class=hover:underline>pre: Event</a>
<a href=/dotnetandwindows/lib/function/ class=hover:underline>next: Function</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#什么是异常>什么是异常</a><ul><li><a href=#三类异常>三类异常</a></li></ul></li><li><a href=#exception-in-c>Exception in C#</a><ul><li><a href=#异常处理的核心关键字try-catch-finally>异常处理的核心关键字：<code>try</code>, <code>catch</code>, <code>finally</code></a></li><li><a href=#基本语法和工作流程>基本语法和工作流程</a></li><li><a href=#常见的异常类型继承自systemexception>常见的异常类型（继承自<code>System.Exception</code>）</a></li><li><a href=#创建和抛出自定义异常>创建和抛出自定义异常</a></li><li><a href=#finally><code>finally</code></a><ul><li><a href=#简化写法>简化写法</a></li></ul></li><li><a href=#异常机制的底层逻辑>异常机制的底层逻辑</a><ul><li><a href=#catch的多种形态>catch的多种形态</a></li></ul></li><li><a href=#异常机制底层实现>异常机制底层实现</a><ul><li><a href=#异常在底层的运行>异常在底层的运行</a></li><li><a href=#性能开销>性能开销</a></li><li><a href=#c为什么要这么设计>C#为什么要这么设计</a></li><li><a href=#throw与throw-ex的区别><code>throw</code>与<code>throw ex</code>的区别</a></li><li><a href=#内部结果异常表exception-handling-table>内部结果：异常表（Exception Handling Table）</a></li></ul></li><li><a href=#c中异常控制结构的正确使用方式>C#中异常控制结构的正确使用方式</a><ul><li><a href=#最佳实践>最佳实践</a></li><li><a href=#异常适用场景>异常适用场景</a></li></ul></li></ul></li><li><a href=#用返回值表示失败-vs-抛出异常>用返回值表示失败 vs 抛出异常</a></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>