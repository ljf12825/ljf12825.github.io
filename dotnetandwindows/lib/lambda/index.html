<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>Lambda</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/lib/>Lib</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /             <a class=nav-item data-path=/engine/ href=/engine/>Engine</a>         |
|                             |  /                 |           |
|                             | /                  |           |
|                             |/                   |           |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/framework/ href=/framework/>Framework</a>       |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |       <a class=nav-item data-path=/language/ href=/language/>Language</a>                 |
|                        /    |      /                         |
|                       /     |     /                          |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |    /           <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |   /            <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                        <a class=nav-item data-path=/leftbrain/ href=/leftbrain/>LeftBrain</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>Lambda<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><p>简单来说，Lambda表达式是一个匿名函数。可以把它理解为一个没有名字的、简洁的方法。它使用<code>=></code>这个Lambda运算符（读作"goes to"）来连接参数列表和表达式主体</p><p>它的核心思想是：需要方法的地方，如果这个方法很简单，且只会用一次，就不必费心去定义一个完整的方法，而是直接用Lambda表达式内联写出它的实现</p><h2 id=lambda表达式的语法演变>Lambda表达式的语法演变</h2><p>假设有一个需求：从一个整数列表中找出所有偶数</p><ul><li>传统方法：命名方法
这是C#1.0的方式，需要定义一个完整的方法，然后将这个方法作为参数传递</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        List&lt;<span style=color:#66d9ef>int</span>&gt; numbers = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt; { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将命名方法 IsEven 作为参数传递给 FindAll 方法</span>
</span></span><span style=display:flex><span>        List&lt;<span style=color:#66d9ef>int</span>&gt; evenNumvers = numbers.FindAll(IsEven);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> num <span style=color:#66d9ef>in</span> evenNumbers)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(num);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 定义一个独立的、命名的方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> IsEven(<span style=color:#66d9ef>int</span> number)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (number %<span style=color:#ae81ff>2</span>) == <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>匿名方法
C#2.0引入了匿名方法，允许内联地定义一个没有名字的代码块</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; numbers = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt; { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用匿名方法，省略了方法名和返回类型声明</span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; evenNumbers = numbers.FindAll(<span style=color:#66d9ef>delegate</span> (<span style=color:#66d9ef>int</span> number)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (number % <span style=color:#ae81ff>2</span>) == <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><ul><li>Lambda表达式
C#3.0引入了Lambda表达式，语法得到了极大的简化</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; numbers = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt; { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用 Lambda 表达式</span>
</span></span><span style=display:flex><span>List&lt;<span style=color:#66d9ef>int</span>&gt; evenNumbers = numbers.FindAll(number =&gt; number % <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><blockquote><p>Lambda表达式的本质是：编译器在语法层面自动生成了一个符合委托签名的方法，然后在运行时通过委托对象引用它</p></blockquote><h2 id=lambda表达式的两种形式>Lambda表达式的两种形式</h2><ul><li>表达式Lambda
当函数体只有一个表达式时，可以省略<code>{ }</code>和<code>return</code>语句。编译器会自动计算这个表达式并返回其结果</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>(input-parameters) =&gt; expression
</span></span></code></pre></div><p>示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 一个参数，可以省略括号</span>
</span></span><span style=display:flex><span>x =&gt; x * x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 两个参数，必须加括号</span>
</span></span><span style=display:flex><span>(x, y) =&gt; x == y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 显式指定参数类型（通常编译器能推断，但有时需要）</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>string</span> s) =&gt; s.Length &gt; x
</span></span></code></pre></div><ul><li>语句 Lambda
当函数体包含多条语句时，需要使用<code>{ }</code>将它们包围起来，并且需要显式地使用<code>return</code>语句（如果有返回值的话）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>(input-parameters) =&gt; { &lt;sequence-of-statements&gt; }
</span></span></code></pre></div><p>示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 多条语句，使用 { }</span>
</span></span><span style=display:flex><span>(name, age) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> greeting = <span style=color:#e6db74>$&#34;Hello, {name}&#34;</span>;
</span></span><span style=display:flex><span>    Console.WriteLine(greeting);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> age &gt;= <span style=color:#ae81ff>18</span>; <span style=color:#75715e>// 显式 return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=lambda底层与性能>Lambda底层与性能</h2><p>Lambda在底层有两种完全不同的实现路径，性能差异巨大</p><h3 id=两种底层实现>两种底层实现</h3><p>C#的Lambda主要分两种语义</p><table><thead><tr><th>类型</th><th>示例</th><th>编译后本质</th><th>性能特点</th></tr></thead><tbody><tr><td>委托 Lambda</td><td><code>x => x * 2</code>（直接赋给<code>Func&lt;int, int></code>）</td><td>编译成<strong>方法 + 委托对象</strong></td><td>快，零表达式树开销</td></tr><tr><td>表达式树 Lambda</td><td><code>x => x * 2</code>（赋给<code>Expression&lt;Func&lt;int, int>></code>）</td><td>编译成 <strong>表达式树对象（AST）</strong></td><td>慢，主要用于动态执行或编译时分析</td></tr></tbody></table><h4 id=委托-lambda最常见>委托 Lambda（最常见）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; f = x =&gt; x * <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>Console.WriteLine(f(<span style=color:#ae81ff>10</span>));
</span></span></code></pre></div><p>编译器行为：会生成一个隐藏的类（closure class）和一个静态或实例方法。例如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DisplayClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Multiply(<span style=color:#66d9ef>int</span> x) =&gt; x * <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f = <span style=color:#66d9ef>new</span> Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt;(<span style=color:#66d9ef>new</span> DisplayClass().Multiply);
</span></span></code></pre></div><p>如果Lambda没有捕获外部变量，那么甚至连类都不需要</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>f = <span style=color:#66d9ef>new</span> Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt;(&lt;PrivateImplementationDetails&gt;.LambdaMethod);
</span></span></code></pre></div><ul><li>如果不捕获外部变量，Lambda编译成普通的静态方法 -> 零额外内存分配</li><li>如果捕获了外部变量，会生成一个闭包类（closure object），捕获的变量变为这个类的字段</li></ul><h4 id=表达式树-lambda>表达式树 Lambda</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Expression&lt;Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt;&gt; expr = x =&gt; x * <span style=color:#ae81ff>2</span>;
</span></span></code></pre></div><p>这不是一个可直接执行的函数，而是生成一个完整的表达式树对象结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>BinaryExpression(
</span></span><span style=display:flex><span>    ParameterExpression(<span style=color:#e6db74>&#34;x&#34;</span>) * ConstantExpression(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>这个结构在运行时可分析、修改、在编译成可执行代码（通过<code>Compile()</code>）<br>这类Lambda常见于 LINQ to SQL / EF / 动态编译场景<br>性能上，它要创建大量对象节点，远慢于普通委托 Lambda</p><h3 id=闭包closure的底层机制>闭包（Closure）的底层机制</h3><p>这是影响性能的关键</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> factor = <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; f= x =&gt; x * factor;
</span></span></code></pre></div><p>编译器生成的底层代码会变成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DisplayClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> factor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Multiply(<span style=color:#66d9ef>int</span> x) =&gt; x * factor;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行时</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> display = <span style=color:#66d9ef>new</span> DisplayClass { factor = <span style=color:#ae81ff>3</span> };
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; f = <span style=color:#66d9ef>new</span> Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt;(display.Multiply);
</span></span></code></pre></div><p>这意味着：</p><ul><li><code>factor</code>不再是栈变量，而是被提升到堆上的对象字段</li><li>Lambda的生命周期和这个closure对象绑定</li><li>只要<code>f</code>存活，<code>factor</code>也不会被回收</li></ul><p>所以闭包在频繁创建时会产生GC压力</p><table><thead><tr><th>场景</th><th>底层实现</th><th>性能影响</th><th>建议</th></tr></thead><tbody><tr><td>不捕获外部变量</td><td>静态方法 + 委托</td><td>最快，等价于普通函数调用</td><td>尽量用这种形式</td></tr><tr><td>捕获外部变量</td><td>生成闭包类 + 对象分配</td><td>会有额外堆分配</td><td>在高频路径中避免</td></tr><tr><td>表达式树 Lambda</td><td>创建表达式节点 + Compile()</td><td>极慢</td><td>只在动态场景使用</td></tr><tr><td>async / await 中的 Lambda</td><td>状态机 + 闭包 + 任务封装</td><td>有编译器生成状态类</td><td>避免频繁创建</td></tr></tbody></table><h3 id=jit优化与调用成本>JIT优化与调用成本</h3><p>Lambda委托最终在JIT阶段优化的非常彻底</p><ul><li>调用开销：几乎等价于调用一个普通方法（<code>callvirt</code>指令调用委托）</li><li>内联：JIT不会自动内联委托调用，但可以通过直接写方法绕过</li><li>分配：捕获变量会产生一次堆分配，但复用时不会反复分配</li></ul><blockquote><p>Lambda只是语法糖，真正的性能瓶颈来自闭包捕获和委托分配，不来自Lambda本身</p></blockquote><h2 id=lambda表达式的核心特性捕获外部变量闭包closure-class>Lambda表达式的核心特性：捕获外部变量（闭包）（closure class）</h2><p>这是Lambda表达式最强大也是最让人困惑的特性之一。Lambda可以访问和修改其定义所在作用域内的变量（局部变量、参数、<code>this</code>等）</p><h3 id=本质>本质</h3><p>当Lambda使用了外部变量时（比如局部变量、参数），编译器必须想办法让这个变量在Lambda执行期间依然存在<br>因为Lambda可能在原函数返回后才执行</p><p>于是，编译器会自动生成一个类（称为closure class或display class），把这些捕获的变量变成它的字段</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> Test()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> counter = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    Action inc = () =&gt; counter++;
</span></span><span style=display:flex><span>    inc();
</span></span><span style=display:flex><span>    Console.WriteLine(counter);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>表面看是一个局部变量被Lambda修改了<br>实际上编译器生成了相当于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DisplayClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> counter;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Inc() =&gt; counter++;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Test()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> display = <span style=color:#66d9ef>new</span> DisplayClass();
</span></span><span style=display:flex><span>    display.counter = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    Action inc = <span style=color:#66d9ef>new</span> Action(display.Inc);
</span></span><span style=display:flex><span>    inc();
</span></span><span style=display:flex><span>    Console.WriteLine(display.counter);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>所以<code>counter</code>不再在栈上，而是在堆上<br>这就是“捕获外部变量”的本质：将局部变量提升到堆上，以延长生命周期</p><h3 id=捕获类型详解>捕获类型详解</h3><p>C#的捕获规则非常精细</p><table><thead><tr><th>捕获形式</th><th>示例</th><th>底层行为</th></tr></thead><tbody><tr><td>捕获值类型局部变量</td><td><code>int a = 1; Func&lt;int> f = () => a;</code></td><td>自动生成类字段，存值的拷贝（值类型）</td></tr><tr><td>捕获引用类型变量</td><td><code>var list = new List&lt;int>(); Func&lt;int> f = () => list.Count;</code></td><td>捕获的是“引用”，即堆地址</td></tr><tr><td>捕获参数</td><td><code>void F(int x) { Func&lt;int> f = () => x; }</code></td><td>参数同样变为闭包字段</td></tr><tr><td>捕获<code>this</code></td><td><code>Action f = () => this.DoSomething()</code></td><td>捕获外部对象引用</td></tr><tr><td>捕获<code>in</code>, <code>ref</code>, <code>out</code>参数</td><td>不允许，编译器禁止，因为生命周期无法保证</td><td></td></tr></tbody></table><h3 id=多个lambda捕获同一变量>多个Lambda捕获同一变量</h3><p>这个情况很关键</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>void</span> Foo()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    Action a1 = () =&gt; n++;
</span></span><span style=display:flex><span>    Action a2 = () =&gt; n--;
</span></span><span style=display:flex><span>    a1();
</span></span><span style=display:flex><span>    a2();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译器只生成一个共享的closure对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DisplayClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> A1() =&gt; n++;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> A2() =&gt; n--;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也就是说，这两个Lambda实际上在操作同一个堆对象的字段<br>任何修改都会互相影响</p><h3 id=生命周期延长与gc问题>生命周期延长与GC问题</h3><p>因为捕获的变量被放进堆上的closure对象中，只要Lambda存活，变量就不会被回收</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>&gt; MakeCounter()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> () =&gt; ++count;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>count</code>在栈上原本会随着函数退出而消失<br>但由于Lambda返回出去了，它被提升到了堆上，直到返回Lambda不再被引用才释放</p><p>这就是闭包的“延长生命周期”特性<br>在异步任务、事件回调中尤其容易导致隐藏的内存泄露（比如UI事件不注销）</p><table><thead><tr><th>情况</th><th>成本</th><th>说明</th></tr></thead><tbody><tr><td>捕获 0 个外部变量</td><td>零分配</td><td>编译器生成静态方法</td></tr><tr><td>捕获 1+ 外部变量</td><td>1 次堆分配</td><td>生成 closure 对象</td></tr><tr><td>多个 Lambda 捕获相同变量</td><td>共享 closure 对象</td><td>不额外分配</td></tr><tr><td>捕获大量值类型</td><td>装箱或堆字段</td><td>可能产生额外复制或装箱</td></tr><tr><td>闭包长期存活</td><td>内存压力</td><td>导致 GC 不回收局部变量</td></tr></tbody></table><h3 id=避免无意的捕获>避免无意的捕获</h3><p>这是写高性能C#的关键</p><ol><li>用<code>static</code>Lambda，见后文</li><li>不要在循环中声明捕获变量</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 每次循环都会创建新的闭包对象</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span> ; i &lt; <span style=color:#ae81ff>10</span>; i++)
</span></span><span style=display:flex><span>    actions.Add(() =&gt; Console.WriteLine(i));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 改写</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>10</span>; i++)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> local = i;
</span></span><span style=display:flex><span>    actions.Add(() =&gt; Console.WriteLine(local));
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><ol start=3><li>短生命周期场景中复用闭包<ul><li>比如事件绑定要即时解绑</li><li>不要在频繁调用路径中反复创建Lambda</li></ul></li><li>注意 async + Lambda<ul><li>async会生成状态机对象</li><li>再加Lambda，会叠加多个堆分配</li></ul></li></ol><blockquote><p>Lambda捕获外部变量，就是编译器自动帮你把这些变量提升到堆上，生成一个闭包对象，让Lambda可以在原作用域消失后仍能访问这些变量。性能问题的根源在于：堆分配 + 生命周期延长，不是Lambda语法本身</p></blockquote><h2 id=使用场景>使用场景</h2><h3 id=linq查询>LINQ查询</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> names = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>string</span>&gt; { <span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#e6db74>&#34;Bob&#34;</span>, <span style=color:#e6db74>&#34;Charlie&#34;</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Where：过滤</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> shortNames = names.Where(name =&gt; name.Length &lt; <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Select：投影/转换</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> nameLengths = names.Select(name =&gt; name.Length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// OrderBy：排序</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> sortedNames = names.OrderBy(name =&gt; name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Any/All：判断存在性</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> hasA = names.Any(name =&gt; name.StartsWith(<span style=color:#e6db74>&#34;A&#34;</span>));
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> allLone = names.All(name =&gt; name.Length &gt; <span style=color:#ae81ff>3</span>);
</span></span></code></pre></div><h3 id=事件处理>事件处理</h3><p>让事件处理代码更紧凑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 传统方式</span>
</span></span><span style=display:flex><span>button.Click += <span style=color:#66d9ef>new</span> EventHandler(Button_Click);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Button_Click(<span style=color:#66d9ef>object</span> sender, EventArgs e) { ... }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Lambda 方式</span>
</span></span><span style=display:flex><span>button.Click += (sender, e) =&gt; MessageBox.Show(<span style=color:#e6db74>&#34;Button clicked!&#34;</span>);
</span></span></code></pre></div><h3 id=创建委托实例>创建委托实例</h3><p>快速创建<code>Func</code>（有返回值的委托）或<code>Action</code>（无返回值的委托）的实例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; <span style=color:#66d9ef>add</span> = (a, b) =&gt; a + b;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> result = <span style=color:#66d9ef>add</span>(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Action&lt;<span style=color:#66d9ef>string</span>&gt; logger = message =&gt; Console.WriteLine(<span style=color:#e6db74>$&#34;[LOG] {message}&#34;</span>);
</span></span><span style=display:flex><span>logger(<span style=color:#e6db74>&#34;This is a log&#34;</span>);
</span></span></code></pre></div><h3 id=用于task和异步编程>用于<code>Task</code>和异步编程</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 启动一个后台任务</span>
</span></span><span style=display:flex><span>Task.Run(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 执行一些耗时操作</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>10</span>; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;Working... {i}&#34;</span>);
</span></span><span style=display:flex><span>        Thread.Sleep(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=lambda生命周期>Lambda生命周期</h2><p>Lambda表达式在C#中看起来只是“匿名函数语法糖”，但它的生命周期其实和闭包捕获、委托实例化以及垃圾回收机制紧密相关</p><p>在C#编译阶段，Lambda会被“脱糖”成一个方法（或一个隐藏类中的方法）<br>有两种情况</p><ol><li>不捕获外部变量的Lambda
编译器会直接生成一个静态方法<br>生命周期和普通静态方法一样：</li></ol><ul><li>它的代码在程序集加载后常驻</li><li>它不会引用任何外部对象</li><li>不会延长外部变量或对象的寿命</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; f = x =&gt; x * <span style=color:#ae81ff>2</span>;
</span></span></code></pre></div><p>编译器生成相当于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> &lt;lambda&gt;(<span style=color:#66d9ef>int</span> x) =&gt; x * <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; f = <span style=color:#66d9ef>new</span> Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt;(&lt;lambda&gt;);
</span></span></code></pre></div><p>生命周期：常驻，只有委托对象<code>f</code>被GC掉之后，这个引用关系结束</p><ol start=2><li>捕获外部变量的Lambda（闭包）
编译器会为Lambda生成一个隐藏类（closure class），把被捕获的变量转化为这个类的字段</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>int</span> counter = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>&gt; next = () =&gt; ++counter;
</span></span></code></pre></div><p>编译器生成的伪代码大致是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DisplayClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> counter;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> &lt;lambda&gt;() =&gt; ++counter;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> obj = <span style=color:#66d9ef>new</span> DisplayClass();
</span></span><span style=display:flex><span>obj.counter = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>&gt; next = <span style=color:#66d9ef>new</span> Func&lt;<span style=color:#66d9ef>int</span>&gt;(obj.&lt;lambda&gt;);
</span></span></code></pre></div><p>此时，<code>counter</code>已经不在栈上，而是提升到堆上，由这个<code>DisplayClass</code>实例持有<br>只要<code>next</code>委托还存在，对象<code>obj</code>就不会被GC回收</p><h3 id=总结>总结</h3><ul><li>Lambda的生命周期由它所捕获的上下文对象决定</li><li>这个上下文对象的生命周期会被委托延长</li><li>当没有任何地方再引用这个委托时，Lambda与其闭包对象才能一起被回收</li></ul><h2 id=lambda与委托类型表达式树>Lambda与委托类型、表达式树</h2><h3 id=委托类型>委托类型</h3><p>Lambda表达式可以隐式转换为兼容的委托类型。编译器会根据使用Lambda的上下文来推断其类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 编译器推断 number =&gt; number &gt; 0 是一个 Func&lt;int, bool&gt;</span>
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>&gt; isPositive = number =&gt; number &gt; <span style=color:#ae81ff>0</span>;
</span></span></code></pre></div><h3 id=表达式树>表达式树</h3><p>表达式树（Expression Tree）是C#语言中非常强大的一个特性，它不是“Lambda的另一种写法”，而是把代码本身结构化成数据的机制<br>它是LINQ、ORM、动态编译、规则引擎、AI模型DSL等领域的核心基础之一</p><h4 id=表达式树是什么>表达式树是什么</h4><p>表达式树是把Lambda表达式的语法结构保存为对象树，而不是编译成可执行的IL代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Expression&lt;Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt;&gt; expr = x =&gt; x * <span style=color:#ae81ff>2</span>;
</span></span></code></pre></div><p>这里的<code>expr</code>不是一个可直接执行的委托，而是一个对象结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>LambdaExpression
</span></span><span style=display:flex><span> └── BinaryExpression (*)
</span></span><span style=display:flex><span>     ├── ParameterExpression (x)
</span></span><span style=display:flex><span>     └── ConstantExpression (2)
</span></span></code></pre></div><p>可以像访问AST一样去遍历和修改它</p><h4 id=存在意义>存在意义</h4><p>普通Lambda是执行逻辑的工具<br>表达式树是分析逻辑的工具</p><ul><li>普通Lambda：执行一段逻辑（<code>Func&lt;int, int></code>）</li><li>表达式树Lambda：描述一段逻辑（<code>Expression&lt;Func&lt;int, int>></code>）</li></ul><p>简单来说，表达式树的核心意义在于：它将代码（逻辑）从“执行指令”变成了“可遍历的数据结构”。这个根本性的转变，带来了巨大的灵活性和可能性</p><h5 id=核心意义>核心意义</h5><p>在传统编程中，一个表达式<code>x + y</code>在编译后就会变成一系列的CPU指令，它的唯一目的就是立即计算出一个结果</p><p>而表达式树则不同，它把这个表达式本身的结构（操作数是<code>x</code>和<code>y</code>，操作符是<code>+</code>）存储为一个树形结构的数据。这样，就可以在运行时分析、修改、解释这个表达式，而不是仅仅执行它</p><ul><li>传统方式（立即执行）：<code>var result = x + y</code> -> 直接得到结果</li><li>表达式树方式（延迟或转换执行）：<code>Expression&lt;Func&lt;int, int>> expr = () => x + y;</code> -> 得到一个表达式<code>x + y</code> 这个逻辑的数据结构</li></ul><h5 id=主要应用和优势>主要应用和优势</h5><h6 id=应用一linq-to-sql--entity-framework将c代码转换为sql>应用一：LINQ to SQL / Entity Framework（将C#代码转换为SQL）</h6><p>这是表达式树最经典、最成功的应用场景</p><ul><li>问题：当我们写<code>db.User.Where(u => u.Age > 18)</code>时，C#的<code>u.Age > 18</code>时也给委托（lambda表达式）。如果直接执行，他需要在客户端过滤所有数据，效率极低</li><li>解决方案：这里的<code>u => u.Age > 18</code>被编译器转换为一个表达式树，而不是一个编译后的委托</li><li>过程：<ol><li>EF Core 或 Dapper 等库接收到这个表达式树</li><li>它像一个“编译器”，遍历这棵树的节点（这是一个参数<code>u</code>，这是一个成员访问<code>u.Age</code>，这是一个常量<code>18</code>，这是一个“大于”操作）</li><li>根据遍历的结果，它动态地生成对应的SQL语句：<code>SELECT * FROM Users WHERE Age > 18</code></li><li>这个SQL语句被发送到数据库服务器执行，实现了高效的服务端查询</li></ol></li></ul><p>意义：它架起了一座桥梁，让.NET世界中的C#代码能够无缝地映射到外部数据源（如数据库、Web服务）在查询语言上</p><h6 id=应用二动态生成代码>应用二：动态生成代码</h6><p>可以在运行时动态地构建一个表达式树，然后将其编译成可执行的委托。这比使用<code>Emit</code>或<code>CodeDom</code>要简单和安全的多</p><ul><li>示例：创建一个属性设置器的委托</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> param = Expression.Parameter(<span style=color:#66d9ef>typeof</span>(<span style=color:#66d9ef>string</span>), <span style=color:#e6db74>&#34;x&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> property = Expression.Property(Expression.Constant(myObject), <span style=color:#e6db74>&#34;Name&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> assignment = Expression.Assign(property, param);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> lambda = Expression.Lambda&lt;Action&lt;<span style=color:#66d9ef>string</span>&gt;&gt;(assignment, param).Compile();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>lambda(<span style=color:#e6db74>&#34;New Name&#34;</span>); <span style=color:#75715e>// 这行代码等价于 myObject.Name = &#34;New Name&#34;;</span>
</span></span></code></pre></div><ul><li>意义：极大地简化了运行时代码生成，常用于实现ORM、序列化库、依赖注入容器、Mock框架等需要高性能反射替代方案的场景</li></ul><h6 id=应用三构建动态查询>应用三：构建动态查询</h6><p>在UI中，用户可能通过下拉菜单、输入框等组合复杂的查询操作。使用表达式树可以轻松地动态拼接<code>Where</code>、<code>OrderBy</code>等子句</p><ul><li>示例：根据用户输入，动态构建<code>Where(u => u.Age > 18 && u.Name.Contains("A"))</code>这样的查询</li><li>意义：提供了极大的灵活性，能够应对复杂多变的业务查询需求</li></ul><h6 id=应用四规则引擎和dsl领域特定语言>应用四：规则引擎和DSL（领域特定语言）</h6><p>可以用表达式树来构建一个简单的规则引擎。规则可以被定义数据（例如存储在JSON或XML中）<br>然后在运行时被解析并构建成表达式树来执行</p><ul><li>意义：使业务规则可配置、可扩展，而无需修改和重新编译代码</li></ul><table><thead><tr><th>特性</th><th>传统委托（立即执行）</th><th>表达式树（作为数据结构）</th></tr></thead><tbody><tr><td>核心</td><td>做什么（What to do）</td><td>如何做（How to do）的描述</td></tr><tr><td>执行时机</td><td>立即在本地执行</td><td>可以延迟执行，或转换为其他形式（如SQL）</td></tr><tr><td>可读性</td><td>编译后时机器码，不可读</td><td>是结构化数据，可在运行时被分析和理解</td></tr><tr><td>主要用途</td><td>通用编程逻辑</td><td>数据转换（如LINQ to SQL）、动态代码生成、元编程</td></tr></tbody></table><blockquote><p>总而言之，表达式树存在的根本意义在于它实现了“元编程”的一个关键环节：让程序能够像处理数据一样处理自身的逻辑。它将代码从“静态的、编译时的”领域解放出来，使其成为“动态的、运行时的”实体，从而为解决像ORM、动态查询、代码生成等复杂问题提供了优雅而强大的工具</p></blockquote><h4 id=内部结构systemlinqexpressions-命名空间>内部结构（System.Linq.Expressions 命名空间）</h4><p>表达式树的核心类型是<code>Expression</code>抽象类<br>它有几十个派生类型，常见的几类：</p><table><thead><tr><th>类型</th><th>代表语法</th><th>示例</th></tr></thead><tbody><tr><td><code>ConstantExpression</code></td><td>常量</td><td><code>2</code>, <code>"hello"</code></td></tr><tr><td><code>ParameterExpression</code></td><td>参数</td><td><code>x</code></td></tr><tr><td><code>BinaryExpression</code></td><td>二元运算</td><td><code>x * 2</code>, <code>x + y</code></td></tr><tr><td><code>UnaryExpression</code></td><td>一元运算</td><td><code>-x</code>, <code>!flag</code></td></tr><tr><td><code>MemberExpression</code></td><td>成员访问</td><td><code>x.Age</code></td></tr><tr><td><code>MethodCallExpression</code></td><td>方法调用</td><td><code>x.ToString()</code></td></tr><tr><td><code>LambdaExpression</code></td><td>Lambda定义</td><td><code>x => x + 1</code></td></tr></tbody></table><p>这些类组合起来，就能完整描述一段计算逻辑</p><h4 id=编译器行为>编译器行为</h4><p>当你写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Expression&lt;Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt;&gt; expr = x =&gt; x * <span style=color:#ae81ff>2</span>;
</span></span></code></pre></div><p>编译器做了两件事</p><ol><li>分析Lambda表达式语法</li><li>构造表达式树对象（而非IL代码）</li></ol><p>实际上，它等价于手动构造</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>ParameterExpression p = Expression.Parameter(<span style=color:#66d9ef>typeof</span>(<span style=color:#66d9ef>int</span>), <span style=color:#e6db74>&#34;x&#34;</span>);
</span></span><span style=display:flex><span>ConstantExpression c = Experssion.Constant(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>BinaryExpression body = Expression.Multiply(p, c);
</span></span><span style=display:flex><span>Expression&lt;Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt;&gt; expr = Expression.Lambda&lt;Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt;&gt;(body, p)
</span></span></code></pre></div><p>表达式树本身只是数据结构，不可直接执行<br>要执行它，必须先编译成委托</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> func = expr.Compile(); <span style=color:#75715e>// 生成 Func&lt;int, int&gt;</span>
</span></span><span style=display:flex><span>Console.WriteLine(func(<span style=color:#ae81ff>5</span>)); <span style=color:#75715e>// 输出 10</span>
</span></span></code></pre></div><p><code>Compile()</code>会动态生成IL（使用 Reflection.Emit），开销很大<br>频繁调用Compile()是性能杀手，通常应该缓存结果</p><h4 id=用法>用法</h4><ol><li>LINQ to SQL / Entity Framework</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> q = <span style=color:#66d9ef>from</span> u <span style=color:#66d9ef>in</span> db.Users
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>where</span> u.Age &gt; <span style=color:#ae81ff>18</span> &amp;&amp; u.Name.StartsWith(<span style=color:#e6db74>&#34;A&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>select</span> u;
</span></span></code></pre></div><p>这个<code>where</code>子句编译成表达式树</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>x =&gt; (x.Age &gt; <span style=color:#ae81ff>18</span>) &amp;&amp; x.Name.StartsWith(<span style=color:#e6db74>&#34;A&#34;</span>);
</span></span></code></pre></div><p>EF不执行它，而是解析表达式树结构，翻译成SQL</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> Users <span style=color:#66d9ef>WHERE</span> Age <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>18</span> <span style=color:#66d9ef>AND</span> Name <span style=color:#66d9ef>LIKE</span> <span style=color:#e6db74>&#39;A%&#39;</span>
</span></span></code></pre></div><p>所以LINQ to SQL 能把 C#代码“转译”为SQL，就是靠表达式树解析</p><ol start=2><li>动态编译和规则引擎
例如想在运行时根据配置拼出一段逻辑</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Expression&lt;Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>&gt;&gt; expr = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (rule == <span style=color:#e6db74>&#34;greaterThan10&#34;</span>)
</span></span><span style=display:flex><span>    expr = x =&gt; x &gt; <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    expr = x =&gt; x &lt; <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> compiled = expr.Compile();
</span></span><span style=display:flex><span>Console.WriteLine(compiled(<span style=color:#ae81ff>8</span>));
</span></span></code></pre></div><p>这里Lambda的逻辑是动态的，不需要写死<br>还能再运行时拼接表达式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Expression&lt;Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>&gt;&gt; e1 = x =&gt; x &gt; <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>Expression&lt;Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>&gt;&gt; e2 = x =&gt; x &lt; <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> body = Expression.OrElse(e1.Body, e2.Body);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> param = e1.Parameters[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> combined = Expression.Lambda&lt;Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>&gt;&gt;(body, param);
</span></span></code></pre></div><p>实现动态规则系统的关键原理就在这</p><ol start=3><li>代码分析与重写
可以用<code>ExpressionVisitor</code>遍历并修改表达式树</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyVisitor</span> : ExpressionVisitor
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> Expression VisitConstant(ConstantExpression node)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (node.Type == <span style=color:#66d9ef>typeof</span>(<span style=color:#66d9ef>int</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Expression.Constant((<span style=color:#66d9ef>int</span>)node.Value * <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> modified = <span style=color:#66d9ef>new</span> MyVisitor().Visit(expr);
</span></span><span style=display:flex><span>Console.WriteLine(modified);
</span></span></code></pre></div><p>这可以用来做</p><ul><li>自动代码重写</li><li>日志插桩</li><li>调试器表达式分析</li><li>自定义DSL解释器</li></ul><table><thead><tr><th>操作</th><th>开销</th><th>原因</th></tr></thead><tbody><tr><td>构造表达式树</td><td>高</td><td>多对象创建</td></tr><tr><td>遍历表达式树</td><td>中</td><td>反射式访问</td></tr><tr><td>Compile()</td><td>很高</td><td>动态生成 IL</td></tr><tr><td>调用编译后委托</td><td>快</td><td>等价于普通函数调用</td></tr></tbody></table><blockquote><p>表达式树用于“构建逻辑”，而非“高频执行逻辑”；一旦编译完成并缓存，性能就接近普通委托</p></blockquote><table><thead><tr><th>版本</th><th>新特性</th></tr></thead><tbody><tr><td>.NET 3.5</td><td>引入表达式树，支持 Lambda 表达式（LINQ）</td></tr><tr><td>.NET 4.0</td><td>Expression 可表示更多语法（如循环、条件）</td></tr><tr><td>.NET 4.6+</td><td>Compile() 性能提升显著</td></tr><tr><td>C# 10</td><td>支持更复杂的表达式模式</td></tr></tbody></table><p>C#的表达式树本质上是一个受限的AST，目标是安全 + 可分析，而不是编译器级别的AST</p><h4 id=类比语法树>类比语法树</h4><h5 id=编译时的语法树syntax-tree>编译时的语法树（Syntax Tree）</h5><ol><li>阶段：编译时（Compile-time）</li><li>目的：帮助编译器理解代码结构，进行语法检查、类型推断、优化，并最终生成IL代码或本地机器码</li><li>生命周期：一旦编译完成，这个语法树通常就被丢弃了。它存在于编译过程中，不会出现在最终的程序集里</li><li>内容：包含所有的语言结构，如<code>if</code>语句、<code>for</code>循环、方法定义、类定义等。它是一个完整的程序结构表示</li></ol><p>它的使命是翻译：将C#源代码翻译成可执行的指令</p><h5 id=运行时的表达式树expression-tree>运行时的表达式树（Expression Tree）</h5><ol><li>阶段：运行时（Runtime）</li><li>目的：将代码逻辑（特别是单行的表达式逻辑）表示为一种可遍历、可检查、可动态构建的数据结构。它本身不是用来直接执行的，而是作为数据供其他组件分析</li><li>生命周期：作为数据存在于运行时的内存中，可以被程序动态创建、修改、传递</li><li>内容：主要表示一个单一的表达式，例如<code>x + y</code>、<code>user.Age > 18</code>、<code>obj.Method()</code>。它不包含复杂的语句（在早期版本中，后来也支持了块等更复杂的结构，但核心用途仍是表达式）</li></ol><p>它的使命是代表：在运行时充当代码逻辑的蓝图</p><p>编译器的工作在程序运行前就结束了。它生成的语法树包含了编译所需的全部信息，但运行时的环境（比如数据库连接、动态条件）是编译时无法预知的</p><p>表达式树是.NET框架特意暴露给运行时的一个API，它只选取了语法树中关于“表达式”的那一小部分，将其物化为<code>System.Linq.Expressions.Expression</code>类的实例，使得开发者可以在运行时像操作普通对象一样操作代码逻辑</p><blockquote><p>.NET将AST这个概念的一部分“下游化”，使其从编译器的内部工具，变成了开发者可以在运行时使用的强大武器</p></blockquote><h2 id=异步lambda>异步Lambda</h2><p>简单来说，异步Lambda就是使用<code>async</code>和<code>await</code>关键字来编写能够执行异步操作的Lambda表达式。它允许在Lambda中方便地调用诸如HTTP请求、文件I/O、数据库查询等异步方法，而不会阻塞调用线程</p><h3 id=从同步到异步>从同步到异步</h3><p>同步Lambda</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 一个接受字符串并返回整数的同步Lambda</span>
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>int</span>&gt; parse = (<span style=color:#66d9ef>string</span> s) =&gt; <span style=color:#66d9ef>int</span>.Parse(s);
</span></span><span style=display:flex><span>Console.WriteLine(parse(<span style=color:#e6db74>&#34;123&#34;</span>)); <span style=color:#75715e>// 输出：123</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 一个无返回值的同步Lambda</span>
</span></span><span style=display:flex><span>button.Click += (sender, e) =&gt; MessageBox.Show(<span style=color:#e6db74>&#34;Clicked!&#34;</span>);
</span></span></code></pre></div><p>假设想在Lambda内部调用一个异步方法（例如<code>HttpClient.GetStringAsync</code>）。如果直接用同步Lambda，会导致编译错误或阻塞线程</p><p><strong>错误示例</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Error this</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 无法在同步Lambda中等待异步方法</span>
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>string</span>&gt; getWebpage = (<span style=color:#66d9ef>string</span> url) =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// HttpClient.GetStringAsync 返回 Task&lt;string&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 无法直接“等待”这个Task</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> task = httpClient.GetStringAsync(url);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> task.Result; <span style=color:#75715e>// 会阻塞线程</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>为了解决这个问题，需要异步Lambda</p><h3 id=异步lambda是什么>异步Lambda是什么</h3><p>异步Lambda(asynchronous lambda)是带有<code>async</code>修饰符的Lambda表达式，本质上就是返回一个<code>Task</code>或<code>Task&lt;T></code>的匿名函数<br>最常见的场景是使用<code>Func&lt;Task></code>或<code>Func&lt;T, Task></code>等委托类型</p><ol><li>无返回值的异步Lambda（<code>Func&lt;Task></code>）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 这是一个异步Lambda，它不接收参数，返回一个Task</span>
</span></span><span style=display:flex><span>Func&lt;Task&gt; doSomethingAsync = <span style=color:#66d9ef>async</span> () =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>&#34;开始异步操作...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> Task.Delay(<span style=color:#ae81ff>1000</span>); <span style=color:#75715e>// 模拟一个异步操作（如网络请求）</span>
</span></span><span style=display:flex><span>    Consolw.WriteLine(<span style=color:#e6db74>&#34;异步操作完成！&#34;</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 调用时，需要等待它返回的Task</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> doSomethingAsync();
</span></span></code></pre></div><ol start=2><li>有返回值的异步Lambda（<code>Func&lt;T, Task&lt;TResult>></code>）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 这是一个异步Lambda，它接收一个string 参数，返回一个 Task&lt;string&gt;</span>
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>string</span>, Task&lt;<span style=color:#66d9ef>string</span>&gt;&gt; getWebpage = <span style=color:#66d9ef>async</span> (<span style=color:#66d9ef>string</span> url) =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> httpClient = <span style=color:#66d9ef>new</span> HttpClient())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 等待异步HTTP请求</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> content = <span style=color:#66d9ef>await</span> httpClient.GetStringAsync(url);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> content; <span style=color:#75715e>// 注意：这里返回的是 string，但整个Lambda的返回值是 Task&lt;string&gt;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 调用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> html = <span style=color:#66d9ef>await</span> getWebpage(<span style=color:#e6db74>&#34;https://api.example.com/data&#34;</span>);
</span></span><span style=display:flex><span>Console.WriteLine(html);
</span></span></code></pre></div><ol start=3><li>用于事件处理程序的异步Lambda
这是一个非常常见的用法，但需要小心</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 例如，一个按钮点击事件</span>
</span></span><span style=display:flex><span>button.Click += <span style=color:#66d9ef>async</span> (sender, e) =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 禁用按钮防止重复点击</span>
</span></span><span style=display:flex><span>    button.Enabled = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行一些异步工作</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> SomeAsyncOperation();
</span></span><span style=display:flex><span>        MessageBox.Show(<span style=color:#e6db74>&#34;操作成功！&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        button.Enable = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=要点与注意事项>要点与注意事项</h3><ol><li><code>async void</code> Lambda应尽量避免
与<code>async void</code>方法一样，<code>async void</code>Lambda通常只用于事件处理程序。因为无法等待<code>async void</code>方法，其中的异常会直接在上下文中抛出，可能导致应用程序崩溃</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 尽量避免这样写，除非是顶级事件处理器</span>
</span></span><span style=display:flex><span>button.Click += <span style=color:#66d9ef>async</span> (sender, e) =&gt; { ... }; <span style=color:#75715e>// 这是 async void</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 如果可以，使用返回Task的Lambda，并等待它</span>
</span></span></code></pre></div><ol start=2><li>返回值类型
在异步Lambda中，<code>return</code>语句返回的是<code>T</code>，但整个Lambda表达式返回的是<code>Task&lt;T></code>。编译器会自动进行包装</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;Task&lt;<span style=color:#66d9ef>int</span>&gt;&gt; getNumberAsync = <span style=color:#66d9ef>async</span> () =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> Task.Delay(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>42</span>; <span style=color:#75715e>// 这里返回int， 但 getNumberAsync的返回值是Task&lt;int&gt;</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ol start=3><li>异常处理
异步Lambda中的异常会被捕获并放置在返回的<code>Task</code>对象中；当<code>await</code>这个Task时，异常会被重新抛出</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>Func&lt;Task&gt; throwAsync = <span style=color:#66d9ef>async</span> () =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> Task.Delay(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InvalidOperationException(<span style=color:#e6db74>&#34;异步Lambda中的错误！&#34;</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> throwAsync();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> (InvalidOperationException ex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>$&#34;捕获到异常：{ex.Message}&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>与LINQ一起使用
在LINQ方法（如<code>Where</code>, <code>Select</code>）中，如果谓词或选择器需要调用异步方法，情况会变得复杂。因为标准的LINQ操作不接受返回<code>Task&lt;bool></code>的谓词<br><strong>错误示例</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 无法编译 Where期望一个返回bool的委托，而不是 Task&lt;bool&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> results = data.Where(<span style=color:#66d9ef>async</span> x =&gt; <span style=color:#66d9ef>await</span> SomeAsyncCheck(x));
</span></span></code></pre></div><p>解决方案是使用异步流(<code>IAsyncEnumerable&lt;T></code>)和相应的异步LINQ库（例如<code>System.Linq.Async</code>）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 使用 System.Linq.Async包</span>
</span></span><span style=display:flex><span>IAsyncEnumerable&lt;Data&gt; filteredData = data
</span></span><span style=display:flex><span>    .ToAsyncEnumerable()
</span></span><span style=display:flex><span>    .WhereAwait(<span style=color:#66d9ef>async</span> x =&gt; <span style=color:#66d9ef>await</span> SomeAsyncCheck(x));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> item <span style=color:#66d9ef>in</span> filteredData)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(item);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=5><li><p>不能用在<code>Expression&lt;Func&lt;>></code>中
因为异步Lambda不是可表达的表达式树，只能存在于委托中</p></li><li><p>不要忘记<code>await</code>
会丢失异常、逻辑提前执行完</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> task = asyncLambda(); <span style=color:#75715e>// 忘记 await</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// task 在后台跑，异常不会在这里抛出</span>
</span></span></code></pre></div><ol start=7><li>同步方法内不能直接调用异步Lambda</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 错误，不能await</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> result = f2(<span style=color:#ae81ff>5</span>); <span style=color:#75715e>// 返回的是 Task&lt;int&gt;</span>
</span></span></code></pre></div><ol start=8><li>异步Lambda不支持<code>ref</code>/<code>out</code>参数</li></ol><h3 id=底层>底层</h3><p>编译器会把</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>async</span> (x) =&gt; { <span style=color:#66d9ef>await</span> Task.Delay(<span style=color:#ae81ff>1000</span>); <span style=color:#66d9ef>return</span> x * <span style=color:#ae81ff>2</span>; }
</span></span></code></pre></div><p>编译成一个生成状态机的匿名类，类似</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>(x) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> stateMachine = <span style=color:#66d9ef>new</span> &lt;Anonymous&gt;d__Something();
</span></span><span style=display:flex><span>    stateMachine.x = x;
</span></span><span style=display:flex><span>    stateMachine.builder = AsyncTaskMethodBuilder&lt;<span style=color:#66d9ef>int</span>&gt;.Create();
</span></span><span style=display:flex><span>    stateMachine.Start(<span style=color:#66d9ef>ref</span> stateMachine);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> stateMachinebuilder.Task;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也就是说，每个异步Lambda实际是一个自动生成状态机的匿名函数，它的执行结果就是一个<code>Task</code></p><h2 id=静态lambda>静态Lambda</h2><p>这是C# 9.0引入的一个重要特性<br>静态Lambda是通过在Lambda表达式前添加<code>static</code>修饰符来声明Lambda。它强制Lambda不捕获（即不访问）任何来自外部作用域的变量或实例成员，只能使用其参数和静态成员<br>这是一种编译层面的限制，也就是说，它根本不会被编译，更不会等到运行时去“报错”</p><h3 id=语法>语法</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// 静态 Lambda 语法</span>
</span></span><span style=display:flex><span>Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; staticAdder = <span style=color:#66d9ef>static</span> (a, b) =&gt; a + b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 等同于这个静态方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> StaticAdd(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) =&gt; a + b;
</span></span></code></pre></div><h3 id=特性>特性</h3><p>禁止捕获外部变量<br>静态Lambda不能访问来自外部作用域的实例变量、局部变量或<code>this</code>引用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Calculator</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _instanceValue = <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> _staticValue = <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Test()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> localValue = <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ✔，只使用参数</span>
</span></span><span style=display:flex><span>        Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; adder = <span style=color:#66d9ef>static</span> (a, b) =&gt; a + b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ✔，使用静态成员</span>
</span></span><span style=display:flex><span>        Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; staticMultiplier = <span style=color:#66d9ef>static</span> (x) =&gt; x * _staticValue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 编译错误，不能捕获实例成员</span>
</span></span><span style=display:flex><span>        Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; instanceMultiplier = <span style=color:#66d9ef>static</span> (x) =&gt; x * _instanceValue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 编译错误，不能捕获局部变量</span>
</span></span><span style=display:flex><span>        Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; localMultiplier = <span style=color:#66d9ef>static</span> (x) =&gt; x * localValue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 编译错误，不能使用this</span>
</span></span><span style=display:flex><span>        Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; thisMultiplier = <span style=color:#66d9ef>static</span> (x) =&gt; x * <span style=color:#66d9ef>this</span>._instanceValue;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>性能优势<br>静态Lambda的主要优势在于性能</p><ol><li>减少分配：普通Lambda需要分配一个闭包对象来存储捕获的变量，而静态Lambda不需要</li><li>减少GC压力：避免了不必要的内存分配</li><li>更好的内联机会：编译器可以更积极地进行优化</li></ol><h3 id=使用场景-1>使用场景</h3><ol><li>高性能LINQ查询</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> numbers = Enumeralbe.Range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 普通Lambda，可能分配闭包</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> evenNumbers = numbers.Where(x =&gt; x &amp; <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>0</span>).ToList();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 静态Lambda，无闭包分配，性能更好</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> evenNumbersStatic = numbers.Where(<span style=color:#66d9ef>static</span> x =&gt; x % <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>0</span>).ToList();
</span></span></code></pre></div><ol start=2><li>避免意外捕获</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EventProcessor</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> _processorName = <span style=color:#e6db74>&#34;Processor1&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> SetupEventHandlers()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 危险，可能意外捕获 this，导致内存泄露</span>
</span></span><span style=display:flex><span>        SomeEvent += (sender, args) =&gt; Process(args, _processorName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 安全，静态Lambda防止意外捕获</span>
</span></span><span style=display:flex><span>        SomeEvent += <span style=color:#66d9ef>static</span> (sender, args) =&gt; ProcessStatic(args);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ProcessStatic必须是静态方法</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Process(EventArgs args, <span style=color:#66d9ef>string</span> name) { }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> ProcessStatic(EventArgs args) { }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>与本地函数结合</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ProcessData(List&lt;<span style=color:#66d9ef>int</span>&gt; data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 静态本地函数 + 静态 Lambda</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> IsPrime(<span style=color:#66d9ef>int</span> number)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用静态Lambda进行数学计算</span>
</span></span><span style=display:flex><span>        Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>&gt; hasDivisor = <span style=color:#66d9ef>static</span> (n, divisor) =&gt; n % divisor == <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (number &lt; <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>2</span>; i * i &lt;= number; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (hasDivisor(number, i)) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> primes = data.Where(IsPrime).ToList();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>事件处理器（不依赖外部的前提下）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span>button.Click += <span style=color:#66d9ef>static</span> (sender, args) =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Clicked!&#34;</span>);
</span></span></code></pre></div><ol start=5><li>委托缓存（避免重复创建闭包）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> Func&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>&gt; MultiplyBy2 = <span style=color:#66d9ef>static</span> x =&gt; x * <span style=color:#ae81ff>2</span>;
</span></span></code></pre></div><h3 id=总结-1>总结</h3><table><thead><tr><th>特性</th><th>普通Lambda</th><th>静态Lambda</th></tr></thead><tbody><tr><td>捕获能力</td><td>可以捕获外部变量、实例成员</td><td>只能使用参数和静态成员</td></tr><tr><td>内存分配</td><td>可能分配闭包对象</td><td>通常无额外分配</td></tr><tr><td>性能</td><td>可能稍慢</td><td>通常更快</td></tr><tr><td>使用场景</td><td>需要访问外部状态时</td><td>纯函数、性能敏感代码</td></tr><tr><td>安全性</td><td>可能意外捕获导致内存泄露</td><td>更安全、避免意外捕获</td></tr></tbody></table><h2 id=最佳实践与注意事项>最佳实践与注意事项</h2><ol><li>保持简洁：Lambda的优势在于简洁。如果逻辑非常复杂，超过3-4行，考虑重构为命名方法，以提高可读性</li><li>避免副作用：尽量编写纯函数式的Lambda（输出完全由输入决定，不修改外部状态），避免因捕获外部变量导致难以调试的问题</li><li>注意变量的捕获：在循环或异步上下文中使用Lambda时，要特别注意捕获的变量是否是期望的值</li><li>合理命名参数：即使参数类型很明显，给参数一个有意义的名字（如<code>student => student.Age</code>而不是<code>x => x.Age</code>）也能大大提高代码的可读性</li></ol></div><nav class=post-nav><a href=/dotnetandwindows/lib/iterator/ class=hover:underline>pre: Iterator</a>
<a href=/dotnetandwindows/lib/linq/ class=hover:underline>next: LINQ</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><a href=#lambda表达式的语法演变>Lambda表达式的语法演变</a></li><li><a href=#lambda表达式的两种形式>Lambda表达式的两种形式</a></li><li><a href=#lambda底层与性能>Lambda底层与性能</a><ul><li><a href=#两种底层实现>两种底层实现</a><ul><li><a href=#委托-lambda最常见>委托 Lambda（最常见）</a></li><li><a href=#表达式树-lambda>表达式树 Lambda</a></li></ul></li><li><a href=#闭包closure的底层机制>闭包（Closure）的底层机制</a></li><li><a href=#jit优化与调用成本>JIT优化与调用成本</a></li></ul></li><li><a href=#lambda表达式的核心特性捕获外部变量闭包closure-class>Lambda表达式的核心特性：捕获外部变量（闭包）（closure class）</a><ul><li><a href=#本质>本质</a></li><li><a href=#捕获类型详解>捕获类型详解</a></li><li><a href=#多个lambda捕获同一变量>多个Lambda捕获同一变量</a></li><li><a href=#生命周期延长与gc问题>生命周期延长与GC问题</a></li><li><a href=#避免无意的捕获>避免无意的捕获</a></li></ul></li><li><a href=#使用场景>使用场景</a><ul><li><a href=#linq查询>LINQ查询</a></li><li><a href=#事件处理>事件处理</a></li><li><a href=#创建委托实例>创建委托实例</a></li><li><a href=#用于task和异步编程>用于<code>Task</code>和异步编程</a></li></ul></li><li><a href=#lambda生命周期>Lambda生命周期</a><ul><li><a href=#总结>总结</a></li></ul></li><li><a href=#lambda与委托类型表达式树>Lambda与委托类型、表达式树</a><ul><li><a href=#委托类型>委托类型</a></li><li><a href=#表达式树>表达式树</a><ul><li><a href=#表达式树是什么>表达式树是什么</a></li><li><a href=#存在意义>存在意义</a><ul><li><a href=#核心意义>核心意义</a></li><li><a href=#主要应用和优势>主要应用和优势</a><ul><li><a href=#应用一linq-to-sql--entity-framework将c代码转换为sql>应用一：LINQ to SQL / Entity Framework（将C#代码转换为SQL）</a></li><li><a href=#应用二动态生成代码>应用二：动态生成代码</a></li><li><a href=#应用三构建动态查询>应用三：构建动态查询</a></li><li><a href=#应用四规则引擎和dsl领域特定语言>应用四：规则引擎和DSL（领域特定语言）</a></li></ul></li></ul></li><li><a href=#内部结构systemlinqexpressions-命名空间>内部结构（System.Linq.Expressions 命名空间）</a></li><li><a href=#编译器行为>编译器行为</a></li><li><a href=#用法>用法</a></li><li><a href=#类比语法树>类比语法树</a><ul><li><a href=#编译时的语法树syntax-tree>编译时的语法树（Syntax Tree）</a></li><li><a href=#运行时的表达式树expression-tree>运行时的表达式树（Expression Tree）</a></li></ul></li></ul></li></ul></li><li><a href=#异步lambda>异步Lambda</a><ul><li><a href=#从同步到异步>从同步到异步</a></li><li><a href=#异步lambda是什么>异步Lambda是什么</a></li><li><a href=#要点与注意事项>要点与注意事项</a></li><li><a href=#底层>底层</a></li></ul></li><li><a href=#静态lambda>静态Lambda</a><ul><li><a href=#语法>语法</a></li><li><a href=#特性>特性</a></li><li><a href=#使用场景-1>使用场景</a></li><li><a href=#总结-1>总结</a></li></ul></li><li><a href=#最佳实践与注意事项>最佳实践与注意事项</a></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>