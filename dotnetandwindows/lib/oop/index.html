<!doctype html><html lang=en><head><meta name=page-kind content="page"><meta charset=UTF-8><title>OOP</title><link rel=stylesheet href=/css/style.css><link href=https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/prism.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-csharp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-ini.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=stylesheet href=/css/blogsingle.css></head><body><header class=site-header><div class=container><div class=terminal-overlay aria-label=terminal-prompt><span id=typed-line></span><span class=cursor>█</span></div></div></header><nav class=topnav><div class=container><ul><li><a href=/dotnetandwindows/>★</a></li><li><a href=/dotnetandwindows/lab/>Lab</a></li><li><a href=/dotnetandwindows/lib/>Lib</a></li><li><a href=/dotnetandwindows/file/>File</a></li></ul></div></nav><nav id=star-nav><div id=star-header><span class="title open">>> >> >> Navigation &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Nav>>>>>></span></div><pre class=ascii>
+——————————————————————————————————————————————————————————————+
|                        <a class=nav-item data-path=/rightbrain/ href=/rightbrain/>RightBrain</a>                            |
|                             |                                |
|                             |     <a class=nav-item data-path=/dotnetandwindows/ href=/dotnetandwindows/>.NET-Windows</a>               |
|                             |    /                           |
|                             |   /                            |
|                             |  /                             |
|                             | /                              |
|                             |/                               |
|      <a class=nav-item data-path=/graphic/ href=/graphic/>Graphic</a> ———————————— <a class=nav-item data-path=/home/ href=/home/>Home</a> ————————————— <a class=nav-item data-path=/system/ href=/system/>System</a>          |
|                            /|                                |
|                           / |                                |
|                          /  |                                |
|                         /   |                                |
|                        /    |                                |
|                       /     |                                |
|              <a class=nav-item data-path=/unixlike/ href=/unixlike/>Unix-like</a>      |                <a class=nav-item data-path=/project/ href=/project/>Project</a>         |
|                             |                <a class=nav-item data-path=/miscellaneous/ href=/miscellaneous/>Miscellaneous</a>   |
|                          <a class=nav-item data-path=/csbasic/ href=/csbasic/>CSBasic</a>             <a class=nav-item data-path=/ai/ href=/ai/>AI</a>              |
+——————————————————————————————————————————————————————————————+
    </pre></nav><script defer src=/js/star-nav.js></script><script defer src=/js/site.js></script><script defer src=/js/star-active.js></script><div id=ref-window class="float-window open"><div class=float-header><span class="title open">>> >> >> Reference &lt;&lt; &lt;&lt; &lt;&lt;</span>
<span class="title closed">&lt;&lt;&lt;&lt;&lt;&lt;Ref>>>>>></span></div><div class=float-body><div class=ref-list><a href=https://www.mixamo.com/ target=_blank>Mixamo</a> |
<a href=https://opengameart.org/ target=_blank>OpenGameArt</a><p><a href=https://sharplab.io/ target=_blank>SharpLab</a> |
<a href=https://godbolt.org/ target=_blank>Compiler Explorer</a></p><p><a href="https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false" target=_blank>ASCII Graph Generator</a></p><p><a href=https://mermaid.js.org/ target=_blank>Mermaid</a></p><a href=https://www.vim.org/ target=_blank>Vim</a> | <a href=https://vimdoc.sourceforge.net/ target=_blank>Vim Manual Source</a> |
<a href=https://vimcdoc.sourceforge.net/ target=_blank>Vimcdoc</a> | <a href=https://vimcdoc.sourceforge.net/doc/help.html target=_blank>Vimdoc read online</a><p><a href=https://shields.io/ target=_blank>Shields.io</a></p><p><a href=https://emojidb.org/ target=_blank>EmojiDB</a></p><p><a href=https://cppreference.com/ target=_blank>cppreference</a></p><p><a href=https://gcc.gnu.org/onlinedocs/ target=_blank>GCC Docs</a></p><p><a href=https://clang.llvm.org/docs/ target=_blank>Clang Docs</a></p><p><a href=https://www.boost.org/libraries/ target=_blank>Boost Library Docs</a></p><p><a href=https://learn.microsoft.com/en-us/dotnet/csharp/ target=_blank>Microsoft Learn</a><p><a href=https://www.lua.org/manual/5.4/ target=_blank>Lua 5.4 Reference Manual</a><p><a href=https://docs.unity3d.com/Manual/index.html target=_blank>Unity Manual</a> |
<a href=https://docs.unity3d.com/ScriptReference/index.html target=_blank>Unity API</a></p><p><a href=https://docs.unrealengine.com/ target=_blank>Unreal Engine Docs</a></p><p><a href=https://godotengine.org target=_blank>Godot</a> |
<a href=https://docs.godotengine.org/en/stable/ target=_blank>Godot Docs</a></p><p><a href=https://z-library.sk/ target=_blank>Z-Library</a> : eBook Library</p><p><a href=https://docs.kernel.org/ target=_blank>Linux Kernel Docs</a></p><p><a href=https://www.gnu.org/ target=_blank>GNU</a> : manuals, philosophy, FAQ</p><a href=https://archlinux.org/ target=_blank>ArchLinux</a><p><a href=https://help.ubuntu.com/ target=_blank>Ubuntu Doc</a> |
<a href=https://ubuntu.com/server/docs target=_blank>Ubuntu Server Guide</a></p><p><a href=https://www.vulkan.org/ target=_blank>Vulkan</a> |
<a href=https://docs.vulkan.org/ target=_blank>Vulkan Docs</a></p><p><a href=https://www.opengl.org/ target=_blank>OpenGL</a> |
<a href=https://registry.khronos.org/OpenGL target=_blank>OpenGL API</a> |
<a href=https://www.khronos.org/opengl/wiki/ target=_blank>OpenGL Wiki</a></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/directx target=_blank>DirectX</a></p><p><a href=https://www.realtimerendering.com/ target=_blank>Real-Time Rendering</a></p><p><a href=https://www.pbr-book.org/ target=_blank>Physically Based Rendering</a></p><p><a href=https://www.scratchapixel.com/ target=_blank>Scratchapixel</a></p><p><a href=https://learnopengl.com/ target=_blank>LearnOpenGL</a></p><p><a href=https://raytracing.github.io/ target=_blank>Ray Tracing in One Weekend</a></p><p><a href=https://www.shadertoy.com/ target=_blank>Shadertoy</a></p><p><a href=https://arxiv.org/list/cs.GR/recent target=_blank>arXiv Graphics</a></p><p><a href=https://www.siggraph.org/ target=_blank>SIGGRAPH</a> |
<a href=https://dl.acm.org/conference/siggraph target=_blank>SIGGRAPH Digital Library</a></p><p><a href=https://git-scm.com/ target=_blank>Git</a> |
<a href=https://git-scm.com/doc target=_blank>Docs</a> |
<a href=https://git-scm.com/community target=_blank>Community</a></p></div></div></div><script src=/js/ref-window.js></script><article class=single_article><div class=title>OOP<div class=meta>Modified: 2025-06-01
| Author：ljf12825</div></div><div class=content><p>C#是强类型，面向对象语言</p><h3 id=类和对象>类和对象</h3><ul><li>类是定义对象的模板或蓝图，定义了对象的属性（字段）和行为（方法）</li><li>对象是类的实例，可以将类看作是抽象的定义，对象则是这个定义的具体实现</li></ul><h3 id=面向对象特性>面向对象特性</h3><ul><li><p>封装（encapsulation）
封装是将数据（属性）和操作数据的代码（方法）放在一个类的内部，外部代码只能通过类提供的公共方式来访问这些数据。这样可以隐藏实现细节，保护数据的完整性</p></li><li><p>继承（inheritance）
继承允许一个类继承另一个类的属性和方法，使得子类可以重用父类的代码，并且可以扩展或修改父类的功能。继承体现了类与类之间的is-a关系</p></li><li><p>多态（polymorphism）
多态是指一个对象可以表现出不同的行为，通常通过方法重写（Override）和方法重载（Overload）来实现</p></li><li><p>Override是指在子类中重写父类的方法，以改变父类方法的实现</p></li><li><p>Overload是指同名的方法根据参数的不同来实现不同的功能</p></li><li><p>抽象（abstraction）
抽象是指从多个对象中提取出共同的特性，提供一个抽象的类或接口，使得具体的实现对外部是透明的。抽象类可以包含抽象方法（没有实现的函数），具体的子类需要实现这些方法</p></li></ul><h3 id=c中面向对象的实现>C#中面向对象的实现</h3><p>在C#中对象被视作引用类型存储在托管堆上</p><h4 id=访问限定修饰符>访问限定修饰符</h4><p>默认访问修饰符</p><ul><li><p>类：默认情况下使<code>internal</code>，这意味着类只能在同一程序集内部访问</p></li><li><p>成员：对于类中的成员，如果没有指定，字段默认为<code>private</code>，方法和属性默认为<code>private</code></p></li><li><p><code>public</code></p><ul><li>修饰类：使类对多有代码可见，可以从任何地方访问</li><li>修饰成员：是成员对所有代码可见</li></ul></li><li><p><code>internal</code></p><ul><li>修饰类：使类仅对同一程序集中的代码可见，外部程序集无法访问</li><li>修饰成员：使成员仅对同一程序集中的代码可见</li></ul><blockquote><p>同一程序集（Assembly）是指在.NET或C#中编译后的代码和资源的集合，通常会包含一个或多个类型（如类、接口、结构等）
程序集是.NET应用程序的基本组成单元，通常对应一个.dll或.exe文件
程序集是.NET的元数据（Metadata）和代码（IL代码）的封装，它是运行时加载、版本控制和部署的单位</p></blockquote></li><li><p><code>protected</code></p><ul><li>修饰类：不能用于类，只能修饰成员</li><li>修饰成员：使成员对继承类（子类）可见，但不能被外部代码直接访问</li></ul></li><li><p><code>private</code></p><ul><li>修饰类：不能用于类，只能修饰成员</li><li>修饰成员：使成员仅包含对它的类内部可见，外部无法访问</li></ul></li><li><p><code>protected internal</code></p><ul><li>修饰类：使类对同一程序集中的代码以及继承该类的外部类可见</li><li>修饰成员：使成员对同一程序集中的代码以及继承该类的外部类可见</li></ul></li><li><p><code>private protected</code></p><ul><li>修饰类：不能修饰类，只能修饰成员</li><li>修饰成员：使成员对当前类以及在同一程序集内的继承类可见，但对其他类不可见</li></ul></li></ul><h4 id=字段与属性>字段与属性</h4><p>在C#中，字段和属性是用于存储数据的两种主要方式，它们之间有很大的区别</p><ol><li>字段（Field）
字段是类或结构体中的一个变量，用于存储数据。它们通常直接定义在类中，并且可以通过类的实例进行访问
字段的特点：</li></ol><ul><li>字段是类的成员变量，用来直接存储数据</li><li>字段可以有不同的访问修饰符，来控制其可访问性</li><li>字段一般不包含逻辑，主要是存储数据</li></ul><ol start=2><li>属性（Property）
属性是C#中的一种特殊成员，用于对字段进行封装，是一种语法糖。它通常与字段关联，通过getter和setter方法来访问和修改字段的值</li></ol><p>属性是C#中的一个重要特性，它不仅能提供对数据的访问，还可以在访问数据时添加额外的逻辑，比如验证、计算或其他操作。属性通常用于对类的字段提供更控制的访问方式</p><p>属性的特点：</p><ul><li>属性本质上是对字段的封装，可以控制数据的读写</li><li>属性通常由getter和setter组成，它们可以是自动实现的或手动实现的</li><li>属性能够提供更复杂的逻辑，比如验证输入数据、计算值或触发事件等</li></ul><p>自动实现的属性<br>从C# 3.0开始，如果不需要写特殊逻辑，可以用简化语法<br>自动实现的属性不需要显式定义字段，编译器会自动为其生成一个匿名的私有字段</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } <span style=color:#75715e>// 自动实现的属性</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Age { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } <span style=color:#75715e>// 自动实现的属性</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Person(<span style=color:#66d9ef>string</span> name, <span style=color:#66d9ef>int</span> age)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Name = name;
</span></span><span style=display:flex><span>        Age = age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>手动实现的属性<br>手动实现的属性允许在访问和设置字段时添加自定义逻辑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age; <span style=color:#75715e>// 私有字段</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Age
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> age; } <span style=color:#75715e>// 获取age字段的值</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>set</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>value</span> &gt;= <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// 设置前验证</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                age = <span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>throw</span> ArgumentOutOfRangeException(<span style=color:#e6db74>&#34;Age cannot be negative.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Person(<span style=color:#66d9ef>int</span> age) =&gt; Age = age; <span style=color:#75715e>// 通过get {} 访问</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>属性可以由不同的访问控制：</p><ul><li>自动实现的属性：编译器自动提供私有字段的实现</li><li>只读属性：只有<code>get</code>访问器，没有<code>set</code>访问器，用于只允许读取值的情况
<code>public string Id { get; }</code></li><li>只写属性：只有<code>set</code>访问器，通常用于需要在对象初始化时设置值，但之后不能更改的字段
<code>public sring Passwork( set; )</code></li><li>属性带私有set
<code>public string Username { get; private set; }</code></li></ul><p>C# 9.0 提供了新的访问器<code>init</code><br>只允许初始化时设置值
<code>public string Name { get; init; }</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>init</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Age { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>init</span>; }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ver person = <span style=color:#66d9ef>new</span> Person
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Name = <span style=color:#e6db74>&#34;Alice&#34;</span>,
</span></span><span style=display:flex><span>    Age = <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// person.Name = &#34;A&#34; // 报错</span>
</span></span></code></pre></div><p>抽象属性<br>抽象类可以拥有抽象属性，这些属性应该在派生类中被实现</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>string</span> Name { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>int</span> Age { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> : Person
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Code { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } = <span style=color:#e6db74>&#34;N.A&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>string</span> Name { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } = <span style=color:#e6db74>&#34;N.A&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>int</span> Age { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当创建该类的实例时，如果没有显式为<code>Code</code>,<code>Name</code>，<code>Age</code>赋值，则默认值为给定值</p><p>表达式体属性<br>这种简化语法避免了使用完整的<code>{ get; set; }</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span> =&gt; name; <span style=color:#75715e>// 返回字段name的值</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>set</span> =&gt; name = <span style=color:#66d9ef>value</span>; <span style=color:#75715e>// 设置字段name的值</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对于那些只包含单行逻辑的属性，使用<code>=></code>语法可以使代码更加简洁，特别适合于只需要返回一个字段值的简单属性，或者只需要执行一个简单操作的<code>set</code><br>只包含<code>get</code>的属性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> name = <span style=color:#e6db74>&#34;N.A&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name =&gt; name; <span style=color:#75715e>// get { return name; }</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>只包含<code>set</code>的属性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Age
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>set</span> =&gt; age = <span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>字段vs属性</p><table><thead><tr><th><strong>特性</strong></th><th><strong>字段</strong></th><th><strong>属性</strong></th></tr></thead><tbody><tr><td><strong>定义方式</strong></td><td>直接声明为类的成员变量</td><td>通过 <code>get</code> 和 <code>set</code> 方法定义并封装字段</td></tr><tr><td><strong>访问控制</strong></td><td>通常通过访问修饰符来控制访问权限</td><td>可以通过 <code>get</code> 和 <code>set</code> 方法来控制访问权限</td></tr><tr><td><strong>用途</strong></td><td>用于直接存储数据</td><td>用于控制数据的访问，通常用于封装字段</td></tr><tr><td><strong>数据验证</strong></td><td>不能直接进行数据验证</td><td>可以在 <code>set</code> 访问器中实现数据验证逻辑</td></tr><tr><td><strong>默认行为</strong></td><td>没有默认行为，直接存取数据</td><td>允许在访问数据时加入逻辑或计算</td></tr><tr><td><strong>继承行为</strong></td><td>字段不能在子类中访问，除非是 <code>public</code> 或 <code>protected</code></td><td>属性可以被继承和重写，可以控制子类如何访问数据</td></tr><tr><td><strong>性能</strong></td><td>直接存取，性能开销较小</td><td>因为涉及方法调用，所以通常稍微慢一些，但差异通常很小</td></tr></tbody></table><h4 id=this>this</h4><p>在C#中，<code>this</code>是一个关键字。它用于引用当前对象，尤其是在类的实例方法和构造函数中非常常见</p><ol><li><code>this</code>用于引用当前实例
<code>this</code>关键字用于指向当前对象的实例。在类的成员方法或构造函数中，可以使用<code>this</code>来访问当前对象的字段、属性或方法</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> SetName(<span style=color:#66d9ef>string</span> name)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.Name = name; <span style=color:#75715e>// 使用this引用当前对象的字段</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Person person = <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>        person.SetName(<span style=color:#e6db74>&#34;Alice&#34;</span>);
</span></span><span style=display:flex><span>        Console.WriteLine(person.Name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>SetName</code>方法中，<code>this.Name</code>代表当前实例的<code>Name</code>字段，而方法参数<code>name</code>是传入的值。通过<code>this.Name</code>，明确区分了成员变量和参数变量</p><ol start=2><li><code>this</code>用于区分字段和参数
在类的方法中，当参数名称和成员字段名称相同时，可以使用<code>this</code>来区分它们，这对于避免变量命名冲突非常有用</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Person(<span style=color:#66d9ef>string</span> name)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.name = name; <span style=color:#75715e>// 使用this来区分字段和参数</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> PrintName() =&gt; Console.WriteLine(<span style=color:#66d9ef>this</span>.Name); <span style=color:#75715e>// 使用this引用字段</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在构造函数中，<code>this.name</code>明确表示字段<code>name</code>，而构造函数的参数也叫<code>name</code>，使用<code>this</code>来区分这两个具有相同名称的成员</p><ol start=3><li><code>this</code>用于调用当前类的其他构造函数
C#允许类中使用<code>this</code>来调用当前类的其他构造函数，这叫做构造函数链。这种方式使得多个构造函数能够共享部分代码，避免重复</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 默认构造函数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Person() : <span style=color:#66d9ef>this</span>(<span style=color:#e6db74>&#34;Unknown&#34;</span>, <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// 调用其他构造函数</span>
</span></span><span style=display:flex><span>    {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 带参数的构造函数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Person(<span style=color:#66d9ef>string</span> name, <span style=color:#66d9ef>int</span> age)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.Name = name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.Age = age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Person person = <span style=color:#66d9ef>new</span> Person(); <span style=color:#75715e>// 调用默认构造函数</span>
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;{person.Name}, {person.Age}&#34;</span>); <span style=color:#75715e>// 输出&#34;Unknown, 0&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li><code>this</code>用于传递当前对象作为参数
有时可能需要将当前对象传递给其它方法或者类，这是<code>this</code>可以用来表示当前对象</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> PrintPerson()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#66d9ef>this</span>.Name); <span style=color:#75715e>// 输出当前对象的名称</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> PrintOtherPerson(Person otherPerson)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Consle.WriteLine(otherPerson.Name); <span style=color:#75715e>// 输出其他Person对象的名称</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> CompareWithOtherPerson(Person otherPerson)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span> == otherPerson) <span style=color:#75715e>// 比较当前对象和传入对象</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;The same Person&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Different persons&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>CompareWithOtherPerson</code>方法中，<code>this</code>用来表示当前对象，便于和另一个对象进行比较</p><ol start=5><li><code>this</code>用于扩展方法
在C#中，扩展方法可以为现有类型添加方法，而无需修改它们的源代码。扩展方法的第一个参数是<code>this</code>，它表示要扩展的方法所在的对象类型</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PersonExtensions</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> PrintUpperCaseName(<span style=color:#66d9ef>this</span> Person person)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(person.Name.ToUpper()); <span style=color:#75715e>// 使用this访问Person对象</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Person person = <span style=color:#66d9ef>new</span> Person { Name = <span style=color:#e6db74>&#34;Alice&#34;</span> };
</span></span><span style=display:flex><span>        person.PrintUpperCaseName(); <span style=color:#75715e>// 输出“ALICE”（扩展方法）</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中，<code>this</code>关键字使得<code>PrintUpperCaseName</code>方法能够扩展<code>Person</code>类型</p><ol start=6><li><code>this</code>与静态成员
<code>this</code>关键字不能在静态方法中使用，因为静态方法是属于类而不是类的实例的。在静态方法中，<code>this</code>没有意义</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> StaticMethod()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// this.Name = &#34;Alice&#34;; // 错误：无法在静态方法中使用&#39;this&#39;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=static>static</h4><p>在C#中，<code>static</code>关键字用于定义静态成员，它使得某个成员属于类本身而不是某个类的某个实例</p><p>这意味着静态成员在所有类的实例中共享，而不是每个实例拥有一份独立的副本</p><p><code>static</code>可以用于类、字段、方法、属性、构造函数等多个场景</p><h5 id=静态类>静态类</h5><p><code>static</code>可以用来定义静态类，一个类如果声明为静态的，它就不能被实例化，也不能包含实例成员（如实例字段、实例方法等）静态类只能包含静态成员</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MathHelper</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>double</span> Pi = <span style=color:#ae81ff>3.14159</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>double</span> Add(<span style=color:#66d9ef>double</span> a, <span style=color:#66d9ef>double</span> b) =&gt; a + b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 访问静态类的成员</span>
</span></span><span style=display:flex><span>        Console.WriteLine(MathHelper.Pi); <span style=color:#75715e>// 输出：3.14159</span>
</span></span><span style=display:flex><span>        Console.WriteLine(MathHelper.Add(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)); <span style=color:#75715e>// 输出：5</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>静态类不能被实例化，不能使用<code>new</code>来创建对象</li><li>静态类额成员必须是静态的</li></ul><h5 id=静态字段>静态字段</h5><p><code>static</code>可以用于声明静态字段。静态字段属于类本身，而不是类的某个实例。所有类的实例共享一个静态字段的值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> Count = <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 静态字段</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Counter() =&gt; Count++; <span style=color:#75715e>// 每次创建一个实例时，静态字段Count会增加</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(Counter.Count); <span style=color:#75715e>// 输出：0</span>
</span></span><span style=display:flex><span>        Counter c1 = <span style=color:#66d9ef>new</span> Counter();
</span></span><span style=display:flex><span>        Counter c2 = <span style=color:#66d9ef>new</span> Counter();
</span></span><span style=display:flex><span>        Console.WriteLine(Counter.Count); <span style=color:#75715e>// 输出：2</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>Count</code>是一个静态字段，它被类的所有实例共享，因此在创建每个实例时，静态字段的值会发生变化</li></ul><h5 id=静态方法>静态方法</h5><p><code>static</code>也可以用于声明静态方法，静态方法只能访问静态成员，不能访问实例成员。静态方法通常用来执行类级别的操作，而不是操作某个具体实例的数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MathHelper</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> Add(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) =&gt; <span style=color:#66d9ef>return</span> a + b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用静态方法</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> result = MathHelper.Add(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>        Console.WriteLine(result); <span style=color:#75715e>// 输出7</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>静态方法可以通过类名直接访问，无需创建类的实例</li></ul><h5 id=静态构造函数>静态构造函数</h5><p>静态构造函数是一个特殊的构造函数，它用于初始化静态类成员，在类的任何静态成员第一次被访问之前，静态构造函数会自动被调用。静态构造函数没有访问修饰符，并且不能接收参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> Counter;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> MyClass()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Counter = <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// 静态构造函数初始化静态成员</span>
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;静态构造函数调用&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> PrintCounter() =&gt; Console.WriteLine(Counter);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MyClass.PrintCounter(); <span style=color:#75715e>// 输出10</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>静态构造函数在类的静态成员第一次被访问时自动执行一次</li><li>静态构造函数只能存在一个</li></ul><h5 id=静态属性>静态属性</h5><p><code>static</code>也可以用于声明静态属性，它允许你在类层面上控制静态字段的访问。静态属性是对静态字段的一种封装，通常用于获取或设置静态字段的值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GlobalSettings</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>string</span> settingValue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>string</span> Setting
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> settingValue; }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>set</span> { settingValue = <span style=color:#66d9ef>value</span>; }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        GlobalSettings.Setting = <span style=color:#e6db74>&#34;Dark Mode&#34;</span>;
</span></span><span style=display:flex><span>        Console.WriteLine(GlobalSettings.Setting); <span style=color:#75715e>// 输出Dark Mode</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>静态属性提供了对静态字段的访问控制，并且同样可以通过类名直接访问</li></ul><p>静态类的局限性</p><ul><li>静态类不能实例化</li><li>静态类只能包含静态成员，不能有实例成员</li><li>静态构造函数只能有一个，它会在类的静态成员首次访问时被自动调用</li></ul><p>静态成员的使用场景</p><ul><li>共享数据：静态字段适合用来存储在所有实例之间共享的数据</li><li>工具类：静态方法常用于那些不依赖实例的功能，比如数学运算、字符串处理等</li><li>单例模式：静态类和静态字段可以用于实现单例模式，确保一个类只有一个实例</li></ul><h4 id=嵌套类>嵌套类</h4><p>在C#中，嵌套类是指定义在另一个类内部的类。嵌套类可以时静态的或实例化的，并且它的访问权限可以受到外部类访问控制修饰符的限制。嵌套类通常用于以下几种情况：</p><ul><li>封装逻辑：将一些仅在外部类内使用的类封装在外部类内部，避免类的暴露，确保数据和方法的封装性</li><li>辅助功能：嵌套类用于实现外部类的某些辅助功能，比如构建复杂数据结构、实现辅助算法等</li></ul><h5 id=嵌套类的定义>嵌套类的定义</h5><p>嵌套类通常定义在外部类内部，并且有自己的访问修饰符，这决定了它的可访问范围</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OuterClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 外部类的成员</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> outerField;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 嵌套类</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NestedClass</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> nestedField;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Display() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Nested class method&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Display() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Outer class method&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建外部类的实例</span>
</span></span><span style=display:flex><span>        OuterClass outer = <span style=color:#66d9ef>new</span> OuterClass();
</span></span><span style=display:flex><span>        outer.outerField = <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>        outer.Display();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建嵌套类的实例</span>
</span></span><span style=display:flex><span>        OuterClass.NestedClass nested = <span style=color:#66d9ef>new</span> OuterClass.NestedClass();
</span></span><span style=display:flex><span>        nested.nestedField = <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>        nested.Display();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>OuterClass</code>包含了一个嵌套类<code>NestedClass</code></li><li><code>OuterClass</code>和<code>NestedClass</code>都可以包含自己的字段和方法</li><li>嵌套类通过<code>OuterClass.NestedClass</code>访问</li></ul><h5 id=访问修饰符>访问修饰符</h5><p>嵌套类的访问修饰符决定了它的访问范围，嵌套类和它的成员可以设置为不同的访问级别</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OuterClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PrivateNestedClass</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Display()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Private nested class&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PublicNestedClass</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Display()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Public nested class&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> CreateNestedClasses()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 只有外部类的实例方法能访问私有嵌套类</span>
</span></span><span style=display:flex><span>        PrivateNestedClass privateNested = <span style=color:#66d9ef>new</span> PrivateNestedClass();
</span></span><span style=display:flex><span>        privateNested.Display();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        PublicNestedClass publicNested = <span style=color:#66d9ef>new</span> PublicNestedClass();
</span></span><span style=display:flex><span>        publicNested.Display();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        OuterClass outer = <span style=color:#66d9ef>new</span> OuterClass();
</span></span><span style=display:flex><span>        outer.CreateNestedClasses();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 无法直接访问 PrivateNestedClass</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// OuterClass.PrivateNestedClass privateNested = new OuterClass.PrivateNestedClass(); // 错误！</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        OuterClass.PublicNestedClass publicNested = <span style=color:#66d9ef>new</span> OuterClass.PublicNestedClass(); <span style=color:#75715e>// 允许</span>
</span></span><span style=display:flex><span>        publicNested.Display();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=嵌套静态类>嵌套静态类</h5><p>嵌套类可以是 静态的，这意味着它不能访问外部类的实例成员，只能访问外部类的静态成员。静态嵌套类通常用于封装一些与外部类实例无关的功能</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OuterClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> staticField = <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 嵌套静态类</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StaticNestedClass</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Display()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Static nested class method&#34;</span>);
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Accessing static field from outer class: &#34;</span> + OuterClass.staticField);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 访问静态嵌套类</span>
</span></span><span style=display:flex><span>        OuterClass.StaticNestedClass.Display();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=嵌套类访问外部类的实例成员>嵌套类访问外部类的实例成员</h5><p>嵌套类能够访问外部类的实例成员（字段和方法）。但要注意，嵌套类访问外部类实例成员时，必须先实例化外部类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OuterClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> outerField = <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 嵌套类访问外部类实例成员</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NestedClass</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Display(OuterClass outer)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Outer class field: &#34;</span> + outer.outerField);  <span style=color:#75715e>// 访问外部类的实例成员</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        OuterClass outer = <span style=color:#66d9ef>new</span> OuterClass();
</span></span><span style=display:flex><span>        OuterClass.NestedClass nested = <span style=color:#66d9ef>new</span> OuterClass.NestedClass();
</span></span><span style=display:flex><span>        nested.Display(outer);  <span style=color:#75715e>// 传入外部类实例</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=嵌套类的使用场景>嵌套类的使用场景</h5><ul><li>封装实现细节：当某个类仅在另一个类的上下文中有意义时，可以将其作为嵌套类来封装</li><li>逻辑分组：将功能相关的类进行嵌套，避免类的过度暴露，减少命名冲突</li><li>辅助功能：嵌套类用于实现外部类的辅助功能，比如遍历、处理数据等</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Book</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Title { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Author { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 嵌套类用于表示书籍的章节</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Chapter</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Title { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> PageCount { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Display() =&gt; Console.WriteLine(<span style=color:#e6db74>$&#34;{Title}, {PageCount}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Book book = <span style=color:#66d9ef>new</span> Book { Title = <span style=color:#e6db74>&#34;C# Programming&#34;</span>, Author = <span style=color:#e6db74>&#34;John Doe&#34;</span> };
</span></span><span style=display:flex><span>        Book.Chapter chapter = <span style=color:#66d9ef>new</span> Book.Chapter { Title = <span style=color:#e6db74>&#34;Introduction&#34;</span>, PageCount = <span style=color:#ae81ff>10</span> };
</span></span><span style=display:flex><span>        chapter.Display();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=扩展方法extension-methods>扩展方法（Extension Methods）</h4><p>在C#中，扩展方法是一种通过静态方法扩展现有类型功能的技术，而无需修改原始类型的代码。这使得可以为已经存在的类型（如系统库中的类）添加新方法，而不需要继承、修改类或重新编译库</p><p><strong>定义</strong><br>扩展方法实际上是静态方法，但是它们的调用方式和实例方法一样。扩展方法的定义依赖于<code>this</code>关键字，它指定了要扩展的类型</p><p><strong>扩展方法的语法</strong><br>扩展方法必须是静态的，并且定义在一个静态类中。扩展方法的第一个参数表示被扩展的类型，前面加上<code>this</code>关键字。通过这种方式，编译器会将扩展方法作为实例方法来调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ExtensionClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ReturnType MethodName(<span style=color:#66d9ef>this</span> TargetType instance, Parameters)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 方法体</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>this TargetType</code>：这是扩展方法的目标类型，也就是说这个方法是为<code>TargetType</code>类型添加的</li><li><code>MethodName</code>：扩展方法的名称，可以像调用实例方法一样调用</li><li><code>Parameters</code>：扩展方法可以有参数，就像普通方法一样</li></ul><p><strong>示例</strong>\</p><ol><li>为<code>string</code>类型扩展一个方法<br>假设要为<code>string</code>类型扩展一个方法<code>IsNullOrEmpty</code>，用于检查字符串是否为<code>null</code>或空字符串</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StringExtensions</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 扩展方法：检查字符串是否为null或空</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> IsNullOrEmpty(<span style=color:#66d9ef>this</span> <span style=color:#66d9ef>string</span> str)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>string</span>.InNullOrEmpty(str);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> text = <span style=color:#e6db74>&#34;Hello, World!&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> result = text.IsNullOrEmpty(); <span style=color:#75715e>// 调用扩展方法</span>
</span></span><span style=display:flex><span>        Console.WriteLine(result); <span style=color:#75715e>// False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> exptyText = <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>        Console.WriteLine(emptyText.IsNullOrEmpty()); <span style=color:#75715e>//True</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中，为<code>string</code>类型添加了一个<code>IsNullOrEmpty</code>方法，它检查字符串是否为空或为<code>null</code></p><ul><li>调用时像调用实例方法一样，<code>text.IsNullOrEmpty()</code></li><li>编译器会自动将<code>text</code>当作第一个参数传递给扩展方法</li></ul><ol start=2><li>为<code>List&lt;int></code>扩展一个方法<br>为<code>List&lt;int></code>扩展一个<code>Sum</code>方法，用于计算一个整数列表的和</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ListExtensions</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 扩展方法：计算整数列表的和</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> Sum(<span style=color:#66d9ef>this</span> List&lt;<span style=color:#66d9ef>int</span>&gt; list)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> sum = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> item <span style=color:#66d9ef>in</span> list) sum += item;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        List&lt;<span style=color:#66d9ef>int</span>&gt; numbers = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt; { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>        Console.WriteLine(numbers.Sum());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>为<code>DateTime</code>扩展一个方法<br>为<code>DateTime</code>扩展一个方法，检查是否是工作日</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DateTimeExtensions</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 扩展方法：检查日期是否是工作日</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> IsWeekday(<span style=color:#66d9ef>this</span> DateTime date) =&gt; date.DayOfWeek != DayOfWeek.Saturday &amp;&amp; date.DayOfWeek != DayOfWeek.Sunday;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>注意事项</strong>\</p><ul><li>命名空间：扩展方法定义在特定的静态类中，所以需要确保在使用扩展方法的文件中包含该类的命名空间</li><li>扩展方法的优先级：扩展方法在方法解析时具有较高的优先级。如果目标类型本身已经定义了相同的方法，编译器会优先选择目标类型的方法，而不是扩展方法</li><li>静态方法：扩展方法本质上是静态方法，但它的调用方式与实例方法相同</li><li>不能重载扩展方法：你不能为一个类型扩展多个相同名称、参数个数和类型的方法</li></ul><p><strong>实际应用</strong>\</p><ul><li>为.NET库提供额外功能</li><li>简化常见操作</li><li>增强可读性和维护性</li></ul><p><strong>特点</strong><br>优点</p><ul><li>不修改现有代码</li><li>提升可读性</li><li>增强灵活性</li></ul><p>缺点</p><ul><li>可能导致混淆：如果扩展方法和目标类型的方法名称及或功能相似，可能会导致方法解析的冲突或混淆</li><li>只能使用<code>static</code>方法：扩展方法本质上是静态方法，不能访问实例的非静态成员</li></ul><h4 id=抽象类与接口interface>抽象类与接口（interface）</h4><p>抽象类和接口都是用来定义一组方法和属性，但它们的目的和使用方式不同</p><h5 id=抽象类>抽象类</h5><p>抽象类是一种不能实例化的类，它提供一个模板，可以包含已实现的方法和未实现的方法（抽象方法）。抽象类允许部分实现，因此它可以定义字段、构造函数和方法，并且可以在其中包含抽象方法（没有方法体）<br>特点：</p><ul><li>不能实例化：抽象类不能直接创建实例</li><li>可以包含已实现的方法：抽象类可以有已实现的方法，也可以有未实现的方法（抽象方法）</li><li>可以包含字段和构造函数：抽象类允许有实例字段、静态字段和构造函数</li><li>可以实现接口：抽象类可以实现接口，这样它就需要提供接口的所有抽象方法实现，或者让其子类来提供实现</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 抽象方法：子类必须实现</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> MakeSound();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 已实现方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Sleep() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Sleeping...&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span> : Animal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 必须实现抽象方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> MakeSound() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Bark!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Animal animal = new Animal(); // 不能实例化抽象类</span>
</span></span><span style=display:flex><span>        Animal dog = <span style=color:#66d9ef>new</span> Dog(); <span style=color:#75715e>// 通过子类实例化</span>
</span></span><span style=display:flex><span>        dog.MakeSound(); <span style=color:#75715e>// Bark!</span>
</span></span><span style=display:flex><span>        dog.Sleep(); <span style=color:#75715e>// Sleeping...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Animal</code>本身不能实例化，只能通过其子类来实例化</p><p><strong>使用场景</strong>\</p><ul><li>当有多个类需要共享某些方法的实现时，可以将这些方法放在抽象类中，并让各个子类继承和重写抽象方法</li><li>当需要部分实现，比如某些方法需要通用实现而其他子方法则有子类提供实现</li></ul><h5 id=接口>接口</h5><p>接口是一种定义契约的方式，所有声明的成员都是抽象的（没有实现）。接口只能包含方法、属性、事件或索引器的声明，而不能包含任何实现。类可以实现多个接口，但它们必须实现接口中的所有方法</p><p>特点：</p><ul><li>只包含声明：接口只能声明方法、属性、事件等，而不能提供任何实现</li><li>不能包含字段：接口不能包含字段或构造函数</li><li>多继承：一个类可以实现多个接口（C#允许类实现多个接口，但只能继承一个类）</li><li>强制实现：当类实现接口时必须实现接口中声明的所有方法</li><li>不能实例化：接口本身不能被实例化</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IAnimal</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 接口方法：没有实现</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> MakeSound();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ICanFly</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Fly();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bird</span> : IAnimal, ICanFly
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> MakeSound()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;Chirp!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Fly()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;Flying...&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        IAnimal animal = <span style=color:#66d9ef>new</span> Bird();
</span></span><span style=display:flex><span>        animal.MakeSound(); <span style=color:#75715e>// 输出：Chirp</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ICanFly bird = <span style=color:#66d9ef>new</span> Bird();
</span></span><span style=display:flex><span>        bird.Fly(); <span style=color:#75715e>// 输出：Flying...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>IAnimal</code>和<code>ICanFly</code>是接口，分别声明了<code>MakeSound</code>和<code>Fly</code>方法</li><li><code>Bird</code>类实现了这两个几口，并提供了这两个方法的实现</li></ul><p><strong>使用场景</strong></p><ul><li>当需要定义一组方法，但不关心这些方法如何实现，这时可以使用接口</li><li>当多个类需要共享某种行为，而不需要继承相同的类，例如，一个类可以实现多个接口来获得不同的功能</li><li>用于多继承：C#不支持多类继承，但可以通过接口来实现类似的功能</li></ul><h5 id=抽象类与接口>抽象类与接口</h5><table><thead><tr><th>特性</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td><strong>设计理念</strong></td><td>is-a</td><td>can-do</td></tr><tr><td><strong>实现方法</strong></td><td>可以有部分实现（普通方法）</td><td>只能有方法声明，无实现</td></tr><tr><td><strong>构造函数</strong></td><td>可以有构造函数</td><td>不能有构造函数</td></tr><tr><td><strong>字段</strong></td><td>可以有字段（实例或静态）</td><td>不能有字段</td></tr><tr><td><strong>多继承</strong></td><td>只能继承一个类</td><td>可以实现多个接口</td></tr><tr><td><strong>实现方式</strong></td><td>类继承，子类必须实现所有抽象方法</td><td>类实现，必须实现接口中的所有方法</td></tr><tr><td><strong>成员访问控制</strong></td><td>可以有访问修饰符（<code>public</code>、<code>protected</code>、<code>private</code>等）</td><td>所有成员默认是 <code>public</code>，不能有访问修饰符</td></tr><tr><td><strong>默认行为</strong></td><td>可以有默认实现（非抽象方法）</td><td>所有方法默认是抽象的，不能有实现</td></tr></tbody></table><h4 id=继承问题>继承问题</h4><p>在C#中，继承方式总是<code>public</code>，接口只能继承接口，类只能继承一个类，但可以继承多个接口，以实现多继承，同时避免了菱形继承问题，因为接口中只有函数签名，实现在子类中‘</p><h5 id=virtual和abstract><code>virtual</code>和<code>abstract</code></h5><ol><li><code>virtual</code>方法</li></ol><p><code>virtual</code>关键字用于允许类中的方法、属性和事件被重写（<code>override</code>）或继承，但它不强制要求子类必须重写该方法。如果子类没有重写该方法，它将调用基类提供的默认实现</p><p>特点：</p><ul><li>可以提供默认实现：<code>virtual</code>方法有一个默认实现，子类可以选择重写它，也可以继承这个实现</li><li>子类可以重写：子类如果需要修改该方法的行为，可以使用<code>override</code>关键字重写</li><li>可选重写：如果子类不重写，基类的默认实现将被使用</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// virtual方法，允许被重写</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Speak() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Animal speaks&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span> : Animal
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 重写基类的虚拟方法</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Speak() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Dog barks&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Animal myAnimal = <span style=color:#66d9ef>new</span> Animal();
</span></span><span style=display:flex><span>        myAnimal.Speak(); <span style=color:#75715e>// Animal speaks</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Animal myDog = <span style=color:#66d9ef>new</span> Dog();
</span></span><span style=display:flex><span>        myDog.Speak(); <span style=color:#75715e>// Dog barks</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>Speak</code>方法是<code>virtual</code>的，可以在<code>Dog</code>类中重写</li><li><code>Dog</code>类重写了<code>Speak</code>方法，使得调用<code>myDog.Speak()</code>时输出 Dog barks，而不是基类<code>Animal</code>的默认实现</li></ul><p>使用场景</p><ul><li>当你想提供一个默认实现，但希望子类可以根据需要覆盖它时</li><li>当你希望子类能够自定义基类方法的行为，但保留基类默认行为时</li></ul><ol start=2><li><code>abstract</code>方法
<code>abstract</code>关键字用于声明抽象方法，这意味着该方法在基类中没有实现，并且必须在派生类中实现。抽象方法只能存在于抽象类中，抽象类时是不能被实例化的，它用于定义子类的模板</li></ol><p>特点：</p><ul><li>没有实现：<code>abstract</code>方法没有方法体，它只是方法签名</li><li>必须被重写：所有继承自抽象类的非抽象子类必须重写该方法</li><li>用于强制派生类实现特定行为</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// abstract方法，必须在派生类中实现</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> Speak();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span> : Animal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 必须实现基类的抽象方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Speak() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Dog barks&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Animal myAnimal = new Animal(); // 错误：不能实例化抽象类</span>
</span></span><span style=display:flex><span>        Animal myDog = <span style=color:#66d9ef>new</span> Dog();
</span></span><span style=display:flex><span>        myDog.Speak(); <span style=color:#75715e>// 输出：Dog barks</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>Speak</code>方法是<code>abstract</code>的，没有实现，因此无法在<code>Animal</code>类中提供具体实现</li><li><code>Dog</code>类继承<code>Animal</code>并实现了<code>Speak</code>方法，这样就满足了抽象类的要求</li></ul><p>使用场景</p><ul><li>当你希望确保派生类实现特定的行为时，例如定义一组必须被所有派生类实现的操作</li><li>当你不能为某些方法提供通用实现时，而是希望每个派生类都有自己的特定实现</li></ul><p><code>virtual</code> vs <code>abstract</code></p><table><thead><tr><th>特性</th><th><code>virtual</code> 方法</th><th><code>abstract</code> 方法</th></tr></thead><tbody><tr><td><strong>方法实现</strong></td><td>有默认实现，可以选择重写</td><td>没有默认实现，必须在派生类中实现</td></tr><tr><td><strong>派生类的要求</strong></td><td>派生类可以选择是否重写方法</td><td>派生类必须实现该方法</td></tr><tr><td><strong>可用范围</strong></td><td>可以用于普通类，派生类可以选择是否重写</td><td>只能用于抽象类，必须被重写</td></tr><tr><td><strong>是否可以实例化</strong></td><td>可以在基类中实例化</td><td>不能实例化抽象类</td></tr><tr><td><strong>行为</strong></td><td>允许派生类重写该方法</td><td>强制派生类提供该方法的实现</td></tr></tbody></table><p><code>virtual</code>与<code>abstract</code>的组合使用
可以在某些情况下结合使用<code>virtual</code>和<code>abstract</code>，例如，在抽象类中定义一个抽象方法，然后提供一个虚拟方法作为默认实现，这样派生类可以选择重写该方法，或者使用基类提供的默认实现</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// abstract 方法：强制子类实现</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> MakeSound();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// virtual 方法：提供默认实现，可以选择重写</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Sleep() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Aniaml sleeps&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span> : Animal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> MakeSound() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Dog barks&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 可以选择重写虚拟方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Sleep() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Dog sleeps&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Animal myDog = <span style=color:#66d9ef>new</span> Dog();
</span></span><span style=display:flex><span>        myDog.MakeSound(); <span style=color:#75715e>// Dog barks</span>
</span></span><span style=display:flex><span>        myDog.Sleep(); <span style=color:#75715e>// Dog sleeps</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=运算符重载>运算符重载</h4><h4 id=构造函数和析构函数>构造函数和析构函数</h4><p>在C#中，构造函数和析构函数时特殊的方法，它们分别在创建对象和销毁对象时被自动调用。它们用于初始化对象和清理资源</p><h5 id=构造函数constructor>构造函数（Constructor）</h5><p>构造函数时当创建对象时自动调用的特殊方法，它用于初始化对象，通常用于设置对象的初始状态</p><p>特点：</p><ul><li>构造函数没有返回值（即使时<code>void</code>也不能指定）</li><li>与类同名：构造函数的名称必须与类名相同</li><li>可以重载：类可以有多个构造函数（重载），以便以不同的方式初始化对象</li><li>自动调用：每次实例化对象时，构造函数都会自动调用</li></ul><p>构造函数的类型</p><ul><li>默认构造函数</li><li>参数化构造函数</li><li>静态构造函数：仅在类第一次使用时自动调用，用于初始化静态成员</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> StaticValue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 静态构造函数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> MyClass()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;Static constructor called.&#34;</span>);
</span></span><span style=display:flex><span>        StaticValue = <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> DisplayValue() =&gt; Console.WriteLine(<span style=color:#e6db74>$&#34;Static Value: {StaticValue}&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MyClass.DisplayValue(); 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=析构函数destructor>析构函数（Destructor）</h5><p>析构函数时当对象销毁时自动调用的特殊方法，主要用于释放资源，尤其时非托管资源（如文件句柄、数据库连接等）</p><p>在C#中，析构函数通常用来清理那些没有被垃圾回收器管理的资源</p><p>特点：</p><ul><li>析构函数没有参数和返回值</li><li>自动调用：当对象的生命周期结束并被垃圾回收时，析构函数会自动调用</li><li>只会有一个析构函数：每个类只能有一个析构函数</li><li>不需要显式调用：析构函数由GC管理，在对象生命周期结束时自动调用</li></ul><p>注意事项：</p><ul><li>不建议手动调用析构函数，它是由垃圾回收器管理的</li><li>C#的垃圾回收器自动管理托管资源的清理，所以析构函数主要用于清理非托管资源</li><li>如果在类中使用了<code>IDisposable</code>接口来管理资源，那么应考虑使用<code>Dispose</code>方法来显式释放资源而不是依赖析构函数</li></ul><h4 id=partial><code>partial</code></h4><p><code>partial</code>关键字的作用是将一个类、结构、接口、方法的定义拆分到多个文件或多个位置，在编译时由C#编译器把它们合并成一个完整定义</p><p>它本质上就是编译器的代码拼接，运行时你看到的还是一个完整的类型或方法</p><h5 id=示例>示例</h5><ol><li>拆分类</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Player.Data.cs</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>partial</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Player</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Level;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Player.Logic.cs</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>partial</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Player</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Levelup()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Level++;
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;{name} 升级到 {Level}级！&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译时，C#会自动把<code>Player.Data.cs</code>和<code>Player.Logic.cs</code>的代码合并成一个<code>Player</code>类</p><ol start=2><li>拆分方法
C# 3.0引入了<code>partial method</code>，用于让一个方法的声明和实现分开，且实现可选</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Game.partial.cs</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>partial</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Game</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>partial</span> <span style=color:#66d9ef>void</span> OnGameStart(); <span style=color:#75715e>// 声明（没有方法体）</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Game.impl.cs</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>partial</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Game</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>partial</span> <span style=color:#66d9ef>void</span> OnGameStart()<span style=color:#75715e>// 实现</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;游戏开始！&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>特点：</p><ul><li>没有实现的话，编译器会直接删除这个方法声明和所有调用（不会报错）</li><li>必须是<code>void</code>且默认是<code>private</code></li><li>常用于自动生成代码是预留扩展点</li></ul><h5 id=常见应用场景>常见应用场景</h5><ol><li>代码生成 + 手写代码分离
比如WinForms、WPF、Unity自动生成的UI代码</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Form1.Designer.cs（自动生成）</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>partial</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Form1</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InitializeComponent() { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>// Form1.cs （手写逻辑）</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>partial</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Form1</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Form1_Load(...) { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样自动生成的代码和手写的逻辑分开，避免每次UI改动都覆盖手写部分</p><ol start=2><li>大型类文件拆分
当一个类太大时，可以按功能模块拆到多个文件</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>Enemy.Movement.cs
</span></span><span style=display:flex><span>Enemy.Attack.cs
</span></span><span style=display:flex><span>Enemy.Health.cs
</span></span></code></pre></div><p>阅读和维护更轻松</p><ol start=3><li>团队协作
多人维护同一个类时，<code>partial</code>允许每个人在不同文件里写各自负责的部分，减少合并冲突</li></ol><h5 id=注意事项>注意事项</h5><ol><li>所有<code>partial</code>部分必须</li></ol><ul><li>在同一个命名空间中</li><li>有相同的访问修饰符</li><li>同类型</li></ul><ol start=2><li><p>编译时自动合并，不会影响运行时性能</p></li><li><p><code>partial method</code>如果没有实现，编译器会把它和调用都优化掉</p></li></ol><h4 id=readonly><code>readonly</code></h4><p>在C#中，<code>readonly</code>关键字用于修饰字段，使得这些字段在初始化后不能再修改，确保字段在对象生命周期内的不可变性。具体来说，<code>readonly</code>适用于以下情况</p><ol><li>只能在构造函数中初始化
<code>readonly</code>字段只能在构造函数中被复制，或者在声明时进行初始化。它不能在类的其他方法或外部代码中被修改</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> MyClass(<span style=color:#66d9ef>int</span> val) =&gt; x = val; <span style=color:#75715e>// 可以在构造函数中赋值</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>不可再其他方法或外部修改
一旦被赋值，<code>readonly</code>字段的值就不能再被修改。如果尝试再其他地方修改它，编译器会报错</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> x = <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ChangeValue()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// x = 20; // 编译错误，无法修改只读字段</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>对于静态字段
如果一个字段被声明为<code>static readonly</code>，它将是类级别的常量，并且只能再静态构造函数中初始化</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> staitc <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> MyConstant = <span style=color:#e6db74>&#34;Hello, World!&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> MyClass()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 也可以再静态构造函数中初始化</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>和<code>const</code>的区别</li></ol><ul><li><code>const</code>字段在编译时就已知，并且是隐式静态的，无法在运行时修改</li><li><code>readonly</code>字段可以在构造函数中初始化，因此支持运行时赋值，且只能在类的实例创建时设置</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> ConstantValue = <span style=color:#ae81ff>100</span>; <span style=color:#75715e>// 编译时确定</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> ReadonlyValue; <span style=color:#75715e>// 运行时可以初始化</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> MyClass(<span style=color:#66d9ef>int</span> <span style=color:#66d9ef>value</span>) =&gt; ReadonlyValue = <span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=常见用法>常见用法</h5><p><code>readonly</code>主要用于哪些需要保证值在对象生命周期内不变的场景，比如配置参数、唯一标识符等
例如，一个表示”出生日期”的字段可以使用<code>readonly</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>readonly</span> DateTime DateOfBirth;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Person(DateTime birthDate) =&gt; DateOfBirth = birthDate;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样一来，<code>DateOfBirth</code>一旦初始化后，就不能在对象的生命周期中被改变，确保了数据的安全性和一致性</p><h4 id=sealed><code>sealed</code></h4><p><code>sealed</code>（密封）是一个关键字，用于限制类或类成员的继承和重写，控制继承行为，并非访问修饰符</p><h5 id=sealed修饰类><code>sealed</code>修饰类</h5><p>当一个类被声明为<code>sealed</code>时，它不能被其他类继承</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SealedClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Display() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;这是一个sealed类&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// class DerivedClass : SealedClass { } // Error: &#39;DerivedClass&#39;: cannot derive from sealed type &#39;SealedClass&#39;</span>
</span></span></code></pre></div><p>使用场景</p><ul><li>防止意外的继承</li><li>安全性考虑（如System.String就是sealed类）</li><li>性能优化（某些情况下）</li></ul><h5 id=sealed修饰方法><code>sealed</code>修饰方法</h5><p>当方法被声明为<code>sealed</code>时，它不能在派生类中被重写。注意：<code>sealed</code>只能用于已标记为<code>override</code>的方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BaseClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Method1() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Base Method1&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Method2() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Base Method2&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DerivedClass</span> : BaseClass
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 重写并密封 Method1，防止进一步重写</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Method1() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Derived sealed Method1&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 只重写Method2，没有密封</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Method2() =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Derived Method2&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ThirdClass</span> : DerivedClass
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// public override void Method1() { } // 错误，不能重写sealed方法</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Method2() { } <span style=color:#75715e>// 可以重写非sealed方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=破坏sealed>破坏sealed</h5><p>在正常的C#编程中，没有官方支持的方法可以打破<code>sealed</code>的限制<br>但有一些非正统的技术手段，不过这些都有严重的问题，不推荐在生产环境中使用</p><ol><li><p>反射（有限度的打破）
只能访问成员，不能继承sealed类</p></li><li><p>直接使用指针操作内存（危险行为）</p></li><li><p>使用DynamicMethod或IL生成
可以绕过一些编译时检查，但极其复杂且不稳定</p></li><li><p>序列化技巧
通过序列化/反序列化可能改变对象状态，但无法改变类的继承关系</p></li></ol><h5 id=使用sealed的好处>使用sealed的好处</h5><ol><li>安全性：防止关键功能被修改</li><li>性能：编译器可以进行更好的优化</li><li>设计意图明确：明确表示该类或方法不应被进一步扩展</li><li>版本控制：确保基类行为的一致性</li></ol><h5 id=注意事项-1>注意事项</h5><ul><li><code>sealed</code>类不能是抽象类</li><li><code>sealed</code>方法必须与<code>override</code>一起使用</li><li>谨慎使用，因为它限制了代码的扩展性</li></ul><h4 id=base><code>base</code></h4><p><code>base</code>关键字用于从派生类（子类）中访问基类（父类）的成员。它的作用类似于对象自身的<code>this</code>关键字，但<code>base</code>指向的是其直接基类</p><h5 id=主要用途>主要用途</h5><ol><li>调用基类中已被重写的方法
当在派生类中重写（使用<code>override</code>关键字）了也给基类的虚方法或抽象方法后，有时希望在执行新代码的同时，仍然保留基类方法的原有逻辑。这时候就可以使用<code>base</code>来调用它</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> MakeSound()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;The animal makes a sound.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span> : Animal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> MakeSound()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用基类 Animal 的 MakeSound 方法</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>base</span>.MakeSound(); <span style=color:#75715e>// 输出：The animal makes a sound.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 然后添加狗特有的行为</span>
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;The dog barks: Woof woof!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Dog myDog = <span style=color:#66d9ef>new</span> Dog();
</span></span><span style=display:flex><span>        myDog.MakeSound();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 输出：</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The animal makes a sound.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The dog barks: Woof woof!</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中，<code>Dog</code>类重写了<code>MakeSound</code>方法。通过<code>base.MakeSound()</code>，它首先执行了基类<code>Animal</code>中的通用逻辑，然后才执行自己特有的逻辑<br>它避免了代码重复，可以在扩展功能的同时，复用基类已经实现好的、稳定的核心功能</p><ol start=2><li>调用基类的构造函数（特别是在派生类的构造函数中）
这是<code>base</code>关键字非常常见和重要的用法。当一个派生类被实例化时，其构造函数首先调用其基类的构造函数，以确保基类部分的成员被正确初始化。这个过程是自动的，但有时需要显式地控制调用基类的哪一个构造函数</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Vehicle</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Brand { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Year { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 基类构造函数 1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Vehicle(<span style=color:#66d9ef>string</span> brand)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Brand = brand;
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;Vehicle constructor called for {brand}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 基类构造函数 2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Vehicle(<span style=color:#66d9ef>string</span> brand, <span style=color:#66d9ef>int</span> year) : <span style=color:#66d9ef>this</span>(brand) <span style=color:#75715e>// 使用 this 调用同一个类的另一个构造函数</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Year = year;
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;Vehicle constructor with year called. Year: {year}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Car</span> : Vehicle
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> NumberOfDoors { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Car 的构造函数，调用基类 Vehicle 的构造函数 (string, int)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Car(<span style=color:#66d9ef>string</span> brand, <span style=color:#66d9ef>int</span> year, <span style=color:#66d9ef>int</span> doors) : <span style=color:#66d9ef>base</span>(brand, year) <span style=color:#75715e>// 关键在这里！</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        NumberOfDoors = doors;
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;Car constructor called. Doors: {doors}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Car myCar = <span style=color:#66d9ef>new</span> Car(<span style=color:#e6db74>&#34;Toyota&#34;</span>, <span style=color:#ae81ff>2023</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Vehicle constructor called for Toyota</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Vehicle constructor with year called. Year: 2023</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Car constructor called. Doors: 4</span>
</span></span></code></pre></div><p>执行顺序</p><ol><li>创建<code>Car</code>对象时，首先进入<code>Car</code>的构造函数</li><li>但由于有<code>: base(brand, year)</code>，所以程序会先跳转到基类<code>Vehicle</code>匹配的构造函数<code>Vehicle(string brand, int year)</code></li><li>在<code>Vehicle(string brand, int year)</code>中，又因为<code>: this(brand)</code>，会先调用<code>Vehicle(string brand)</code></li><li>执行完所有基类构造函数的逻辑后，最后才回到<code>Car</code>的构造函数体中执行<code>NumberOfDoors = doors;</code></li></ol><h5 id=重要规则>重要规则</h5><ul><li>基类构造函数的调用发生在派生类构造函数体执行之前</li><li>如果基类没有定义任何构造函数，编译器会提供一个默认的无参构造函数，并且派生类会隐式地调用它</li><li>如果基类没有无参构造函数（只有有参构造函数），那么派生类必须使用<code>base</code>关键字显式地调用基类的某个有参构造函数，否则会编译错误</li></ul></div><nav class=post-nav><a href=/dotnetandwindows/lib/miscellaneous/ class=hover:underline>pre: Miscellaneous</a>
<a href=/dotnetandwindows/lib/platforminvocation/ class=hover:underline>next: P/Invoke</a></nav></article><aside class=toc><h3>TOC</h3><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#类和对象>类和对象</a></li><li><a href=#面向对象特性>面向对象特性</a></li><li><a href=#c中面向对象的实现>C#中面向对象的实现</a><ul><li><a href=#访问限定修饰符>访问限定修饰符</a></li><li><a href=#字段与属性>字段与属性</a></li><li><a href=#this>this</a></li><li><a href=#static>static</a><ul><li><a href=#静态类>静态类</a></li><li><a href=#静态字段>静态字段</a></li><li><a href=#静态方法>静态方法</a></li><li><a href=#静态构造函数>静态构造函数</a></li><li><a href=#静态属性>静态属性</a></li></ul></li><li><a href=#嵌套类>嵌套类</a><ul><li><a href=#嵌套类的定义>嵌套类的定义</a></li><li><a href=#访问修饰符>访问修饰符</a></li><li><a href=#嵌套静态类>嵌套静态类</a></li><li><a href=#嵌套类访问外部类的实例成员>嵌套类访问外部类的实例成员</a></li><li><a href=#嵌套类的使用场景>嵌套类的使用场景</a></li></ul></li><li><a href=#扩展方法extension-methods>扩展方法（Extension Methods）</a></li><li><a href=#抽象类与接口interface>抽象类与接口（interface）</a><ul><li><a href=#抽象类>抽象类</a></li><li><a href=#接口>接口</a></li><li><a href=#抽象类与接口>抽象类与接口</a></li></ul></li><li><a href=#继承问题>继承问题</a><ul><li><a href=#virtual和abstract><code>virtual</code>和<code>abstract</code></a></li></ul></li><li><a href=#运算符重载>运算符重载</a></li><li><a href=#构造函数和析构函数>构造函数和析构函数</a><ul><li><a href=#构造函数constructor>构造函数（Constructor）</a></li><li><a href=#析构函数destructor>析构函数（Destructor）</a></li></ul></li><li><a href=#partial><code>partial</code></a><ul><li><a href=#示例>示例</a></li><li><a href=#常见应用场景>常见应用场景</a></li><li><a href=#注意事项>注意事项</a></li></ul></li><li><a href=#readonly><code>readonly</code></a><ul><li><a href=#常见用法>常见用法</a></li></ul></li><li><a href=#sealed><code>sealed</code></a><ul><li><a href=#sealed修饰类><code>sealed</code>修饰类</a></li><li><a href=#sealed修饰方法><code>sealed</code>修饰方法</a></li><li><a href=#破坏sealed>破坏sealed</a></li><li><a href=#使用sealed的好处>使用sealed的好处</a></li><li><a href=#注意事项-1>注意事项</a></li></ul></li><li><a href=#base><code>base</code></a><ul><li><a href=#主要用途>主要用途</a></li><li><a href=#重要规则>重要规则</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav></aside><script src=/js/scrollspy.js defer></script><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
  mermaid.initialize({ 
    startOnLoad: true, theme: "default" });
</script><footer><div class=container><p>© 2026 Jeff Lee(ljf12825). All rights reserved |
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Article: CC BY-NC-SA 4.0</a> |
<a href=https://creativecommons.org/licenses/by-sa/4.0/>Content: CC BY-SA 4.0</a> |
<a href=https://opensource.org/licenses/MIT>Code: MIT License</a> |
<a href=/LICENSES.md>Full License</a></p></div></footer></body></html>